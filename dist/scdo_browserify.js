require=(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
'use strict';

// created 2023-09-25T01:01:55.148Z
// compressed base64-encoded blob for include-ens data
// source: https://github.com/adraffy/ens-normalize.js/blob/main/src/make.js
// see: https://github.com/adraffy/ens-normalize.js#security
// SHA-256: 0565ed049b9cf1614bb9e11ba7d8ac6a6fb96c893253d890f7e2b2884b9ded32
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _wrapNativeSuper(t) { var r = "function" == typeof Map ? new Map() : void 0; return _wrapNativeSuper = function _wrapNativeSuper(t) { if (null === t || !_isNativeFunction(t)) return t; if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function"); if (void 0 !== r) { if (r.has(t)) return r.get(t); r.set(t, Wrapper); } function Wrapper() { return _construct(t, arguments, _getPrototypeOf(this).constructor); } return Wrapper.prototype = Object.create(t.prototype, { constructor: { value: Wrapper, enumerable: !1, writable: !0, configurable: !0 } }), _setPrototypeOf(Wrapper, t); }, _wrapNativeSuper(t); }
function _construct(t, e, r) { if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments); var o = [null]; o.push.apply(o, e); var p = new (t.bind.apply(t, o))(); return r && _setPrototypeOf(p, r.prototype), p; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _isNativeFunction(t) { try { return -1 !== Function.toString.call(t).indexOf("[native code]"); } catch (n) { return "function" == typeof t; } }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _toArray(r) { return _arrayWithHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
var COMPRESSED$1 = 'AEEUdwmgDS8BxQKKAP4BOgDjATAAngDUAIMAoABoAOAAagCOAEQAhABMAHIAOwA9ACsANgAmAGIAHgAuACgAJwAXAC0AGgAjAB8ALwAUACkAEgAeAAkAGwARABkAFgA5ACgALQArADcAFQApABAAHgAiABAAGgAeABMAGAUhBe8BFxREN8sF2wC5AK5HAW8ArQkDzQCuhzc3NzcBP68NEfMABQdHBuw5BV8FYAA9MzkI9r4ZBg7QyQAWA9CeOwLNCjcCjqkChuA/lm+RAsXTAoP6ASfnEQDytQFJAjWVCkeXAOsA6godAB/cwdAUE0WlBCN/AQUCQRjFD/MRBjHxDQSJbw0jBzUAswBxme+tnIcAYwabAysG8QAjAEMMmxcDqgPKQyDXCMMxA7kUQwD3NXOrAKmFIAAfBC0D3x4BJQDBGdUFAhEgVD8JnwmQJiNWYUzrg0oAGwAUAB0AFnNcACkAFgBP9h3gPfsDOWDKneY2ChglX1UDYD30ABsAFAAdABZzIGRAnwDD8wAjAEEMzRbDqgMB2sAFYwXqAtCnAsS4AwpUJKRtFHsadUz9AMMVbwLpABM1NJEX0ZkCgYMBEyMAxRVvAukAEzUBUFAtmUwSAy4DBTER33EftQHfSwB5MxJ/AjkWKQLzL8E/cwBB6QH9LQDPDtO9ASNriQC5DQANAwCK21EFI91zHwCoL9kBqQcHBwcHKzUDowBvAQohPvU3fAQgHwCyAc8CKQMA5zMSezr7ULgFmDp/LzVQBgEGAi8FYQVgt8AFcTtlQhpCWEmfe5tmZ6IAExsDzQ8t+X8rBKtTAltbAn0jsy8Bl6utPWMDTR8Ei2kRANkDBrNHNysDBzECQWUAcwFpJ3kAiyUhAJ0BUb8AL3EfAbfNAz81KUsFWwF3YQZtAm0A+VEfAzEJDQBRSQCzAQBlAHsAM70GD/v3IZWHBwARKQAxALsjTwHZAeMPEzmXgIHwABIAGQA8AEUAQDt3gdvIEGcQZAkGTRFMdEIVEwK0D64L7REdDNkq09PgADSxB/MDWwfzA1sDWwfzB/MDWwfzA1sDWwNbA1scEvAi28gQZw9QBHUFlgWTBN4IiyZREYkHMAjaVBV0JhxPA00BBCMtSSQ7mzMTJUpMFE0LCAQ2SmyvfUADTzGzVP2QqgPTMlc5dAkGHnkSqAAyD3skNb1OhnpPcagKU0+2tYdJak5vAsY6sEAACikJm2/Dd1YGRRAfJ6kQ+ww3AbkBPw3xS9wE9QY/BM0fgRkdD9GVoAipLeEM8SbnLqWAXiP5KocF8Uv4POELUVFsD10LaQnnOmeBUgMlAREijwrhDT0IcRD3Cs1vDekRSQc9A9lJngCpBwULFR05FbkmFGKwCw05ewb/GvoLkyazEy17AAXXGiUGUQEtGwMA0y7rhbRaNVwgT2MGBwspI8sUrFAkDSlAu3hMGh8HGSWtApVDdEqLUToelyH6PEENai4XUYAH+TwJGVMLhTyiRq9FEhHWPpE9TCJNTDAEOYMsMyePCdMPiQy9fHYBXQklCbUMdRM1ERs3yQg9Bx0xlygnGQglRplgngT7owP3E9UDDwVDCUUHFwO5HDETMhUtBRGBKNsC9zbZLrcCk1aEARsFzw8pH+MQVEfkDu0InwJpA4cl7wAxFSUAGyKfCEdnAGOP3FMJLs8Iy2pwI3gDaxTrZRF3B5UOWwerHDcVwxzlcMxeD4YMKKezCV8BeQmdAWME5wgNNV+MpCBFZ1eLXBifIGVBQ14AAjUMaRWjRMGHfAKPD28SHwE5AXcHPQ0FAnsR8RFvEJkI74YINbkz/DopBFMhhyAVCisDU2zSCysm/Qz8bQGnEmYDEDRBd/Jnr2C6KBgBBx0yyUFkIfULlk/RDKAaxRhGVDIZ6AfDA/ca9yfuQVsGAwOnBxc6UTPyBMELbQiPCUMATQ6nGwfbGG4KdYzUATWPAbudA1uVhwJzkwY7Bw8Aaw+LBX3pACECqwinAAkA0wNbAD0CsQehAB0AiUUBQQMrMwEl6QKTA5cINc8BmTMB9y0EH8cMGQD7O25OAsO1AoBuZqYF4VwCkgJNOQFRKQQJUktVA7N15QDfAE8GF+NLARmvTs8e50cB43MvAMsA/wAJOQcJRQHRAfdxALsBYws1Caa3uQFR7S0AhwAZbwHbAo0A4QA5AIP1AVcAUQVd/QXXAlNNARU1HC9bZQG/AyMBNwERAH0Gz5GpzQsjBHEH1wIQHxXlAu8yB7kFAyLjE9FCyQK94lkAMhoKPAqrCqpgX2Q3CjV2PVQAEh+sPss/UgVVO1c7XDtXO1w7VztcO1c7XDtXO1wDm8Pmw+YKcF9JYe8Mqg3YRMw6TRPfYFVgNhPMLbsUxRXSJVoZQRrAJwkl6FUNDwgt12Y0CDA0eRfAAEMpbINFY4oeNApPHOtTlVT8LR8AtUumM7MNsBsZREQFS3XxYi4WEgomAmSFAmJGX1GzAV83JAKh+wJonAJmDQKfiDgfDwJmPwJmKgRyBIMDfxcDfpY5Cjl7GzmGOicnAmwhAjI6OA4CbcsCbbLzjgM3a0kvAWsA4gDlAE4JB5wMkQECD8YAEbkCdzMCdqZDAnlPRwJ4viFg30WyRvcCfEMCeswCfQ0CfPRIBEiBZygALxlJXEpfGRtK0ALRBQLQ0EsrA4hTA4fqRMmRNgLypV0HAwOyS9JMMSkH001QTbMCi0MCitzFHwshR2sJuwKOOwKOYESbhQKO3QKOYHxRuFM5AQ5S2FSJApP/ApMQAO0AIFUiVbNV1AosHymZijLleGpFPz0Cl6MC77ZYJawAXSkClpMCloCgAK1ZsFoNhVEAPwKWuQKWUlxIXNUCmc8CmWhczl0LHQKcnznGOqECnBoCn58CnryOACETNS4TAp31Ap6WALlBYThh8wKe1wKgcgGtAp6jIwKeUqljzGQrKS8CJ7MCJoICoP8CoFDbAqYzAqXSAqgDAIECp/ZogGi1AAdNaiBq1QKs5wKssgKtawKtBgJXIQJV4AKx5dsDH1JsmwKywRECsuwbbORtZ21MYwMl0QK2YD9DbpQDKUkCuGICuUsZArkue3A6cOUCvR0DLbYDMhUCvoxyBgMzdQK+HnMmc1MCw88CwwhzhnRPOUl05AM8qwEDPJ4DPcMCxYACxksCxhSNAshtVQLISALJUwLJMgJkoQLd1nh9ZXiyeSlL1AMYp2cGAmH4GfeVKHsPXpZevxUCz28Cz3AzT1fW9xejAMqxAs93AS3uA04Wfk8JAtwrAtuOAtJTA1JgA1NjAQUDVZCAjUMEzxrxZEl5A4LSg5EC2ssC2eKEFIRNp0ADhqkAMwNkEoZ1Xf0AWQLfaQLevHd7AuIz7RgB8zQrAfSfAfLWiwLr9wLpdH0DAur9AuroAP1LAb0C7o0C66CWrpcHAu5DA4XkmH1w5HGlAvMHAG0DjhqZlwL3FwORcgOSiwL3nAL53QL4apogmq+/O5siA52HAv7+AR8APZ8gAZ+3AwWRA6ZuA6bdANXJAwZuoYyiCQ0DDE0BEwEjB3EGZb1rCQC/BG/DFY8etxEAG3k9ACcDNxJRA42DAWcrJQCM8wAlAOanC6OVCLsGI6fJBgCvBRnDBvElRUYFFoAFcD9GSDNCKUK8X3kZX8QAls0FOgCQVCGbwTsuYDoZutcONxjOGJHJ/gVfBWAFXwVgBWsFYAVfBWAFXwVgBV8FYAVfBWBOHQjfjW8KCgoKbF7xMwTRA7kGN8PDAMMEr8MA70gxFroFTj5xPnhCR0K+X30/X/AAWBkzswCNBsxzzASm70aCRS4rDDMeLz49fnXfcsH5GcoscQFz13Y4HwVnBXLJycnACNdRYwgICAqEXoWTxgA7P4kACxbZBu21Kw0AjMsTAwkVAOVtJUUsJ1JCuULESUArXy9gPi9AKwnJRQYKTD9LPoA+iT54PnkCkULEUUpDX9NWV3JVEjQAc1w3A3IBE3YnX+g7QiMJb6MKaiszRCUuQrNCxDPMCcwEX9EWJzYREBEEBwIHKn6l33JCNVIfybPJtAltydPUCmhBZw/tEKsZAJOVJU1CLRuxbUHOQAo7P0s+eEJHHA8SJVRPdGM0NVrpvBoKhfUlM0JHHGUQUhEWO1xLSj8MO0ucNAqJIzVCRxv9EFsqKyA4OQgNj2nwZgp5ZNFgE2A1K3YHS2AhQQojJmC7DgpzGG1WYFUZCQYHZO9gHWCdYIVgu2BTYJlwFh8GvRbcXbG8YgtDHrMBwzPVyQonHQgkCyYBgQJ0Ajc4nVqIAwGSCsBPIgDsK3SWEtIVBa5N8gGjAo+kVwVIZwD/AEUSCDweX4ITrRQsJ8K3TwBXFDwEAB0TvzVcAtoTS20RIwDgVgZ9BBImYgA5AL4Coi8LFnezOkCnIQFjAY4KBAPh9RcGsgZSBsEAJctdsWIRu2kTkQstRw7DAcMBKgpPBGIGMDAwKCYnKTQaLg4AKRSVAFwCdl+YUZ0JdicFD3lPAdt1F9ZZKCGxuE3yBxkFVGcA/wBFEgiCBwAOLHQSjxOtQDg1z7deFRMAZ8QTAGtKb1ApIiPHADkAvgKiLy1DFtYCmBiDAlDDWNB0eo7fpaMO/aEVRRv0ATEQZBIODyMEAc8JQhCbDRgzFD4TAEMAu9YBCgCsAOkAm5I3ABwAYxvONnR+MhXJAxgKQyxL2+kkJhMbhQKDBMkSsvF0AD9BNQ6uQC7WqSQHwxEAEEIu1hkhAH2z4iQPwyJPHNWpdyYBRSpnJALzoBAEVPPsH20MxA0CCEQKRgAFyAtFAlMNwwjEDUQJRArELtapMg7DDZgJIw+TGukEIwvDFkMAqAtDEMMMBhioe+QAO3MMRAACrgnEBSPY9Q0FDnbSBoMAB8MSYxkSxAEJAPIJAAB8FWMOFtMc/HcXwxhDAC7DAvOowwAewwJdKDKHAAHDAALrFUQVwwAbwyvzpWMWv8wA/ABpAy++bcYDUKPD0KhDCwKmJ1MAAmMA5+UZwxAagwipBRL/eADfw6fDGOMCGsOjk3l6BwOpo4sAEsMOGxMAA5sAbcMOAAvDp0MJGkMDwgipnNIPAwfIqUMGAOGDAAPzABXDAAcDAAnDAGmTABrDAA7DChjDjnEWAwABYwAOcwAuUyYABsMAF8MIKQANUgC6wy4AA8MADqMq8wCyYgAcIwAB8wqpAAXOCx0V4wAHowBCwwEKAGnDAAuDAB3DAAjDCakABdIAbqcZ3QCZCCkABdIAAAFDAAfjAB2jCCkABqIACYMAGzMAbSMA5sOIAAhjAAhDABTDBAkpAAbSAOOTAAlDC6kOzPtnAAdDAG6kQFAATwAKwwwAA0MACbUDPwAHIwAZgwACE6cDAAojAApDAAoDp/MGwwAJIwADEwAQQwgAFEMAEXMAD5MADfMADcMAGRMOFiMAFUMAbqMWuwHDAMIAE0MLAGkzEgDhUwACQwAEWgAXgwUjAAbYABjDBSYBgzBaAEFNALcQBxUMegAwMngBrA0IZgJ0KxQHBREPd1N0ZzKRJwaIHAZqNT4DqQq8BwngAB4DAwt2AX56T1ocKQNXAh1GATQGC3tOxYNagkgAMQA5CQADAQEAWxLjAIOYNAEzAH7tFRk6TglSAF8NAAlYAQ+S1ACAQwQorQBiAN4dAJ1wPyeTANVzuQDX3AIeEMp9eyMgXiUAEdkBkJizKltbVVAaRMqRAAEAhyQ/SDEz6BmfVwB6ATEsOClKIRcDOF0E/832AFNt5AByAnkCRxGCOs94NjXdAwINGBonDBwPALW2AwICAgAAAAAAAAYDBQMDARrUAwAtAAAAAgEGBgYGBgYFBQUFBQUEBQYHCAkEBQUFBQQAAAICAAAAIgCNAJAAlT0A6gC7ANwApEQAwgCyAK0AqADuAKYA2gCjAOcBCAEDAMcAgQBiANIA1AEDAN4A8gCQAKkBMQDqAN8A3AsBCQ8yO9ra2tq8xuLT1tRJOB0BUgFcNU0BWgFpAWgBWwFMUUlLbhMBUxsNEAs6PhMOACcUKy0vMj5AQENDQ0RFFEYGJFdXV1dZWVhZL1pbXVxcI2NnZ2ZoZypsbnZ1eHh4eHh4enp6enp6enp6enp8fH18e2IARPIASQCaAHgAMgBm+ACOAFcAVwA3AnbvAIsABfj4AGQAk/IAnwBPAGIAZP//sACFAIUAaQBWALEAJAC2AIMCQAJDAPwA5wD+AP4A6AD/AOkA6QDoAOYALwJ7AVEBQAE+AVQBPgE+AT4BOQE4ATgBOAEcAVgXADEQCAEAUx8SHgsdHhYAjgCWAKYAUQBqIAIxAHYAbwCXAxUDJzIDIUlGTzEAkQJPAMcCVwKkAMAClgKWApYClgKWApYCiwKWApYClgKWApYClgKVApUCmAKgApcClgKWApQClAKUApQCkgKVAnUB1AKXAp8ClgKWApUeAIETBQD+DQOfAmECOh8BVBg9AuIZEjMbAU4/G1WZAXusRAFpYQEFA0FPAQYAmTEeIJdyADFoAHEANgCRA5zMk/C2jGINwjMWygIZCaXdfDILBCs5dAE7YnQBugDlhoiHhoiGiYqKhouOjIaNkI6Ij4qQipGGkoaThpSSlYaWhpeKmIaZhpqGm4aci52QnoqfhuIC4XTpAt90AIp0LHSoAIsAdHQEQwRABEIERQRDBEkERgRBBEcESQRIBEQERgRJAJ5udACrA490ALxuAQ10ANFZdHQA13QCFHQA/mJ0AP4BIQD+APwA/AD9APwDhGZ03ASMK23HAP4A/AD8AP0A/CR0dACRYnQA/gCRASEA/gCRAvQA/gCRA4RmdNwEjCttxyR0AP9idAEhAP4A/gD8APwA/QD8AP8A/AD8AP0A/AOEZnTcBIwrbcckdHQAkWJ0ASEA/gCRAP4AkQL0AP4AkQOEZnTcBIwrbcckdAJLAT50AlIBQXQCU8l0dAJfdHQDpgL0A6YDpgOnA6cDpwOnA4RmdNwEjCttxyR0dACRYnQBIQOmAJEDpgCRAvQDpgCRA4RmdNwEjCttxyR0BDh0AJEEOQCRDpU5dSgCADR03gV2CwArdAEFAM5iCnR0AF1iAAYcOgp0dACRCnQAXAEIwWZ0CnRmdHQAkWZ0CnRmdEXgAFF03gp0dEY0tlT2u3SOAQTwscwhjZZKrhYcBSfFp9XNbKiVDOD2b+cpe4/Z17mQnbtzzhaeQtE2GGj0IDNTjRUSyTxxw/RPHW/+vS7d1NfRt9z9QPZg4X7QFfhCnkvgNPIItOsC2eV6hPannZNHlZ9xrwZXIMOlu3jSoQSq78WEjwLjw1ELSlF1aBvfzwk5ZX7AUvQzjPQKbDuQ+sm4wNOp4A6AdVuRS0t1y/DZpg4R6m7FNjM9HgvW7Bi88zaMjOo6lM8wtBBdj8LP4ylv3zCXPhebMKJc066o9sF71oFW/8JXu86HJbwDID5lzw5GWLR/LhT0Qqnp2JQxNZNfcbLIzPy+YypqRm/lBmGmex+82+PisxUumSeJkALIT6rJezxMH+CTJmQtt5uwTVbL3ptmjDUQzlSIvWi8Tl7ng1NpuRn1Ng4n14Qc+3Iil7OwkvNWogLSPkn3pihIFytyIGmMhOe3n1tWsuMy9BdKyqF4Z3v2SgggTL9KVvMXPnCbRe+oOuFFP3HejBG/w9gvmfNYvg6JuWia2lcSSN1uIjBktzoIazOHPJZ7kKHPz8mRWVdW3lA8WGF9dQF6Bm673boov3BUWDU2JNcahR23GtfHKLOz/viZ+rYnZFaIznXO67CYEJ1fXuTRpZhYZkKe54xeoagkNGLs+NTZHE0rX45/XvQ2RGADX6vcAvdxIUBV27wxGm2zjZo4X3ILgAlrOFheuZ6wtsvaIj4yLY7qqawlliaIcrz2G+c3vscAnCkCuMzMmZvMfu9lLwTvfX+3cVSyPdN9ZwgDZhfjRgNJcLiJ67b9xx8JHswprbiE3v9UphotAPIgnXVIN5KmMc0piXhc6cChPnN+MRhG9adtdttQTTwSIpl8I4/j//d3sz1326qTBTpPRM/Hgh3kzqEXs8ZAk4ErQhNO8hzrQ0DLkWMA/N+91tn2MdOJnWC2FCZehkQrwzwbKOjhvZsbM95QoeL9skYyMf4srVPVJSgg7pOLUtr/n9eT99oe9nLtFRpjA9okV2Kj8h9k5HaC0oivRD8VyXkJ81tcd4fHNXPCfloIQasxsuO18/46dR2jgul/UIet2G0kRvnyONMKhHs6J26FEoqSqd+rfYjeEGwHWVDpX1fh1jBBcKGMqRepju9Y00mDVHC+Xdij/j44rKfvfjGinNs1jO/0F3jB83XCDINN/HB84axlP+3E/klktRo+vl3U/aiyMJbIodE1XSsDn6UAzIoMtUObY2+k/4gY/l+AkZJ5Sj2vQrkyLm3FoxjhDX+31UXBFf9XrAH31fFqoBmDEZvhvvpnZ87N+oZEu7U9O/nnk+QWj3x8uyoRbEnf+O5UMr9i0nHP38IF5AvzrBW8YWBUR0mIAzIvndQq9N3v/Jto3aPjPXUPl8ASdPPyAp7jENf8bk7VMM9ol9XGmlBmeDMuGqt+WzuL6CXAxXjIhCPM5vACchgMJ/8XBGLO/D1isVvGhwwHHr1DLaI5mn2Jr/b1pUD90uciDaS8cXNDzCWvNmT/PhQe5e8nTnnnkt8Ds/SIjibcum/fqDhKopxAY8AkSrPn+IGDEKOO+U3XOP6djFs2H5N9+orhOahiQk5KnEUWa+CzkVzhp8bMHRbg81qhjjXuIKbHjSLSIBKWqockGtKinY+z4/RdBUF6pcc3JmnlxVcNgrI4SEzKUZSwcD2QCyxzKve+gAmg6ZuSRkpPFa6mfThu7LJNu3H5K42uCpNvPAsoedolKV/LHe/eJ+BbaG5MG0NaSGVPRUmNFMFFSSpXEcXwbVh7UETOZZtoVNRGOIbbkig3McEtR68cG0RZAoJevWYo7Dg/lZ1CQzblWeUvVHmr8fY4Nqd9JJiH/zEX24mJviH60fAyFr0A3c4bC1j3yZU60VgJxXn8JgJXLUIsiBnmKmMYz+7yBQFBvqb2eYnuW59joZBf56/wXvWIR4R8wTmV80i1mZy+S4+BUES+hzjk0uXpC///z/IlqHZ1monzlXp8aCfhGKMti73FI1KbL1q6IKO4fuBuZ59gagjn5xU79muMpHXg6S+e+gDM/U9BKLHbl9l6o8czQKl4RUkJJiqftQG2i3BMg/TQlUYFkJDYBOOvAugYuzYSDnZbDDd/aSd9x0Oe6F+bJcHfl9+gp6L5/TgA+BdFFovbfCrQ40s5vMPw8866pNX8zyFGeFWdxIpPVp9Rg1UPOVFbFZrvaFq/YAzHQgqMWpahMYfqHpmwXfHL1/kpYmGuHFwT55mQu0dylfNuq2Oq0hTMCPwqfxnuBIPLXfci4Y1ANy+1CUipQxld/izVh16WyG2Q0CQQ9NqtAnx1HCHwDj7sYxOSB0wopZSnOzxQOcExmxrVTF2BkOthVpGfuhaGECfCJpJKpjnihY+xOT2QJxN61+9K6QSqtv2Shr82I3jgJrqBg0wELFZPjvHpvzTtaJnLK6Vb97Yn933koO/saN7fsjwNKzp4l2lJVx2orjCGzC/4ZL4zCver6aQYtC5sdoychuFE6ufOiog+VWi5UDkbmvmtah/3aArEBIi39s5ILUnlFLgilcGuz9CQshEY7fw2ouoILAYPVT/gyAIq3TFAIwVsl+ktkRz/qGfnCDGrm5gsl/l9QdvCWGsjPz3dU7XuqKfdUrr/6XIgjp4rey6AJBmCmUJMjITHVdFb5m1p+dLMCL8t55zD42cmftmLEJC0Da04YiRCVUBLLa8D071/N5UBNBXDh0LFsmhV/5B5ExOB4j3WVG/S3lfK5o+V6ELHvy6RR9n4ac+VsK4VE4yphPvV+kG9FegTBH4ZRXL2HytUHCduJazB/KykjfetYxOXTLws267aGOd+I+JhKP//+VnXmS90OD/jvLcVu0asyqcuYN1mSb6XTlCkqv1vigZPIYwNF/zpWcT1GR/6aEIRjkh0yhg4LXJfaGobYJTY4JI58KiAKgmmgAKWdl5nYCeLqavRJGQNuYuZtZFGx+IkI4w4NS2xwbetNMunOjBu/hmKCI/w7tfiiyUd//4rbTeWt4izBY8YvGIN6vyKYmP/8X8wHKCeN+WRcKM70+tXKNGyevU9H2Dg5BsljnTf8YbsJ1TmMs74Ce2XlHisleguhyeg44rQOHZuw/6HTkhnnurK2d62q6yS7210SsAIaR+jXMQA+svkrLpsUY+F30Uw89uOdGAR6vo4FIME0EfVVeHTu6eKicfhSqOeXJhbftcd08sWEnNUL1C9fnprTgd83IMut8onVUF0hvqzZfHduPjbjwEXIcoYmy+P6tcJZHmeOv6VrvEdkHDJecjHuHeWANe79VG662qTjA/HCvumVv3qL+LrOcpqGps2ZGwQdFJ7PU4iuyRlBrwfO+xnPyr47s2cXVbWzAyznDiBGjCM3ksxjjqM62GE9C8f5U38kB3VjtabKp/nRdvMESPGDG90bWRLAt1Qk5DyLuazRR1YzdC1c+hZXvAWV8xA72S4A8B67vjVhbba3MMop293FeEXpe7zItMWrJG/LOH9ByOXmYnNJfjmfuX9KbrpgLOba4nZ+fl8Gbdv/ihv+6wFGKHCYrVwmhFC0J3V2bn2tIB1wCc1CST3d3X2OyxhguXcs4sm679UngzofuSeBewMFJboIQHbUh/m2JhW2hG9DIvG2t7yZIzKBTz9wBtnNC+2pCRYhSIuQ1j8xsz5VvqnyUIthvuoyyu7fNIrg/KQUVmGQaqkqZk/Vx5b33/gsEs8yX7SC1J+NV4icz6bvIE7C5G6McBaI8rVg56q5QBJWxn/87Q1sPK4+sQa8fLU5gXo4paaq4cOcQ4wR0VBHPGjKh+UlPCbA1nLXyEUX45qZ8J7/Ln4FPJE2TdzD0Z8MLSNQiykMMmSyOCiFfy84Rq60emYB2vD09KjYwsoIpeDcBDTElBbXxND72yhd9pC/1CMid/5HUMvAL27OtcIJDzNKpRPNqPOpyt2aPGz9QWIs9hQ9LiX5s8m9hjTUu/f7MyIatjjd+tSfQ3ufZxPpmJhTaBtZtKLUcfOCUqADuO+QoH8B9v6U+P0HV1GLQmtoNFTb3s74ivZgjES0qfK+8RdGgBbcCMSy8eBvh98+et1KIFqSe1KQPyXULBMTsIYnysIwiZBJYdI20vseV+wuJkcqGemehKjaAb9L57xZm3g2zX0bZ2xk/fU+bCo7TlnbW7JuF1YdURo/2Gw7VclDG1W7LOtas2LX4upifZ/23rzpsnY/ALfRgrcWP5hYmV9VxVOQA1fZvp9F2UNU+7d7xRyVm5wiLp3/0dlV7vdw1PMiZrbDAYzIVqEjRY2YU03sJhPnlwIPcZUG5ltL6S8XCxU1eYS5cjr34veBmXAvy7yN4ZjArIG0dfD/5UpBNlX1ZPoxJOwyqRi3wQWtOzd4oNKh0LkoTm8cwqgIfKhqqGOhwo71I+zXnMemTv2B2AUzABWyFztGgGULjDDzWYwJUVBTjKCn5K2QGMK1CQT7SzziOjo+BhAmqBjzuc3xYym2eedGeOIRJVyTwDw37iCMe4g5Vbnsb5ZBdxOAnMT7HU4DHpxWGuQ7GeiY30Cpbvzss55+5Km1YsbD5ea3NI9QNYIXol5apgSu9dZ8f8xS5dtHpido5BclDuLWY4lhik0tbJa07yJhH0BOyEut/GRbYTS6RfiTYWGMCkNpfSHi7HvdiTglEVHKZXaVhezH4kkXiIvKopYAlPusftpE4a5IZwvw1x/eLvoDIh/zpo9FiQInsTb2SAkKHV42XYBjpJDg4374XiVb3ws4qM0s9eSQ5HzsMU4OZJKuopFjBM+dAZEl8RUMx5uU2N486Kr141tVsGQfGjORYMCJAMsxELeNT4RmWjRcpdTGBwcx6XN9drWqPmJzcrGrH4+DRc7+n1w3kPZwu0BkNr6hQrqgo7JTB9A5kdJ/H7P4cWBMwsmuixAzJB3yrQpnGIq90lxAXLzDCdn1LPibsRt7rHNjgQBklRgPZ8vTbjXdgXrTWQsK5MdrXXQVPp0Rinq3frzZKJ0qD6Qhc40VzAraUXlob1gvkhK3vpmHgI6FRlQZNx6eRqkp0zy4AQlX813fAPtL3jMRaitGFFjo0zmErloC+h+YYdVQ6k4F/epxAoF0BmqEoKNTt6j4vQZNQ2BoqF9Vj53TOIoNmDiu9Xp15RkIgQIGcoLpfoIbenzpGUAtqFJp5W+LLnx38jHeECTJ/navKY1NWfN0sY1T8/pB8kIH3DU3DX+u6W3YwpypBMYOhbSxGjq84RZ84fWJow8pyHqn4S/9J15EcCMsXqrfwyd9mhiu3+rEo9pPpoJkdZqHjra4NvzFwuThNKy6hao/SlLw3ZADUcUp3w3SRVfW2rhl80zOgTYnKE0Hs2qp1J6H3xqPqIkvUDRMFDYyRbsFI3M9MEyovPk8rlw7/0a81cDVLmBsR2ze2pBuKb23fbeZC0uXoIvDppfTwIDxk1Oq2dGesGc+oJXWJLGkOha3CX+DUnzgAp9HGH9RsPZN63Hn4RMA5eSVhPHO+9RcRb/IOgtW31V1Q5IPGtoxPjC+MEJbVlIMYADd9aHYWUIQKopuPOHmoqSkubnAKnzgKHqgIOfW5RdAgotN6BN+O2ZYHkuemLnvQ8U9THVrS1RtLmKbcC7PeeDsYznvqzeg6VCNwmr0Yyx1wnLjyT84BZz3EJyCptD3yeueAyDWIs0L2qs/VQ3HUyqfrja0V1LdDzqAikeWuV4sc7RLIB69jEIBjCkyZedoUHqCrOvShVzyd73OdrJW0hPOuQv2qOoHDc9xVb6Yu6uq3Xqp2ZaH46A7lzevbxQEmfrzvAYSJuZ4WDk1Hz3QX1LVdiUK0EvlAGAYlG3Md30r7dcPN63yqBCIj25prpvZP0nI4+EgWoFG95V596CurXpKRBGRjQlHCvy5Ib/iW8nZJWwrET3mgd6mEhfP4KCuaLjopWs7h+MdXFdIv8dHQJgg1xi1eYqB0uDYjxwVmri0Sv5XKut/onqapC+FQiC2C1lvYJ9MVco6yDYsS3AANUfMtvtbYI2hfwZatiSsnoUeMZd34GVjkMMKA+XnjJpXgRW2SHTZplVowPmJsvXy6w3cfO1AK2dvtZEKTkC/TY9LFiKHCG0DnrMQdGm2lzlBHM9iEYynH2UcVMhUEjsc0oDBTgo2ZSQ1gzkAHeWeBXYFjYLuuf8yzTCy7/RFR81WDjXMbq2BOH5dURnxo6oivmxL3cKzKInlZkD31nvpHB9Kk7GfcfE1t+1V64b9LtgeJGlpRFxQCAqWJ5DoY77ski8gsOEOr2uywZaoO/NGa0X0y1pNQHBi3b2SUGNpcZxDT7rLbBf1FSnQ8guxGW3W+36BW0gBje4DOz6Ba6SVk0xiKgt+q2JOFyr4SYfnu+Ic1QZYIuwHBrgzr6UvOcSCzPTOo7D6IC4ISeS7zkl4h+2VoeHpnG/uWR3+ysNgPcOIXQbv0n4mr3BwQcdKJxgPSeyuP/z1Jjg4e9nUvoXegqQVIE30EHx5GHv+FAVUNTowYDJgyFhf5IvlYmEqRif6+WN1MkEJmDcQITx9FX23a4mxy1AQRsOHO/+eImX9l8EMJI3oPWzVXxSOeHU1dUWYr2uAA7AMb+vAEZSbU3qob9ibCyXeypEMpZ6863o6QPqlqGHZkuWABSTVNd4cOh9hv3qEpSx2Zy/DJMP6cItEmiBJ5PFqQnDEIt3NrA3COlOSgz43D7gpNFNJ5MBh4oFzhDPiglC2ypsNU4ISywY2erkyb1NC3Qh/IfWj0eDgZI4/ln8WPfBsT3meTjq1Uqt1E7Zl/qftqkx6aM9KueMCekSnMrcHj1CqTWWzEzPsZGcDe3Ue4Ws+XFYVxNbOFF8ezkvQGR6ZOtOLU2lQEnMBStx47vE6Pb7AYMBRj2OOfZXfisjJnpTfSNjo6sZ6qSvNxZNmDeS7Gk3yYyCk1HtKN2UnhMIjOXUzAqDv90lx9O/q/AT1ZMnit5XQe9wmQxnE/WSH0CqZ9/2Hy+Sfmpeg8RwsHI5Z8kC8H293m/LHVVM/BA7HaTJYg5Enk7M/xWpq0192ACfBai2LA/qrCjCr6Dh1BIMzMXINBmX96MJ5Hn2nxln/RXPFhwHxUmSV0EV2V0jm86/dxxuYSU1W7sVkEbN9EzkG0QFwPhyHKyb3t+Fj5WoUUTErcazE/N6EW6Lvp0d//SDPj7EV9UdJN+Amnf3Wwk3A0SlJ9Z00yvXZ7n3z70G47Hfsow8Wq1JXcfwnA+Yxa5mFsgV464KKP4T31wqIgzFPd3eCe3j5ory5fBF2hgCFyVFrLzI9eetNXvM7oQqyFgDo4CTp/hDV9NMX9JDHQ/nyHTLvZLNLF6ftn2OxjGm8+PqOwhxnPHWipkE/8wbtyri80Sr7pMNkQGMfo4ZYK9OcCC4ESVFFbLMIvlxSoRqWie0wxqnLfcLSXMSpMMQEJYDVObYsXIQNv4TGNwjq1kvT1UOkicTrG3IaBZ3XdScS3u8sgeZPVpOLkbiF940FjbCeNRINNvDbd01EPBrTCPpm12m43ze1bBB59Ia6Ovhnur/Nvx3IxwSWol+3H2qfCJR8df6aQf4v6WiONxkK+IqT4pKQrZK/LplgDI/PJZbOep8dtbV7oCr6CgfpWa8NczOkPx81iSHbsNhVSJBOtrLIMrL31LK9TqHqAbAHe0RLmmV806kRLDLNEhUEJfm9u0sxpkL93Zgd6rw+tqBfTMi59xqXHLXSHwSbSBl0EK0+loECOPtrl+/nsaFe197di4yUgoe4jKoAJDXc6DGDjrQOoFDWZJ9HXwt8xDrQP+7aRwWKWI1GF8s8O4KzxWBBcwnl3vnl1Oez3oh6Ea1vjR7/z7DDTrFtqU2W/KAEzAuXDNZ7MY73MF216dzdSbWmUp4lcm7keJfWaMHgut9x5C9mj66Z0lJ+yhsjVvyiWrfk1lzPOTdhG15Y7gQlXtacvI7qv/XNSscDwqkgwHT/gUsD5yB7LdRRvJxQGYINn9hTpodKFVSTPrtGvyQw+HlRFXIkodErAGu9Iy1YpfSPc3jkFh5CX3lPxv7aqjE/JAfTIpEjGb/H7MO0e2vsViSW1qa/Lmi4/n4DEI3g7lYrcanspDfEpKkdV1OjSLOy0BCUqVoECaB55vs06rXl4jqmLsPsFM/7vYJ0vrBhDCm/00A/H81l1uekJ/6Lml3Hb9+NKiLqATJmDpyzfYZFHumEjC662L0Bwkxi7E9U4cQA0XMVDuMYAIeLMPgQaMVOd8fmt5SflFIfuBoszeAw7ow5gXPE2Y/yBc/7jExARUf/BxIHQBF5Sn3i61w4z5xJdCyO1F1X3+3ax+JSvMeZ7S6QSKp1Fp/sjYz6Z+VgCZzibGeEoujryfMulH7Rai5kAft9ebcW50DyJr2uo2z97mTWIu45YsSnNSMrrNUuG1XsYBtD9TDYzQffKB87vWbkM4EbPAFgoBV4GQS+vtFDUqOFAoi1nTtmIOvg38N4hT2Sn8r8clmBCXspBlMBYTnrqFJGBT3wZOzAyJDre9dHH7+x7qaaKDOB4UQALD5ecS0DE4obubQEiuJZ0EpBVpLuYcce8Aa4PYd/V4DLDAJBYKQPCWTcrEaZ5HYbJi11Gd6hjGom1ii18VHYnG28NKpkz2UKVPxlhYSp8uZr367iOmoy7zsxehW9wzcy2zG0a80PBMCRQMb32hnaHeOR8fnNDzZhaNYhkOdDsBUZ3loDMa1YP0uS0cjUP3b/6DBlqmZOeNABDsLl5BI5QJups8uxAuWJdkUB/pO6Zax6tsg7fN5mjjDgMGngO+DPcKqiHIDbFIGudxtPTIyDi9SFMKBDcfdGQRv41q1AqmxgkVfJMnP8w/Bc7N9/TR6C7mGObFqFkIEom8sKi2xYqJLTCHK7cxzaZvqODo22c3wisBCP4HeAgcRbNPAsBkNRhSmD48dHupdBRw4mIvtS5oeF6zeT1KMCyhMnmhpkFAGWnGscoNkwvQ8ZM5lE/vgTHFYL99OuNxdFBxTEDd5v2qLR8y9WkXsWgG6kZNndFG+pO/UAkOCipqIhL3hq7cRSdrCq7YhUsTocEcnaFa6nVkhnSeRYUA1YO0z5itF9Sly3VlxYDw239TJJH6f3EUfYO5lb7bcFcz8Bp7Oo8QmnsUHOz/fagVUBtKEw1iT88j+aKkv8cscKNkMxjYr8344D1kFoZ7/td1W6LCNYN594301tUGRmFjAzeRg5vyoM1F6+bJZ/Q54jN/k8SFd3DxPTYaAUsivsBfgTn7Mx8H2SpPt4GOdYRnEJOH6jHM2p6SgB0gzIRq6fHxGMmSmqaPCmlfwxiuloaVIitLGN8wie2CDWhkzLoCJcODh7KIOAqbHEvXdUxaS4TTTs07Clzj/6GmVs9kiZDerMxEnhUB6QQPlcfqkG9882RqHoLiHGBoHfQuXIsAG8GTAtao2KVwRnvvam8jo1e312GQAKWEa4sUVEAMG4G6ckcONDwRcg1e2D3+ohXgY4UAWF8wHKQMrSnzCgfFpsxh+aHXMGtPQroQasRY4U6UdG0rz1Vjbka0MekOGRZQEvqQFlxseFor8zWFgHek3v29+WqN6gaK5gZOTOMZzpQIC1201LkMCXild3vWXSc5UX9xcFYfbRPzGFa1FDcPfPB/jUEq/FeGt419CI3YmBlVoHsa4KdcwQP5ZSwHHhFJ7/Ph/Rap/4vmG91eDwPP0lDfCDRCLszTqfzM71xpmiKi2HwS4WlqvGNwtvwF5Dqpn6KTq8ax00UMPkxDcZrEEEsIvHiUXXEphdb4GB4FymlPwBz4Gperqq5pW7TQ6/yNRhW8VT5NhuP0udlxo4gILq5ZxAZk8ZGh3g4CqxJlPKY7AQxupfUcVpWT5VItp1+30UqoyP4wWsRo3olRRgkWZZ2ZN6VC3OZFeXB8NbnUrSdikNptD1QiGuKkr8EmSR/AK9Rw+FF3s5uwuPbvHGiPeFOViltMK7AUaOsq9+x9cndk3iJEE5LKZRlWJbKOZweROzmPNVPkjE3K/TyA57Rs68TkZ3MR8akKpm7cFjnjPd/DdkWjgYoKHSr5Wu5ssoBYU4acRs5g2DHxUmdq8VXOXRbunD8QN0LhgkssgahcdoYsNvuXGUK/KXD/7oFb+VGdhqIn02veuM5bLudJOc2Ky0GMaG4W/xWBxIJcL7yliJOXOpx0AkBqUgzlDczmLT4iILXDxxtRR1oZa2JWFgiAb43obrJnG/TZC2KSK2wqOzRZTXavZZFMb1f3bXvVaNaK828w9TO610gk8JNf3gMfETzXXsbcvRGCG9JWQZ6+cDPqc4466Yo2RcKH+PILeKOqtnlbInR3MmBeGG3FH10yzkybuqEC2HSQwpA0An7d9+73BkDUTm30bZmoP/RGbgFN+GrCOfADgqr0WbI1a1okpFms8iHYw9hm0zUvlEMivBRxModrbJJ+9/p3jUdQQ9BCtQdxnOGrT5dzRUmw0593/mbRSdBg0nRvRZM5/E16m7ZHmDEtWhwvfdZCZ8J8M12W0yRMszXamWfQTwIZ4ayYktrnscQuWr8idp3PjT2eF/jmtdhIfcpMnb+IfZY2FebW6UY/AK3jP4u3Tu4zE4qlnQgLFbM19EBIsNf7KhjdbqQ/D6yiDb+NlEi2SKD+ivXVUK8ib0oBo366gXkR8ZxGjpJIDcEgZPa9TcYe0TIbiPl/rPUQDu3XBJ9X/GNq3FAUsKsll57DzaGMrjcT+gctp+9MLYXCq+sqP81eVQ0r9lt+gcQfZbACRbEjvlMskztZG8gbC8Qn9tt26Q7y7nDrbZq/LEz7kR6Jc6pg3N9rVX8Y5MJrGlML9p9lU4jbTkKqCveeZUJjHB03m2KRKR2TytoFkTXOLg7keU1s1lrPMQJpoOKLuAAC+y1HlJucU6ysB5hsXhvSPPLq5J7JtnqHKZ4vYjC4Vy8153QY+6780xDuGARsGbOs1WqzH0QS765rnSKEbbKlkO8oI/VDwUd0is13tKpqILu1mDJFNy/iJAWcvDgjxvusIT+PGz3ST/J9r9Mtfd0jpaGeiLYIqXc7DiHSS8TcjFVksi66PEkxW1z6ujbLLUGNNYnzOWpH8BZGK4bCK7iR+MbIv8ncDAz1u4StN3vTTzewr9IQjk9wxFxn+6N1ddKs0vffJiS08N3a4G1SVrlZ97Q/M+8G9fe5AP6d9/Qq4WRnORVhofPIKEdCr3llspUfE0oKIIYoByBRPh+bX1HLS3JWGJRhIvE1aW4NTd8ePi4Z+kXb+Z8snYfSNcqijhAgVsx4RCM54cXUiYkjeBmmC4ajOHrChoELscJJC7+9jjMjw5BagZKlgRMiSNYz7h7vvZIoQqbtQmspc0cUk1G/73iXtSpROl5wtLgQi0mW2Ex8i3WULhcggx6E1LMVHUsdc9GHI1PH3U2Ko0PyGdn9KdVOLm7FPBui0i9a0HpA60MsewVE4z8CAt5d401Gv6zXlIT5Ybit1VIA0FCs7wtvYreru1fUyW3oLAZ/+aTnZrOcYRNVA8spoRtlRoWflsRClFcgzkqiHOrf0/SVw+EpVaFlJ0g4Kxq1MMOmiQdpMNpte8lMMQqm6cIFXlnGbfJllysKDi+0JJMotkqgIxOSQgU9dn/lWkeVf8nUm3iwX2Nl3WDw9i6AUK3vBAbZZrcJpDQ/N64AVwjT07Jef30GSSmtNu2WlW7YoyW2FlWfZFQUwk867EdLYKk9VG6JgEnBiBxkY7LMo4YLQJJlAo9l/oTvJkSARDF/XtyAzM8O2t3eT/iXa6wDN3WewNmQHdPfsxChU/KtLG2Mn8i4ZqKdSlIaBZadxJmRzVS/o4yA65RTSViq60oa395Lqw0pzY4SipwE0SXXsKV+GZraGSkr/RW08wPRvqvSUkYBMA9lPx4m24az+IHmCbXA+0faxTRE9wuGeO06DIXa6QlKJ3puIyiuAVfPr736vzo2pBirS+Vxel3TMm3JKhz9o2ZoRvaFVpIkykb0Hcm4oHFBMcNSNj7/4GJt43ogonY2Vg4nsDQIWxAcorpXACzgBqQPjYsE/VUpXpwNManEru4NwMCFPkXvMoqvoeLN3qyu/N1eWEHttMD65v19l/0kH2mR35iv/FI+yjoHJ9gPMz67af3Mq/BoWXqu3rphiWMXVkmnPSEkpGpUI2h1MThideGFEOK6YZHPwYzMBvpNC7+ZHxPb7epfefGyIB4JzO9DTNEYnDLVVHdQyvOEVefrk6Uv5kTQYVYWWdqrdcIl7yljwwIWdfQ/y+2QB3eR/qxYObuYyB4gTbo2in4PzarU1sO9nETkmj9/AoxDA+JM3GMqQtJR4jtduHtnoCLxd1gQUscHRB/MoRYIEsP2pDZ9KvHgtlk1iTbWWbHhohwFEYX7y51fUV2nuUmnoUcqnWIQAAgl9LTVX+Bc0QGNEhChxHR4YjfE51PUdGfsSFE6ck7BL3/hTf9jLq4G1IafINxOLKeAtO7quulYvH5YOBc+zX7CrMgWnW47/jfRsWnJjYYoE7xMfWV2HN2iyIqLI';
var FENCED = new Map([[8217, "apostrophe"], [8260, "fraction slash"], [12539, "middle dot"]]);
var NSM_MAX = 4;
function decode_arithmetic(bytes) {
  var pos = 0;
  function u16() {
    return bytes[pos++] << 8 | bytes[pos++];
  }

  // decode the frequency table
  var symbol_count = u16();
  var total = 1;
  var acc = [0, 1]; // first symbol has frequency 1
  for (var i = 1; i < symbol_count; i++) {
    acc.push(total += u16());
  }

  // skip the sized-payload that the last 3 symbols index into
  var skip = u16();
  var pos_payload = pos;
  pos += skip;
  var read_width = 0;
  var read_buffer = 0;
  function read_bit() {
    if (read_width == 0) {
      // this will read beyond end of buffer
      // but (undefined|0) => zero pad
      read_buffer = read_buffer << 8 | bytes[pos++];
      read_width = 8;
    }
    return read_buffer >> --read_width & 1;
  }
  var N = 31;
  var FULL = Math.pow(2, N);
  var HALF = FULL >>> 1;
  var QRTR = HALF >> 1;
  var MASK = FULL - 1;

  // fill register
  var register = 0;
  for (var _i = 0; _i < N; _i++) register = register << 1 | read_bit();
  var symbols = [];
  var low = 0;
  var range = FULL; // treat like a float
  while (true) {
    var value = Math.floor(((register - low + 1) * total - 1) / range);
    var start = 0;
    var end = symbol_count;
    while (end - start > 1) {
      // binary search
      var mid = start + end >>> 1;
      if (value < acc[mid]) {
        end = mid;
      } else {
        start = mid;
      }
    }
    if (start == 0) break; // first symbol is end mark
    symbols.push(start);
    var a = low + Math.floor(range * acc[start] / total);
    var b = low + Math.floor(range * acc[start + 1] / total) - 1;
    while (((a ^ b) & HALF) == 0) {
      register = register << 1 & MASK | read_bit();
      a = a << 1 & MASK;
      b = b << 1 & MASK | 1;
    }
    while (a & ~b & QRTR) {
      register = register & HALF | register << 1 & MASK >>> 1 | read_bit();
      a = a << 1 ^ HALF;
      b = (b ^ HALF) << 1 | HALF | 1;
    }
    low = a;
    range = 1 + b - a;
  }
  var offset = symbol_count - 4;
  return symbols.map(function (x) {
    // index into payload
    switch (x - offset) {
      case 3:
        return offset + 0x10100 + (bytes[pos_payload++] << 16 | bytes[pos_payload++] << 8 | bytes[pos_payload++]);
      case 2:
        return offset + 0x100 + (bytes[pos_payload++] << 8 | bytes[pos_payload++]);
      case 1:
        return offset + bytes[pos_payload++];
      default:
        return x - 1;
    }
  });
}

// returns an iterator which returns the next symbol
function read_payload(v) {
  var pos = 0;
  return function () {
    return v[pos++];
  };
}
function read_compressed_payload(s) {
  return read_payload(decode_arithmetic(unsafe_atob(s)));
}

// unsafe in the sense:
// expected well-formed Base64 w/o padding 
// 20220922: added for https://github.com/adraffy/ens-normalize.js/issues/4
function unsafe_atob(s) {
  var lookup = [];
  _toConsumableArray('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/').forEach(function (c, i) {
    return lookup[c.charCodeAt(0)] = i;
  });
  var n = s.length;
  var ret = new Uint8Array(6 * n >> 3);
  for (var i = 0, pos = 0, width = 0, carry = 0; i < n; i++) {
    carry = carry << 6 | lookup[s.charCodeAt(i)];
    width += 6;
    if (width >= 8) {
      ret[pos++] = carry >> (width -= 8);
    }
  }
  return ret;
}

// eg. [0,1,2,3...] => [0,-1,1,-2,...]
function signed(i) {
  return i & 1 ? ~i >> 1 : i >> 1;
}
function read_deltas(n, next) {
  var v = Array(n);
  for (var i = 0, x = 0; i < n; i++) v[i] = x += signed(next());
  return v;
}

// [123][5] => [0 3] [1 1] [0 0]
function read_sorted(next) {
  var prev = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var ret = [];
  while (true) {
    var x = next();
    var n = next();
    if (!n) break;
    prev += x;
    for (var i = 0; i < n; i++) {
      ret.push(prev + i);
    }
    prev += n + 1;
  }
  return ret;
}
function read_sorted_arrays(next) {
  return read_array_while(function () {
    var v = read_sorted(next);
    if (v.length) return v;
  });
}

// returns map of x => ys
function read_mapped(next) {
  var ret = [];
  while (true) {
    var w = next();
    if (w == 0) break;
    ret.push(read_linear_table(w, next));
  }
  while (true) {
    var _w = next() - 1;
    if (_w < 0) break;
    ret.push(read_replacement_table(_w, next));
  }
  return ret.flat();
}

// read until next is falsy
// return array of read values
function read_array_while(next) {
  var v = [];
  while (true) {
    var x = next(v.length);
    if (!x) break;
    v.push(x);
  }
  return v;
}

// read w columns of length n
// return as n rows of length w
function read_transposed(n, w, next) {
  var m = Array(n).fill().map(function () {
    return [];
  });
  for (var i = 0; i < w; i++) {
    read_deltas(n, next).forEach(function (x, j) {
      return m[j].push(x);
    });
  }
  return m;
}

// returns [[x, ys], [x+dx, ys+dy], [x+2*dx, ys+2*dy], ...]
// where dx/dy = steps, n = run size, w = length of y
function read_linear_table(w, next) {
  var dx = 1 + next();
  var dy = next();
  var vN = read_array_while(next);
  var m = read_transposed(vN.length, 1 + w, next);
  return m.flatMap(function (v, i) {
    var _v = _toArray(v),
      x = _v[0],
      ys = _v.slice(1);
    return Array(vN[i]).fill().map(function (_, j) {
      var j_dy = j * dy;
      return [x + j * dx, ys.map(function (y) {
        return y + j_dy;
      })];
    });
  });
}

// return [[x, ys...], ...]
// where w = length of y
function read_replacement_table(w, next) {
  var n = 1 + next();
  var m = read_transposed(n, 1 + w, next);
  return m.map(function (v) {
    return [v[0], v.slice(1)];
  });
}
function read_trie(next) {
  var ret = [];
  var sorted = read_sorted(next);
  expand(decode([]), []);
  return ret; // not sorted
  function decode(Q) {
    // characters that lead into this node
    var S = next(); // state: valid, save, check
    var B = read_array_while(function () {
      // buckets leading to new nodes
      var cps = read_sorted(next).map(function (i) {
        return sorted[i];
      });
      if (cps.length) return decode(cps);
    });
    return {
      S: S,
      B: B,
      Q: Q
    };
  }
  function expand(_ref, cps, saved) {
    var S = _ref.S,
      B = _ref.B;
    if (S & 4 && saved === cps[cps.length - 1]) return;
    if (S & 2) saved = cps[cps.length - 1];
    if (S & 1) ret.push(cps);
    var _iterator = _createForOfIteratorHelper(B),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var br = _step.value;
        var _iterator2 = _createForOfIteratorHelper(br.Q),
          _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var cp = _step2.value;
            expand(br, [].concat(_toConsumableArray(cps), [cp]), saved);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }
}
function hex_cp(cp) {
  return cp.toString(16).toUpperCase().padStart(2, '0');
}
function quote_cp(cp) {
  return "{".concat(hex_cp(cp), "}"); // raffy convention: like "\u{X}" w/o the "\u"
}

/*
export function explode_cp(s) {
	return [...s].map(c => c.codePointAt(0));
}
*/
function explode_cp(s) {
  // this is about 2x faster
  var cps = [];
  for (var pos = 0, len = s.length; pos < len;) {
    var cp = s.codePointAt(pos);
    pos += cp < 0x10000 ? 1 : 2;
    cps.push(cp);
  }
  return cps;
}
function str_from_cps(cps) {
  var chunk = 4096;
  var len = cps.length;
  if (len < chunk) return String.fromCodePoint.apply(String, _toConsumableArray(cps));
  var buf = [];
  for (var i = 0; i < len;) {
    buf.push(String.fromCodePoint.apply(String, _toConsumableArray(cps.slice(i, i += chunk))));
  }
  return buf.join('');
}
function compare_arrays(a, b) {
  var n = a.length;
  var c = n - b.length;
  for (var i = 0; c == 0 && i < n; i++) c = a[i] - b[i];
  return c;
}

// created 2023-09-25T01:01:55.148Z
// compressed base64-encoded blob for include-nf data
// source: https://github.com/adraffy/ens-normalize.js/blob/main/src/make.js
// see: https://github.com/adraffy/ens-normalize.js#security
// SHA-256: a974b6f8541fc29d919bc85118af0a44015851fab5343f8679cb31be2bdb209e
var COMPRESSED = 'AEUDTAHBCFQATQDRADAAcgAgADQAFAAsABQAHwAOACQADQARAAoAFwAHABIACAAPAAUACwAFAAwABAAQAAMABwAEAAoABQAIAAIACgABAAQAFAALAAIACwABAAIAAQAHAAMAAwAEAAsADAAMAAwACgANAA0AAwAKAAkABAAdAAYAZwDSAdsDJgC0CkMB8xhZAqfoC190UGcThgBurwf7PT09Pb09AjgJum8OjDllxHYUKXAPxzq6tABAxgK8ysUvWAgMPT09PT09PSs6LT2HcgWXWwFLoSMEEEl5RFVMKvO0XQ8ExDdJMnIgsj26PTQyy8FfEQ8AY8IPAGcEbwRwBHEEcgRzBHQEdQR2BHcEeAR6BHsEfAR+BIAEgfndBQoBYgULAWIFDAFiBNcE2ATZBRAFEQUvBdALFAsVDPcNBw13DYcOMA4xDjMB4BllHI0B2grbAMDpHLkQ7QHVAPRNQQFnGRUEg0yEB2uaJF8AJpIBpob5AERSMAKNoAXqaQLUBMCzEiACnwRZEkkVsS7tANAsBG0RuAQLEPABv9HICTUBXigPZwRBApMDOwAamhtaABqEAY8KvKx3LQ4ArAB8UhwEBAVSagD8AEFZADkBIadVj2UMUgx5Il4ANQC9AxIB1BlbEPMAs30CGxlXAhwZKQIECBc6EbsCoxngzv7UzRQA8M0BawL6ZwkN7wABAD33OQRcsgLJCjMCjqUChtw/km+NAsXPAoP2BT84PwURAK0RAvptb6cApQS/OMMey5HJS84UdxpxTPkCogVFITaTOwERAK5pAvkNBOVyA7q3BKlOJSALAgUIBRcEdASpBXqzABXFSWZOawLCOqw//AolCZdvv3dSBkEQGyelEPcMMwG1ATsN7UvYBPEGOwTJH30ZGQ/NlZwIpS3dDO0m4y6hgFoj9SqDBe1L9DzdC01RaA9ZC2UJ4zpjgU4DIQENIosK3Q05CG0Q8wrJaw3lEUUHOQPVSZoApQcBCxEdNRW1JhBirAsJOXcG+xr2C48mrxMpevwF0xohBk0BKRr/AM8u54WwWjFcHE9fBgMLJSPHFKhQIA0lQLd4SBobBxUlqQKRQ3BKh1E2HpMh9jw9DWYuE1F8B/U8BRlPC4E8nkarRQ4R0j6NPUgiSUwsBDV/LC8niwnPD4UMuXxyAVkJIQmxDHETMREXN8UIOQcZLZckJxUIIUaVYJoE958D8xPRAwsFPwlBBxMDtRwtEy4VKQUNgSTXAvM21S6zAo9WgAEXBcsPJR/fEFBH4A7pCJsCZQODJesALRUhABcimwhDYwBfj9hTBS7LCMdqbCN0A2cU52ERcweRDlcHpxwzFb8c4XDIXguGCCijrwlbAXUJmQFfBOMICTVbjKAgQWdTi1gYmyBhQT9d/AIxDGUVn0S9h3gCiw9rEhsBNQFzBzkNAQJ3Ee0RaxCVCOuGBDW1M/g6JQRPIYMgEQonA09szgsnJvkM+GkBoxJiAww0PXfuZ6tgtiQX/QcZMsVBYCHxC5JPzQycGsEYQlQuGeQHvwPzGvMn6kFXBf8DowMTOk0z7gS9C2kIiwk/AEkOoxcH1xhqCnGM0AExiwG3mQNXkYMCb48GNwcLAGcLhwV55QAdAqcIowAFAM8DVwA5Aq0HnQAZAIVBAT0DJy8BIeUCjwOTCDHLAZUvAfMpBBvDDBUA9zduSgLDsQKAamaiBd1YAo4CSTUBTSUEBU5HUQOvceEA2wBLBhPfRwEVq0rLGuNDAd9vKwDHAPsABTUHBUEBzQHzbQC3AV8LMQmis7UBTekpAIMAFWsB1wKJAN0ANQB/8QFTAE0FWfkF0wJPSQERMRgrV2EBuwMfATMBDQB5BsuNpckHHwRtB9MCEBsV4QLvLge1AQMi3xPNQsUCvd5VoWACZIECYkJbTa9bNyACofcCaJgCZgkCn4Q4GwsCZjsCZiYEbgR/A38TA36SOQY5dxc5gjojIwJsHQIyNjgKAm3HAm2u74ozZ0UrAWcA3gDhAEoFB5gMjQD+C8IADbUCdy8CdqI/AnlLQwJ4uh1c20WuRtcCfD8CesgCfQkCfPAFWQUgSABIfWMkAoFtAoAAAoAFAn+uSVhKWxUXSswC0QEC0MxLJwOITwOH5kTFkTIC8qFdAwMDrkvOTC0lA89NTE2vAos/AorYwRsHHUNnBbcCjjcCjlxAl4ECjtkCjlx4UbRTNQpS1FSFApP7ApMMAOkAHFUeVa9V0AYsGymVhjLheGZFOzkCl58C77JYIagAWSUClo8ClnycAKlZrFoJgU0AOwKWtQKWTlxEXNECmcsCmWRcyl0HGQKcmznCOp0CnBYCn5sCnriKAB0PMSoPAp3xAp6SALU9YTRh7wKe0wKgbgGpAp6fHwKeTqVjyGQnJSsCJ68CJn4CoPsCoEwCot0CocQCpi8Cpc4Cp/8AfQKn8mh8aLEAA0lqHGrRAqzjAqyuAq1nAq0CAlcdAlXcArHh1wMfTmyXArK9DQKy6Bds4G1jbUhfAyXNArZcOz9ukAMpRQK4XgK5RxUCuSp3cDZw4QK9GQK72nCWAzIRAr6IcgIDM3ECvhpzInNPAsPLAsMEc4J0SzVFdOADPKcDPJoDPb8CxXwCxkcCxhCJAshpUQLIRALJTwLJLgJknQLd0nh5YXiueSVL0AMYo2cCAmH0GfOVJHsLXpJeuxECz2sCz2wvS1PS8xOfAMatAs9zASnqA04SfksFAtwnAtuKAtJPA1JcA1NfAQEDVYyAiT8AyxbtYEWCHILTgs6DjQLaxwLZ3oQQhEmnPAOGpQAvA2QOhnFZ+QBVAt9lAt64c3cC4i/tFAHzMCcB9JsB8tKHAuvzAulweQLq+QLq5AD5RwG5Au6JAuuclqqXAwLuPwOF4Jh5cOBxoQLzAwBpA44WmZMC9xMDkW4DkocC95gC+dkC+GaaHJqruzebHgOdgwL++gEbADmfHJ+zAwWNA6ZqA6bZANHFAwZqoYiiBQkDDEkCwAA/AwDhQRdTARHzA2sHl2cFAJMtK7evvdsBiZkUfxEEOQH7KQUhDp0JnwCS/SlXxQL3AZ0AtwW5AG8LbUEuFCaNLgFDAYD8AbUmAHUDDgRtACwCFgyhAAAKAj0CagPdA34EkQEgRQUhfAoABQBEABMANhICdwEABdUDa+8KxQIA9wqfJ7+xt+UBkSFBQgHpFH8RNMCJAAQAGwBaAkUChIsABjpTOpSNbQC4Oo860ACNOME63AClAOgAywE6gTo7Ofw5+Tt2iTpbO56JOm85GAFWATMBbAUvNV01njWtNWY1dTW2NcU1gjWRNdI14TWeNa017jX9NbI1wTYCNhE1xjXVNhY2JzXeNe02LjY9Ni41LSE2OjY9Njw2yTcIBJA8VzY4Nt03IDcPNsogN4k3MAoEsDxnNiQ3GTdsOo03IULUQwdC4EMLHA8PCZsobShRVQYA6X8A6bABFCnXAukBowC9BbcAbwNzBL8MDAMMAQgDAAkKCwsLCQoGBAVVBI/DvwDz9b29kaUCb0QtsRTNLt4eGBcSHAMZFhYZEhYEARAEBUEcQRxBHEEcQRxBHEEaQRxBHEFCSTxBPElISUhBNkM2QTYbNklISVmBVIgBFLWZAu0BhQCjBcEAbykBvwGJAaQcEZ0ePCklMAAhMvAIMAL54gC7Bm8EescjzQMpARQpKgDUABavAj626xQAJP0A3etzuf4NNRA7efy2Z9NQrCnC0OSyANz5BBIbJ5IFDR6miIavYS6tprjjmuKebxm5C74Q225X1pkaYYPb6f1DK4k3xMEBb9S2WMjEibTNWhsRJIA+vwNVEiXTE5iXs/wezV66oFLfp9NZGYW+Gk19J2+bCT6Ye2w6LDYdgzKMUabk595eLBCXANz9HUpWbATq9vqXVx9XDg+Pc9Xp4+bsS005SVM/BJBM4687WUuf+Uj9dEi8aDNaPxtpbDxcG1THTImUMZq4UCaaNYpsVqraNyKLJXDYsFZ/5jl7bLRtO88t7P3xZaAxhb5OdPMXqsSkp1WCieG8jXm1U99+blvLlXzPCS+M93VnJCiK+09LfaSaBAVBomyDgJua8dfUzR7ga34IvR2Nvj+A9heJ6lsl1KG4NkI1032Cnff1m1wof2B9oHJK4bi6JkEdSqeNeiuo6QoZZincoc73/TH9SXF8sCE7XyuYyW8WSgbGFCjPV0ihLKhdPs08Tx82fYAkLLc4I2wdl4apY7GU5lHRFzRWJep7Ww3wbeA3qmd59/86P4xuNaqDpygXt6M85glSBHOCGgJDnt+pN9bK7HApMguX6+06RZNjzVmcZJ+wcUrJ9//bpRNxNuKpNl9uFds+S9tdx7LaM5ZkIrPj6nIU9mnbFtVbs9s/uLgl8MVczAwet+iOEzzBlYW7RCMgE6gyNLeq6+1tIx4dpgZnd0DksJS5f+JNDpwwcPNXaaVspq1fbQajOrJgK0ofKtJ1Ne90L6VO4MOl5S886p7u6xo7OLjG8TGL+HU1JXGJgppg4nNbNJ5nlzSpuPYy21JUEcUA94PoFiZfjZue+QnyQ80ekOuZVkxx4g+cvhJfHgNl4hy1/a6+RKcKlar/J29y//EztlbVPHVUeQ1zX86eQVAjR/M3dA9w4W8LfaXp4EgM85wOWasli837PzVMOnsLzR+k3o75/lRPAJSE1xAKQzEi5v10ke+VBvRt1cwQRMd+U5mLCTGVd6XiZtgBG5cDi0w22GKcVNvHiu5LQbZEDVtz0onn7k5+heuKXVsZtSzilkLRAUmjMXEMB3J9YC50XBxPiz53SC+EhnPl9WsKCv92SM/OFFIMJZYfl0WW8tIO3UxYcwdMAj7FSmgrsZ2aAZO03BOhP1bNNZItyXYQFTpC3SG1VuPDqH9GkiCDmE+JwxyIVSO5siDErAOpEXFgjy6PQtOVDj+s6e1r8heWVvmZnTciuf4EiNZzCAd7SOMhXERIOlsHIMG399i9aLTy3m2hRLZjJVDNLS53iGIK11dPqQt0zBDyg6qc7YqkDm2M5Ve6dCWCaCbTXX2rToaIgz6+zh4lYUi/+6nqcFMAkQJKHYLK0wYk5N9szV6xihDbDDFr45lN1K4aCXBq/FitPSud9gLt5ZVn+ZqGX7cwm2z5EGMgfFpIFyhGGuDPmso6TItTMwny+7uPnLCf4W6goFQFV0oQSsc9VfMmVLcLr6ZetDZbaSFTLqnSO/bIPjA3/zAUoqgGFAEQS4IhuMzEp2I3jJzbzkk/IEmyax+rhZTwd6f+CGtwPixu8IvzACquPWPREu9ZvGkUzpRwvRRuaNN6cr0W1wWits9ICdYJ7ltbgMiSL3sTPeufgNcVqMVWFkCPDH4jG2jA0XcVgQj62Cb29v9f/z/+2KbYvIv/zzjpQAPkliaVDzNrW57TZ/ZOyZD0nlfMmAIBIAGAI0D3k/mdN4xr9v85ZbZbbqfH2jGd5hUqNZWwl5SPfoGmfElmazUIeNL1j/mkF7VNAzTq4jNt8JoQ11NQOcmhprXoxSxfRGJ9LDEOAQ+dmxAQH90iti9e2u/MoeuaGcDTHoC+xsmEeWmxEKefQuIzHbpw5Tc5cEocboAD09oipWQhtTO1wivf/O+DRe2rpl/E9wlrzBorjJsOeG1B/XPW4EaJEFdNlECEZga5ZoGRHXgYouGRuVkm8tDESiEyFNo+3s5M5puSdTyUL2llnINVHEt91XUNW4ewdMgJ4boJfEyt/iY5WXqbA+A2Fkt5Z0lutiWhe9nZIyIUjyXDC3UsaG1t+eNx6z4W/OYoTB7A6x+dNSTOi9AInctbESqm5gvOLww7OWXPrmHwVZasrl4eD113pm+JtT7JVOvnCXqdzzdTRHgJ0PiGTFYW5Gvt9R9LD6Lzfs0v/TZZHSmyVNq7viIHE6DBK7Qp07Iz55EM8SYtQvZf/obBniTWi5C2/ovHfw4VndkE5XYdjOhCMRjDeOEfXeN/CwfGduiUIfsoFeUxXeQXba7c7972XNv8w+dTjjUM0QeNAReW+J014dKAD/McQYXT7c0GQPIkn3Ll6R7gGjuiQoZD0TEeEqQpKoZ15g/0OPQI17QiSv9AUROa/V/TQN3dvLArec3RrsYlvBm1b8LWzltdugsC50lNKYLEp2a+ZZYqPejULRlOJh5zj/LVMyTDvwKhMxxwuDkxJ1QpoNI0OTWLom4Z71SNzI9TV1iXJrIu9Wcnd+MCaAw8o1jSXd94YU/1gnkrC9BUEOtQvEIQ7g0i6h+KL2JKk8Ydl7HruvgWMSAmNe+LshGhV4qnWHhO9/RIPQzY1tHRj2VqOyNsDpK0cww+56AdDC4gsWwY0XxoucIWIqs/GcwnWqlaT0KPr8mbK5U94/301i1WLt4YINTVvCFBrFZbIbY8eycOdeJ2teD5IfPLCRg7jjcFTwlMFNl9zdh/o3E/hHPwj7BWg0MU09pPrBLbrCgm54A6H+I6v27+jL5gkjWg/iYdks9jbfVP5y/n0dlgWEMlKasl7JvFZd56LfybW1eeaVO0gxTfXZwD8G4SI116yx7UKVRgui6Ya1YpixqXeNLc8IxtAwCU5IhwQgn+NqHnRaDv61CxKhOq4pOX7M6pkA+Pmpd4j1vn6ACUALoLLc4vpXci8VidLxzm7qFBe7s+quuJs6ETYmnpgS3LwSZxPIltgBDXz8M1k/W2ySNv2f9/NPhxLGK2D21dkHeSGmenRT3Yqcdl0m/h3OYr8V+lXNYGf8aCCpd4bWjE4QIPj7vUKN4Nrfs7ML6Y2OyS830JCnofg/k7lpFpt4SqZc5HGg1HCOrHvOdC8bP6FGDbE/VV0mX4IakzbdS/op+Kt3G24/8QbBV7y86sGSQ/vZzU8FXs7u6jIvwchsEP2BpIhW3G8uWNwa3HmjfH/ZjhhCWvluAcF+nMf14ClKg5hGgtPLJ98ueNAkc5Hs2WZlk2QHvfreCK1CCGO6nMZVSb99VM/ajr8WHTte9JSmkXq/i/U943HEbdzW6Re/S88dKgg8pGOLlAeNiqrcLkUR3/aClFpMXcOUP3rmETcWSfMXZE3TUOi8i+fqRnTYLflVx/Vb/6GJ7eIRZUA6k3RYR3iFSK9c4iDdNwJuZL2FKz/IK5VimcNWEqdXjSoxSgmF0UPlDoUlNrPcM7ftmA8Y9gKiqKEHuWN+AZRIwtVSxye2Kf8rM3lhJ5XcBXU9n4v0Oy1RU2M+4qM8AQPVwse8ErNSob5oFPWxuqZnVzo1qB/IBxkM3EVUKFUUlO3e51259GgNcJbCmlvrdjtoTW7rChm1wyCKzpCTwozUUEOIcWLneRLgMXh+SjGSFkAllzbGS5HK7LlfCMRNRDSvbQPjcXaenNYxCvu2Qyznz6StuxVj66SgI0T8B6/sfHAJYZaZ78thjOSIFumNWLQbeZixDCCC+v0YBtkxiBB3jefHqZ/dFHU+crbj6OvS1x/JDD7vlm7zOVPwpUC01nhxZuY/63E7g';

// https://unicode.org/reports/tr15/
// for reference implementation
// see: /derive/nf.js

// algorithmic hangul
// https://www.unicode.org/versions/Unicode15.0.0/ch03.pdf (page 144)
var S0 = 0xAC00;
var L0 = 0x1100;
var V0 = 0x1161;
var T0 = 0x11A7;
var L_COUNT = 19;
var V_COUNT = 21;
var T_COUNT = 28;
var N_COUNT = V_COUNT * T_COUNT;
var S_COUNT = L_COUNT * N_COUNT;
var S1 = S0 + S_COUNT;
var L1 = L0 + L_COUNT;
var V1 = V0 + V_COUNT;
var T1 = T0 + T_COUNT;
function unpack_cc(packed) {
  return packed >> 24 & 0xFF;
}
function unpack_cp(packed) {
  return packed & 0xFFFFFF;
}
var SHIFTED_RANK, EXCLUSIONS, DECOMP, RECOMP;
function init$1() {
  //console.time('nf');
  var r = read_compressed_payload(COMPRESSED);
  SHIFTED_RANK = new Map(read_sorted_arrays(r).flatMap(function (v, i) {
    return v.map(function (x) {
      return [x, i + 1 << 24];
    });
  })); // pre-shifted
  EXCLUSIONS = new Set(read_sorted(r));
  DECOMP = new Map();
  RECOMP = new Map();
  var _iterator3 = _createForOfIteratorHelper(read_mapped(r)),
    _step3;
  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var _step3$value = _slicedToArray(_step3.value, 2),
        cp = _step3$value[0],
        cps = _step3$value[1];
      if (!EXCLUSIONS.has(cp) && cps.length == 2) {
        var _cps = _slicedToArray(cps, 2),
          a = _cps[0],
          b = _cps[1];
        var bucket = RECOMP.get(a);
        if (!bucket) {
          bucket = new Map();
          RECOMP.set(a, bucket);
        }
        bucket.set(b, cp);
      }
      DECOMP.set(cp, cps.reverse()); // stored reversed
    }
    //console.timeEnd('nf');
    // 20230905: 11ms
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }
}
function is_hangul(cp) {
  return cp >= S0 && cp < S1;
}
function compose_pair(a, b) {
  if (a >= L0 && a < L1 && b >= V0 && b < V1) {
    return S0 + (a - L0) * N_COUNT + (b - V0) * T_COUNT;
  } else if (is_hangul(a) && b > T0 && b < T1 && (a - S0) % T_COUNT == 0) {
    return a + (b - T0);
  } else {
    var recomp = RECOMP.get(a);
    if (recomp) {
      recomp = recomp.get(b);
      if (recomp) {
        return recomp;
      }
    }
    return -1;
  }
}
function decomposed(cps) {
  if (!SHIFTED_RANK) init$1();
  var ret = [];
  var buf = [];
  var check_order = false;
  function add(cp) {
    var cc = SHIFTED_RANK.get(cp);
    if (cc) {
      check_order = true;
      cp |= cc;
    }
    ret.push(cp);
  }
  var _iterator4 = _createForOfIteratorHelper(cps),
    _step4;
  try {
    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
      var cp = _step4.value;
      while (true) {
        if (cp < 0x80) {
          ret.push(cp);
        } else if (is_hangul(cp)) {
          var s_index = cp - S0;
          var l_index = s_index / N_COUNT | 0;
          var v_index = s_index % N_COUNT / T_COUNT | 0;
          var t_index = s_index % T_COUNT;
          add(L0 + l_index);
          add(V0 + v_index);
          if (t_index > 0) add(T0 + t_index);
        } else {
          var mapped = DECOMP.get(cp);
          if (mapped) {
            buf.push.apply(buf, _toConsumableArray(mapped));
          } else {
            add(cp);
          }
        }
        if (!buf.length) break;
        cp = buf.pop();
      }
    }
  } catch (err) {
    _iterator4.e(err);
  } finally {
    _iterator4.f();
  }
  if (check_order && ret.length > 1) {
    var prev_cc = unpack_cc(ret[0]);
    for (var i = 1; i < ret.length; i++) {
      var cc = unpack_cc(ret[i]);
      if (cc == 0 || prev_cc <= cc) {
        prev_cc = cc;
        continue;
      }
      var j = i - 1;
      while (true) {
        var tmp = ret[j + 1];
        ret[j + 1] = ret[j];
        ret[j] = tmp;
        if (!j) break;
        prev_cc = unpack_cc(ret[--j]);
        if (prev_cc <= cc) break;
      }
      prev_cc = unpack_cc(ret[i]);
    }
  }
  return ret;
}
function composed_from_decomposed(v) {
  var ret = [];
  var stack = [];
  var prev_cp = -1;
  var prev_cc = 0;
  var _iterator5 = _createForOfIteratorHelper(v),
    _step5;
  try {
    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
      var packed = _step5.value;
      var cc = unpack_cc(packed);
      var cp = unpack_cp(packed);
      if (prev_cp == -1) {
        if (cc == 0) {
          prev_cp = cp;
        } else {
          ret.push(cp);
        }
      } else if (prev_cc > 0 && prev_cc >= cc) {
        if (cc == 0) {
          ret.push.apply(ret, [prev_cp].concat(stack));
          stack.length = 0;
          prev_cp = cp;
        } else {
          stack.push(cp);
        }
        prev_cc = cc;
      } else {
        var composed = compose_pair(prev_cp, cp);
        if (composed >= 0) {
          prev_cp = composed;
        } else if (prev_cc == 0 && cc == 0) {
          ret.push(prev_cp);
          prev_cp = cp;
        } else {
          stack.push(cp);
          prev_cc = cc;
        }
      }
    }
  } catch (err) {
    _iterator5.e(err);
  } finally {
    _iterator5.f();
  }
  if (prev_cp >= 0) {
    ret.push.apply(ret, [prev_cp].concat(stack));
  }
  return ret;
}

// note: cps can be iterable
function nfd(cps) {
  return decomposed(cps).map(unpack_cp);
}
function nfc(cps) {
  return composed_from_decomposed(decomposed(cps));
}
var HYPHEN = 0x2D;
var STOP = 0x2E;
var STOP_CH = '.';
var FE0F = 0xFE0F;
var UNIQUE_PH = 1;

// 20230913: replace [...v] with Array_from(v) to avoid large spreads
var Array_from = function Array_from(x) {
  return Array.from(x);
}; // Array.from.bind(Array);

function group_has_cp(g, cp) {
  // 20230913: keep primary and secondary distinct instead of creating valid union
  return g.P.has(cp) || g.Q.has(cp);
}
var Emoji = /*#__PURE__*/function (_Array) {
  function Emoji() {
    _classCallCheck(this, Emoji);
    return _callSuper(this, Emoji, arguments);
  }
  _inherits(Emoji, _Array);
  return _createClass(Emoji, [{
    key: "is_emoji",
    get: function get() {
      return true;
    } // free tagging system
  }]);
}( /*#__PURE__*/_wrapNativeSuper(Array));
var MAPPED, IGNORED, CM, NSM, ESCAPE, NFC_CHECK, GROUPS, WHOLE_VALID, WHOLE_MAP, VALID, EMOJI_LIST, EMOJI_ROOT;
function init() {
  if (MAPPED) return;
  var r = read_compressed_payload(COMPRESSED$1);
  var read_sorted_array = function read_sorted_array() {
    return read_sorted(r);
  };
  var read_sorted_set = function read_sorted_set() {
    return new Set(read_sorted_array());
  };
  var set_add_many = function set_add_many(set, v) {
    return v.forEach(function (x) {
      return set.add(x);
    });
  };
  MAPPED = new Map(read_mapped(r));
  IGNORED = read_sorted_set(); // ignored characters are not valid, so just read raw codepoints

  /*
  // direct include from payload is smaller than the decompression code
  const FENCED = new Map(read_array_while(() => {
  	let cp = r();
  	if (cp) return [cp, read_str(r())];
  }));
  */
  // 20230217: we still need all CM for proper error formatting
  // but norm only needs NSM subset that are potentially-valid
  CM = read_sorted_array();
  NSM = new Set(read_sorted_array().map(function (i) {
    return CM[i];
  }));
  CM = new Set(CM);
  ESCAPE = read_sorted_set(); // characters that should not be printed
  NFC_CHECK = read_sorted_set(); // only needed to illustrate ens_tokenize() transformations

  var chunks = read_sorted_arrays(r);
  var unrestricted = r();
  //const read_chunked = () => new Set(read_sorted_array().flatMap(i => chunks[i]).concat(read_sorted_array()));
  var read_chunked = function read_chunked() {
    // 20230921: build set in parts, 2x faster
    var set = new Set();
    read_sorted_array().forEach(function (i) {
      return set_add_many(set, chunks[i]);
    });
    set_add_many(set, read_sorted_array());
    return set;
  };
  GROUPS = read_array_while(function (i) {
    // minifier property mangling seems unsafe
    // so these are manually renamed to single chars
    var N = read_array_while(r).map(function (x) {
      return x + 0x60;
    });
    if (N.length) {
      var R = i >= unrestricted; // unrestricted then restricted
      N[0] -= 32; // capitalize
      N = str_from_cps(N);
      if (R) N = "Restricted[".concat(N, "]");
      var P = read_chunked(); // primary
      var Q = read_chunked(); // secondary
      var M = !r(); // not-whitelisted, check for NSM
      // *** this code currently isn't needed ***
      /*
      let V = [...P, ...Q].sort((a, b) => a-b); // derive: sorted valid
      let M = r()-1; // number of combining mark
      if (M < 0) { // whitelisted
      	M = new Map(read_array_while(() => {
      		let i = r();
      		if (i) return [V[i-1], read_array_while(() => {
      			let v = read_array_while(r);
      			if (v.length) return v.map(x => x-1);
      		})];
      	}));
      }*/
      return {
        N: N,
        P: P,
        Q: Q,
        M: M,
        R: R
      };
    }
  });

  // decode compressed wholes
  WHOLE_VALID = read_sorted_set();
  WHOLE_MAP = new Map();
  var wholes = read_sorted_array().concat(Array_from(WHOLE_VALID)).sort(function (a, b) {
    return a - b;
  }); // must be sorted
  wholes.forEach(function (cp, i) {
    var d = r();
    var w = wholes[i] = d ? wholes[i - d] : {
      V: [],
      M: new Map()
    };
    w.V.push(cp); // add to member set
    if (!WHOLE_VALID.has(cp)) {
      WHOLE_MAP.set(cp, w); // register with whole map
    }
  });

  // compute confusable-extent complements
  // usage: WHOLE_MAP.get(cp).M.get(cp) = complement set
  var _iterator6 = _createForOfIteratorHelper(new Set(WHOLE_MAP.values())),
    _step6;
  try {
    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
      var _step6$value = _step6.value,
        V = _step6$value.V,
        M = _step6$value.M;
      // connect all groups that have each whole character
      var recs = [];
      var _iterator10 = _createForOfIteratorHelper(V),
        _step10;
      try {
        var _loop2 = function _loop2() {
          var cp = _step10.value;
          var gs = GROUPS.filter(function (g) {
            return group_has_cp(g, cp);
          });
          var rec = recs.find(function (_ref2) {
            var G = _ref2.G;
            return gs.some(function (g) {
              return G.has(g);
            });
          });
          if (!rec) {
            rec = {
              G: new Set(),
              V: []
            };
            recs.push(rec);
          }
          rec.V.push(cp);
          set_add_many(rec.G, gs);
        };
        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
          _loop2();
        }
        // per character cache groups which are not a member of the extent
      } catch (err) {
        _iterator10.e(err);
      } finally {
        _iterator10.f();
      }
      var union = recs.flatMap(function (x) {
        return Array_from(x.G);
      }); // all of the groups used by this whole
      var _loop = function _loop() {
        var _recs$_i = _recs[_i2],
          G = _recs$_i.G,
          V = _recs$_i.V;
        var complement = new Set(union.filter(function (g) {
          return !G.has(g);
        })); // groups not covered by the extent
        var _iterator11 = _createForOfIteratorHelper(V),
          _step11;
        try {
          for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
            var cp = _step11.value;
            M.set(cp, complement); // this is the same reference
          }
        } catch (err) {
          _iterator11.e(err);
        } finally {
          _iterator11.f();
        }
      };
      for (var _i2 = 0, _recs = recs; _i2 < _recs.length; _i2++) {
        _loop();
      }
    }

    // compute valid set
    // 20230924: VALID was union but can be re-used
  } catch (err) {
    _iterator6.e(err);
  } finally {
    _iterator6.f();
  }
  VALID = new Set(); // exists in 1+ groups
  var multi = new Set(); // exists in 2+ groups
  var add_to_union = function add_to_union(cp) {
    return VALID.has(cp) ? multi.add(cp) : VALID.add(cp);
  };
  var _iterator7 = _createForOfIteratorHelper(GROUPS),
    _step7;
  try {
    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
      var g = _step7.value;
      var _iterator12 = _createForOfIteratorHelper(g.P),
        _step12;
      try {
        for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
          var cp = _step12.value;
          add_to_union(cp);
        }
      } catch (err) {
        _iterator12.e(err);
      } finally {
        _iterator12.f();
      }
      var _iterator13 = _createForOfIteratorHelper(g.Q),
        _step13;
      try {
        for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {
          var _cp = _step13.value;
          add_to_union(_cp);
        }
      } catch (err) {
        _iterator13.e(err);
      } finally {
        _iterator13.f();
      }
    }
    // dual purpose WHOLE_MAP: return placeholder if unique non-confusable
  } catch (err) {
    _iterator7.e(err);
  } finally {
    _iterator7.f();
  }
  var _iterator8 = _createForOfIteratorHelper(VALID),
    _step8;
  try {
    for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
      var _cp2 = _step8.value;
      if (!WHOLE_MAP.has(_cp2) && !multi.has(_cp2)) {
        WHOLE_MAP.set(_cp2, UNIQUE_PH);
      }
    }
    // add all decomposed parts
    // see derive: "Valid is Closed (via Brute-force)"
  } catch (err) {
    _iterator8.e(err);
  } finally {
    _iterator8.f();
  }
  set_add_many(VALID, nfd(VALID));

  // decode emoji
  // 20230719: emoji are now fully-expanded to avoid quirk logic 
  EMOJI_LIST = read_trie(r).map(function (v) {
    return Emoji.from(v);
  }).sort(compare_arrays);
  EMOJI_ROOT = new Map(); // this has approx 7K nodes (2+ per emoji)
  var _iterator9 = _createForOfIteratorHelper(EMOJI_LIST),
    _step9;
  try {
    for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
      var cps = _step9.value;
      // 20230719: change to *slightly* stricter algorithm which disallows 
      // insertion of misplaced FE0F in emoji sequences (matching ENSIP-15)
      // example: beautified [A B] (eg. flag emoji) 
      //  before: allow: [A FE0F B], error: [A FE0F FE0F B] 
      //   after: error: both
      // note: this code now matches ENSNormalize.{cs,java} logic
      var prev = [EMOJI_ROOT];
      var _iterator14 = _createForOfIteratorHelper(cps),
        _step14;
      try {
        var _loop3 = function _loop3() {
          var cp = _step14.value;
          var next = prev.map(function (node) {
            var child = node.get(cp);
            if (!child) {
              // should this be object? 
              // (most have 1-2 items, few have many)
              // 20230719: no, v8 default map is 4?
              child = new Map();
              node.set(cp, child);
            }
            return child;
          });
          if (cp === FE0F) {
            var _prev;
            (_prev = prev).push.apply(_prev, _toConsumableArray(next)); // less than 20 elements
          } else {
            prev = next;
          }
        };
        for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {
          _loop3();
        }
      } catch (err) {
        _iterator14.e(err);
      } finally {
        _iterator14.f();
      }
      var _iterator15 = _createForOfIteratorHelper(prev),
        _step15;
      try {
        for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {
          var x = _step15.value;
          x.V = cps;
        }
      } catch (err) {
        _iterator15.e(err);
      } finally {
        _iterator15.f();
      }
    }
  } catch (err) {
    _iterator9.e(err);
  } finally {
    _iterator9.f();
  }
}

// if escaped: {HEX}
//       else: "x" {HEX}
function quoted_cp(cp) {
  return (should_escape(cp) ? '' : "".concat(bidi_qq(safe_str_from_cps([cp])), " ")) + quote_cp(cp);
}

// 20230211: some messages can be mixed-directional and result in spillover
// use 200E after a quoted string to force the remainder of a string from 
// acquring the direction of the quote
// https://www.w3.org/International/questions/qa-bidi-unicode-controls#exceptions
function bidi_qq(s) {
  return "\"".concat(s, "\"\u200E"); // strong LTR
}
function check_label_extension(cps) {
  if (cps.length >= 4 && cps[2] == HYPHEN && cps[3] == HYPHEN) {
    throw new Error("invalid label extension: \"".concat(str_from_cps(cps.slice(0, 4)), "\"")); // this can only be ascii so cant be bidi
  }
}
function check_leading_underscore(cps) {
  var UNDERSCORE = 0x5F;
  for (var i = cps.lastIndexOf(UNDERSCORE); i > 0;) {
    if (cps[--i] !== UNDERSCORE) {
      throw new Error('underscore allowed only at start');
    }
  }
}
// check that a fenced cp is not leading, trailing, or touching another fenced cp
function check_fenced(cps) {
  var cp = cps[0];
  var prev = FENCED.get(cp);
  if (prev) throw error_placement("leading ".concat(prev));
  var n = cps.length;
  var last = -1; // prevents trailing from throwing
  for (var i = 1; i < n; i++) {
    cp = cps[i];
    var match = FENCED.get(cp);
    if (match) {
      // since cps[0] isn't fenced, cps[1] cannot throw
      if (last == i) throw error_placement("".concat(prev, " + ").concat(match));
      last = i + 1;
      prev = match;
    }
  }
  if (last == n) throw error_placement("trailing ".concat(prev));
}

// create a safe to print string 
// invisibles are escaped
// leading cm uses placeholder
// if cps exceed max, middle truncate with ellipsis
// quoter(cp) => string, eg. 3000 => "{3000}"
// note: in html, you'd call this function then replace [<>&] with entities
function safe_str_from_cps(cps) {
  var max = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Infinity;
  var quoter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : quote_cp;
  //if (Number.isInteger(cps)) cps = [cps];
  //if (!Array.isArray(cps)) throw new TypeError(`expected codepoints`);
  var buf = [];
  if (is_combining_mark(cps[0])) buf.push('');
  if (cps.length > max) {
    max >>= 1;
    cps = [].concat(_toConsumableArray(cps.slice(0, max)), [0x2026], _toConsumableArray(cps.slice(-max)));
  }
  var prev = 0;
  var n = cps.length;
  for (var i = 0; i < n; i++) {
    var cp = cps[i];
    if (should_escape(cp)) {
      buf.push(str_from_cps(cps.slice(prev, i)));
      buf.push(quoter(cp));
      prev = i + 1;
    }
  }
  buf.push(str_from_cps(cps.slice(prev, n)));
  return buf.join('');
}

// note: set(s) cannot be exposed because they can be modified
// note: Object.freeze() doesn't work
function is_combining_mark(cp) {
  init();
  return CM.has(cp);
}
function should_escape(cp) {
  init();
  return ESCAPE.has(cp);
}

// return all supported emoji as fully-qualified emoji 
// ordered by length then lexicographic 
function ens_emoji() {
  init();
  return EMOJI_LIST.map(function (x) {
    return x.slice();
  }); // emoji are exposed so copy
}
function ens_normalize_fragment(frag, decompose) {
  init();
  var nf = decompose ? nfd : nfc;
  return frag.split(STOP_CH).map(function (label) {
    return str_from_cps(tokens_from_str(explode_cp(label), nf, filter_fe0f).flat());
  }).join(STOP_CH);
}
function ens_normalize(name) {
  return flatten(split(name, nfc, filter_fe0f));
}
function ens_beautify(name) {
  var labels = split(name, nfc, function (x) {
    return x;
  }); // emoji not exposed
  var _iterator16 = _createForOfIteratorHelper(labels),
    _step16;
  try {
    for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {
      var _step16$value = _step16.value,
        type = _step16$value.type,
        output = _step16$value.output,
        error = _step16$value.error;
      if (error) break; // flatten will throw

      // replace leading/trailing hyphen
      // 20230121: consider beautifing all or leading/trailing hyphen to unicode variant
      // not exactly the same in every font, but very similar: "-" vs ""
      /*
      const UNICODE_HYPHEN = 0x2010;
      // maybe this should replace all for visual consistancy?
      // `node tools/reg-count.js regex ^-\{2,\}` => 592
      //for (let i = 0; i < output.length; i++) if (output[i] == 0x2D) output[i] = 0x2010;
      if (output[0] == HYPHEN) output[0] = UNICODE_HYPHEN;
      let end = output.length-1;
      if (output[end] == HYPHEN) output[end] = UNICODE_HYPHEN;
      */
      // 20230123: WHATWG URL uses "CheckHyphens" false
      // https://url.spec.whatwg.org/#idna

      // update ethereum symbol
      //  =>  if not greek
      if (type !== 'Greek') array_replace(output, 0x3BE, 0x39E);

      // 20221213: fixes bidi subdomain issue, but breaks invariant (200E is disallowed)
      // could be fixed with special case for: 2D (.) + 200E (LTR)
      // https://discuss.ens.domains/t/bidi-label-ordering-spoof/15824
      //output.splice(0, 0, 0x200E);
    }
  } catch (err) {
    _iterator16.e(err);
  } finally {
    _iterator16.f();
  }
  return flatten(labels);
}
function array_replace(v, a, b) {
  var prev = 0;
  while (true) {
    var next = v.indexOf(a, prev);
    if (next < 0) break;
    v[next] = b;
    prev = next + 1;
  }
}
function ens_split(name, preserve_emoji) {
  return split(name, nfc, preserve_emoji ? function (x) {
    return x.slice();
  } : filter_fe0f); // emoji are exposed so copy
}
function split(name, nf, ef) {
  if (!name) return []; // 20230719: empty name allowance
  init();
  var offset = 0;
  // https://unicode.org/reports/tr46/#Validity_Criteria
  // 4.) "The label must not contain a U+002E ( . ) FULL STOP."
  return name.split(STOP_CH).map(function (label) {
    var input = explode_cp(label);
    var info = {
      input: input,
      offset: offset // codepoint, not substring!
    };
    offset += input.length + 1; // + stop
    try {
      // 1.) "The label must be in Unicode Normalization Form NFC"
      var tokens = info.tokens = tokens_from_str(input, nf, ef);
      var token_count = tokens.length;
      var type;
      if (!token_count) {
        // the label was effectively empty (could of had ignored characters)
        //norm = [];
        //type = 'None'; // use this instead of next match, "ASCII"
        // 20230120: change to strict
        // https://discuss.ens.domains/t/ens-name-normalization-2nd/14564/59
        throw new Error("empty label");
      }
      var norm = info.output = tokens.flat();
      check_leading_underscore(norm);
      var emoji = info.emoji = token_count > 1 || tokens[0].is_emoji; // same as: tokens.some(x => x.is_emoji);
      if (!emoji && norm.every(function (cp) {
        return cp < 0x80;
      })) {
        // special case for ascii
        // 20230123: matches matches WHATWG, see note 3.3
        check_label_extension(norm); // only needed for ascii
        // cant have fenced
        // cant have cm
        // cant have wholes
        // see derive: "Fastpath ASCII"
        type = 'ASCII';
      } else {
        var chars = tokens.flatMap(function (x) {
          return x.is_emoji ? [] : x;
        }); // all of the nfc tokens concat together
        if (!chars.length) {
          // theres no text, just emoji
          type = 'Emoji';
        } else {
          // 5.) "The label must not begin with a combining mark, that is: General_Category=Mark."
          if (CM.has(norm[0])) throw error_placement('leading combining mark');
          for (var i = 1; i < token_count; i++) {
            // we've already checked the first token
            var cps = tokens[i];
            if (!cps.is_emoji && CM.has(cps[0])) {
              // every text token has emoji neighbors, eg. EtEEEtEt...
              // bidi_qq() not needed since emoji is LTR and cps is a CM
              throw error_placement("emoji + combining mark: \"".concat(str_from_cps(tokens[i - 1]), " + ").concat(safe_str_from_cps([cps[0]]), "\""));
            }
          }
          check_fenced(norm);
          var unique = Array_from(new Set(chars));
          var _determine_group = determine_group(unique),
            _determine_group2 = _slicedToArray(_determine_group, 1),
            g = _determine_group2[0]; // take the first match
          // see derive: "Matching Groups have Same CM Style"
          // alternative: could form a hybrid type: Latin/Japanese/...	
          check_group(g, chars); // need text in order
          check_whole(g, unique); // only need unique text (order would be required for multiple-char confusables)
          type = g.N;
          // 20230121: consider exposing restricted flag
          // it's simpler to just check for 'Restricted'
          // or even better: type.endsWith(']')
          //if (g.R) info.restricted = true;
        }
      }
      info.type = type;
    } catch (err) {
      info.error = err; // use full error object
    }
    return info;
  });
}
function check_whole(group, unique) {
  var maker;
  var shared = [];
  var _iterator17 = _createForOfIteratorHelper(unique),
    _step17;
  try {
    var _loop5 = function _loop5() {
        var cp = _step17.value;
        var whole = WHOLE_MAP.get(cp);
        if (whole === UNIQUE_PH) return {
          v: void 0
        }; // unique, non-confusable
        if (whole) {
          var set = whole.M.get(cp); // groups which have a character that look-like this character
          maker = maker ? maker.filter(function (g) {
            return set.has(g);
          }) : Array_from(set);
          if (!maker.length) return {
            v: void 0
          }; // confusable intersection is empty
        } else {
          shared.push(cp);
        }
      },
      _ret;
    for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {
      _ret = _loop5();
      if (_ret) return _ret.v;
    }
  } catch (err) {
    _iterator17.e(err);
  } finally {
    _iterator17.f();
  }
  if (maker) {
    // we have 1+ confusable
    // check if any of the remaining groups
    // contain the shared characters too
    var _iterator18 = _createForOfIteratorHelper(maker),
      _step18;
    try {
      var _loop4 = function _loop4() {
        var g = _step18.value;
        if (shared.every(function (cp) {
          return group_has_cp(g, cp);
        })) {
          throw new Error("whole-script confusable: ".concat(group.N, "/").concat(g.N));
        }
      };
      for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {
        _loop4();
      }
    } catch (err) {
      _iterator18.e(err);
    } finally {
      _iterator18.f();
    }
  }
}

// assumption: unique.size > 0
// returns list of matching groups
function determine_group(unique) {
  var groups = GROUPS;
  var _iterator19 = _createForOfIteratorHelper(unique),
    _step19;
  try {
    var _loop6 = function _loop6() {
      var cp = _step19.value;
      // note: we need to dodge CM that are whitelisted
      // but that code isn't currently necessary
      var gs = groups.filter(function (g) {
        return group_has_cp(g, cp);
      });
      if (!gs.length) {
        if (!GROUPS.some(function (g) {
          return group_has_cp(g, cp);
        })) {
          // the character was composed of valid parts
          // but it's NFC form is invalid
          // 20230716: change to more exact statement, see: ENSNormalize.{cs,java}
          // note: this doesn't have to be a composition
          // 20230720: change to full check
          throw error_disallowed(cp); // this should be rare
        } else {
          // there is no group that contains all these characters
          // throw using the highest priority group that matched
          // https://www.unicode.org/reports/tr39/#mixed_script_confusables
          throw error_group_member(groups[0], cp);
        }
      }
      groups = gs;
      if (gs.length == 1) return 1; // break
      // there is only one group left
    };
    for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {
      if (_loop6()) break;
    }
    // there are at least 1 group(s) with all of these characters
  } catch (err) {
    _iterator19.e(err);
  } finally {
    _iterator19.f();
  }
  return groups;
}

// throw on first error
function flatten(split) {
  return split.map(function (_ref3) {
    var input = _ref3.input,
      error = _ref3.error,
      output = _ref3.output;
    if (error) {
      // don't print label again if just a single label
      var msg = error.message;
      // bidi_qq() only necessary if msg is digits
      throw new Error(split.length == 1 ? msg : "Invalid label ".concat(bidi_qq(safe_str_from_cps(input, 63)), ": ").concat(msg));
    }
    return str_from_cps(output);
  }).join(STOP_CH);
}
function error_disallowed(cp) {
  // TODO: add cp to error?
  return new Error("disallowed character: ".concat(quoted_cp(cp)));
}
function error_group_member(g, cp) {
  var quoted = quoted_cp(cp);
  var gg = GROUPS.find(function (g) {
    return g.P.has(cp);
  }); // only check primary
  if (gg) {
    quoted = "".concat(gg.N, " ").concat(quoted);
  }
  return new Error("illegal mixture: ".concat(g.N, " + ").concat(quoted));
}
function error_placement(where) {
  return new Error("illegal placement: ".concat(where));
}

// assumption: cps.length > 0
// assumption: cps[0] isn't a CM
// assumption: the previous character isn't an emoji
function check_group(g, cps) {
  var _iterator20 = _createForOfIteratorHelper(cps),
    _step20;
  try {
    for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {
      var _cp3 = _step20.value;
      if (!group_has_cp(g, _cp3)) {
        // for whitelisted scripts, this will throw illegal mixture on invalid cm, eg. "e{300}{300}"
        // at the moment, it's unnecessary to introduce an extra error type
        // until there exists a whitelisted multi-character
        //   eg. if (M < 0 && is_combining_mark(cp)) { ... }
        // there are 3 cases:
        //   1. illegal cm for wrong group => mixture error
        //   2. illegal cm for same group => cm error
        //       requires set of whitelist cm per group: 
        //        eg. new Set([...g.P, ...g.Q].flatMap(nfc).filter(cp => CM.has(cp)))
        //   3. wrong group => mixture error
        throw error_group_member(g, _cp3);
      }
    }
    //if (M >= 0) { // we have a known fixed cm count
  } catch (err) {
    _iterator20.e(err);
  } finally {
    _iterator20.f();
  }
  if (g.M) {
    // we need to check for NSM
    var _decomposed = nfd(cps);
    for (var i = 1, e = _decomposed.length; i < e; i++) {
      // see: assumption
      // 20230210: bugfix: using cps instead of decomposed h/t Carbon225
      /*
      if (CM.has(decomposed[i])) {
      	let j = i + 1;
      	while (j < e && CM.has(decomposed[j])) j++;
      	if (j - i > M) {
      		throw new Error(`too many combining marks: ${g.N} ${bidi_qq(str_from_cps(decomposed.slice(i-1, j)))} (${j-i}/${M})`);
      	}
      	i = j;
      }
      */
      // 20230217: switch to NSM counting
      // https://www.unicode.org/reports/tr39/#Optional_Detection
      if (NSM.has(_decomposed[i])) {
        var j = i + 1;
        for (var cp; j < e && NSM.has(cp = _decomposed[j]); j++) {
          // a. Forbid sequences of the same nonspacing mark.
          for (var k = i; k < j; k++) {
            // O(n^2) but n < 100
            if (_decomposed[k] == cp) {
              throw new Error("duplicate non-spacing marks: ".concat(quoted_cp(cp)));
            }
          }
        }
        // parse to end so we have full nsm count
        // b. Forbid sequences of more than 4 nonspacing marks (gc=Mn or gc=Me).
        if (j - i > NSM_MAX) {
          // note: this slice starts with a base char or spacing-mark cm
          throw new Error("excessive non-spacing marks: ".concat(bidi_qq(safe_str_from_cps(_decomposed.slice(i - 1, j))), " (").concat(j - i, "/").concat(NSM_MAX, ")"));
        }
        i = j;
      }
    }
  }
  // *** this code currently isn't needed ***
  /*
  let cm_whitelist = M instanceof Map;
  for (let i = 0, e = cps.length; i < e; ) {
  	let cp = cps[i++];
  	let seqs = cm_whitelist && M.get(cp);
  	if (seqs) { 
  		// list of codepoints that can follow
  		// if this exists, this will always be 1+
  		let j = i;
  		while (j < e && CM.has(cps[j])) j++;
  		let cms = cps.slice(i, j);
  		let match = seqs.find(seq => !compare_arrays(seq, cms));
  		if (!match) throw new Error(`disallowed combining mark sequence: "${safe_str_from_cps([cp, ...cms])}"`);
  		i = j;
  	} else if (!V.has(cp)) {
  		// https://www.unicode.org/reports/tr39/#mixed_script_confusables
  		let quoted = quoted_cp(cp);
  		for (let cp of cps) {
  			let u = UNIQUE.get(cp);
  			if (u && u !== g) {
  				// if both scripts are restricted this error is confusing
  				// because we don't differentiate RestrictedA from RestrictedB 
  				if (!u.R) quoted = `${quoted} is ${u.N}`;
  				break;
  			}
  		}
  		throw new Error(`disallowed ${g.N} character: ${quoted}`);
  		//throw new Error(`disallowed character: ${quoted} (expected ${g.N})`);
  		//throw new Error(`${g.N} does not allow: ${quoted}`);
  	}
  }
  if (!cm_whitelist) {
  	let decomposed = nfd(cps);
  	for (let i = 1, e = decomposed.length; i < e; i++) { // we know it can't be cm leading
  		if (CM.has(decomposed[i])) {
  			let j = i + 1;
  			while (j < e && CM.has(decomposed[j])) j++;
  			if (j - i > M) {
  				throw new Error(`too many combining marks: "${str_from_cps(decomposed.slice(i-1, j))}" (${j-i}/${M})`);
  			}
  			i = j;
  		}
  	}
  }
  */
}

// given a list of codepoints
// returns a list of lists, where emoji are a fully-qualified (as Array subclass)
// eg. explode_cp("abcd") => [[61, 62, 63], Emoji[1F4A9, FE0F], [64]]
// 20230818: rename for 'process' name collision h/t Javarome
// https://github.com/adraffy/ens-normalize.js/issues/23
function tokens_from_str(input, nf, ef) {
  var ret = [];
  var chars = [];
  input = input.slice().reverse(); // flip so we can pop
  while (input.length) {
    var emoji = consume_emoji_reversed(input);
    if (emoji) {
      if (chars.length) {
        ret.push(nf(chars));
        chars = [];
      }
      ret.push(ef(emoji));
    } else {
      var cp = input.pop();
      if (VALID.has(cp)) {
        chars.push(cp);
      } else {
        var cps = MAPPED.get(cp);
        if (cps) {
          var _chars;
          (_chars = chars).push.apply(_chars, _toConsumableArray(cps)); // less than 10 elements
        } else if (!IGNORED.has(cp)) {
          // 20230912: unicode 15.1 changed the order of processing such that
          // disallowed parts are only rejected after NFC
          // https://unicode.org/reports/tr46/#Validity_Criteria
          // this doesn't impact normalization as of today
          // technically, this error can be removed as the group logic will apply similar logic
          // however the error type might be less clear
          throw error_disallowed(cp);
        }
      }
    }
  }
  if (chars.length) {
    ret.push(nf(chars));
  }
  return ret;
}
function filter_fe0f(cps) {
  return cps.filter(function (cp) {
    return cp != FE0F;
  });
}

// given array of codepoints
// returns the longest valid emoji sequence (or undefined if no match)
// *MUTATES* the supplied array
// disallows interleaved ignored characters
// fills (optional) eaten array with matched codepoints
function consume_emoji_reversed(cps, eaten) {
  var node = EMOJI_ROOT;
  var emoji;
  var pos = cps.length;
  while (pos) {
    node = node.get(cps[--pos]);
    if (!node) break;
    var _node = node,
      V = _node.V;
    if (V) {
      // this is a valid emoji (so far)
      emoji = V;
      if (eaten) eaten.push.apply(eaten, _toConsumableArray(cps.slice(pos).reverse())); // (optional) copy input, used for ens_tokenize()
      cps.length = pos; // truncate
    }
  }
  return emoji;
}

// ************************************************************
// tokenizer 

var TY_VALID = 'valid';
var TY_MAPPED = 'mapped';
var TY_IGNORED = 'ignored';
var TY_DISALLOWED = 'disallowed';
var TY_EMOJI = 'emoji';
var TY_NFC = 'nfc';
var TY_STOP = 'stop';
function ens_tokenize(name) {
  var _ref4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
    _ref4$nf = _ref4.nf,
    nf = _ref4$nf === void 0 ? true : _ref4$nf;
  init();
  var input = explode_cp(name).reverse();
  var eaten = [];
  var tokens = [];
  while (input.length) {
    var emoji = consume_emoji_reversed(input, eaten);
    if (emoji) {
      tokens.push({
        type: TY_EMOJI,
        emoji: emoji.slice(),
        // copy emoji
        input: eaten,
        cps: filter_fe0f(emoji)
      });
      eaten = []; // reset buffer
    } else {
      var cp = input.pop();
      if (cp == STOP) {
        tokens.push({
          type: TY_STOP,
          cp: cp
        });
      } else if (VALID.has(cp)) {
        tokens.push({
          type: TY_VALID,
          cps: [cp]
        });
      } else if (IGNORED.has(cp)) {
        tokens.push({
          type: TY_IGNORED,
          cp: cp
        });
      } else {
        var cps = MAPPED.get(cp);
        if (cps) {
          tokens.push({
            type: TY_MAPPED,
            cp: cp,
            cps: cps.slice()
          });
        } else {
          tokens.push({
            type: TY_DISALLOWED,
            cp: cp
          });
        }
      }
    }
  }
  if (nf) {
    for (var i = 0, start = -1; i < tokens.length; i++) {
      var token = tokens[i];
      if (is_valid_or_mapped(token.type)) {
        if (requires_check(token.cps)) {
          // normalization might be needed
          var end = i + 1;
          for (var pos = end; pos < tokens.length; pos++) {
            // find adjacent text
            var _tokens$pos = tokens[pos],
              type = _tokens$pos.type,
              _cps2 = _tokens$pos.cps;
            if (is_valid_or_mapped(type)) {
              if (!requires_check(_cps2)) break;
              end = pos + 1;
            } else if (type !== TY_IGNORED) {
              // || type !== TY_DISALLOWED) { 
              break;
            }
          }
          if (start < 0) start = i;
          var slice = tokens.slice(start, end);
          var cps0 = slice.flatMap(function (x) {
            return is_valid_or_mapped(x.type) ? x.cps : [];
          }); // strip junk tokens
          var _cps3 = nfc(cps0);
          if (compare_arrays(_cps3, cps0)) {
            // bundle into an nfc token
            tokens.splice(start, end - start, {
              type: TY_NFC,
              input: cps0,
              // there are 3 states: tokens0 ==(process)=> input ==(nfc)=> tokens/cps
              cps: _cps3,
              tokens0: collapse_valid_tokens(slice),
              tokens: ens_tokenize(str_from_cps(_cps3), {
                nf: false
              })
            });
            i = start;
          } else {
            i = end - 1; // skip to end of slice
          }
          start = -1; // reset
        } else {
          start = i; // remember last
        }
      } else if (token.type !== TY_IGNORED) {
        // 20221024: is this correct?
        start = -1; // reset
      }
    }
  }
  return collapse_valid_tokens(tokens);
}
function is_valid_or_mapped(type) {
  return type == TY_VALID || type == TY_MAPPED;
}
function requires_check(cps) {
  return cps.some(function (cp) {
    return NFC_CHECK.has(cp);
  });
}
function collapse_valid_tokens(tokens) {
  for (var i = 0; i < tokens.length; i++) {
    if (tokens[i].type == TY_VALID) {
      var j = i + 1;
      while (j < tokens.length && tokens[j].type == TY_VALID) j++;
      tokens.splice(i, j - i, {
        type: TY_VALID,
        cps: tokens.slice(i, j).flatMap(function (x) {
          return x.cps;
        })
      });
    }
  }
  return tokens;
}
exports.ens_beautify = ens_beautify;
exports.ens_emoji = ens_emoji;
exports.ens_normalize = ens_normalize;
exports.ens_normalize_fragment = ens_normalize_fragment;
exports.ens_split = ens_split;
exports.ens_tokenize = ens_tokenize;
exports.is_combining_mark = is_combining_mark;
exports.nfc = nfc;
exports.nfd = nfd;
exports.safe_str_from_cps = safe_str_from_cps;
exports.should_escape = should_escape;

},{}],2:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.version = void 0;
exports.version = "abi/5.7.0";

},{}],3:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.defaultAbiCoder = exports.AbiCoder = void 0;
// See: https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI
var bytes_1 = require("@ethersproject/bytes");
var properties_1 = require("@ethersproject/properties");
var logger_1 = require("@ethersproject/logger");
var _version_1 = require("./_version");
var logger = new logger_1.Logger(_version_1.version);
var abstract_coder_1 = require("./coders/abstract-coder");
var address_1 = require("./coders/address");
var array_1 = require("./coders/array");
var boolean_1 = require("./coders/boolean");
var bytes_2 = require("./coders/bytes");
var fixed_bytes_1 = require("./coders/fixed-bytes");
var null_1 = require("./coders/null");
var number_1 = require("./coders/number");
var string_1 = require("./coders/string");
var tuple_1 = require("./coders/tuple");
var fragments_1 = require("./fragments");
var paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);
var paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);
var AbiCoder = /** @class */function () {
  function AbiCoder(coerceFunc) {
    (0, properties_1.defineReadOnly)(this, "coerceFunc", coerceFunc || null);
  }
  AbiCoder.prototype._getCoder = function (param) {
    var _this = this;
    switch (param.baseType) {
      case "address":
        return new address_1.AddressCoder(param.name);
      case "bool":
        return new boolean_1.BooleanCoder(param.name);
      case "string":
        return new string_1.StringCoder(param.name);
      case "bytes":
        return new bytes_2.BytesCoder(param.name);
      case "array":
        return new array_1.ArrayCoder(this._getCoder(param.arrayChildren), param.arrayLength, param.name);
      case "tuple":
        return new tuple_1.TupleCoder((param.components || []).map(function (component) {
          return _this._getCoder(component);
        }), param.name);
      case "":
        return new null_1.NullCoder(param.name);
    }
    // u?int[0-9]*
    var match = param.type.match(paramTypeNumber);
    if (match) {
      var size = parseInt(match[2] || "256");
      if (size === 0 || size > 256 || size % 8 !== 0) {
        logger.throwArgumentError("invalid " + match[1] + " bit length", "param", param);
      }
      return new number_1.NumberCoder(size / 8, match[1] === "int", param.name);
    }
    // bytes[0-9]+
    match = param.type.match(paramTypeBytes);
    if (match) {
      var size = parseInt(match[1]);
      if (size === 0 || size > 32) {
        logger.throwArgumentError("invalid bytes length", "param", param);
      }
      return new fixed_bytes_1.FixedBytesCoder(size, param.name);
    }
    return logger.throwArgumentError("invalid type", "type", param.type);
  };
  AbiCoder.prototype._getWordSize = function () {
    return 32;
  };
  AbiCoder.prototype._getReader = function (data, allowLoose) {
    return new abstract_coder_1.Reader(data, this._getWordSize(), this.coerceFunc, allowLoose);
  };
  AbiCoder.prototype._getWriter = function () {
    return new abstract_coder_1.Writer(this._getWordSize());
  };
  AbiCoder.prototype.getDefaultValue = function (types) {
    var _this = this;
    var coders = types.map(function (type) {
      return _this._getCoder(fragments_1.ParamType.from(type));
    });
    var coder = new tuple_1.TupleCoder(coders, "_");
    return coder.defaultValue();
  };
  AbiCoder.prototype.encode = function (types, values) {
    var _this = this;
    if (types.length !== values.length) {
      logger.throwError("types/values length mismatch", logger_1.Logger.errors.INVALID_ARGUMENT, {
        count: {
          types: types.length,
          values: values.length
        },
        value: {
          types: types,
          values: values
        }
      });
    }
    var coders = types.map(function (type) {
      return _this._getCoder(fragments_1.ParamType.from(type));
    });
    var coder = new tuple_1.TupleCoder(coders, "_");
    var writer = this._getWriter();
    coder.encode(writer, values);
    return writer.data;
  };
  AbiCoder.prototype.decode = function (types, data, loose) {
    var _this = this;
    var coders = types.map(function (type) {
      return _this._getCoder(fragments_1.ParamType.from(type));
    });
    var coder = new tuple_1.TupleCoder(coders, "_");
    return coder.decode(this._getReader((0, bytes_1.arrayify)(data), loose));
  };
  return AbiCoder;
}();
exports.AbiCoder = AbiCoder;
exports.defaultAbiCoder = new AbiCoder();

},{"./_version":2,"./coders/abstract-coder":4,"./coders/address":5,"./coders/array":7,"./coders/boolean":8,"./coders/bytes":9,"./coders/fixed-bytes":10,"./coders/null":11,"./coders/number":12,"./coders/string":13,"./coders/tuple":14,"./fragments":15,"@ethersproject/bytes":28,"@ethersproject/logger":45,"@ethersproject/properties":47}],4:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Reader = exports.Writer = exports.Coder = exports.checkResultErrors = void 0;
var bytes_1 = require("@ethersproject/bytes");
var bignumber_1 = require("@ethersproject/bignumber");
var properties_1 = require("@ethersproject/properties");
var logger_1 = require("@ethersproject/logger");
var _version_1 = require("../_version");
var logger = new logger_1.Logger(_version_1.version);
function checkResultErrors(result) {
  // Find the first error (if any)
  var errors = [];
  var checkErrors = function checkErrors(path, object) {
    if (!Array.isArray(object)) {
      return;
    }
    for (var key in object) {
      var childPath = path.slice();
      childPath.push(key);
      try {
        checkErrors(childPath, object[key]);
      } catch (error) {
        errors.push({
          path: childPath,
          error: error
        });
      }
    }
  };
  checkErrors([], result);
  return errors;
}
exports.checkResultErrors = checkResultErrors;
var Coder = /** @class */function () {
  function Coder(name, type, localName, dynamic) {
    // @TODO: defineReadOnly these
    this.name = name;
    this.type = type;
    this.localName = localName;
    this.dynamic = dynamic;
  }
  Coder.prototype._throwError = function (message, value) {
    logger.throwArgumentError(message, this.localName, value);
  };
  return Coder;
}();
exports.Coder = Coder;
var Writer = /** @class */function () {
  function Writer(wordSize) {
    (0, properties_1.defineReadOnly)(this, "wordSize", wordSize || 32);
    this._data = [];
    this._dataLength = 0;
    this._padding = new Uint8Array(wordSize);
  }
  Object.defineProperty(Writer.prototype, "data", {
    get: function get() {
      return (0, bytes_1.hexConcat)(this._data);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Writer.prototype, "length", {
    get: function get() {
      return this._dataLength;
    },
    enumerable: false,
    configurable: true
  });
  Writer.prototype._writeData = function (data) {
    this._data.push(data);
    this._dataLength += data.length;
    return data.length;
  };
  Writer.prototype.appendWriter = function (writer) {
    return this._writeData((0, bytes_1.concat)(writer._data));
  };
  // Arrayish items; padded on the right to wordSize
  Writer.prototype.writeBytes = function (value) {
    var bytes = (0, bytes_1.arrayify)(value);
    var paddingOffset = bytes.length % this.wordSize;
    if (paddingOffset) {
      bytes = (0, bytes_1.concat)([bytes, this._padding.slice(paddingOffset)]);
    }
    return this._writeData(bytes);
  };
  Writer.prototype._getValue = function (value) {
    var bytes = (0, bytes_1.arrayify)(bignumber_1.BigNumber.from(value));
    if (bytes.length > this.wordSize) {
      logger.throwError("value out-of-bounds", logger_1.Logger.errors.BUFFER_OVERRUN, {
        length: this.wordSize,
        offset: bytes.length
      });
    }
    if (bytes.length % this.wordSize) {
      bytes = (0, bytes_1.concat)([this._padding.slice(bytes.length % this.wordSize), bytes]);
    }
    return bytes;
  };
  // BigNumberish items; padded on the left to wordSize
  Writer.prototype.writeValue = function (value) {
    return this._writeData(this._getValue(value));
  };
  Writer.prototype.writeUpdatableValue = function () {
    var _this = this;
    var offset = this._data.length;
    this._data.push(this._padding);
    this._dataLength += this.wordSize;
    return function (value) {
      _this._data[offset] = _this._getValue(value);
    };
  };
  return Writer;
}();
exports.Writer = Writer;
var Reader = /** @class */function () {
  function Reader(data, wordSize, coerceFunc, allowLoose) {
    (0, properties_1.defineReadOnly)(this, "_data", (0, bytes_1.arrayify)(data));
    (0, properties_1.defineReadOnly)(this, "wordSize", wordSize || 32);
    (0, properties_1.defineReadOnly)(this, "_coerceFunc", coerceFunc);
    (0, properties_1.defineReadOnly)(this, "allowLoose", allowLoose);
    this._offset = 0;
  }
  Object.defineProperty(Reader.prototype, "data", {
    get: function get() {
      return (0, bytes_1.hexlify)(this._data);
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(Reader.prototype, "consumed", {
    get: function get() {
      return this._offset;
    },
    enumerable: false,
    configurable: true
  });
  // The default Coerce function
  Reader.coerce = function (name, value) {
    var match = name.match("^u?int([0-9]+)$");
    if (match && parseInt(match[1]) <= 48) {
      value = value.toNumber();
    }
    return value;
  };
  Reader.prototype.coerce = function (name, value) {
    if (this._coerceFunc) {
      return this._coerceFunc(name, value);
    }
    return Reader.coerce(name, value);
  };
  Reader.prototype._peekBytes = function (offset, length, loose) {
    var alignedLength = Math.ceil(length / this.wordSize) * this.wordSize;
    if (this._offset + alignedLength > this._data.length) {
      if (this.allowLoose && loose && this._offset + length <= this._data.length) {
        alignedLength = length;
      } else {
        logger.throwError("data out-of-bounds", logger_1.Logger.errors.BUFFER_OVERRUN, {
          length: this._data.length,
          offset: this._offset + alignedLength
        });
      }
    }
    return this._data.slice(this._offset, this._offset + alignedLength);
  };
  Reader.prototype.subReader = function (offset) {
    return new Reader(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc, this.allowLoose);
  };
  Reader.prototype.readBytes = function (length, loose) {
    var bytes = this._peekBytes(0, length, !!loose);
    this._offset += bytes.length;
    // @TODO: Make sure the length..end bytes are all 0?
    return bytes.slice(0, length);
  };
  Reader.prototype.readValue = function () {
    return bignumber_1.BigNumber.from(this.readBytes(this.wordSize));
  };
  return Reader;
}();
exports.Reader = Reader;

},{"../_version":2,"@ethersproject/bignumber":25,"@ethersproject/bytes":28,"@ethersproject/logger":45,"@ethersproject/properties":47}],5:[function(require,module,exports){
"use strict";

var __extends = void 0 && (void 0).__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };
    return _extendStatics(d, b);
  };
  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    _extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AddressCoder = void 0;
var address_1 = require("@ethersproject/address");
var bytes_1 = require("@ethersproject/bytes");
var abstract_coder_1 = require("./abstract-coder");
var AddressCoder = /** @class */function (_super) {
  __extends(AddressCoder, _super);
  function AddressCoder(localName) {
    return _super.call(this, "address", "address", localName, false) || this;
  }
  AddressCoder.prototype.defaultValue = function () {
    return "0x0000000000000000000000000000000000000000";
  };
  AddressCoder.prototype.encode = function (writer, value) {
    try {
      value = (0, address_1.getAddress)(value);
    } catch (error) {
      this._throwError(error.message, value);
    }
    return writer.writeValue(value);
  };
  AddressCoder.prototype.decode = function (reader) {
    return (0, address_1.getAddress)((0, bytes_1.hexZeroPad)(reader.readValue().toHexString(), 20));
  };
  return AddressCoder;
}(abstract_coder_1.Coder);
exports.AddressCoder = AddressCoder;

},{"./abstract-coder":4,"@ethersproject/address":19,"@ethersproject/bytes":28}],6:[function(require,module,exports){
"use strict";

var __extends = void 0 && (void 0).__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };
    return _extendStatics(d, b);
  };
  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    _extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AnonymousCoder = void 0;
var abstract_coder_1 = require("./abstract-coder");
// Clones the functionality of an existing Coder, but without a localName
var AnonymousCoder = /** @class */function (_super) {
  __extends(AnonymousCoder, _super);
  function AnonymousCoder(coder) {
    var _this = _super.call(this, coder.name, coder.type, undefined, coder.dynamic) || this;
    _this.coder = coder;
    return _this;
  }
  AnonymousCoder.prototype.defaultValue = function () {
    return this.coder.defaultValue();
  };
  AnonymousCoder.prototype.encode = function (writer, value) {
    return this.coder.encode(writer, value);
  };
  AnonymousCoder.prototype.decode = function (reader) {
    return this.coder.decode(reader);
  };
  return AnonymousCoder;
}(abstract_coder_1.Coder);
exports.AnonymousCoder = AnonymousCoder;

},{"./abstract-coder":4}],7:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var __extends = void 0 && (void 0).__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };
    return _extendStatics(d, b);
  };
  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    _extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ArrayCoder = exports.unpack = exports.pack = void 0;
var logger_1 = require("@ethersproject/logger");
var _version_1 = require("../_version");
var logger = new logger_1.Logger(_version_1.version);
var abstract_coder_1 = require("./abstract-coder");
var anonymous_1 = require("./anonymous");
function pack(writer, coders, values) {
  var arrayValues = null;
  if (Array.isArray(values)) {
    arrayValues = values;
  } else if (values && _typeof(values) === "object") {
    var unique_1 = {};
    arrayValues = coders.map(function (coder) {
      var name = coder.localName;
      if (!name) {
        logger.throwError("cannot encode object for signature with missing names", logger_1.Logger.errors.INVALID_ARGUMENT, {
          argument: "values",
          coder: coder,
          value: values
        });
      }
      if (unique_1[name]) {
        logger.throwError("cannot encode object for signature with duplicate names", logger_1.Logger.errors.INVALID_ARGUMENT, {
          argument: "values",
          coder: coder,
          value: values
        });
      }
      unique_1[name] = true;
      return values[name];
    });
  } else {
    logger.throwArgumentError("invalid tuple value", "tuple", values);
  }
  if (coders.length !== arrayValues.length) {
    logger.throwArgumentError("types/value length mismatch", "tuple", values);
  }
  var staticWriter = new abstract_coder_1.Writer(writer.wordSize);
  var dynamicWriter = new abstract_coder_1.Writer(writer.wordSize);
  var updateFuncs = [];
  coders.forEach(function (coder, index) {
    var value = arrayValues[index];
    if (coder.dynamic) {
      // Get current dynamic offset (for the future pointer)
      var dynamicOffset_1 = dynamicWriter.length;
      // Encode the dynamic value into the dynamicWriter
      coder.encode(dynamicWriter, value);
      // Prepare to populate the correct offset once we are done
      var updateFunc_1 = staticWriter.writeUpdatableValue();
      updateFuncs.push(function (baseOffset) {
        updateFunc_1(baseOffset + dynamicOffset_1);
      });
    } else {
      coder.encode(staticWriter, value);
    }
  });
  // Backfill all the dynamic offsets, now that we know the static length
  updateFuncs.forEach(function (func) {
    func(staticWriter.length);
  });
  var length = writer.appendWriter(staticWriter);
  length += writer.appendWriter(dynamicWriter);
  return length;
}
exports.pack = pack;
function unpack(reader, coders) {
  var values = [];
  // A reader anchored to this base
  var baseReader = reader.subReader(0);
  coders.forEach(function (coder) {
    var value = null;
    if (coder.dynamic) {
      var offset = reader.readValue();
      var offsetReader = baseReader.subReader(offset.toNumber());
      try {
        value = coder.decode(offsetReader);
      } catch (error) {
        // Cannot recover from this
        if (error.code === logger_1.Logger.errors.BUFFER_OVERRUN) {
          throw error;
        }
        value = error;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    } else {
      try {
        value = coder.decode(reader);
      } catch (error) {
        // Cannot recover from this
        if (error.code === logger_1.Logger.errors.BUFFER_OVERRUN) {
          throw error;
        }
        value = error;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    }
    if (value != undefined) {
      values.push(value);
    }
  });
  // We only output named properties for uniquely named coders
  var uniqueNames = coders.reduce(function (accum, coder) {
    var name = coder.localName;
    if (name) {
      if (!accum[name]) {
        accum[name] = 0;
      }
      accum[name]++;
    }
    return accum;
  }, {});
  // Add any named parameters (i.e. tuples)
  coders.forEach(function (coder, index) {
    var name = coder.localName;
    if (!name || uniqueNames[name] !== 1) {
      return;
    }
    if (name === "length") {
      name = "_length";
    }
    if (values[name] != null) {
      return;
    }
    var value = values[index];
    if (value instanceof Error) {
      Object.defineProperty(values, name, {
        enumerable: true,
        get: function get() {
          throw value;
        }
      });
    } else {
      values[name] = value;
    }
  });
  var _loop_1 = function _loop_1(i) {
    var value = values[i];
    if (value instanceof Error) {
      Object.defineProperty(values, i, {
        enumerable: true,
        get: function get() {
          throw value;
        }
      });
    }
  };
  for (var i = 0; i < values.length; i++) {
    _loop_1(i);
  }
  return Object.freeze(values);
}
exports.unpack = unpack;
var ArrayCoder = /** @class */function (_super) {
  __extends(ArrayCoder, _super);
  function ArrayCoder(coder, length, localName) {
    var _this = this;
    var type = coder.type + "[" + (length >= 0 ? length : "") + "]";
    var dynamic = length === -1 || coder.dynamic;
    _this = _super.call(this, "array", type, localName, dynamic) || this;
    _this.coder = coder;
    _this.length = length;
    return _this;
  }
  ArrayCoder.prototype.defaultValue = function () {
    // Verifies the child coder is valid (even if the array is dynamic or 0-length)
    var defaultChild = this.coder.defaultValue();
    var result = [];
    for (var i = 0; i < this.length; i++) {
      result.push(defaultChild);
    }
    return result;
  };
  ArrayCoder.prototype.encode = function (writer, value) {
    if (!Array.isArray(value)) {
      this._throwError("expected array value", value);
    }
    var count = this.length;
    if (count === -1) {
      count = value.length;
      writer.writeValue(value.length);
    }
    logger.checkArgumentCount(value.length, count, "coder array" + (this.localName ? " " + this.localName : ""));
    var coders = [];
    for (var i = 0; i < value.length; i++) {
      coders.push(this.coder);
    }
    return pack(writer, coders, value);
  };
  ArrayCoder.prototype.decode = function (reader) {
    var count = this.length;
    if (count === -1) {
      count = reader.readValue().toNumber();
      // Check that there is *roughly* enough data to ensure
      // stray random data is not being read as a length. Each
      // slot requires at least 32 bytes for their value (or 32
      // bytes as a link to the data). This could use a much
      // tighter bound, but we are erroring on the side of safety.
      if (count * 32 > reader._data.length) {
        logger.throwError("insufficient data length", logger_1.Logger.errors.BUFFER_OVERRUN, {
          length: reader._data.length,
          count: count
        });
      }
    }
    var coders = [];
    for (var i = 0; i < count; i++) {
      coders.push(new anonymous_1.AnonymousCoder(this.coder));
    }
    return reader.coerce(this.name, unpack(reader, coders));
  };
  return ArrayCoder;
}(abstract_coder_1.Coder);
exports.ArrayCoder = ArrayCoder;

},{"../_version":2,"./abstract-coder":4,"./anonymous":6,"@ethersproject/logger":45}],8:[function(require,module,exports){
"use strict";

var __extends = void 0 && (void 0).__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };
    return _extendStatics(d, b);
  };
  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    _extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BooleanCoder = void 0;
var abstract_coder_1 = require("./abstract-coder");
var BooleanCoder = /** @class */function (_super) {
  __extends(BooleanCoder, _super);
  function BooleanCoder(localName) {
    return _super.call(this, "bool", "bool", localName, false) || this;
  }
  BooleanCoder.prototype.defaultValue = function () {
    return false;
  };
  BooleanCoder.prototype.encode = function (writer, value) {
    return writer.writeValue(value ? 1 : 0);
  };
  BooleanCoder.prototype.decode = function (reader) {
    return reader.coerce(this.type, !reader.readValue().isZero());
  };
  return BooleanCoder;
}(abstract_coder_1.Coder);
exports.BooleanCoder = BooleanCoder;

},{"./abstract-coder":4}],9:[function(require,module,exports){
"use strict";

var __extends = void 0 && (void 0).__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };
    return _extendStatics(d, b);
  };
  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    _extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BytesCoder = exports.DynamicBytesCoder = void 0;
var bytes_1 = require("@ethersproject/bytes");
var abstract_coder_1 = require("./abstract-coder");
var DynamicBytesCoder = /** @class */function (_super) {
  __extends(DynamicBytesCoder, _super);
  function DynamicBytesCoder(type, localName) {
    return _super.call(this, type, type, localName, true) || this;
  }
  DynamicBytesCoder.prototype.defaultValue = function () {
    return "0x";
  };
  DynamicBytesCoder.prototype.encode = function (writer, value) {
    value = (0, bytes_1.arrayify)(value);
    var length = writer.writeValue(value.length);
    length += writer.writeBytes(value);
    return length;
  };
  DynamicBytesCoder.prototype.decode = function (reader) {
    return reader.readBytes(reader.readValue().toNumber(), true);
  };
  return DynamicBytesCoder;
}(abstract_coder_1.Coder);
exports.DynamicBytesCoder = DynamicBytesCoder;
var BytesCoder = /** @class */function (_super) {
  __extends(BytesCoder, _super);
  function BytesCoder(localName) {
    return _super.call(this, "bytes", localName) || this;
  }
  BytesCoder.prototype.decode = function (reader) {
    return reader.coerce(this.name, (0, bytes_1.hexlify)(_super.prototype.decode.call(this, reader)));
  };
  return BytesCoder;
}(DynamicBytesCoder);
exports.BytesCoder = BytesCoder;

},{"./abstract-coder":4,"@ethersproject/bytes":28}],10:[function(require,module,exports){
"use strict";

var __extends = void 0 && (void 0).__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };
    return _extendStatics(d, b);
  };
  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    _extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FixedBytesCoder = void 0;
var bytes_1 = require("@ethersproject/bytes");
var abstract_coder_1 = require("./abstract-coder");
// @TODO: Merge this with bytes
var FixedBytesCoder = /** @class */function (_super) {
  __extends(FixedBytesCoder, _super);
  function FixedBytesCoder(size, localName) {
    var _this = this;
    var name = "bytes" + String(size);
    _this = _super.call(this, name, name, localName, false) || this;
    _this.size = size;
    return _this;
  }
  FixedBytesCoder.prototype.defaultValue = function () {
    return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2);
  };
  FixedBytesCoder.prototype.encode = function (writer, value) {
    var data = (0, bytes_1.arrayify)(value);
    if (data.length !== this.size) {
      this._throwError("incorrect data length", value);
    }
    return writer.writeBytes(data);
  };
  FixedBytesCoder.prototype.decode = function (reader) {
    return reader.coerce(this.name, (0, bytes_1.hexlify)(reader.readBytes(this.size)));
  };
  return FixedBytesCoder;
}(abstract_coder_1.Coder);
exports.FixedBytesCoder = FixedBytesCoder;

},{"./abstract-coder":4,"@ethersproject/bytes":28}],11:[function(require,module,exports){
"use strict";

var __extends = void 0 && (void 0).__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };
    return _extendStatics(d, b);
  };
  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    _extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NullCoder = void 0;
var abstract_coder_1 = require("./abstract-coder");
var NullCoder = /** @class */function (_super) {
  __extends(NullCoder, _super);
  function NullCoder(localName) {
    return _super.call(this, "null", "", localName, false) || this;
  }
  NullCoder.prototype.defaultValue = function () {
    return null;
  };
  NullCoder.prototype.encode = function (writer, value) {
    if (value != null) {
      this._throwError("not null", value);
    }
    return writer.writeBytes([]);
  };
  NullCoder.prototype.decode = function (reader) {
    reader.readBytes(0);
    return reader.coerce(this.name, null);
  };
  return NullCoder;
}(abstract_coder_1.Coder);
exports.NullCoder = NullCoder;

},{"./abstract-coder":4}],12:[function(require,module,exports){
"use strict";

var __extends = void 0 && (void 0).__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };
    return _extendStatics(d, b);
  };
  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    _extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NumberCoder = void 0;
var bignumber_1 = require("@ethersproject/bignumber");
var constants_1 = require("@ethersproject/constants");
var abstract_coder_1 = require("./abstract-coder");
var NumberCoder = /** @class */function (_super) {
  __extends(NumberCoder, _super);
  function NumberCoder(size, signed, localName) {
    var _this = this;
    var name = (signed ? "int" : "uint") + size * 8;
    _this = _super.call(this, name, name, localName, false) || this;
    _this.size = size;
    _this.signed = signed;
    return _this;
  }
  NumberCoder.prototype.defaultValue = function () {
    return 0;
  };
  NumberCoder.prototype.encode = function (writer, value) {
    var v = bignumber_1.BigNumber.from(value);
    // Check bounds are safe for encoding
    var maxUintValue = constants_1.MaxUint256.mask(writer.wordSize * 8);
    if (this.signed) {
      var bounds = maxUintValue.mask(this.size * 8 - 1);
      if (v.gt(bounds) || v.lt(bounds.add(constants_1.One).mul(constants_1.NegativeOne))) {
        this._throwError("value out-of-bounds", value);
      }
    } else if (v.lt(constants_1.Zero) || v.gt(maxUintValue.mask(this.size * 8))) {
      this._throwError("value out-of-bounds", value);
    }
    v = v.toTwos(this.size * 8).mask(this.size * 8);
    if (this.signed) {
      v = v.fromTwos(this.size * 8).toTwos(8 * writer.wordSize);
    }
    return writer.writeValue(v);
  };
  NumberCoder.prototype.decode = function (reader) {
    var value = reader.readValue().mask(this.size * 8);
    if (this.signed) {
      value = value.fromTwos(this.size * 8);
    }
    return reader.coerce(this.name, value);
  };
  return NumberCoder;
}(abstract_coder_1.Coder);
exports.NumberCoder = NumberCoder;

},{"./abstract-coder":4,"@ethersproject/bignumber":25,"@ethersproject/constants":32}],13:[function(require,module,exports){
"use strict";

var __extends = void 0 && (void 0).__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };
    return _extendStatics(d, b);
  };
  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    _extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StringCoder = void 0;
var strings_1 = require("@ethersproject/strings");
var bytes_1 = require("./bytes");
var StringCoder = /** @class */function (_super) {
  __extends(StringCoder, _super);
  function StringCoder(localName) {
    return _super.call(this, "string", localName) || this;
  }
  StringCoder.prototype.defaultValue = function () {
    return "";
  };
  StringCoder.prototype.encode = function (writer, value) {
    return _super.prototype.encode.call(this, writer, (0, strings_1.toUtf8Bytes)(value));
  };
  StringCoder.prototype.decode = function (reader) {
    return (0, strings_1.toUtf8String)(_super.prototype.decode.call(this, reader));
  };
  return StringCoder;
}(bytes_1.DynamicBytesCoder);
exports.StringCoder = StringCoder;

},{"./bytes":9,"@ethersproject/strings":53}],14:[function(require,module,exports){
"use strict";

var __extends = void 0 && (void 0).__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };
    return _extendStatics(d, b);
  };
  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    _extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TupleCoder = void 0;
var abstract_coder_1 = require("./abstract-coder");
var array_1 = require("./array");
var TupleCoder = /** @class */function (_super) {
  __extends(TupleCoder, _super);
  function TupleCoder(coders, localName) {
    var _this = this;
    var dynamic = false;
    var types = [];
    coders.forEach(function (coder) {
      if (coder.dynamic) {
        dynamic = true;
      }
      types.push(coder.type);
    });
    var type = "tuple(" + types.join(",") + ")";
    _this = _super.call(this, "tuple", type, localName, dynamic) || this;
    _this.coders = coders;
    return _this;
  }
  TupleCoder.prototype.defaultValue = function () {
    var values = [];
    this.coders.forEach(function (coder) {
      values.push(coder.defaultValue());
    });
    // We only output named properties for uniquely named coders
    var uniqueNames = this.coders.reduce(function (accum, coder) {
      var name = coder.localName;
      if (name) {
        if (!accum[name]) {
          accum[name] = 0;
        }
        accum[name]++;
      }
      return accum;
    }, {});
    // Add named values
    this.coders.forEach(function (coder, index) {
      var name = coder.localName;
      if (!name || uniqueNames[name] !== 1) {
        return;
      }
      if (name === "length") {
        name = "_length";
      }
      if (values[name] != null) {
        return;
      }
      values[name] = values[index];
    });
    return Object.freeze(values);
  };
  TupleCoder.prototype.encode = function (writer, value) {
    return (0, array_1.pack)(writer, this.coders, value);
  };
  TupleCoder.prototype.decode = function (reader) {
    return reader.coerce(this.name, (0, array_1.unpack)(reader, this.coders));
  };
  return TupleCoder;
}(abstract_coder_1.Coder);
exports.TupleCoder = TupleCoder;

},{"./abstract-coder":4,"./array":7}],15:[function(require,module,exports){
"use strict";

var __extends = void 0 && (void 0).__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };
    return _extendStatics(d, b);
  };
  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    _extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ErrorFragment = exports.FunctionFragment = exports.ConstructorFragment = exports.EventFragment = exports.Fragment = exports.ParamType = exports.FormatTypes = void 0;
var bignumber_1 = require("@ethersproject/bignumber");
var properties_1 = require("@ethersproject/properties");
var logger_1 = require("@ethersproject/logger");
var _version_1 = require("./_version");
var logger = new logger_1.Logger(_version_1.version);
;
var _constructorGuard = {};
var ModifiersBytes = {
  calldata: true,
  memory: true,
  storage: true
};
var ModifiersNest = {
  calldata: true,
  memory: true
};
function checkModifier(type, name) {
  if (type === "bytes" || type === "string") {
    if (ModifiersBytes[name]) {
      return true;
    }
  } else if (type === "address") {
    if (name === "payable") {
      return true;
    }
  } else if (type.indexOf("[") >= 0 || type === "tuple") {
    if (ModifiersNest[name]) {
      return true;
    }
  }
  if (ModifiersBytes[name] || name === "payable") {
    logger.throwArgumentError("invalid modifier", "name", name);
  }
  return false;
}
// @TODO: Make sure that children of an indexed tuple are marked with a null indexed
function parseParamType(param, allowIndexed) {
  var originalParam = param;
  function throwError(i) {
    logger.throwArgumentError("unexpected character at position " + i, "param", param);
  }
  param = param.replace(/\s/g, " ");
  function newNode(parent) {
    var node = {
      type: "",
      name: "",
      parent: parent,
      state: {
        allowType: true
      }
    };
    if (allowIndexed) {
      node.indexed = false;
    }
    return node;
  }
  var parent = {
    type: "",
    name: "",
    state: {
      allowType: true
    }
  };
  var node = parent;
  for (var i = 0; i < param.length; i++) {
    var c = param[i];
    switch (c) {
      case "(":
        if (node.state.allowType && node.type === "") {
          node.type = "tuple";
        } else if (!node.state.allowParams) {
          throwError(i);
        }
        node.state.allowType = false;
        node.type = verifyType(node.type);
        node.components = [newNode(node)];
        node = node.components[0];
        break;
      case ")":
        delete node.state;
        if (node.name === "indexed") {
          if (!allowIndexed) {
            throwError(i);
          }
          node.indexed = true;
          node.name = "";
        }
        if (checkModifier(node.type, node.name)) {
          node.name = "";
        }
        node.type = verifyType(node.type);
        var child = node;
        node = node.parent;
        if (!node) {
          throwError(i);
        }
        delete child.parent;
        node.state.allowParams = false;
        node.state.allowName = true;
        node.state.allowArray = true;
        break;
      case ",":
        delete node.state;
        if (node.name === "indexed") {
          if (!allowIndexed) {
            throwError(i);
          }
          node.indexed = true;
          node.name = "";
        }
        if (checkModifier(node.type, node.name)) {
          node.name = "";
        }
        node.type = verifyType(node.type);
        var sibling = newNode(node.parent);
        //{ type: "", name: "", parent: node.parent, state: { allowType: true } };
        node.parent.components.push(sibling);
        delete node.parent;
        node = sibling;
        break;
      // Hit a space...
      case " ":
        // If reading type, the type is done and may read a param or name
        if (node.state.allowType) {
          if (node.type !== "") {
            node.type = verifyType(node.type);
            delete node.state.allowType;
            node.state.allowName = true;
            node.state.allowParams = true;
          }
        }
        // If reading name, the name is done
        if (node.state.allowName) {
          if (node.name !== "") {
            if (node.name === "indexed") {
              if (!allowIndexed) {
                throwError(i);
              }
              if (node.indexed) {
                throwError(i);
              }
              node.indexed = true;
              node.name = "";
            } else if (checkModifier(node.type, node.name)) {
              node.name = "";
            } else {
              node.state.allowName = false;
            }
          }
        }
        break;
      case "[":
        if (!node.state.allowArray) {
          throwError(i);
        }
        node.type += c;
        node.state.allowArray = false;
        node.state.allowName = false;
        node.state.readArray = true;
        break;
      case "]":
        if (!node.state.readArray) {
          throwError(i);
        }
        node.type += c;
        node.state.readArray = false;
        node.state.allowArray = true;
        node.state.allowName = true;
        break;
      default:
        if (node.state.allowType) {
          node.type += c;
          node.state.allowParams = true;
          node.state.allowArray = true;
        } else if (node.state.allowName) {
          node.name += c;
          delete node.state.allowArray;
        } else if (node.state.readArray) {
          node.type += c;
        } else {
          throwError(i);
        }
    }
  }
  if (node.parent) {
    logger.throwArgumentError("unexpected eof", "param", param);
  }
  delete parent.state;
  if (node.name === "indexed") {
    if (!allowIndexed) {
      throwError(originalParam.length - 7);
    }
    if (node.indexed) {
      throwError(originalParam.length - 7);
    }
    node.indexed = true;
    node.name = "";
  } else if (checkModifier(node.type, node.name)) {
    node.name = "";
  }
  parent.type = verifyType(parent.type);
  return parent;
}
function populate(object, params) {
  for (var key in params) {
    (0, properties_1.defineReadOnly)(object, key, params[key]);
  }
}
exports.FormatTypes = Object.freeze({
  // Bare formatting, as is needed for computing a sighash of an event or function
  sighash: "sighash",
  // Human-Readable with Minimal spacing and without names (compact human-readable)
  minimal: "minimal",
  // Human-Readable with nice spacing, including all names
  full: "full",
  // JSON-format a la Solidity
  json: "json"
});
var paramTypeArray = new RegExp(/^(.*)\[([0-9]*)\]$/);
var ParamType = /** @class */function () {
  function ParamType(constructorGuard, params) {
    if (constructorGuard !== _constructorGuard) {
      logger.throwError("use fromString", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new ParamType()"
      });
    }
    populate(this, params);
    var match = this.type.match(paramTypeArray);
    if (match) {
      populate(this, {
        arrayLength: parseInt(match[2] || "-1"),
        arrayChildren: ParamType.fromObject({
          type: match[1],
          components: this.components
        }),
        baseType: "array"
      });
    } else {
      populate(this, {
        arrayLength: null,
        arrayChildren: null,
        baseType: this.components != null ? "tuple" : this.type
      });
    }
    this._isParamType = true;
    Object.freeze(this);
  }
  // Format the parameter fragment
  //   - sighash: "(uint256,address)"
  //   - minimal: "tuple(uint256,address) indexed"
  //   - full:    "tuple(uint256 foo, address bar) indexed baz"
  ParamType.prototype.format = function (format) {
    if (!format) {
      format = exports.FormatTypes.sighash;
    }
    if (!exports.FormatTypes[format]) {
      logger.throwArgumentError("invalid format type", "format", format);
    }
    if (format === exports.FormatTypes.json) {
      var result_1 = {
        type: this.baseType === "tuple" ? "tuple" : this.type,
        name: this.name || undefined
      };
      if (typeof this.indexed === "boolean") {
        result_1.indexed = this.indexed;
      }
      if (this.components) {
        result_1.components = this.components.map(function (comp) {
          return JSON.parse(comp.format(format));
        });
      }
      return JSON.stringify(result_1);
    }
    var result = "";
    // Array
    if (this.baseType === "array") {
      result += this.arrayChildren.format(format);
      result += "[" + (this.arrayLength < 0 ? "" : String(this.arrayLength)) + "]";
    } else {
      if (this.baseType === "tuple") {
        if (format !== exports.FormatTypes.sighash) {
          result += this.type;
        }
        result += "(" + this.components.map(function (comp) {
          return comp.format(format);
        }).join(format === exports.FormatTypes.full ? ", " : ",") + ")";
      } else {
        result += this.type;
      }
    }
    if (format !== exports.FormatTypes.sighash) {
      if (this.indexed === true) {
        result += " indexed";
      }
      if (format === exports.FormatTypes.full && this.name) {
        result += " " + this.name;
      }
    }
    return result;
  };
  ParamType.from = function (value, allowIndexed) {
    if (typeof value === "string") {
      return ParamType.fromString(value, allowIndexed);
    }
    return ParamType.fromObject(value);
  };
  ParamType.fromObject = function (value) {
    if (ParamType.isParamType(value)) {
      return value;
    }
    return new ParamType(_constructorGuard, {
      name: value.name || null,
      type: verifyType(value.type),
      indexed: value.indexed == null ? null : !!value.indexed,
      components: value.components ? value.components.map(ParamType.fromObject) : null
    });
  };
  ParamType.fromString = function (value, allowIndexed) {
    function ParamTypify(node) {
      return ParamType.fromObject({
        name: node.name,
        type: node.type,
        indexed: node.indexed,
        components: node.components
      });
    }
    return ParamTypify(parseParamType(value, !!allowIndexed));
  };
  ParamType.isParamType = function (value) {
    return !!(value != null && value._isParamType);
  };
  return ParamType;
}();
exports.ParamType = ParamType;
;
function parseParams(value, allowIndex) {
  return splitNesting(value).map(function (param) {
    return ParamType.fromString(param, allowIndex);
  });
}
var Fragment = /** @class */function () {
  function Fragment(constructorGuard, params) {
    if (constructorGuard !== _constructorGuard) {
      logger.throwError("use a static from method", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new Fragment()"
      });
    }
    populate(this, params);
    this._isFragment = true;
    Object.freeze(this);
  }
  Fragment.from = function (value) {
    if (Fragment.isFragment(value)) {
      return value;
    }
    if (typeof value === "string") {
      return Fragment.fromString(value);
    }
    return Fragment.fromObject(value);
  };
  Fragment.fromObject = function (value) {
    if (Fragment.isFragment(value)) {
      return value;
    }
    switch (value.type) {
      case "function":
        return FunctionFragment.fromObject(value);
      case "event":
        return EventFragment.fromObject(value);
      case "constructor":
        return ConstructorFragment.fromObject(value);
      case "error":
        return ErrorFragment.fromObject(value);
      case "fallback":
      case "receive":
        // @TODO: Something? Maybe return a FunctionFragment? A custom DefaultFunctionFragment?
        return null;
    }
    return logger.throwArgumentError("invalid fragment object", "value", value);
  };
  Fragment.fromString = function (value) {
    // Make sure the "returns" is surrounded by a space and all whitespace is exactly one space
    value = value.replace(/\s/g, " ");
    value = value.replace(/\(/g, " (").replace(/\)/g, ") ").replace(/\s+/g, " ");
    value = value.trim();
    if (value.split(" ")[0] === "event") {
      return EventFragment.fromString(value.substring(5).trim());
    } else if (value.split(" ")[0] === "function") {
      return FunctionFragment.fromString(value.substring(8).trim());
    } else if (value.split("(")[0].trim() === "constructor") {
      return ConstructorFragment.fromString(value.trim());
    } else if (value.split(" ")[0] === "error") {
      return ErrorFragment.fromString(value.substring(5).trim());
    }
    return logger.throwArgumentError("unsupported fragment", "value", value);
  };
  Fragment.isFragment = function (value) {
    return !!(value && value._isFragment);
  };
  return Fragment;
}();
exports.Fragment = Fragment;
var EventFragment = /** @class */function (_super) {
  __extends(EventFragment, _super);
  function EventFragment() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  EventFragment.prototype.format = function (format) {
    if (!format) {
      format = exports.FormatTypes.sighash;
    }
    if (!exports.FormatTypes[format]) {
      logger.throwArgumentError("invalid format type", "format", format);
    }
    if (format === exports.FormatTypes.json) {
      return JSON.stringify({
        type: "event",
        anonymous: this.anonymous,
        name: this.name,
        inputs: this.inputs.map(function (input) {
          return JSON.parse(input.format(format));
        })
      });
    }
    var result = "";
    if (format !== exports.FormatTypes.sighash) {
      result += "event ";
    }
    result += this.name + "(" + this.inputs.map(function (input) {
      return input.format(format);
    }).join(format === exports.FormatTypes.full ? ", " : ",") + ") ";
    if (format !== exports.FormatTypes.sighash) {
      if (this.anonymous) {
        result += "anonymous ";
      }
    }
    return result.trim();
  };
  EventFragment.from = function (value) {
    if (typeof value === "string") {
      return EventFragment.fromString(value);
    }
    return EventFragment.fromObject(value);
  };
  EventFragment.fromObject = function (value) {
    if (EventFragment.isEventFragment(value)) {
      return value;
    }
    if (value.type !== "event") {
      logger.throwArgumentError("invalid event object", "value", value);
    }
    var params = {
      name: verifyIdentifier(value.name),
      anonymous: value.anonymous,
      inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
      type: "event"
    };
    return new EventFragment(_constructorGuard, params);
  };
  EventFragment.fromString = function (value) {
    var match = value.match(regexParen);
    if (!match) {
      logger.throwArgumentError("invalid event string", "value", value);
    }
    var anonymous = false;
    match[3].split(" ").forEach(function (modifier) {
      switch (modifier.trim()) {
        case "anonymous":
          anonymous = true;
          break;
        case "":
          break;
        default:
          logger.warn("unknown modifier: " + modifier);
      }
    });
    return EventFragment.fromObject({
      name: match[1].trim(),
      anonymous: anonymous,
      inputs: parseParams(match[2], true),
      type: "event"
    });
  };
  EventFragment.isEventFragment = function (value) {
    return value && value._isFragment && value.type === "event";
  };
  return EventFragment;
}(Fragment);
exports.EventFragment = EventFragment;
function parseGas(value, params) {
  params.gas = null;
  var comps = value.split("@");
  if (comps.length !== 1) {
    if (comps.length > 2) {
      logger.throwArgumentError("invalid human-readable ABI signature", "value", value);
    }
    if (!comps[1].match(/^[0-9]+$/)) {
      logger.throwArgumentError("invalid human-readable ABI signature gas", "value", value);
    }
    params.gas = bignumber_1.BigNumber.from(comps[1]);
    return comps[0];
  }
  return value;
}
function parseModifiers(value, params) {
  params.constant = false;
  params.payable = false;
  params.stateMutability = "nonpayable";
  value.split(" ").forEach(function (modifier) {
    switch (modifier.trim()) {
      case "constant":
        params.constant = true;
        break;
      case "payable":
        params.payable = true;
        params.stateMutability = "payable";
        break;
      case "nonpayable":
        params.payable = false;
        params.stateMutability = "nonpayable";
        break;
      case "pure":
        params.constant = true;
        params.stateMutability = "pure";
        break;
      case "view":
        params.constant = true;
        params.stateMutability = "view";
        break;
      case "external":
      case "public":
      case "":
        break;
      default:
        console.log("unknown modifier: " + modifier);
    }
  });
}
function verifyState(value) {
  var result = {
    constant: false,
    payable: true,
    stateMutability: "payable"
  };
  if (value.stateMutability != null) {
    result.stateMutability = value.stateMutability;
    // Set (and check things are consistent) the constant property
    result.constant = result.stateMutability === "view" || result.stateMutability === "pure";
    if (value.constant != null) {
      if (!!value.constant !== result.constant) {
        logger.throwArgumentError("cannot have constant function with mutability " + result.stateMutability, "value", value);
      }
    }
    // Set (and check things are consistent) the payable property
    result.payable = result.stateMutability === "payable";
    if (value.payable != null) {
      if (!!value.payable !== result.payable) {
        logger.throwArgumentError("cannot have payable function with mutability " + result.stateMutability, "value", value);
      }
    }
  } else if (value.payable != null) {
    result.payable = !!value.payable;
    // If payable we can assume non-constant; otherwise we can't assume
    if (value.constant == null && !result.payable && value.type !== "constructor") {
      logger.throwArgumentError("unable to determine stateMutability", "value", value);
    }
    result.constant = !!value.constant;
    if (result.constant) {
      result.stateMutability = "view";
    } else {
      result.stateMutability = result.payable ? "payable" : "nonpayable";
    }
    if (result.payable && result.constant) {
      logger.throwArgumentError("cannot have constant payable function", "value", value);
    }
  } else if (value.constant != null) {
    result.constant = !!value.constant;
    result.payable = !result.constant;
    result.stateMutability = result.constant ? "view" : "payable";
  } else if (value.type !== "constructor") {
    logger.throwArgumentError("unable to determine stateMutability", "value", value);
  }
  return result;
}
var ConstructorFragment = /** @class */function (_super) {
  __extends(ConstructorFragment, _super);
  function ConstructorFragment() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  ConstructorFragment.prototype.format = function (format) {
    if (!format) {
      format = exports.FormatTypes.sighash;
    }
    if (!exports.FormatTypes[format]) {
      logger.throwArgumentError("invalid format type", "format", format);
    }
    if (format === exports.FormatTypes.json) {
      return JSON.stringify({
        type: "constructor",
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : undefined,
        payable: this.payable,
        gas: this.gas ? this.gas.toNumber() : undefined,
        inputs: this.inputs.map(function (input) {
          return JSON.parse(input.format(format));
        })
      });
    }
    if (format === exports.FormatTypes.sighash) {
      logger.throwError("cannot format a constructor for sighash", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "format(sighash)"
      });
    }
    var result = "constructor(" + this.inputs.map(function (input) {
      return input.format(format);
    }).join(format === exports.FormatTypes.full ? ", " : ",") + ") ";
    if (this.stateMutability && this.stateMutability !== "nonpayable") {
      result += this.stateMutability + " ";
    }
    return result.trim();
  };
  ConstructorFragment.from = function (value) {
    if (typeof value === "string") {
      return ConstructorFragment.fromString(value);
    }
    return ConstructorFragment.fromObject(value);
  };
  ConstructorFragment.fromObject = function (value) {
    if (ConstructorFragment.isConstructorFragment(value)) {
      return value;
    }
    if (value.type !== "constructor") {
      logger.throwArgumentError("invalid constructor object", "value", value);
    }
    var state = verifyState(value);
    if (state.constant) {
      logger.throwArgumentError("constructor cannot be constant", "value", value);
    }
    var params = {
      name: null,
      type: value.type,
      inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
      payable: state.payable,
      stateMutability: state.stateMutability,
      gas: value.gas ? bignumber_1.BigNumber.from(value.gas) : null
    };
    return new ConstructorFragment(_constructorGuard, params);
  };
  ConstructorFragment.fromString = function (value) {
    var params = {
      type: "constructor"
    };
    value = parseGas(value, params);
    var parens = value.match(regexParen);
    if (!parens || parens[1].trim() !== "constructor") {
      logger.throwArgumentError("invalid constructor string", "value", value);
    }
    params.inputs = parseParams(parens[2].trim(), false);
    parseModifiers(parens[3].trim(), params);
    return ConstructorFragment.fromObject(params);
  };
  ConstructorFragment.isConstructorFragment = function (value) {
    return value && value._isFragment && value.type === "constructor";
  };
  return ConstructorFragment;
}(Fragment);
exports.ConstructorFragment = ConstructorFragment;
var FunctionFragment = /** @class */function (_super) {
  __extends(FunctionFragment, _super);
  function FunctionFragment() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  FunctionFragment.prototype.format = function (format) {
    if (!format) {
      format = exports.FormatTypes.sighash;
    }
    if (!exports.FormatTypes[format]) {
      logger.throwArgumentError("invalid format type", "format", format);
    }
    if (format === exports.FormatTypes.json) {
      return JSON.stringify({
        type: "function",
        name: this.name,
        constant: this.constant,
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : undefined,
        payable: this.payable,
        gas: this.gas ? this.gas.toNumber() : undefined,
        inputs: this.inputs.map(function (input) {
          return JSON.parse(input.format(format));
        }),
        outputs: this.outputs.map(function (output) {
          return JSON.parse(output.format(format));
        })
      });
    }
    var result = "";
    if (format !== exports.FormatTypes.sighash) {
      result += "function ";
    }
    result += this.name + "(" + this.inputs.map(function (input) {
      return input.format(format);
    }).join(format === exports.FormatTypes.full ? ", " : ",") + ") ";
    if (format !== exports.FormatTypes.sighash) {
      if (this.stateMutability) {
        if (this.stateMutability !== "nonpayable") {
          result += this.stateMutability + " ";
        }
      } else if (this.constant) {
        result += "view ";
      }
      if (this.outputs && this.outputs.length) {
        result += "returns (" + this.outputs.map(function (output) {
          return output.format(format);
        }).join(", ") + ") ";
      }
      if (this.gas != null) {
        result += "@" + this.gas.toString() + " ";
      }
    }
    return result.trim();
  };
  FunctionFragment.from = function (value) {
    if (typeof value === "string") {
      return FunctionFragment.fromString(value);
    }
    return FunctionFragment.fromObject(value);
  };
  FunctionFragment.fromObject = function (value) {
    if (FunctionFragment.isFunctionFragment(value)) {
      return value;
    }
    if (value.type !== "function") {
      logger.throwArgumentError("invalid function object", "value", value);
    }
    var state = verifyState(value);
    var params = {
      type: value.type,
      name: verifyIdentifier(value.name),
      constant: state.constant,
      inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
      outputs: value.outputs ? value.outputs.map(ParamType.fromObject) : [],
      payable: state.payable,
      stateMutability: state.stateMutability,
      gas: value.gas ? bignumber_1.BigNumber.from(value.gas) : null
    };
    return new FunctionFragment(_constructorGuard, params);
  };
  FunctionFragment.fromString = function (value) {
    var params = {
      type: "function"
    };
    value = parseGas(value, params);
    var comps = value.split(" returns ");
    if (comps.length > 2) {
      logger.throwArgumentError("invalid function string", "value", value);
    }
    var parens = comps[0].match(regexParen);
    if (!parens) {
      logger.throwArgumentError("invalid function signature", "value", value);
    }
    params.name = parens[1].trim();
    if (params.name) {
      verifyIdentifier(params.name);
    }
    params.inputs = parseParams(parens[2], false);
    parseModifiers(parens[3].trim(), params);
    // We have outputs
    if (comps.length > 1) {
      var returns = comps[1].match(regexParen);
      if (returns[1].trim() != "" || returns[3].trim() != "") {
        logger.throwArgumentError("unexpected tokens", "value", value);
      }
      params.outputs = parseParams(returns[2], false);
    } else {
      params.outputs = [];
    }
    return FunctionFragment.fromObject(params);
  };
  FunctionFragment.isFunctionFragment = function (value) {
    return value && value._isFragment && value.type === "function";
  };
  return FunctionFragment;
}(ConstructorFragment);
exports.FunctionFragment = FunctionFragment;
//export class StructFragment extends Fragment {
//}
function checkForbidden(fragment) {
  var sig = fragment.format();
  if (sig === "Error(string)" || sig === "Panic(uint256)") {
    logger.throwArgumentError("cannot specify user defined " + sig + " error", "fragment", fragment);
  }
  return fragment;
}
var ErrorFragment = /** @class */function (_super) {
  __extends(ErrorFragment, _super);
  function ErrorFragment() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  ErrorFragment.prototype.format = function (format) {
    if (!format) {
      format = exports.FormatTypes.sighash;
    }
    if (!exports.FormatTypes[format]) {
      logger.throwArgumentError("invalid format type", "format", format);
    }
    if (format === exports.FormatTypes.json) {
      return JSON.stringify({
        type: "error",
        name: this.name,
        inputs: this.inputs.map(function (input) {
          return JSON.parse(input.format(format));
        })
      });
    }
    var result = "";
    if (format !== exports.FormatTypes.sighash) {
      result += "error ";
    }
    result += this.name + "(" + this.inputs.map(function (input) {
      return input.format(format);
    }).join(format === exports.FormatTypes.full ? ", " : ",") + ") ";
    return result.trim();
  };
  ErrorFragment.from = function (value) {
    if (typeof value === "string") {
      return ErrorFragment.fromString(value);
    }
    return ErrorFragment.fromObject(value);
  };
  ErrorFragment.fromObject = function (value) {
    if (ErrorFragment.isErrorFragment(value)) {
      return value;
    }
    if (value.type !== "error") {
      logger.throwArgumentError("invalid error object", "value", value);
    }
    var params = {
      type: value.type,
      name: verifyIdentifier(value.name),
      inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : []
    };
    return checkForbidden(new ErrorFragment(_constructorGuard, params));
  };
  ErrorFragment.fromString = function (value) {
    var params = {
      type: "error"
    };
    var parens = value.match(regexParen);
    if (!parens) {
      logger.throwArgumentError("invalid error signature", "value", value);
    }
    params.name = parens[1].trim();
    if (params.name) {
      verifyIdentifier(params.name);
    }
    params.inputs = parseParams(parens[2], false);
    return checkForbidden(ErrorFragment.fromObject(params));
  };
  ErrorFragment.isErrorFragment = function (value) {
    return value && value._isFragment && value.type === "error";
  };
  return ErrorFragment;
}(Fragment);
exports.ErrorFragment = ErrorFragment;
function verifyType(type) {
  // These need to be transformed to their full description
  if (type.match(/^uint($|[^1-9])/)) {
    type = "uint256" + type.substring(4);
  } else if (type.match(/^int($|[^1-9])/)) {
    type = "int256" + type.substring(3);
  }
  // @TODO: more verification
  return type;
}
// See: https://github.com/ethereum/solidity/blob/1f8f1a3db93a548d0555e3e14cfc55a10e25b60e/docs/grammar/SolidityLexer.g4#L234
var regexIdentifier = new RegExp("^[a-zA-Z$_][a-zA-Z0-9$_]*$");
function verifyIdentifier(value) {
  if (!value || !value.match(regexIdentifier)) {
    logger.throwArgumentError("invalid identifier \"" + value + "\"", "value", value);
  }
  return value;
}
var regexParen = new RegExp("^([^)(]*)\\((.*)\\)([^)(]*)$");
function splitNesting(value) {
  value = value.trim();
  var result = [];
  var accum = "";
  var depth = 0;
  for (var offset = 0; offset < value.length; offset++) {
    var c = value[offset];
    if (c === "," && depth === 0) {
      result.push(accum);
      accum = "";
    } else {
      accum += c;
      if (c === "(") {
        depth++;
      } else if (c === ")") {
        depth--;
        if (depth === -1) {
          logger.throwArgumentError("unbalanced parenthesis", "value", value);
        }
      }
    }
  }
  if (accum) {
    result.push(accum);
  }
  return result;
}

},{"./_version":2,"@ethersproject/bignumber":25,"@ethersproject/logger":45,"@ethersproject/properties":47}],16:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TransactionDescription = exports.LogDescription = exports.checkResultErrors = exports.Indexed = exports.Interface = exports.defaultAbiCoder = exports.AbiCoder = exports.FormatTypes = exports.ParamType = exports.FunctionFragment = exports.Fragment = exports.EventFragment = exports.ErrorFragment = exports.ConstructorFragment = void 0;
var fragments_1 = require("./fragments");
Object.defineProperty(exports, "ConstructorFragment", {
  enumerable: true,
  get: function get() {
    return fragments_1.ConstructorFragment;
  }
});
Object.defineProperty(exports, "ErrorFragment", {
  enumerable: true,
  get: function get() {
    return fragments_1.ErrorFragment;
  }
});
Object.defineProperty(exports, "EventFragment", {
  enumerable: true,
  get: function get() {
    return fragments_1.EventFragment;
  }
});
Object.defineProperty(exports, "FormatTypes", {
  enumerable: true,
  get: function get() {
    return fragments_1.FormatTypes;
  }
});
Object.defineProperty(exports, "Fragment", {
  enumerable: true,
  get: function get() {
    return fragments_1.Fragment;
  }
});
Object.defineProperty(exports, "FunctionFragment", {
  enumerable: true,
  get: function get() {
    return fragments_1.FunctionFragment;
  }
});
Object.defineProperty(exports, "ParamType", {
  enumerable: true,
  get: function get() {
    return fragments_1.ParamType;
  }
});
var abi_coder_1 = require("./abi-coder");
Object.defineProperty(exports, "AbiCoder", {
  enumerable: true,
  get: function get() {
    return abi_coder_1.AbiCoder;
  }
});
Object.defineProperty(exports, "defaultAbiCoder", {
  enumerable: true,
  get: function get() {
    return abi_coder_1.defaultAbiCoder;
  }
});
var interface_1 = require("./interface");
Object.defineProperty(exports, "checkResultErrors", {
  enumerable: true,
  get: function get() {
    return interface_1.checkResultErrors;
  }
});
Object.defineProperty(exports, "Indexed", {
  enumerable: true,
  get: function get() {
    return interface_1.Indexed;
  }
});
Object.defineProperty(exports, "Interface", {
  enumerable: true,
  get: function get() {
    return interface_1.Interface;
  }
});
Object.defineProperty(exports, "LogDescription", {
  enumerable: true,
  get: function get() {
    return interface_1.LogDescription;
  }
});
Object.defineProperty(exports, "TransactionDescription", {
  enumerable: true,
  get: function get() {
    return interface_1.TransactionDescription;
  }
});

},{"./abi-coder":3,"./fragments":15,"./interface":17}],17:[function(require,module,exports){
"use strict";

var __extends = void 0 && (void 0).__extends || function () {
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };
    return _extendStatics(d, b);
  };
  return function (d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    _extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Interface = exports.Indexed = exports.ErrorDescription = exports.TransactionDescription = exports.LogDescription = exports.checkResultErrors = void 0;
var address_1 = require("@ethersproject/address");
var bignumber_1 = require("@ethersproject/bignumber");
var bytes_1 = require("@ethersproject/bytes");
var hash_1 = require("@ethersproject/hash");
var keccak256_1 = require("@ethersproject/keccak256");
var properties_1 = require("@ethersproject/properties");
var abi_coder_1 = require("./abi-coder");
var abstract_coder_1 = require("./coders/abstract-coder");
Object.defineProperty(exports, "checkResultErrors", {
  enumerable: true,
  get: function get() {
    return abstract_coder_1.checkResultErrors;
  }
});
var fragments_1 = require("./fragments");
var logger_1 = require("@ethersproject/logger");
var _version_1 = require("./_version");
var logger = new logger_1.Logger(_version_1.version);
var LogDescription = /** @class */function (_super) {
  __extends(LogDescription, _super);
  function LogDescription() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  return LogDescription;
}(properties_1.Description);
exports.LogDescription = LogDescription;
var TransactionDescription = /** @class */function (_super) {
  __extends(TransactionDescription, _super);
  function TransactionDescription() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  return TransactionDescription;
}(properties_1.Description);
exports.TransactionDescription = TransactionDescription;
var ErrorDescription = /** @class */function (_super) {
  __extends(ErrorDescription, _super);
  function ErrorDescription() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  return ErrorDescription;
}(properties_1.Description);
exports.ErrorDescription = ErrorDescription;
var Indexed = /** @class */function (_super) {
  __extends(Indexed, _super);
  function Indexed() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Indexed.isIndexed = function (value) {
    return !!(value && value._isIndexed);
  };
  return Indexed;
}(properties_1.Description);
exports.Indexed = Indexed;
var BuiltinErrors = {
  "0x08c379a0": {
    signature: "Error(string)",
    name: "Error",
    inputs: ["string"],
    reason: true
  },
  "0x4e487b71": {
    signature: "Panic(uint256)",
    name: "Panic",
    inputs: ["uint256"]
  }
};
function wrapAccessError(property, error) {
  var wrap = new Error("deferred error during ABI decoding triggered accessing " + property);
  wrap.error = error;
  return wrap;
}
/*
function checkNames(fragment: Fragment, type: "input" | "output", params: Array<ParamType>): void {
    params.reduce((accum, param) => {
        if (param.name) {
            if (accum[param.name]) {
                logger.throwArgumentError(`duplicate ${ type } parameter ${ JSON.stringify(param.name) } in ${ fragment.format("full") }`, "fragment", fragment);
            }
            accum[param.name] = true;
        }
        return accum;
    }, <{ [ name: string ]: boolean }>{ });
}
*/
var Interface = /** @class */function () {
  function Interface(fragments) {
    var _newTarget = this.constructor;
    var _this = this;
    var abi = [];
    if (typeof fragments === "string") {
      abi = JSON.parse(fragments);
    } else {
      abi = fragments;
    }
    (0, properties_1.defineReadOnly)(this, "fragments", abi.map(function (fragment) {
      return fragments_1.Fragment.from(fragment);
    }).filter(function (fragment) {
      return fragment != null;
    }));
    (0, properties_1.defineReadOnly)(this, "_abiCoder", (0, properties_1.getStatic)(_newTarget, "getAbiCoder")());
    (0, properties_1.defineReadOnly)(this, "functions", {});
    (0, properties_1.defineReadOnly)(this, "errors", {});
    (0, properties_1.defineReadOnly)(this, "events", {});
    (0, properties_1.defineReadOnly)(this, "structs", {});
    // Add all fragments by their signature
    this.fragments.forEach(function (fragment) {
      var bucket = null;
      switch (fragment.type) {
        case "constructor":
          if (_this.deploy) {
            logger.warn("duplicate definition - constructor");
            return;
          }
          //checkNames(fragment, "input", fragment.inputs);
          (0, properties_1.defineReadOnly)(_this, "deploy", fragment);
          return;
        case "function":
          //checkNames(fragment, "input", fragment.inputs);
          //checkNames(fragment, "output", (<FunctionFragment>fragment).outputs);
          bucket = _this.functions;
          break;
        case "event":
          //checkNames(fragment, "input", fragment.inputs);
          bucket = _this.events;
          break;
        case "error":
          bucket = _this.errors;
          break;
        default:
          return;
      }
      var signature = fragment.format();
      if (bucket[signature]) {
        logger.warn("duplicate definition - " + signature);
        return;
      }
      bucket[signature] = fragment;
    });
    // If we do not have a constructor add a default
    if (!this.deploy) {
      (0, properties_1.defineReadOnly)(this, "deploy", fragments_1.ConstructorFragment.from({
        payable: false,
        type: "constructor"
      }));
    }
    (0, properties_1.defineReadOnly)(this, "_isInterface", true);
  }
  Interface.prototype.format = function (format) {
    if (!format) {
      format = fragments_1.FormatTypes.full;
    }
    if (format === fragments_1.FormatTypes.sighash) {
      logger.throwArgumentError("interface does not support formatting sighash", "format", format);
    }
    var abi = this.fragments.map(function (fragment) {
      return fragment.format(format);
    });
    // We need to re-bundle the JSON fragments a bit
    if (format === fragments_1.FormatTypes.json) {
      return JSON.stringify(abi.map(function (j) {
        return JSON.parse(j);
      }));
    }
    return abi;
  };
  // Sub-classes can override these to handle other blockchains
  Interface.getAbiCoder = function () {
    return abi_coder_1.defaultAbiCoder;
  };
  Interface.getAddress = function (address) {
    return (0, address_1.getAddress)(address);
  };
  Interface.getSighash = function (fragment) {
    return (0, bytes_1.hexDataSlice)((0, hash_1.id)(fragment.format()), 0, 4);
  };
  Interface.getEventTopic = function (eventFragment) {
    return (0, hash_1.id)(eventFragment.format());
  };
  // Find a function definition by any means necessary (unless it is ambiguous)
  Interface.prototype.getFunction = function (nameOrSignatureOrSighash) {
    if ((0, bytes_1.isHexString)(nameOrSignatureOrSighash)) {
      for (var name_1 in this.functions) {
        if (nameOrSignatureOrSighash === this.getSighash(name_1)) {
          return this.functions[name_1];
        }
      }
      logger.throwArgumentError("no matching function", "sighash", nameOrSignatureOrSighash);
    }
    // It is a bare name, look up the function (will return null if ambiguous)
    if (nameOrSignatureOrSighash.indexOf("(") === -1) {
      var name_2 = nameOrSignatureOrSighash.trim();
      var matching = Object.keys(this.functions).filter(function (f) {
        return f.split("(" /* fix:) */)[0] === name_2;
      });
      if (matching.length === 0) {
        logger.throwArgumentError("no matching function", "name", name_2);
      } else if (matching.length > 1) {
        logger.throwArgumentError("multiple matching functions", "name", name_2);
      }
      return this.functions[matching[0]];
    }
    // Normalize the signature and lookup the function
    var result = this.functions[fragments_1.FunctionFragment.fromString(nameOrSignatureOrSighash).format()];
    if (!result) {
      logger.throwArgumentError("no matching function", "signature", nameOrSignatureOrSighash);
    }
    return result;
  };
  // Find an event definition by any means necessary (unless it is ambiguous)
  Interface.prototype.getEvent = function (nameOrSignatureOrTopic) {
    if ((0, bytes_1.isHexString)(nameOrSignatureOrTopic)) {
      var topichash = nameOrSignatureOrTopic.toLowerCase();
      for (var name_3 in this.events) {
        if (topichash === this.getEventTopic(name_3)) {
          return this.events[name_3];
        }
      }
      logger.throwArgumentError("no matching event", "topichash", topichash);
    }
    // It is a bare name, look up the function (will return null if ambiguous)
    if (nameOrSignatureOrTopic.indexOf("(") === -1) {
      var name_4 = nameOrSignatureOrTopic.trim();
      var matching = Object.keys(this.events).filter(function (f) {
        return f.split("(" /* fix:) */)[0] === name_4;
      });
      if (matching.length === 0) {
        logger.throwArgumentError("no matching event", "name", name_4);
      } else if (matching.length > 1) {
        logger.throwArgumentError("multiple matching events", "name", name_4);
      }
      return this.events[matching[0]];
    }
    // Normalize the signature and lookup the function
    var result = this.events[fragments_1.EventFragment.fromString(nameOrSignatureOrTopic).format()];
    if (!result) {
      logger.throwArgumentError("no matching event", "signature", nameOrSignatureOrTopic);
    }
    return result;
  };
  // Find a function definition by any means necessary (unless it is ambiguous)
  Interface.prototype.getError = function (nameOrSignatureOrSighash) {
    if ((0, bytes_1.isHexString)(nameOrSignatureOrSighash)) {
      var getSighash = (0, properties_1.getStatic)(this.constructor, "getSighash");
      for (var name_5 in this.errors) {
        var error = this.errors[name_5];
        if (nameOrSignatureOrSighash === getSighash(error)) {
          return this.errors[name_5];
        }
      }
      logger.throwArgumentError("no matching error", "sighash", nameOrSignatureOrSighash);
    }
    // It is a bare name, look up the function (will return null if ambiguous)
    if (nameOrSignatureOrSighash.indexOf("(") === -1) {
      var name_6 = nameOrSignatureOrSighash.trim();
      var matching = Object.keys(this.errors).filter(function (f) {
        return f.split("(" /* fix:) */)[0] === name_6;
      });
      if (matching.length === 0) {
        logger.throwArgumentError("no matching error", "name", name_6);
      } else if (matching.length > 1) {
        logger.throwArgumentError("multiple matching errors", "name", name_6);
      }
      return this.errors[matching[0]];
    }
    // Normalize the signature and lookup the function
    var result = this.errors[fragments_1.FunctionFragment.fromString(nameOrSignatureOrSighash).format()];
    if (!result) {
      logger.throwArgumentError("no matching error", "signature", nameOrSignatureOrSighash);
    }
    return result;
  };
  // Get the sighash (the bytes4 selector) used by Solidity to identify a function
  Interface.prototype.getSighash = function (fragment) {
    if (typeof fragment === "string") {
      try {
        fragment = this.getFunction(fragment);
      } catch (error) {
        try {
          fragment = this.getError(fragment);
        } catch (_) {
          throw error;
        }
      }
    }
    return (0, properties_1.getStatic)(this.constructor, "getSighash")(fragment);
  };
  // Get the topic (the bytes32 hash) used by Solidity to identify an event
  Interface.prototype.getEventTopic = function (eventFragment) {
    if (typeof eventFragment === "string") {
      eventFragment = this.getEvent(eventFragment);
    }
    return (0, properties_1.getStatic)(this.constructor, "getEventTopic")(eventFragment);
  };
  Interface.prototype._decodeParams = function (params, data) {
    return this._abiCoder.decode(params, data);
  };
  Interface.prototype._encodeParams = function (params, values) {
    return this._abiCoder.encode(params, values);
  };
  Interface.prototype.encodeDeploy = function (values) {
    return this._encodeParams(this.deploy.inputs, values || []);
  };
  Interface.prototype.decodeErrorResult = function (fragment, data) {
    if (typeof fragment === "string") {
      fragment = this.getError(fragment);
    }
    var bytes = (0, bytes_1.arrayify)(data);
    if ((0, bytes_1.hexlify)(bytes.slice(0, 4)) !== this.getSighash(fragment)) {
      logger.throwArgumentError("data signature does not match error " + fragment.name + ".", "data", (0, bytes_1.hexlify)(bytes));
    }
    return this._decodeParams(fragment.inputs, bytes.slice(4));
  };
  Interface.prototype.encodeErrorResult = function (fragment, values) {
    if (typeof fragment === "string") {
      fragment = this.getError(fragment);
    }
    return (0, bytes_1.hexlify)((0, bytes_1.concat)([this.getSighash(fragment), this._encodeParams(fragment.inputs, values || [])]));
  };
  // Decode the data for a function call (e.g. tx.data)
  Interface.prototype.decodeFunctionData = function (functionFragment, data) {
    if (typeof functionFragment === "string") {
      functionFragment = this.getFunction(functionFragment);
    }
    var bytes = (0, bytes_1.arrayify)(data);
    if ((0, bytes_1.hexlify)(bytes.slice(0, 4)) !== this.getSighash(functionFragment)) {
      logger.throwArgumentError("data signature does not match function " + functionFragment.name + ".", "data", (0, bytes_1.hexlify)(bytes));
    }
    return this._decodeParams(functionFragment.inputs, bytes.slice(4));
  };
  // Encode the data for a function call (e.g. tx.data)
  Interface.prototype.encodeFunctionData = function (functionFragment, values) {
    if (typeof functionFragment === "string") {
      functionFragment = this.getFunction(functionFragment);
    }
    return (0, bytes_1.hexlify)((0, bytes_1.concat)([this.getSighash(functionFragment), this._encodeParams(functionFragment.inputs, values || [])]));
  };
  // Decode the result from a function call (e.g. from eth_call)
  Interface.prototype.decodeFunctionResult = function (functionFragment, data) {
    if (typeof functionFragment === "string") {
      functionFragment = this.getFunction(functionFragment);
    }
    var bytes = (0, bytes_1.arrayify)(data);
    var reason = null;
    var message = "";
    var errorArgs = null;
    var errorName = null;
    var errorSignature = null;
    switch (bytes.length % this._abiCoder._getWordSize()) {
      case 0:
        try {
          return this._abiCoder.decode(functionFragment.outputs, bytes);
        } catch (error) {}
        break;
      case 4:
        {
          var selector = (0, bytes_1.hexlify)(bytes.slice(0, 4));
          var builtin = BuiltinErrors[selector];
          if (builtin) {
            errorArgs = this._abiCoder.decode(builtin.inputs, bytes.slice(4));
            errorName = builtin.name;
            errorSignature = builtin.signature;
            if (builtin.reason) {
              reason = errorArgs[0];
            }
            if (errorName === "Error") {
              message = "; VM Exception while processing transaction: reverted with reason string " + JSON.stringify(errorArgs[0]);
            } else if (errorName === "Panic") {
              message = "; VM Exception while processing transaction: reverted with panic code " + errorArgs[0];
            }
          } else {
            try {
              var error = this.getError(selector);
              errorArgs = this._abiCoder.decode(error.inputs, bytes.slice(4));
              errorName = error.name;
              errorSignature = error.format();
            } catch (error) {}
          }
          break;
        }
    }
    return logger.throwError("call revert exception" + message, logger_1.Logger.errors.CALL_EXCEPTION, {
      method: functionFragment.format(),
      data: (0, bytes_1.hexlify)(data),
      errorArgs: errorArgs,
      errorName: errorName,
      errorSignature: errorSignature,
      reason: reason
    });
  };
  // Encode the result for a function call (e.g. for eth_call)
  Interface.prototype.encodeFunctionResult = function (functionFragment, values) {
    if (typeof functionFragment === "string") {
      functionFragment = this.getFunction(functionFragment);
    }
    return (0, bytes_1.hexlify)(this._abiCoder.encode(functionFragment.outputs, values || []));
  };
  // Create the filter for the event with search criteria (e.g. for eth_filterLog)
  Interface.prototype.encodeFilterTopics = function (eventFragment, values) {
    var _this = this;
    if (typeof eventFragment === "string") {
      eventFragment = this.getEvent(eventFragment);
    }
    if (values.length > eventFragment.inputs.length) {
      logger.throwError("too many arguments for " + eventFragment.format(), logger_1.Logger.errors.UNEXPECTED_ARGUMENT, {
        argument: "values",
        value: values
      });
    }
    var topics = [];
    if (!eventFragment.anonymous) {
      topics.push(this.getEventTopic(eventFragment));
    }
    var encodeTopic = function encodeTopic(param, value) {
      if (param.type === "string") {
        return (0, hash_1.id)(value);
      } else if (param.type === "bytes") {
        return (0, keccak256_1.keccak256)((0, bytes_1.hexlify)(value));
      }
      if (param.type === "bool" && typeof value === "boolean") {
        value = value ? "0x01" : "0x00";
      }
      if (param.type.match(/^u?int/)) {
        value = bignumber_1.BigNumber.from(value).toHexString();
      }
      // Check addresses are valid
      if (param.type === "address") {
        _this._abiCoder.encode(["address"], [value]);
      }
      return (0, bytes_1.hexZeroPad)((0, bytes_1.hexlify)(value), 32);
    };
    values.forEach(function (value, index) {
      var param = eventFragment.inputs[index];
      if (!param.indexed) {
        if (value != null) {
          logger.throwArgumentError("cannot filter non-indexed parameters; must be null", "contract." + param.name, value);
        }
        return;
      }
      if (value == null) {
        topics.push(null);
      } else if (param.baseType === "array" || param.baseType === "tuple") {
        logger.throwArgumentError("filtering with tuples or arrays not supported", "contract." + param.name, value);
      } else if (Array.isArray(value)) {
        topics.push(value.map(function (value) {
          return encodeTopic(param, value);
        }));
      } else {
        topics.push(encodeTopic(param, value));
      }
    });
    // Trim off trailing nulls
    while (topics.length && topics[topics.length - 1] === null) {
      topics.pop();
    }
    return topics;
  };
  Interface.prototype.encodeEventLog = function (eventFragment, values) {
    var _this = this;
    if (typeof eventFragment === "string") {
      eventFragment = this.getEvent(eventFragment);
    }
    var topics = [];
    var dataTypes = [];
    var dataValues = [];
    if (!eventFragment.anonymous) {
      topics.push(this.getEventTopic(eventFragment));
    }
    if (values.length !== eventFragment.inputs.length) {
      logger.throwArgumentError("event arguments/values mismatch", "values", values);
    }
    eventFragment.inputs.forEach(function (param, index) {
      var value = values[index];
      if (param.indexed) {
        if (param.type === "string") {
          topics.push((0, hash_1.id)(value));
        } else if (param.type === "bytes") {
          topics.push((0, keccak256_1.keccak256)(value));
        } else if (param.baseType === "tuple" || param.baseType === "array") {
          // @TODO
          throw new Error("not implemented");
        } else {
          topics.push(_this._abiCoder.encode([param.type], [value]));
        }
      } else {
        dataTypes.push(param);
        dataValues.push(value);
      }
    });
    return {
      data: this._abiCoder.encode(dataTypes, dataValues),
      topics: topics
    };
  };
  // Decode a filter for the event and the search criteria
  Interface.prototype.decodeEventLog = function (eventFragment, data, topics) {
    if (typeof eventFragment === "string") {
      eventFragment = this.getEvent(eventFragment);
    }
    if (topics != null && !eventFragment.anonymous) {
      var topicHash = this.getEventTopic(eventFragment);
      if (!(0, bytes_1.isHexString)(topics[0], 32) || topics[0].toLowerCase() !== topicHash) {
        logger.throwError("fragment/topic mismatch", logger_1.Logger.errors.INVALID_ARGUMENT, {
          argument: "topics[0]",
          expected: topicHash,
          value: topics[0]
        });
      }
      topics = topics.slice(1);
    }
    var indexed = [];
    var nonIndexed = [];
    var dynamic = [];
    eventFragment.inputs.forEach(function (param, index) {
      if (param.indexed) {
        if (param.type === "string" || param.type === "bytes" || param.baseType === "tuple" || param.baseType === "array") {
          indexed.push(fragments_1.ParamType.fromObject({
            type: "bytes32",
            name: param.name
          }));
          dynamic.push(true);
        } else {
          indexed.push(param);
          dynamic.push(false);
        }
      } else {
        nonIndexed.push(param);
        dynamic.push(false);
      }
    });
    var resultIndexed = topics != null ? this._abiCoder.decode(indexed, (0, bytes_1.concat)(topics)) : null;
    var resultNonIndexed = this._abiCoder.decode(nonIndexed, data, true);
    var result = [];
    var nonIndexedIndex = 0,
      indexedIndex = 0;
    eventFragment.inputs.forEach(function (param, index) {
      if (param.indexed) {
        if (resultIndexed == null) {
          result[index] = new Indexed({
            _isIndexed: true,
            hash: null
          });
        } else if (dynamic[index]) {
          result[index] = new Indexed({
            _isIndexed: true,
            hash: resultIndexed[indexedIndex++]
          });
        } else {
          try {
            result[index] = resultIndexed[indexedIndex++];
          } catch (error) {
            result[index] = error;
          }
        }
      } else {
        try {
          result[index] = resultNonIndexed[nonIndexedIndex++];
        } catch (error) {
          result[index] = error;
        }
      }
      // Add the keyword argument if named and safe
      if (param.name && result[param.name] == null) {
        var value_1 = result[index];
        // Make error named values throw on access
        if (value_1 instanceof Error) {
          Object.defineProperty(result, param.name, {
            enumerable: true,
            get: function get() {
              throw wrapAccessError("property " + JSON.stringify(param.name), value_1);
            }
          });
        } else {
          result[param.name] = value_1;
        }
      }
    });
    var _loop_1 = function _loop_1(i) {
      var value = result[i];
      if (value instanceof Error) {
        Object.defineProperty(result, i, {
          enumerable: true,
          get: function get() {
            throw wrapAccessError("index " + i, value);
          }
        });
      }
    };
    // Make all error indexed values throw on access
    for (var i = 0; i < result.length; i++) {
      _loop_1(i);
    }
    return Object.freeze(result);
  };
  // Given a transaction, find the matching function fragment (if any) and
  // determine all its properties and call parameters
  Interface.prototype.parseTransaction = function (tx) {
    var fragment = this.getFunction(tx.data.substring(0, 10).toLowerCase());
    if (!fragment) {
      return null;
    }
    return new TransactionDescription({
      args: this._abiCoder.decode(fragment.inputs, "0x" + tx.data.substring(10)),
      functionFragment: fragment,
      name: fragment.name,
      signature: fragment.format(),
      sighash: this.getSighash(fragment),
      value: bignumber_1.BigNumber.from(tx.value || "0")
    });
  };
  // @TODO
  //parseCallResult(data: BytesLike): ??
  // Given an event log, find the matching event fragment (if any) and
  // determine all its properties and values
  Interface.prototype.parseLog = function (log) {
    var fragment = this.getEvent(log.topics[0]);
    if (!fragment || fragment.anonymous) {
      return null;
    }
    // @TODO: If anonymous, and the only method, and the input count matches, should we parse?
    //        Probably not, because just because it is the only event in the ABI does
    //        not mean we have the full ABI; maybe just a fragment?
    return new LogDescription({
      eventFragment: fragment,
      name: fragment.name,
      signature: fragment.format(),
      topic: this.getEventTopic(fragment),
      args: this.decodeEventLog(fragment, log.data, log.topics)
    });
  };
  Interface.prototype.parseError = function (data) {
    var hexData = (0, bytes_1.hexlify)(data);
    var fragment = this.getError(hexData.substring(0, 10).toLowerCase());
    if (!fragment) {
      return null;
    }
    return new ErrorDescription({
      args: this._abiCoder.decode(fragment.inputs, "0x" + hexData.substring(10)),
      errorFragment: fragment,
      name: fragment.name,
      signature: fragment.format(),
      sighash: this.getSighash(fragment)
    });
  };
  /*
  static from(value: Array<Fragment | string | JsonAbi> | string | Interface) {
      if (Interface.isInterface(value)) {
          return value;
      }
      if (typeof(value) === "string") {
          return new Interface(JSON.parse(value));
      }
      return new Interface(value);
  }
  */
  Interface.isInterface = function (value) {
    return !!(value && value._isInterface);
  };
  return Interface;
}();
exports.Interface = Interface;

},{"./_version":2,"./abi-coder":3,"./coders/abstract-coder":4,"./fragments":15,"@ethersproject/address":19,"@ethersproject/bignumber":25,"@ethersproject/bytes":28,"@ethersproject/hash":39,"@ethersproject/keccak256":43,"@ethersproject/logger":45,"@ethersproject/properties":47}],18:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.version = void 0;
exports.version = "address/5.7.0";

},{}],19:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getCreate2Address = exports.getContractAddress = exports.getIcapAddress = exports.isAddress = exports.getAddress = void 0;
var bytes_1 = require("@ethersproject/bytes");
var bignumber_1 = require("@ethersproject/bignumber");
var keccak256_1 = require("@ethersproject/keccak256");
var rlp_1 = require("@ethersproject/rlp");
var logger_1 = require("@ethersproject/logger");
var _version_1 = require("./_version");
var logger = new logger_1.Logger(_version_1.version);
function getChecksumAddress(address) {
  if (!(0, bytes_1.isHexString)(address, 20)) {
    logger.throwArgumentError("invalid address", "address", address);
  }
  address = address.toLowerCase();
  var chars = address.substring(2).split("");
  var expanded = new Uint8Array(40);
  for (var i = 0; i < 40; i++) {
    expanded[i] = chars[i].charCodeAt(0);
  }
  var hashed = (0, bytes_1.arrayify)((0, keccak256_1.keccak256)(expanded));
  for (var i = 0; i < 40; i += 2) {
    if (hashed[i >> 1] >> 4 >= 8) {
      chars[i] = chars[i].toUpperCase();
    }
    if ((hashed[i >> 1] & 0x0f) >= 8) {
      chars[i + 1] = chars[i + 1].toUpperCase();
    }
  }
  return "0x" + chars.join("");
}
// Shims for environments that are missing some required constants and functions
var MAX_SAFE_INTEGER = 0x1fffffffffffff;
function log10(x) {
  if (Math.log10) {
    return Math.log10(x);
  }
  return Math.log(x) / Math.LN10;
}
// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number
// Create lookup table
var ibanLookup = {};
for (var i = 0; i < 10; i++) {
  ibanLookup[String(i)] = String(i);
}
for (var i = 0; i < 26; i++) {
  ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);
}
// How many decimal digits can we process? (for 64-bit float, this is 15)
var safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));
function ibanChecksum(address) {
  address = address.toUpperCase();
  address = address.substring(4) + address.substring(0, 2) + "00";
  var expanded = address.split("").map(function (c) {
    return ibanLookup[c];
  }).join("");
  // Javascript can handle integers safely up to 15 (decimal) digits
  while (expanded.length >= safeDigits) {
    var block = expanded.substring(0, safeDigits);
    expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
  }
  var checksum = String(98 - parseInt(expanded, 10) % 97);
  while (checksum.length < 2) {
    checksum = "0" + checksum;
  }
  return checksum;
}
;
function getAddress(address) {
  var result = null;
  if (typeof address !== "string") {
    logger.throwArgumentError("invalid address", "address", address);
  }
  if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
    // Missing the 0x prefix
    if (address.substring(0, 2) !== "0x") {
      address = "0x" + address;
    }
    result = getChecksumAddress(address);
    // It is a checksummed address with a bad checksum
    if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {
      logger.throwArgumentError("bad address checksum", "address", address);
    }
    // Maybe ICAP? (we only support direct mode)
  } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    // It is an ICAP address with a bad checksum
    if (address.substring(2, 4) !== ibanChecksum(address)) {
      logger.throwArgumentError("bad icap checksum", "address", address);
    }
    result = (0, bignumber_1._base36To16)(address.substring(4));
    while (result.length < 40) {
      result = "0" + result;
    }
    result = getChecksumAddress("0x" + result);
  } else {
    logger.throwArgumentError("invalid address", "address", address);
  }
  return result;
}
exports.getAddress = getAddress;
function isAddress(address) {
  try {
    getAddress(address);
    return true;
  } catch (error) {}
  return false;
}
exports.isAddress = isAddress;
function getIcapAddress(address) {
  var base36 = (0, bignumber_1._base16To36)(getAddress(address).substring(2)).toUpperCase();
  while (base36.length < 30) {
    base36 = "0" + base36;
  }
  return "XE" + ibanChecksum("XE00" + base36) + base36;
}
exports.getIcapAddress = getIcapAddress;
// http://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed
function getContractAddress(transaction) {
  var from = null;
  try {
    from = getAddress(transaction.from);
  } catch (error) {
    logger.throwArgumentError("missing from address", "transaction", transaction);
  }
  var nonce = (0, bytes_1.stripZeros)((0, bytes_1.arrayify)(bignumber_1.BigNumber.from(transaction.nonce).toHexString()));
  return getAddress((0, bytes_1.hexDataSlice)((0, keccak256_1.keccak256)((0, rlp_1.encode)([from, nonce])), 12));
}
exports.getContractAddress = getContractAddress;
function getCreate2Address(from, salt, initCodeHash) {
  if ((0, bytes_1.hexDataLength)(salt) !== 32) {
    logger.throwArgumentError("salt must be 32 bytes", "salt", salt);
  }
  if ((0, bytes_1.hexDataLength)(initCodeHash) !== 32) {
    logger.throwArgumentError("initCodeHash must be 32 bytes", "initCodeHash", initCodeHash);
  }
  return getAddress((0, bytes_1.hexDataSlice)((0, keccak256_1.keccak256)((0, bytes_1.concat)(["0xff", getAddress(from), salt, initCodeHash])), 12));
}
exports.getCreate2Address = getCreate2Address;

},{"./_version":18,"@ethersproject/bignumber":25,"@ethersproject/bytes":28,"@ethersproject/keccak256":43,"@ethersproject/logger":45,"@ethersproject/rlp":49}],20:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.encode = exports.decode = void 0;
var bytes_1 = require("@ethersproject/bytes");
function decode(textData) {
  textData = atob(textData);
  var data = [];
  for (var i = 0; i < textData.length; i++) {
    data.push(textData.charCodeAt(i));
  }
  return (0, bytes_1.arrayify)(data);
}
exports.decode = decode;
function encode(data) {
  data = (0, bytes_1.arrayify)(data);
  var textData = "";
  for (var i = 0; i < data.length; i++) {
    textData += String.fromCharCode(data[i]);
  }
  return btoa(textData);
}
exports.encode = encode;

},{"@ethersproject/bytes":28}],21:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.encode = exports.decode = void 0;
var base64_1 = require("./base64");
Object.defineProperty(exports, "decode", {
  enumerable: true,
  get: function get() {
    return base64_1.decode;
  }
});
Object.defineProperty(exports, "encode", {
  enumerable: true,
  get: function get() {
    return base64_1.encode;
  }
});

},{"./base64":20}],22:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.version = void 0;
exports.version = "bignumber/5.7.0";

},{}],23:[function(require,module,exports){
"use strict";

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._base16To36 = exports._base36To16 = exports.BigNumber = exports.isBigNumberish = void 0;
/**
 *  BigNumber
 *
 *  A wrapper around the BN.js object. We use the BN.js library
 *  because it is used by elliptic, so it is required regardless.
 *
 */
var bn_js_1 = __importDefault(require("bn.js"));
var BN = bn_js_1["default"].BN;
var bytes_1 = require("@ethersproject/bytes");
var logger_1 = require("@ethersproject/logger");
var _version_1 = require("./_version");
var logger = new logger_1.Logger(_version_1.version);
var _constructorGuard = {};
var MAX_SAFE = 0x1fffffffffffff;
function isBigNumberish(value) {
  return value != null && (BigNumber.isBigNumber(value) || typeof value === "number" && value % 1 === 0 || typeof value === "string" && !!value.match(/^-?[0-9]+$/) || (0, bytes_1.isHexString)(value) || typeof value === "bigint" || (0, bytes_1.isBytes)(value));
}
exports.isBigNumberish = isBigNumberish;
// Only warn about passing 10 into radix once
var _warnedToStringRadix = false;
var BigNumber = /** @class */function () {
  function BigNumber(constructorGuard, hex) {
    if (constructorGuard !== _constructorGuard) {
      logger.throwError("cannot call constructor directly; use BigNumber.from", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new (BigNumber)"
      });
    }
    this._hex = hex;
    this._isBigNumber = true;
    Object.freeze(this);
  }
  BigNumber.prototype.fromTwos = function (value) {
    return toBigNumber(toBN(this).fromTwos(value));
  };
  BigNumber.prototype.toTwos = function (value) {
    return toBigNumber(toBN(this).toTwos(value));
  };
  BigNumber.prototype.abs = function () {
    if (this._hex[0] === "-") {
      return BigNumber.from(this._hex.substring(1));
    }
    return this;
  };
  BigNumber.prototype.add = function (other) {
    return toBigNumber(toBN(this).add(toBN(other)));
  };
  BigNumber.prototype.sub = function (other) {
    return toBigNumber(toBN(this).sub(toBN(other)));
  };
  BigNumber.prototype.div = function (other) {
    var o = BigNumber.from(other);
    if (o.isZero()) {
      throwFault("division-by-zero", "div");
    }
    return toBigNumber(toBN(this).div(toBN(other)));
  };
  BigNumber.prototype.mul = function (other) {
    return toBigNumber(toBN(this).mul(toBN(other)));
  };
  BigNumber.prototype.mod = function (other) {
    var value = toBN(other);
    if (value.isNeg()) {
      throwFault("division-by-zero", "mod");
    }
    return toBigNumber(toBN(this).umod(value));
  };
  BigNumber.prototype.pow = function (other) {
    var value = toBN(other);
    if (value.isNeg()) {
      throwFault("negative-power", "pow");
    }
    return toBigNumber(toBN(this).pow(value));
  };
  BigNumber.prototype.and = function (other) {
    var value = toBN(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault("unbound-bitwise-result", "and");
    }
    return toBigNumber(toBN(this).and(value));
  };
  BigNumber.prototype.or = function (other) {
    var value = toBN(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault("unbound-bitwise-result", "or");
    }
    return toBigNumber(toBN(this).or(value));
  };
  BigNumber.prototype.xor = function (other) {
    var value = toBN(other);
    if (this.isNegative() || value.isNeg()) {
      throwFault("unbound-bitwise-result", "xor");
    }
    return toBigNumber(toBN(this).xor(value));
  };
  BigNumber.prototype.mask = function (value) {
    if (this.isNegative() || value < 0) {
      throwFault("negative-width", "mask");
    }
    return toBigNumber(toBN(this).maskn(value));
  };
  BigNumber.prototype.shl = function (value) {
    if (this.isNegative() || value < 0) {
      throwFault("negative-width", "shl");
    }
    return toBigNumber(toBN(this).shln(value));
  };
  BigNumber.prototype.shr = function (value) {
    if (this.isNegative() || value < 0) {
      throwFault("negative-width", "shr");
    }
    return toBigNumber(toBN(this).shrn(value));
  };
  BigNumber.prototype.eq = function (other) {
    return toBN(this).eq(toBN(other));
  };
  BigNumber.prototype.lt = function (other) {
    return toBN(this).lt(toBN(other));
  };
  BigNumber.prototype.lte = function (other) {
    return toBN(this).lte(toBN(other));
  };
  BigNumber.prototype.gt = function (other) {
    return toBN(this).gt(toBN(other));
  };
  BigNumber.prototype.gte = function (other) {
    return toBN(this).gte(toBN(other));
  };
  BigNumber.prototype.isNegative = function () {
    return this._hex[0] === "-";
  };
  BigNumber.prototype.isZero = function () {
    return toBN(this).isZero();
  };
  BigNumber.prototype.toNumber = function () {
    try {
      return toBN(this).toNumber();
    } catch (error) {
      throwFault("overflow", "toNumber", this.toString());
    }
    return null;
  };
  BigNumber.prototype.toBigInt = function () {
    try {
      return BigInt(this.toString());
    } catch (e) {}
    return logger.throwError("this platform does not support BigInt", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
      value: this.toString()
    });
  };
  BigNumber.prototype.toString = function () {
    // Lots of people expect this, which we do not support, so check (See: #889)
    if (arguments.length > 0) {
      if (arguments[0] === 10) {
        if (!_warnedToStringRadix) {
          _warnedToStringRadix = true;
          logger.warn("BigNumber.toString does not accept any parameters; base-10 is assumed");
        }
      } else if (arguments[0] === 16) {
        logger.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", logger_1.Logger.errors.UNEXPECTED_ARGUMENT, {});
      } else {
        logger.throwError("BigNumber.toString does not accept parameters", logger_1.Logger.errors.UNEXPECTED_ARGUMENT, {});
      }
    }
    return toBN(this).toString(10);
  };
  BigNumber.prototype.toHexString = function () {
    return this._hex;
  };
  BigNumber.prototype.toJSON = function (key) {
    return {
      type: "BigNumber",
      hex: this.toHexString()
    };
  };
  BigNumber.from = function (value) {
    if (value instanceof BigNumber) {
      return value;
    }
    if (typeof value === "string") {
      if (value.match(/^-?0x[0-9a-f]+$/i)) {
        return new BigNumber(_constructorGuard, toHex(value));
      }
      if (value.match(/^-?[0-9]+$/)) {
        return new BigNumber(_constructorGuard, toHex(new BN(value)));
      }
      return logger.throwArgumentError("invalid BigNumber string", "value", value);
    }
    if (typeof value === "number") {
      if (value % 1) {
        throwFault("underflow", "BigNumber.from", value);
      }
      if (value >= MAX_SAFE || value <= -MAX_SAFE) {
        throwFault("overflow", "BigNumber.from", value);
      }
      return BigNumber.from(String(value));
    }
    var anyValue = value;
    if (typeof anyValue === "bigint") {
      return BigNumber.from(anyValue.toString());
    }
    if ((0, bytes_1.isBytes)(anyValue)) {
      return BigNumber.from((0, bytes_1.hexlify)(anyValue));
    }
    if (anyValue) {
      // Hexable interface (takes priority)
      if (anyValue.toHexString) {
        var hex = anyValue.toHexString();
        if (typeof hex === "string") {
          return BigNumber.from(hex);
        }
      } else {
        // For now, handle legacy JSON-ified values (goes away in v6)
        var hex = anyValue._hex;
        // New-form JSON
        if (hex == null && anyValue.type === "BigNumber") {
          hex = anyValue.hex;
        }
        if (typeof hex === "string") {
          if ((0, bytes_1.isHexString)(hex) || hex[0] === "-" && (0, bytes_1.isHexString)(hex.substring(1))) {
            return BigNumber.from(hex);
          }
        }
      }
    }
    return logger.throwArgumentError("invalid BigNumber value", "value", value);
  };
  BigNumber.isBigNumber = function (value) {
    return !!(value && value._isBigNumber);
  };
  return BigNumber;
}();
exports.BigNumber = BigNumber;
// Normalize the hex string
function toHex(value) {
  // For BN, call on the hex string
  if (typeof value !== "string") {
    return toHex(value.toString(16));
  }
  // If negative, prepend the negative sign to the normalized positive value
  if (value[0] === "-") {
    // Strip off the negative sign
    value = value.substring(1);
    // Cannot have multiple negative signs (e.g. "--0x04")
    if (value[0] === "-") {
      logger.throwArgumentError("invalid hex", "value", value);
    }
    // Call toHex on the positive component
    value = toHex(value);
    // Do not allow "-0x00"
    if (value === "0x00") {
      return value;
    }
    // Negate the value
    return "-" + value;
  }
  // Add a "0x" prefix if missing
  if (value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  // Normalize zero
  if (value === "0x") {
    return "0x00";
  }
  // Make the string even length
  if (value.length % 2) {
    value = "0x0" + value.substring(2);
  }
  // Trim to smallest even-length string
  while (value.length > 4 && value.substring(0, 4) === "0x00") {
    value = "0x" + value.substring(4);
  }
  return value;
}
function toBigNumber(value) {
  return BigNumber.from(toHex(value));
}
function toBN(value) {
  var hex = BigNumber.from(value).toHexString();
  if (hex[0] === "-") {
    return new BN("-" + hex.substring(3), 16);
  }
  return new BN(hex.substring(2), 16);
}
function throwFault(fault, operation, value) {
  var params = {
    fault: fault,
    operation: operation
  };
  if (value != null) {
    params.value = value;
  }
  return logger.throwError(fault, logger_1.Logger.errors.NUMERIC_FAULT, params);
}
// value should have no prefix
function _base36To16(value) {
  return new BN(value, 36).toString(16);
}
exports._base36To16 = _base36To16;
// value should have no prefix
function _base16To36(value) {
  return new BN(value, 16).toString(36);
}
exports._base16To36 = _base16To36;

},{"./_version":22,"@ethersproject/bytes":28,"@ethersproject/logger":45,"bn.js":26}],24:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FixedNumber = exports.FixedFormat = exports.parseFixed = exports.formatFixed = void 0;
var bytes_1 = require("@ethersproject/bytes");
var logger_1 = require("@ethersproject/logger");
var _version_1 = require("./_version");
var logger = new logger_1.Logger(_version_1.version);
var bignumber_1 = require("./bignumber");
var _constructorGuard = {};
var Zero = bignumber_1.BigNumber.from(0);
var NegativeOne = bignumber_1.BigNumber.from(-1);
function throwFault(message, fault, operation, value) {
  var params = {
    fault: fault,
    operation: operation
  };
  if (value !== undefined) {
    params.value = value;
  }
  return logger.throwError(message, logger_1.Logger.errors.NUMERIC_FAULT, params);
}
// Constant to pull zeros from for multipliers
var zeros = "0";
while (zeros.length < 256) {
  zeros += zeros;
}
// Returns a string "1" followed by decimal "0"s
function getMultiplier(decimals) {
  if (typeof decimals !== "number") {
    try {
      decimals = bignumber_1.BigNumber.from(decimals).toNumber();
    } catch (e) {}
  }
  if (typeof decimals === "number" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {
    return "1" + zeros.substring(0, decimals);
  }
  return logger.throwArgumentError("invalid decimal size", "decimals", decimals);
}
function formatFixed(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  var multiplier = getMultiplier(decimals);
  // Make sure wei is a big number (convert as necessary)
  value = bignumber_1.BigNumber.from(value);
  var negative = value.lt(Zero);
  if (negative) {
    value = value.mul(NegativeOne);
  }
  var fraction = value.mod(multiplier).toString();
  while (fraction.length < multiplier.length - 1) {
    fraction = "0" + fraction;
  }
  // Strip training 0
  fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];
  var whole = value.div(multiplier).toString();
  if (multiplier.length === 1) {
    value = whole;
  } else {
    value = whole + "." + fraction;
  }
  if (negative) {
    value = "-" + value;
  }
  return value;
}
exports.formatFixed = formatFixed;
function parseFixed(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }
  var multiplier = getMultiplier(decimals);
  if (typeof value !== "string" || !value.match(/^-?[0-9.]+$/)) {
    logger.throwArgumentError("invalid decimal value", "value", value);
  }
  // Is it negative?
  var negative = value.substring(0, 1) === "-";
  if (negative) {
    value = value.substring(1);
  }
  if (value === ".") {
    logger.throwArgumentError("missing value", "value", value);
  }
  // Split it into a whole and fractional part
  var comps = value.split(".");
  if (comps.length > 2) {
    logger.throwArgumentError("too many decimal points", "value", value);
  }
  var whole = comps[0],
    fraction = comps[1];
  if (!whole) {
    whole = "0";
  }
  if (!fraction) {
    fraction = "0";
  }
  // Trim trailing zeros
  while (fraction[fraction.length - 1] === "0") {
    fraction = fraction.substring(0, fraction.length - 1);
  }
  // Check the fraction doesn't exceed our decimals size
  if (fraction.length > multiplier.length - 1) {
    throwFault("fractional component exceeds decimals", "underflow", "parseFixed");
  }
  // If decimals is 0, we have an empty string for fraction
  if (fraction === "") {
    fraction = "0";
  }
  // Fully pad the string with zeros to get to wei
  while (fraction.length < multiplier.length - 1) {
    fraction += "0";
  }
  var wholeValue = bignumber_1.BigNumber.from(whole);
  var fractionValue = bignumber_1.BigNumber.from(fraction);
  var wei = wholeValue.mul(multiplier).add(fractionValue);
  if (negative) {
    wei = wei.mul(NegativeOne);
  }
  return wei;
}
exports.parseFixed = parseFixed;
var FixedFormat = /** @class */function () {
  function FixedFormat(constructorGuard, signed, width, decimals) {
    if (constructorGuard !== _constructorGuard) {
      logger.throwError("cannot use FixedFormat constructor; use FixedFormat.from", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.signed = signed;
    this.width = width;
    this.decimals = decimals;
    this.name = (signed ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
    this._multiplier = getMultiplier(decimals);
    Object.freeze(this);
  }
  FixedFormat.from = function (value) {
    if (value instanceof FixedFormat) {
      return value;
    }
    if (typeof value === "number") {
      value = "fixed128x" + value;
    }
    var signed = true;
    var width = 128;
    var decimals = 18;
    if (typeof value === "string") {
      if (value === "fixed") {
        // defaults...
      } else if (value === "ufixed") {
        signed = false;
      } else {
        var match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
        if (!match) {
          logger.throwArgumentError("invalid fixed format", "format", value);
        }
        signed = match[1] !== "u";
        width = parseInt(match[2]);
        decimals = parseInt(match[3]);
      }
    } else if (value) {
      var check = function check(key, type, defaultValue) {
        if (value[key] == null) {
          return defaultValue;
        }
        if (_typeof(value[key]) !== type) {
          logger.throwArgumentError("invalid fixed format (" + key + " not " + type + ")", "format." + key, value[key]);
        }
        return value[key];
      };
      signed = check("signed", "boolean", signed);
      width = check("width", "number", width);
      decimals = check("decimals", "number", decimals);
    }
    if (width % 8) {
      logger.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", width);
    }
    if (decimals > 80) {
      logger.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", decimals);
    }
    return new FixedFormat(_constructorGuard, signed, width, decimals);
  };
  return FixedFormat;
}();
exports.FixedFormat = FixedFormat;
var FixedNumber = /** @class */function () {
  function FixedNumber(constructorGuard, hex, value, format) {
    if (constructorGuard !== _constructorGuard) {
      logger.throwError("cannot use FixedNumber constructor; use FixedNumber.from", logger_1.Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }
    this.format = format;
    this._hex = hex;
    this._value = value;
    this._isFixedNumber = true;
    Object.freeze(this);
  }
  FixedNumber.prototype._checkFormat = function (other) {
    if (this.format.name !== other.format.name) {
      logger.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", other);
    }
  };
  FixedNumber.prototype.addUnsafe = function (other) {
    this._checkFormat(other);
    var a = parseFixed(this._value, this.format.decimals);
    var b = parseFixed(other._value, other.format.decimals);
    return FixedNumber.fromValue(a.add(b), this.format.decimals, this.format);
  };
  FixedNumber.prototype.subUnsafe = function (other) {
    this._checkFormat(other);
    var a = parseFixed(this._value, this.format.decimals);
    var b = parseFixed(other._value, other.format.decimals);
    return FixedNumber.fromValue(a.sub(b), this.format.decimals, this.format);
  };
  FixedNumber.prototype.mulUnsafe = function (other) {
    this._checkFormat(other);
    var a = parseFixed(this._value, this.format.decimals);
    var b = parseFixed(other._value, other.format.decimals);
    return FixedNumber.fromValue(a.mul(b).div(this.format._multiplier), this.format.decimals, this.format);
  };
  FixedNumber.prototype.divUnsafe = function (other) {
    this._checkFormat(other);
    var a = parseFixed(this._value, this.format.decimals);
    var b = parseFixed(other._value, other.format.decimals);
    return FixedNumber.fromValue(a.mul(this.format._multiplier).div(b), this.format.decimals, this.format);
  };
  FixedNumber.prototype.floor = function () {
    var comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    var result = FixedNumber.from(comps[0], this.format);
    var hasFraction = !comps[1].match(/^(0*)$/);
    if (this.isNegative() && hasFraction) {
      result = result.subUnsafe(ONE.toFormat(result.format));
    }
    return result;
  };
  FixedNumber.prototype.ceiling = function () {
    var comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    var result = FixedNumber.from(comps[0], this.format);
    var hasFraction = !comps[1].match(/^(0*)$/);
    if (!this.isNegative() && hasFraction) {
      result = result.addUnsafe(ONE.toFormat(result.format));
    }
    return result;
  };
  // @TODO: Support other rounding algorithms
  FixedNumber.prototype.round = function (decimals) {
    if (decimals == null) {
      decimals = 0;
    }
    // If we are already in range, we're done
    var comps = this.toString().split(".");
    if (comps.length === 1) {
      comps.push("0");
    }
    if (decimals < 0 || decimals > 80 || decimals % 1) {
      logger.throwArgumentError("invalid decimal count", "decimals", decimals);
    }
    if (comps[1].length <= decimals) {
      return this;
    }
    var factor = FixedNumber.from("1" + zeros.substring(0, decimals), this.format);
    var bump = BUMP.toFormat(this.format);
    return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);
  };
  FixedNumber.prototype.isZero = function () {
    return this._value === "0.0" || this._value === "0";
  };
  FixedNumber.prototype.isNegative = function () {
    return this._value[0] === "-";
  };
  FixedNumber.prototype.toString = function () {
    return this._value;
  };
  FixedNumber.prototype.toHexString = function (width) {
    if (width == null) {
      return this._hex;
    }
    if (width % 8) {
      logger.throwArgumentError("invalid byte width", "width", width);
    }
    var hex = bignumber_1.BigNumber.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();
    return (0, bytes_1.hexZeroPad)(hex, width / 8);
  };
  FixedNumber.prototype.toUnsafeFloat = function () {
    return parseFloat(this.toString());
  };
  FixedNumber.prototype.toFormat = function (format) {
    return FixedNumber.fromString(this._value, format);
  };
  FixedNumber.fromValue = function (value, decimals, format) {
    // If decimals looks more like a format, and there is no format, shift the parameters
    if (format == null && decimals != null && !(0, bignumber_1.isBigNumberish)(decimals)) {
      format = decimals;
      decimals = null;
    }
    if (decimals == null) {
      decimals = 0;
    }
    if (format == null) {
      format = "fixed";
    }
    return FixedNumber.fromString(formatFixed(value, decimals), FixedFormat.from(format));
  };
  FixedNumber.fromString = function (value, format) {
    if (format == null) {
      format = "fixed";
    }
    var fixedFormat = FixedFormat.from(format);
    var numeric = parseFixed(value, fixedFormat.decimals);
    if (!fixedFormat.signed && numeric.lt(Zero)) {
      throwFault("unsigned value cannot be negative", "overflow", "value", value);
    }
    var hex = null;
    if (fixedFormat.signed) {
      hex = numeric.toTwos(fixedFormat.width).toHexString();
    } else {
      hex = numeric.toHexString();
      hex = (0, bytes_1.hexZeroPad)(hex, fixedFormat.width / 8);
    }
    var decimal = formatFixed(numeric, fixedFormat.decimals);
    return new FixedNumber(_constructorGuard, hex, decimal, fixedFormat);
  };
  FixedNumber.fromBytes = function (value, format) {
    if (format == null) {
      format = "fixed";
    }
    var fixedFormat = FixedFormat.from(format);
    if ((0, bytes_1.arrayify)(value).length > fixedFormat.width / 8) {
      throw new Error("overflow");
    }
    var numeric = bignumber_1.BigNumber.from(value);
    if (fixedFormat.signed) {
      numeric = numeric.fromTwos(fixedFormat.width);
    }
    var hex = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();
    var decimal = formatFixed(numeric, fixedFormat.decimals);
    return new FixedNumber(_constructorGuard, hex, decimal, fixedFormat);
  };
  FixedNumber.from = function (value, format) {
    if (typeof value === "string") {
      return FixedNumber.fromString(value, format);
    }
    if ((0, bytes_1.isBytes)(value)) {
      return FixedNumber.fromBytes(value, format);
    }
    try {
      return FixedNumber.fromValue(value, 0, format);
    } catch (error) {
      // Allow NUMERIC_FAULT to bubble up
      if (error.code !== logger_1.Logger.errors.INVALID_ARGUMENT) {
        throw error;
      }
    }
    return logger.throwArgumentError("invalid FixedNumber value", "value", value);
  };
  FixedNumber.isFixedNumber = function (value) {
    return !!(value && value._isFixedNumber);
  };
  return FixedNumber;
}();
exports.FixedNumber = FixedNumber;
var ONE = FixedNumber.from(1);
var BUMP = FixedNumber.from("0.5");

},{"./_version":22,"./bignumber":23,"@ethersproject/bytes":28,"@ethersproject/logger":45}],25:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._base36To16 = exports._base16To36 = exports.parseFixed = exports.FixedNumber = exports.FixedFormat = exports.formatFixed = exports.BigNumber = void 0;
var bignumber_1 = require("./bignumber");
Object.defineProperty(exports, "BigNumber", {
  enumerable: true,
  get: function get() {
    return bignumber_1.BigNumber;
  }
});
var fixednumber_1 = require("./fixednumber");
Object.defineProperty(exports, "formatFixed", {
  enumerable: true,
  get: function get() {
    return fixednumber_1.formatFixed;
  }
});
Object.defineProperty(exports, "FixedFormat", {
  enumerable: true,
  get: function get() {
    return fixednumber_1.FixedFormat;
  }
});
Object.defineProperty(exports, "FixedNumber", {
  enumerable: true,
  get: function get() {
    return fixednumber_1.FixedNumber;
  }
});
Object.defineProperty(exports, "parseFixed", {
  enumerable: true,
  get: function get() {
    return fixednumber_1.parseFixed;
  }
});
// Internal methods used by address
var bignumber_2 = require("./bignumber");
Object.defineProperty(exports, "_base16To36", {
  enumerable: true,
  get: function get() {
    return bignumber_2._base16To36;
  }
});
Object.defineProperty(exports, "_base36To16", {
  enumerable: true,
  get: function get() {
    return bignumber_2._base36To16;
  }
});

},{"./bignumber":23,"./fixednumber":24}],26:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
(function (module, exports) {
  'use strict';

  // Utils
  function assert(val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
  }

  // Could use `inherits` module, but don't want to move from single file
  // architecture yet.
  function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function TempCtor() {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  }

  // BN

  function BN(number, base, endian) {
    if (BN.isBN(number)) {
      return number;
    }
    this.negative = 0;
    this.words = null;
    this.length = 0;

    // Reduction context
    this.red = null;
    if (number !== null) {
      if (base === 'le' || base === 'be') {
        endian = base;
        base = 10;
      }
      this._init(number || 0, base || 10, endian || 'be');
    }
  }
  if (_typeof(module) === 'object') {
    module.exports = BN;
  } else {
    exports.BN = BN;
  }
  BN.BN = BN;
  BN.wordSize = 26;
  var Buffer;
  try {
    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
      Buffer = window.Buffer;
    } else {
      Buffer = require('buffer').Buffer;
    }
  } catch (e) {}
  BN.isBN = function isBN(num) {
    if (num instanceof BN) {
      return true;
    }
    return num !== null && _typeof(num) === 'object' && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
  };
  BN.max = function max(left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
  };
  BN.min = function min(left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
  };
  BN.prototype._init = function init(number, base, endian) {
    if (typeof number === 'number') {
      return this._initNumber(number, base, endian);
    }
    if (_typeof(number) === 'object') {
      return this._initArray(number, base, endian);
    }
    if (base === 'hex') {
      base = 16;
    }
    assert(base === (base | 0) && base >= 2 && base <= 36);
    number = number.toString().replace(/\s+/g, '');
    var start = 0;
    if (number[0] === '-') {
      start++;
      this.negative = 1;
    }
    if (start < number.length) {
      if (base === 16) {
        this._parseHex(number, start, endian);
      } else {
        this._parseBase(number, base, start);
        if (endian === 'le') {
          this._initArray(this.toArray(), base, endian);
        }
      }
    }
  };
  BN.prototype._initNumber = function _initNumber(number, base, endian) {
    if (number < 0) {
      this.negative = 1;
      number = -number;
    }
    if (number < 0x4000000) {
      this.words = [number & 0x3ffffff];
      this.length = 1;
    } else if (number < 0x10000000000000) {
      this.words = [number & 0x3ffffff, number / 0x4000000 & 0x3ffffff];
      this.length = 2;
    } else {
      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
      this.words = [number & 0x3ffffff, number / 0x4000000 & 0x3ffffff, 1];
      this.length = 3;
    }
    if (endian !== 'le') return;

    // Reverse the bytes
    this._initArray(this.toArray(), base, endian);
  };
  BN.prototype._initArray = function _initArray(number, base, endian) {
    // Perhaps a Uint8Array
    assert(typeof number.length === 'number');
    if (number.length <= 0) {
      this.words = [0];
      this.length = 1;
      return this;
    }
    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }
    var j, w;
    var off = 0;
    if (endian === 'be') {
      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
        w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
        this.words[j] |= w << off & 0x3ffffff;
        this.words[j + 1] = w >>> 26 - off & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    } else if (endian === 'le') {
      for (i = 0, j = 0; i < number.length; i += 3) {
        w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
        this.words[j] |= w << off & 0x3ffffff;
        this.words[j + 1] = w >>> 26 - off & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    }
    return this._strip();
  };
  function parseHex4Bits(string, index) {
    var c = string.charCodeAt(index);
    // '0' - '9'
    if (c >= 48 && c <= 57) {
      return c - 48;
      // 'A' - 'F'
    } else if (c >= 65 && c <= 70) {
      return c - 55;
      // 'a' - 'f'
    } else if (c >= 97 && c <= 102) {
      return c - 87;
    } else {
      assert(false, 'Invalid character in ' + string);
    }
  }
  function parseHexByte(string, lowerBound, index) {
    var r = parseHex4Bits(string, index);
    if (index - 1 >= lowerBound) {
      r |= parseHex4Bits(string, index - 1) << 4;
    }
    return r;
  }
  BN.prototype._parseHex = function _parseHex(number, start, endian) {
    // Create possibly bigger array to ensure that it fits the number
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    // 24-bits chunks
    var off = 0;
    var j = 0;
    var w;
    if (endian === 'be') {
      for (i = number.length - 1; i >= start; i -= 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    } else {
      var parseLength = number.length - start;
      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    }
    this._strip();
  };
  function parseBase(str, start, end, mul) {
    var r = 0;
    var b = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;
      r *= mul;

      // 'a'
      if (c >= 49) {
        b = c - 49 + 0xa;

        // 'A'
      } else if (c >= 17) {
        b = c - 17 + 0xa;

        // '0' - '9'
      } else {
        b = c;
      }
      assert(c >= 0 && b < mul, 'Invalid character');
      r += b;
    }
    return r;
  }
  BN.prototype._parseBase = function _parseBase(number, base, start) {
    // Initialize as zero
    this.words = [0];
    this.length = 1;

    // Find length of limb in base
    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
      limbLen++;
    }
    limbLen--;
    limbPow = limbPow / base | 0;
    var total = number.length - start;
    var mod = total % limbLen;
    var end = Math.min(total, total - mod) + start;
    var word = 0;
    for (var i = start; i < end; i += limbLen) {
      word = parseBase(number, i, i + limbLen, base);
      this.imuln(limbPow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }
    if (mod !== 0) {
      var pow = 1;
      word = parseBase(number, i, number.length, base);
      for (i = 0; i < mod; i++) {
        pow *= base;
      }
      this.imuln(pow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }
    this._strip();
  };
  BN.prototype.copy = function copy(dest) {
    dest.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      dest.words[i] = this.words[i];
    }
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
  };
  function move(dest, src) {
    dest.words = src.words;
    dest.length = src.length;
    dest.negative = src.negative;
    dest.red = src.red;
  }
  BN.prototype._move = function _move(dest) {
    move(dest, this);
  };
  BN.prototype.clone = function clone() {
    var r = new BN(null);
    this.copy(r);
    return r;
  };
  BN.prototype._expand = function _expand(size) {
    while (this.length < size) {
      this.words[this.length++] = 0;
    }
    return this;
  };

  // Remove leading `0` from `this`
  BN.prototype._strip = function strip() {
    while (this.length > 1 && this.words[this.length - 1] === 0) {
      this.length--;
    }
    return this._normSign();
  };
  BN.prototype._normSign = function _normSign() {
    // -0 = 0
    if (this.length === 1 && this.words[0] === 0) {
      this.negative = 0;
    }
    return this;
  };

  // Check Symbol.for because not everywhere where Symbol defined
  // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#Browser_compatibility
  if (typeof Symbol !== 'undefined' && typeof Symbol["for"] === 'function') {
    try {
      BN.prototype[Symbol["for"]('nodejs.util.inspect.custom')] = inspect;
    } catch (e) {
      BN.prototype.inspect = inspect;
    }
  } else {
    BN.prototype.inspect = inspect;
  }
  function inspect() {
    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
  }

  /*
   var zeros = [];
  var groupSizes = [];
  var groupBases = [];
   var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }
   */

  var zeros = ['', '0', '00', '000', '0000', '00000', '000000', '0000000', '00000000', '000000000', '0000000000', '00000000000', '000000000000', '0000000000000', '00000000000000', '000000000000000', '0000000000000000', '00000000000000000', '000000000000000000', '0000000000000000000', '00000000000000000000', '000000000000000000000', '0000000000000000000000', '00000000000000000000000', '000000000000000000000000', '0000000000000000000000000'];
  var groupSizes = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5];
  var groupBases = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
  BN.prototype.toString = function toString(base, padding) {
    base = base || 10;
    padding = padding | 0 || 1;
    var out;
    if (base === 16 || base === 'hex') {
      out = '';
      var off = 0;
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = this.words[i];
        var word = ((w << off | carry) & 0xffffff).toString(16);
        carry = w >>> 24 - off & 0xffffff;
        off += 2;
        if (off >= 26) {
          off -= 26;
          i--;
        }
        if (carry !== 0 || i !== this.length - 1) {
          out = zeros[6 - word.length] + word + out;
        } else {
          out = word + out;
        }
      }
      if (carry !== 0) {
        out = carry.toString(16) + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }
    if (base === (base | 0) && base >= 2 && base <= 36) {
      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
      var groupSize = groupSizes[base];
      // var groupBase = Math.pow(base, groupSize);
      var groupBase = groupBases[base];
      out = '';
      var c = this.clone();
      c.negative = 0;
      while (!c.isZero()) {
        var r = c.modrn(groupBase).toString(base);
        c = c.idivn(groupBase);
        if (!c.isZero()) {
          out = zeros[groupSize - r.length] + r + out;
        } else {
          out = r + out;
        }
      }
      if (this.isZero()) {
        out = '0' + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }
    assert(false, 'Base should be between 2 and 36');
  };
  BN.prototype.toNumber = function toNumber() {
    var ret = this.words[0];
    if (this.length === 2) {
      ret += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
      // NOTE: at this stage it is known that the top bit is set
      ret += 0x10000000000000 + this.words[1] * 0x4000000;
    } else if (this.length > 2) {
      assert(false, 'Number can only safely store up to 53 bits');
    }
    return this.negative !== 0 ? -ret : ret;
  };
  BN.prototype.toJSON = function toJSON() {
    return this.toString(16, 2);
  };
  if (Buffer) {
    BN.prototype.toBuffer = function toBuffer(endian, length) {
      return this.toArrayLike(Buffer, endian, length);
    };
  }
  BN.prototype.toArray = function toArray(endian, length) {
    return this.toArrayLike(Array, endian, length);
  };
  var allocate = function allocate(ArrayType, size) {
    if (ArrayType.allocUnsafe) {
      return ArrayType.allocUnsafe(size);
    }
    return new ArrayType(size);
  };
  BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
    this._strip();
    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert(byteLength <= reqLength, 'byte array longer than desired length');
    assert(reqLength > 0, 'Requested array length <= 0');
    var res = allocate(ArrayType, reqLength);
    var postfix = endian === 'le' ? 'LE' : 'BE';
    this['_toArrayLike' + postfix](res, byteLength);
    return res;
  };
  BN.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {
    var position = 0;
    var carry = 0;
    for (var i = 0, shift = 0; i < this.length; i++) {
      var word = this.words[i] << shift | carry;
      res[position++] = word & 0xff;
      if (position < res.length) {
        res[position++] = word >> 8 & 0xff;
      }
      if (position < res.length) {
        res[position++] = word >> 16 & 0xff;
      }
      if (shift === 6) {
        if (position < res.length) {
          res[position++] = word >> 24 & 0xff;
        }
        carry = 0;
        shift = 0;
      } else {
        carry = word >>> 24;
        shift += 2;
      }
    }
    if (position < res.length) {
      res[position++] = carry;
      while (position < res.length) {
        res[position++] = 0;
      }
    }
  };
  BN.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {
    var position = res.length - 1;
    var carry = 0;
    for (var i = 0, shift = 0; i < this.length; i++) {
      var word = this.words[i] << shift | carry;
      res[position--] = word & 0xff;
      if (position >= 0) {
        res[position--] = word >> 8 & 0xff;
      }
      if (position >= 0) {
        res[position--] = word >> 16 & 0xff;
      }
      if (shift === 6) {
        if (position >= 0) {
          res[position--] = word >> 24 & 0xff;
        }
        carry = 0;
        shift = 0;
      } else {
        carry = word >>> 24;
        shift += 2;
      }
    }
    if (position >= 0) {
      res[position--] = carry;
      while (position >= 0) {
        res[position--] = 0;
      }
    }
  };
  if (Math.clz32) {
    BN.prototype._countBits = function _countBits(w) {
      return 32 - Math.clz32(w);
    };
  } else {
    BN.prototype._countBits = function _countBits(w) {
      var t = w;
      var r = 0;
      if (t >= 0x1000) {
        r += 13;
        t >>>= 13;
      }
      if (t >= 0x40) {
        r += 7;
        t >>>= 7;
      }
      if (t >= 0x8) {
        r += 4;
        t >>>= 4;
      }
      if (t >= 0x02) {
        r += 2;
        t >>>= 2;
      }
      return r + t;
    };
  }
  BN.prototype._zeroBits = function _zeroBits(w) {
    // Short-cut
    if (w === 0) return 26;
    var t = w;
    var r = 0;
    if ((t & 0x1fff) === 0) {
      r += 13;
      t >>>= 13;
    }
    if ((t & 0x7f) === 0) {
      r += 7;
      t >>>= 7;
    }
    if ((t & 0xf) === 0) {
      r += 4;
      t >>>= 4;
    }
    if ((t & 0x3) === 0) {
      r += 2;
      t >>>= 2;
    }
    if ((t & 0x1) === 0) {
      r++;
    }
    return r;
  };

  // Return number of used bits in a BN
  BN.prototype.bitLength = function bitLength() {
    var w = this.words[this.length - 1];
    var hi = this._countBits(w);
    return (this.length - 1) * 26 + hi;
  };
  function toBitArray(num) {
    var w = new Array(num.bitLength());
    for (var bit = 0; bit < w.length; bit++) {
      var off = bit / 26 | 0;
      var wbit = bit % 26;
      w[bit] = num.words[off] >>> wbit & 0x01;
    }
    return w;
  }

  // Number of trailing zero bits
  BN.prototype.zeroBits = function zeroBits() {
    if (this.isZero()) return 0;
    var r = 0;
    for (var i = 0; i < this.length; i++) {
      var b = this._zeroBits(this.words[i]);
      r += b;
      if (b !== 26) break;
    }
    return r;
  };
  BN.prototype.byteLength = function byteLength() {
    return Math.ceil(this.bitLength() / 8);
  };
  BN.prototype.toTwos = function toTwos(width) {
    if (this.negative !== 0) {
      return this.abs().inotn(width).iaddn(1);
    }
    return this.clone();
  };
  BN.prototype.fromTwos = function fromTwos(width) {
    if (this.testn(width - 1)) {
      return this.notn(width).iaddn(1).ineg();
    }
    return this.clone();
  };
  BN.prototype.isNeg = function isNeg() {
    return this.negative !== 0;
  };

  // Return negative clone of `this`
  BN.prototype.neg = function neg() {
    return this.clone().ineg();
  };
  BN.prototype.ineg = function ineg() {
    if (!this.isZero()) {
      this.negative ^= 1;
    }
    return this;
  };

  // Or `num` with `this` in-place
  BN.prototype.iuor = function iuor(num) {
    while (this.length < num.length) {
      this.words[this.length++] = 0;
    }
    for (var i = 0; i < num.length; i++) {
      this.words[i] = this.words[i] | num.words[i];
    }
    return this._strip();
  };
  BN.prototype.ior = function ior(num) {
    assert((this.negative | num.negative) === 0);
    return this.iuor(num);
  };

  // Or `num` with `this`
  BN.prototype.or = function or(num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
  };
  BN.prototype.uor = function uor(num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
  };

  // And `num` with `this` in-place
  BN.prototype.iuand = function iuand(num) {
    // b = min-length(num, this)
    var b;
    if (this.length > num.length) {
      b = num;
    } else {
      b = this;
    }
    for (var i = 0; i < b.length; i++) {
      this.words[i] = this.words[i] & num.words[i];
    }
    this.length = b.length;
    return this._strip();
  };
  BN.prototype.iand = function iand(num) {
    assert((this.negative | num.negative) === 0);
    return this.iuand(num);
  };

  // And `num` with `this`
  BN.prototype.and = function and(num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
  };
  BN.prototype.uand = function uand(num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
  };

  // Xor `num` with `this` in-place
  BN.prototype.iuxor = function iuxor(num) {
    // a.length > b.length
    var a;
    var b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }
    for (var i = 0; i < b.length; i++) {
      this.words[i] = a.words[i] ^ b.words[i];
    }
    if (this !== a) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }
    this.length = a.length;
    return this._strip();
  };
  BN.prototype.ixor = function ixor(num) {
    assert((this.negative | num.negative) === 0);
    return this.iuxor(num);
  };

  // Xor `num` with `this`
  BN.prototype.xor = function xor(num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
  };
  BN.prototype.uxor = function uxor(num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
  };

  // Not ``this`` with ``width`` bitwidth
  BN.prototype.inotn = function inotn(width) {
    assert(typeof width === 'number' && width >= 0);
    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26;

    // Extend the buffer with leading zeroes
    this._expand(bytesNeeded);
    if (bitsLeft > 0) {
      bytesNeeded--;
    }

    // Handle complete words
    for (var i = 0; i < bytesNeeded; i++) {
      this.words[i] = ~this.words[i] & 0x3ffffff;
    }

    // Handle the residue
    if (bitsLeft > 0) {
      this.words[i] = ~this.words[i] & 0x3ffffff >> 26 - bitsLeft;
    }

    // And remove leading zeroes
    return this._strip();
  };
  BN.prototype.notn = function notn(width) {
    return this.clone().inotn(width);
  };

  // Set `bit` of `this`
  BN.prototype.setn = function setn(bit, val) {
    assert(typeof bit === 'number' && bit >= 0);
    var off = bit / 26 | 0;
    var wbit = bit % 26;
    this._expand(off + 1);
    if (val) {
      this.words[off] = this.words[off] | 1 << wbit;
    } else {
      this.words[off] = this.words[off] & ~(1 << wbit);
    }
    return this._strip();
  };

  // Add `num` to `this` in-place
  BN.prototype.iadd = function iadd(num) {
    var r;

    // negative + positive
    if (this.negative !== 0 && num.negative === 0) {
      this.negative = 0;
      r = this.isub(num);
      this.negative ^= 1;
      return this._normSign();

      // positive + negative
    } else if (this.negative === 0 && num.negative !== 0) {
      num.negative = 0;
      r = this.isub(num);
      num.negative = 1;
      return r._normSign();
    }

    // a.length > b.length
    var a, b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }
    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }
    this.length = a.length;
    if (carry !== 0) {
      this.words[this.length] = carry;
      this.length++;
      // Copy the rest of the words
    } else if (a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }
    return this;
  };

  // Add `num` to `this`
  BN.prototype.add = function add(num) {
    var res;
    if (num.negative !== 0 && this.negative === 0) {
      num.negative = 0;
      res = this.sub(num);
      num.negative ^= 1;
      return res;
    } else if (num.negative === 0 && this.negative !== 0) {
      this.negative = 0;
      res = num.sub(this);
      this.negative = 1;
      return res;
    }
    if (this.length > num.length) return this.clone().iadd(num);
    return num.clone().iadd(this);
  };

  // Subtract `num` from `this` in-place
  BN.prototype.isub = function isub(num) {
    // this - (-num) = this + num
    if (num.negative !== 0) {
      num.negative = 0;
      var r = this.iadd(num);
      num.negative = 1;
      return r._normSign();

      // -this - num = -(this + num)
    } else if (this.negative !== 0) {
      this.negative = 0;
      this.iadd(num);
      this.negative = 1;
      return this._normSign();
    }

    // At this point both numbers are positive
    var cmp = this.cmp(num);

    // Optimization - zeroify
    if (cmp === 0) {
      this.negative = 0;
      this.length = 1;
      this.words[0] = 0;
      return this;
    }

    // a > b
    var a, b;
    if (cmp > 0) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }
    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }

    // Copy rest of the words
    if (carry === 0 && i < a.length && a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }
    this.length = Math.max(this.length, i);
    if (a !== this) {
      this.negative = 1;
    }
    return this._strip();
  };

  // Subtract `num` from `this`
  BN.prototype.sub = function sub(num) {
    return this.clone().isub(num);
  };
  function smallMulTo(self, num, out) {
    out.negative = num.negative ^ self.negative;
    var len = self.length + num.length | 0;
    out.length = len;
    len = len - 1 | 0;

    // Peel one iteration (compiler can't do it, because of code complexity)
    var a = self.words[0] | 0;
    var b = num.words[0] | 0;
    var r = a * b;
    var lo = r & 0x3ffffff;
    var carry = r / 0x4000000 | 0;
    out.words[0] = lo;
    for (var k = 1; k < len; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = carry >>> 26;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j | 0;
        a = self.words[i] | 0;
        b = num.words[j] | 0;
        r = a * b + rword;
        ncarry += r / 0x4000000 | 0;
        rword = r & 0x3ffffff;
      }
      out.words[k] = rword | 0;
      carry = ncarry | 0;
    }
    if (carry !== 0) {
      out.words[k] = carry | 0;
    } else {
      out.length--;
    }
    return out._strip();
  }

  // TODO(indutny): it may be reasonable to omit it for users who don't need
  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
  // multiplication (like elliptic secp256k1).
  var comb10MulTo = function comb10MulTo(self, num, out) {
    var a = self.words;
    var b = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;
    out.negative = self.negative ^ num.negative;
    out.length = 19;
    /* k = 0 */
    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = mid + Math.imul(ah0, bl0) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
    w0 &= 0x3ffffff;
    /* k = 1 */
    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = mid + Math.imul(ah1, bl0) | 0;
    hi = Math.imul(ah1, bh0);
    lo = lo + Math.imul(al0, bl1) | 0;
    mid = mid + Math.imul(al0, bh1) | 0;
    mid = mid + Math.imul(ah0, bl1) | 0;
    hi = hi + Math.imul(ah0, bh1) | 0;
    var w1 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
    w1 &= 0x3ffffff;
    /* k = 2 */
    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = mid + Math.imul(ah2, bl0) | 0;
    hi = Math.imul(ah2, bh0);
    lo = lo + Math.imul(al1, bl1) | 0;
    mid = mid + Math.imul(al1, bh1) | 0;
    mid = mid + Math.imul(ah1, bl1) | 0;
    hi = hi + Math.imul(ah1, bh1) | 0;
    lo = lo + Math.imul(al0, bl2) | 0;
    mid = mid + Math.imul(al0, bh2) | 0;
    mid = mid + Math.imul(ah0, bl2) | 0;
    hi = hi + Math.imul(ah0, bh2) | 0;
    var w2 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
    w2 &= 0x3ffffff;
    /* k = 3 */
    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = mid + Math.imul(ah3, bl0) | 0;
    hi = Math.imul(ah3, bh0);
    lo = lo + Math.imul(al2, bl1) | 0;
    mid = mid + Math.imul(al2, bh1) | 0;
    mid = mid + Math.imul(ah2, bl1) | 0;
    hi = hi + Math.imul(ah2, bh1) | 0;
    lo = lo + Math.imul(al1, bl2) | 0;
    mid = mid + Math.imul(al1, bh2) | 0;
    mid = mid + Math.imul(ah1, bl2) | 0;
    hi = hi + Math.imul(ah1, bh2) | 0;
    lo = lo + Math.imul(al0, bl3) | 0;
    mid = mid + Math.imul(al0, bh3) | 0;
    mid = mid + Math.imul(ah0, bl3) | 0;
    hi = hi + Math.imul(ah0, bh3) | 0;
    var w3 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
    w3 &= 0x3ffffff;
    /* k = 4 */
    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = mid + Math.imul(ah4, bl0) | 0;
    hi = Math.imul(ah4, bh0);
    lo = lo + Math.imul(al3, bl1) | 0;
    mid = mid + Math.imul(al3, bh1) | 0;
    mid = mid + Math.imul(ah3, bl1) | 0;
    hi = hi + Math.imul(ah3, bh1) | 0;
    lo = lo + Math.imul(al2, bl2) | 0;
    mid = mid + Math.imul(al2, bh2) | 0;
    mid = mid + Math.imul(ah2, bl2) | 0;
    hi = hi + Math.imul(ah2, bh2) | 0;
    lo = lo + Math.imul(al1, bl3) | 0;
    mid = mid + Math.imul(al1, bh3) | 0;
    mid = mid + Math.imul(ah1, bl3) | 0;
    hi = hi + Math.imul(ah1, bh3) | 0;
    lo = lo + Math.imul(al0, bl4) | 0;
    mid = mid + Math.imul(al0, bh4) | 0;
    mid = mid + Math.imul(ah0, bl4) | 0;
    hi = hi + Math.imul(ah0, bh4) | 0;
    var w4 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
    w4 &= 0x3ffffff;
    /* k = 5 */
    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = mid + Math.imul(ah5, bl0) | 0;
    hi = Math.imul(ah5, bh0);
    lo = lo + Math.imul(al4, bl1) | 0;
    mid = mid + Math.imul(al4, bh1) | 0;
    mid = mid + Math.imul(ah4, bl1) | 0;
    hi = hi + Math.imul(ah4, bh1) | 0;
    lo = lo + Math.imul(al3, bl2) | 0;
    mid = mid + Math.imul(al3, bh2) | 0;
    mid = mid + Math.imul(ah3, bl2) | 0;
    hi = hi + Math.imul(ah3, bh2) | 0;
    lo = lo + Math.imul(al2, bl3) | 0;
    mid = mid + Math.imul(al2, bh3) | 0;
    mid = mid + Math.imul(ah2, bl3) | 0;
    hi = hi + Math.imul(ah2, bh3) | 0;
    lo = lo + Math.imul(al1, bl4) | 0;
    mid = mid + Math.imul(al1, bh4) | 0;
    mid = mid + Math.imul(ah1, bl4) | 0;
    hi = hi + Math.imul(ah1, bh4) | 0;
    lo = lo + Math.imul(al0, bl5) | 0;
    mid = mid + Math.imul(al0, bh5) | 0;
    mid = mid + Math.imul(ah0, bl5) | 0;
    hi = hi + Math.imul(ah0, bh5) | 0;
    var w5 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
    w5 &= 0x3ffffff;
    /* k = 6 */
    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = mid + Math.imul(ah6, bl0) | 0;
    hi = Math.imul(ah6, bh0);
    lo = lo + Math.imul(al5, bl1) | 0;
    mid = mid + Math.imul(al5, bh1) | 0;
    mid = mid + Math.imul(ah5, bl1) | 0;
    hi = hi + Math.imul(ah5, bh1) | 0;
    lo = lo + Math.imul(al4, bl2) | 0;
    mid = mid + Math.imul(al4, bh2) | 0;
    mid = mid + Math.imul(ah4, bl2) | 0;
    hi = hi + Math.imul(ah4, bh2) | 0;
    lo = lo + Math.imul(al3, bl3) | 0;
    mid = mid + Math.imul(al3, bh3) | 0;
    mid = mid + Math.imul(ah3, bl3) | 0;
    hi = hi + Math.imul(ah3, bh3) | 0;
    lo = lo + Math.imul(al2, bl4) | 0;
    mid = mid + Math.imul(al2, bh4) | 0;
    mid = mid + Math.imul(ah2, bl4) | 0;
    hi = hi + Math.imul(ah2, bh4) | 0;
    lo = lo + Math.imul(al1, bl5) | 0;
    mid = mid + Math.imul(al1, bh5) | 0;
    mid = mid + Math.imul(ah1, bl5) | 0;
    hi = hi + Math.imul(ah1, bh5) | 0;
    lo = lo + Math.imul(al0, bl6) | 0;
    mid = mid + Math.imul(al0, bh6) | 0;
    mid = mid + Math.imul(ah0, bl6) | 0;
    hi = hi + Math.imul(ah0, bh6) | 0;
    var w6 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
    w6 &= 0x3ffffff;
    /* k = 7 */
    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = mid + Math.imul(ah7, bl0) | 0;
    hi = Math.imul(ah7, bh0);
    lo = lo + Math.imul(al6, bl1) | 0;
    mid = mid + Math.imul(al6, bh1) | 0;
    mid = mid + Math.imul(ah6, bl1) | 0;
    hi = hi + Math.imul(ah6, bh1) | 0;
    lo = lo + Math.imul(al5, bl2) | 0;
    mid = mid + Math.imul(al5, bh2) | 0;
    mid = mid + Math.imul(ah5, bl2) | 0;
    hi = hi + Math.imul(ah5, bh2) | 0;
    lo = lo + Math.imul(al4, bl3) | 0;
    mid = mid + Math.imul(al4, bh3) | 0;
    mid = mid + Math.imul(ah4, bl3) | 0;
    hi = hi + Math.imul(ah4, bh3) | 0;
    lo = lo + Math.imul(al3, bl4) | 0;
    mid = mid + Math.imul(al3, bh4) | 0;
    mid = mid + Math.imul(ah3, bl4) | 0;
    hi = hi + Math.imul(ah3, bh4) | 0;
    lo = lo + Math.imul(al2, bl5) | 0;
    mid = mid + Math.imul(al2, bh5) | 0;
    mid = mid + Math.imul(ah2, bl5) | 0;
    hi = hi + Math.imul(ah2, bh5) | 0;
    lo = lo + Math.imul(al1, bl6) | 0;
    mid = mid + Math.imul(al1, bh6) | 0;
    mid = mid + Math.imul(ah1, bl6) | 0;
    hi = hi + Math.imul(ah1, bh6) | 0;
    lo = lo + Math.imul(al0, bl7) | 0;
    mid = mid + Math.imul(al0, bh7) | 0;
    mid = mid + Math.imul(ah0, bl7) | 0;
    hi = hi + Math.imul(ah0, bh7) | 0;
    var w7 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
    w7 &= 0x3ffffff;
    /* k = 8 */
    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = mid + Math.imul(ah8, bl0) | 0;
    hi = Math.imul(ah8, bh0);
    lo = lo + Math.imul(al7, bl1) | 0;
    mid = mid + Math.imul(al7, bh1) | 0;
    mid = mid + Math.imul(ah7, bl1) | 0;
    hi = hi + Math.imul(ah7, bh1) | 0;
    lo = lo + Math.imul(al6, bl2) | 0;
    mid = mid + Math.imul(al6, bh2) | 0;
    mid = mid + Math.imul(ah6, bl2) | 0;
    hi = hi + Math.imul(ah6, bh2) | 0;
    lo = lo + Math.imul(al5, bl3) | 0;
    mid = mid + Math.imul(al5, bh3) | 0;
    mid = mid + Math.imul(ah5, bl3) | 0;
    hi = hi + Math.imul(ah5, bh3) | 0;
    lo = lo + Math.imul(al4, bl4) | 0;
    mid = mid + Math.imul(al4, bh4) | 0;
    mid = mid + Math.imul(ah4, bl4) | 0;
    hi = hi + Math.imul(ah4, bh4) | 0;
    lo = lo + Math.imul(al3, bl5) | 0;
    mid = mid + Math.imul(al3, bh5) | 0;
    mid = mid + Math.imul(ah3, bl5) | 0;
    hi = hi + Math.imul(ah3, bh5) | 0;
    lo = lo + Math.imul(al2, bl6) | 0;
    mid = mid + Math.imul(al2, bh6) | 0;
    mid = mid + Math.imul(ah2, bl6) | 0;
    hi = hi + Math.imul(ah2, bh6) | 0;
    lo = lo + Math.imul(al1, bl7) | 0;
    mid = mid + Math.imul(al1, bh7) | 0;
    mid = mid + Math.imul(ah1, bl7) | 0;
    hi = hi + Math.imul(ah1, bh7) | 0;
    lo = lo + Math.imul(al0, bl8) | 0;
    mid = mid + Math.imul(al0, bh8) | 0;
    mid = mid + Math.imul(ah0, bl8) | 0;
    hi = hi + Math.imul(ah0, bh8) | 0;
    var w8 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
    w8 &= 0x3ffffff;
    /* k = 9 */
    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = mid + Math.imul(ah9, bl0) | 0;
    hi = Math.imul(ah9, bh0);
    lo = lo + Math.imul(al8, bl1) | 0;
    mid = mid + Math.imul(al8, bh1) | 0;
    mid = mid + Math.imul(ah8, bl1) | 0;
    hi = hi + Math.imul(ah8, bh1) | 0;
    lo = lo + Math.imul(al7, bl2) | 0;
    mid = mid + Math.imul(al7, bh2) | 0;
    mid = mid + Math.imul(ah7, bl2) | 0;
    hi = hi + Math.imul(ah7, bh2) | 0;
    lo = lo + Math.imul(al6, bl3) | 0;
    mid = mid + Math.imul(al6, bh3) | 0;
    mid = mid + Math.imul(ah6, bl3) | 0;
    hi = hi + Math.imul(ah6, bh3) | 0;
    lo = lo + Math.imul(al5, bl4) | 0;
    mid = mid + Math.imul(al5, bh4) | 0;
    mid = mid + Math.imul(ah5, bl4) | 0;
    hi = hi + Math.imul(ah5, bh4) | 0;
    lo = lo + Math.imul(al4, bl5) | 0;
    mid = mid + Math.imul(al4, bh5) | 0;
    mid = mid + Math.imul(ah4, bl5) | 0;
    hi = hi + Math.imul(ah4, bh5) | 0;
    lo = lo + Math.imul(al3, bl6) | 0;
    mid = mid + Math.imul(al3, bh6) | 0;
    mid = mid + Math.imul(ah3, bl6) | 0;
    hi = hi + Math.imul(ah3, bh6) | 0;
    lo = lo + Math.imul(al2, bl7) | 0;
    mid = mid + Math.imul(al2, bh7) | 0;
    mid = mid + Math.imul(ah2, bl7) | 0;
    hi = hi + Math.imul(ah2, bh7) | 0;
    lo = lo + Math.imul(al1, bl8) | 0;
    mid = mid + Math.imul(al1, bh8) | 0;
    mid = mid + Math.imul(ah1, bl8) | 0;
    hi = hi + Math.imul(ah1, bh8) | 0;
    lo = lo + Math.imul(al0, bl9) | 0;
    mid = mid + Math.imul(al0, bh9) | 0;
    mid = mid + Math.imul(ah0, bl9) | 0;
    hi = hi + Math.imul(ah0, bh9) | 0;
    var w9 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
    w9 &= 0x3ffffff;
    /* k = 10 */
    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = mid + Math.imul(ah9, bl1) | 0;
    hi = Math.imul(ah9, bh1);
    lo = lo + Math.imul(al8, bl2) | 0;
    mid = mid + Math.imul(al8, bh2) | 0;
    mid = mid + Math.imul(ah8, bl2) | 0;
    hi = hi + Math.imul(ah8, bh2) | 0;
    lo = lo + Math.imul(al7, bl3) | 0;
    mid = mid + Math.imul(al7, bh3) | 0;
    mid = mid + Math.imul(ah7, bl3) | 0;
    hi = hi + Math.imul(ah7, bh3) | 0;
    lo = lo + Math.imul(al6, bl4) | 0;
    mid = mid + Math.imul(al6, bh4) | 0;
    mid = mid + Math.imul(ah6, bl4) | 0;
    hi = hi + Math.imul(ah6, bh4) | 0;
    lo = lo + Math.imul(al5, bl5) | 0;
    mid = mid + Math.imul(al5, bh5) | 0;
    mid = mid + Math.imul(ah5, bl5) | 0;
    hi = hi + Math.imul(ah5, bh5) | 0;
    lo = lo + Math.imul(al4, bl6) | 0;
    mid = mid + Math.imul(al4, bh6) | 0;
    mid = mid + Math.imul(ah4, bl6) | 0;
    hi = hi + Math.imul(ah4, bh6) | 0;
    lo = lo + Math.imul(al3, bl7) | 0;
    mid = mid + Math.imul(al3, bh7) | 0;
    mid = mid + Math.imul(ah3, bl7) | 0;
    hi = hi + Math.imul(ah3, bh7) | 0;
    lo = lo + Math.imul(al2, bl8) | 0;
    mid = mid + Math.imul(al2, bh8) | 0;
    mid = mid + Math.imul(ah2, bl8) | 0;
    hi = hi + Math.imul(ah2, bh8) | 0;
    lo = lo + Math.imul(al1, bl9) | 0;
    mid = mid + Math.imul(al1, bh9) | 0;
    mid = mid + Math.imul(ah1, bl9) | 0;
    hi = hi + Math.imul(ah1, bh9) | 0;
    var w10 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
    w10 &= 0x3ffffff;
    /* k = 11 */
    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = mid + Math.imul(ah9, bl2) | 0;
    hi = Math.imul(ah9, bh2);
    lo = lo + Math.imul(al8, bl3) | 0;
    mid = mid + Math.imul(al8, bh3) | 0;
    mid = mid + Math.imul(ah8, bl3) | 0;
    hi = hi + Math.imul(ah8, bh3) | 0;
    lo = lo + Math.imul(al7, bl4) | 0;
    mid = mid + Math.imul(al7, bh4) | 0;
    mid = mid + Math.imul(ah7, bl4) | 0;
    hi = hi + Math.imul(ah7, bh4) | 0;
    lo = lo + Math.imul(al6, bl5) | 0;
    mid = mid + Math.imul(al6, bh5) | 0;
    mid = mid + Math.imul(ah6, bl5) | 0;
    hi = hi + Math.imul(ah6, bh5) | 0;
    lo = lo + Math.imul(al5, bl6) | 0;
    mid = mid + Math.imul(al5, bh6) | 0;
    mid = mid + Math.imul(ah5, bl6) | 0;
    hi = hi + Math.imul(ah5, bh6) | 0;
    lo = lo + Math.imul(al4, bl7) | 0;
    mid = mid + Math.imul(al4, bh7) | 0;
    mid = mid + Math.imul(ah4, bl7) | 0;
    hi = hi + Math.imul(ah4, bh7) | 0;
    lo = lo + Math.imul(al3, bl8) | 0;
    mid = mid + Math.imul(al3, bh8) | 0;
    mid = mid + Math.imul(ah3, bl8) | 0;
    hi = hi + Math.imul(ah3, bh8) | 0;
    lo = lo + Math.imul(al2, bl9) | 0;
    mid = mid + Math.imul(al2, bh9) | 0;
    mid = mid + Math.imul(ah2, bl9) | 0;
    hi = hi + Math.imul(ah2, bh9) | 0;
    var w11 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
    w11 &= 0x3ffffff;
    /* k = 12 */
    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = mid + Math.imul(ah9, bl3) | 0;
    hi = Math.imul(ah9, bh3);
    lo = lo + Math.imul(al8, bl4) | 0;
    mid = mid + Math.imul(al8, bh4) | 0;
    mid = mid + Math.imul(ah8, bl4) | 0;
    hi = hi + Math.imul(ah8, bh4) | 0;
    lo = lo + Math.imul(al7, bl5) | 0;
    mid = mid + Math.imul(al7, bh5) | 0;
    mid = mid + Math.imul(ah7, bl5) | 0;
    hi = hi + Math.imul(ah7, bh5) | 0;
    lo = lo + Math.imul(al6, bl6) | 0;
    mid = mid + Math.imul(al6, bh6) | 0;
    mid = mid + Math.imul(ah6, bl6) | 0;
    hi = hi + Math.imul(ah6, bh6) | 0;
    lo = lo + Math.imul(al5, bl7) | 0;
    mid = mid + Math.imul(al5, bh7) | 0;
    mid = mid + Math.imul(ah5, bl7) | 0;
    hi = hi + Math.imul(ah5, bh7) | 0;
    lo = lo + Math.imul(al4, bl8) | 0;
    mid = mid + Math.imul(al4, bh8) | 0;
    mid = mid + Math.imul(ah4, bl8) | 0;
    hi = hi + Math.imul(ah4, bh8) | 0;
    lo = lo + Math.imul(al3, bl9) | 0;
    mid = mid + Math.imul(al3, bh9) | 0;
    mid = mid + Math.imul(ah3, bl9) | 0;
    hi = hi + Math.imul(ah3, bh9) | 0;
    var w12 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
    w12 &= 0x3ffffff;
    /* k = 13 */
    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = mid + Math.imul(ah9, bl4) | 0;
    hi = Math.imul(ah9, bh4);
    lo = lo + Math.imul(al8, bl5) | 0;
    mid = mid + Math.imul(al8, bh5) | 0;
    mid = mid + Math.imul(ah8, bl5) | 0;
    hi = hi + Math.imul(ah8, bh5) | 0;
    lo = lo + Math.imul(al7, bl6) | 0;
    mid = mid + Math.imul(al7, bh6) | 0;
    mid = mid + Math.imul(ah7, bl6) | 0;
    hi = hi + Math.imul(ah7, bh6) | 0;
    lo = lo + Math.imul(al6, bl7) | 0;
    mid = mid + Math.imul(al6, bh7) | 0;
    mid = mid + Math.imul(ah6, bl7) | 0;
    hi = hi + Math.imul(ah6, bh7) | 0;
    lo = lo + Math.imul(al5, bl8) | 0;
    mid = mid + Math.imul(al5, bh8) | 0;
    mid = mid + Math.imul(ah5, bl8) | 0;
    hi = hi + Math.imul(ah5, bh8) | 0;
    lo = lo + Math.imul(al4, bl9) | 0;
    mid = mid + Math.imul(al4, bh9) | 0;
    mid = mid + Math.imul(ah4, bl9) | 0;
    hi = hi + Math.imul(ah4, bh9) | 0;
    var w13 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
    w13 &= 0x3ffffff;
    /* k = 14 */
    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = mid + Math.imul(ah9, bl5) | 0;
    hi = Math.imul(ah9, bh5);
    lo = lo + Math.imul(al8, bl6) | 0;
    mid = mid + Math.imul(al8, bh6) | 0;
    mid = mid + Math.imul(ah8, bl6) | 0;
    hi = hi + Math.imul(ah8, bh6) | 0;
    lo = lo + Math.imul(al7, bl7) | 0;
    mid = mid + Math.imul(al7, bh7) | 0;
    mid = mid + Math.imul(ah7, bl7) | 0;
    hi = hi + Math.imul(ah7, bh7) | 0;
    lo = lo + Math.imul(al6, bl8) | 0;
    mid = mid + Math.imul(al6, bh8) | 0;
    mid = mid + Math.imul(ah6, bl8) | 0;
    hi = hi + Math.imul(ah6, bh8) | 0;
    lo = lo + Math.imul(al5, bl9) | 0;
    mid = mid + Math.imul(al5, bh9) | 0;
    mid = mid + Math.imul(ah5, bl9) | 0;
    hi = hi + Math.imul(ah5, bh9) | 0;
    var w14 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
    w14 &= 0x3ffffff;
    /* k = 15 */
    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = mid + Math.imul(ah9, bl6) | 0;
    hi = Math.imul(ah9, bh6);
    lo = lo + Math.imul(al8, bl7) | 0;
    mid = mid + Math.imul(al8, bh7) | 0;
    mid = mid + Math.imul(ah8, bl7) | 0;
    hi = hi + Math.imul(ah8, bh7) | 0;
    lo = lo + Math.imul(al7, bl8) | 0;
    mid = mid + Math.imul(al7, bh8) | 0;
    mid = mid + Math.imul(ah7, bl8) | 0;
    hi = hi + Math.imul(ah7, bh8) | 0;
    lo = lo + Math.imul(al6, bl9) | 0;
    mid = mid + Math.imul(al6, bh9) | 0;
    mid = mid + Math.imul(ah6, bl9) | 0;
    hi = hi + Math.imul(ah6, bh9) | 0;
    var w15 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
    w15 &= 0x3ffffff;
    /* k = 16 */
    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = mid + Math.imul(ah9, bl7) | 0;
    hi = Math.imul(ah9, bh7);
    lo = lo + Math.imul(al8, bl8) | 0;
    mid = mid + Math.imul(al8, bh8) | 0;
    mid = mid + Math.imul(ah8, bl8) | 0;
    hi = hi + Math.imul(ah8, bh8) | 0;
    lo = lo + Math.imul(al7, bl9) | 0;
    mid = mid + Math.imul(al7, bh9) | 0;
    mid = mid + Math.imul(ah7, bl9) | 0;
    hi = hi + Math.imul(ah7, bh9) | 0;
    var w16 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
    w16 &= 0x3ffffff;
    /* k = 17 */
    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = mid + Math.imul(ah9, bl8) | 0;
    hi = Math.imul(ah9, bh8);
    lo = lo + Math.imul(al8, bl9) | 0;
    mid = mid + Math.imul(al8, bh9) | 0;
    mid = mid + Math.imul(ah8, bl9) | 0;
    hi = hi + Math.imul(ah8, bh9) | 0;
    var w17 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
    w17 &= 0x3ffffff;
    /* k = 18 */
    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = mid + Math.imul(ah9, bl9) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;
    if (c !== 0) {
      o[19] = c;
      out.length++;
    }
    return out;
  };

  // Polyfill comb
  if (!Math.imul) {
    comb10MulTo = smallMulTo;
  }
  function bigMulTo(self, num, out) {
    out.negative = num.negative ^ self.negative;
    out.length = self.length + num.length;
    var carry = 0;
    var hncarry = 0;
    for (var k = 0; k < out.length - 1; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = hncarry;
      hncarry = 0;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j;
        var a = self.words[i] | 0;
        var b = num.words[j] | 0;
        var r = a * b;
        var lo = r & 0x3ffffff;
        ncarry = ncarry + (r / 0x4000000 | 0) | 0;
        lo = lo + rword | 0;
        rword = lo & 0x3ffffff;
        ncarry = ncarry + (lo >>> 26) | 0;
        hncarry += ncarry >>> 26;
        ncarry &= 0x3ffffff;
      }
      out.words[k] = rword;
      carry = ncarry;
      ncarry = hncarry;
    }
    if (carry !== 0) {
      out.words[k] = carry;
    } else {
      out.length--;
    }
    return out._strip();
  }
  function jumboMulTo(self, num, out) {
    // Temporary disable, see https://github.com/indutny/bn.js/issues/211
    // var fftm = new FFTM();
    // return fftm.mulp(self, num, out);
    return bigMulTo(self, num, out);
  }
  BN.prototype.mulTo = function mulTo(num, out) {
    var res;
    var len = this.length + num.length;
    if (this.length === 10 && num.length === 10) {
      res = comb10MulTo(this, num, out);
    } else if (len < 63) {
      res = smallMulTo(this, num, out);
    } else if (len < 1024) {
      res = bigMulTo(this, num, out);
    } else {
      res = jumboMulTo(this, num, out);
    }
    return res;
  };

  // Cooley-Tukey algorithm for FFT
  // slightly revisited to rely on looping instead of recursion

  function FFTM(x, y) {
    this.x = x;
    this.y = y;
  }
  FFTM.prototype.makeRBT = function makeRBT(N) {
    var t = new Array(N);
    var l = BN.prototype._countBits(N) - 1;
    for (var i = 0; i < N; i++) {
      t[i] = this.revBin(i, l, N);
    }
    return t;
  };

  // Returns binary-reversed representation of `x`
  FFTM.prototype.revBin = function revBin(x, l, N) {
    if (x === 0 || x === N - 1) return x;
    var rb = 0;
    for (var i = 0; i < l; i++) {
      rb |= (x & 1) << l - i - 1;
      x >>= 1;
    }
    return rb;
  };

  // Performs "tweedling" phase, therefore 'emulating'
  // behaviour of the recursive algorithm
  FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
    for (var i = 0; i < N; i++) {
      rtws[i] = rws[rbt[i]];
      itws[i] = iws[rbt[i]];
    }
  };
  FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);
    for (var s = 1; s < N; s <<= 1) {
      var l = s << 1;
      var rtwdf = Math.cos(2 * Math.PI / l);
      var itwdf = Math.sin(2 * Math.PI / l);
      for (var p = 0; p < N; p += l) {
        var rtwdf_ = rtwdf;
        var itwdf_ = itwdf;
        for (var j = 0; j < s; j++) {
          var re = rtws[p + j];
          var ie = itws[p + j];
          var ro = rtws[p + j + s];
          var io = itws[p + j + s];
          var rx = rtwdf_ * ro - itwdf_ * io;
          io = rtwdf_ * io + itwdf_ * ro;
          ro = rx;
          rtws[p + j] = re + ro;
          itws[p + j] = ie + io;
          rtws[p + j + s] = re - ro;
          itws[p + j + s] = ie - io;

          /* jshint maxdepth : false */
          if (j !== l) {
            rx = rtwdf * rtwdf_ - itwdf * itwdf_;
            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
            rtwdf_ = rx;
          }
        }
      }
    }
  };
  FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
    var N = Math.max(m, n) | 1;
    var odd = N & 1;
    var i = 0;
    for (N = N / 2 | 0; N; N = N >>> 1) {
      i++;
    }
    return 1 << i + 1 + odd;
  };
  FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
    if (N <= 1) return;
    for (var i = 0; i < N / 2; i++) {
      var t = rws[i];
      rws[i] = rws[N - i - 1];
      rws[N - i - 1] = t;
      t = iws[i];
      iws[i] = -iws[N - i - 1];
      iws[N - i - 1] = -t;
    }
  };
  FFTM.prototype.normalize13b = function normalize13b(ws, N) {
    var carry = 0;
    for (var i = 0; i < N / 2; i++) {
      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 + Math.round(ws[2 * i] / N) + carry;
      ws[i] = w & 0x3ffffff;
      if (w < 0x4000000) {
        carry = 0;
      } else {
        carry = w / 0x4000000 | 0;
      }
    }
    return ws;
  };
  FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
    var carry = 0;
    for (var i = 0; i < len; i++) {
      carry = carry + (ws[i] | 0);
      rws[2 * i] = carry & 0x1fff;
      carry = carry >>> 13;
      rws[2 * i + 1] = carry & 0x1fff;
      carry = carry >>> 13;
    }

    // Pad with zeroes
    for (i = 2 * len; i < N; ++i) {
      rws[i] = 0;
    }
    assert(carry === 0);
    assert((carry & ~0x1fff) === 0);
  };
  FFTM.prototype.stub = function stub(N) {
    var ph = new Array(N);
    for (var i = 0; i < N; i++) {
      ph[i] = 0;
    }
    return ph;
  };
  FFTM.prototype.mulp = function mulp(x, y, out) {
    var N = 2 * this.guessLen13b(x.length, y.length);
    var rbt = this.makeRBT(N);
    var _ = this.stub(N);
    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);
    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);
    var rmws = out.words;
    rmws.length = N;
    this.convert13b(x.words, x.length, rws, N);
    this.convert13b(y.words, y.length, nrws, N);
    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);
    for (var i = 0; i < N; i++) {
      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
      rwst[i] = rx;
    }
    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);
    out.negative = x.negative ^ y.negative;
    out.length = x.length + y.length;
    return out._strip();
  };

  // Multiply `this` by `num`
  BN.prototype.mul = function mul(num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
  };

  // Multiply employing FFT
  BN.prototype.mulf = function mulf(num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
  };

  // In-place Multiplication
  BN.prototype.imul = function imul(num) {
    return this.clone().mulTo(num, this);
  };
  BN.prototype.imuln = function imuln(num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;
    assert(typeof num === 'number');
    assert(num < 0x4000000);

    // Carry
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = (this.words[i] | 0) * num;
      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
      carry >>= 26;
      carry += w / 0x4000000 | 0;
      // NOTE: lo is 27bit maximum
      carry += lo >>> 26;
      this.words[i] = lo & 0x3ffffff;
    }
    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    return isNegNum ? this.ineg() : this;
  };
  BN.prototype.muln = function muln(num) {
    return this.clone().imuln(num);
  };

  // `this` * `this`
  BN.prototype.sqr = function sqr() {
    return this.mul(this);
  };

  // `this` * `this` in-place
  BN.prototype.isqr = function isqr() {
    return this.imul(this.clone());
  };

  // Math.pow(`this`, `num`)
  BN.prototype.pow = function pow(num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1);

    // Skip leading zeroes
    var res = this;
    for (var i = 0; i < w.length; i++, res = res.sqr()) {
      if (w[i] !== 0) break;
    }
    if (++i < w.length) {
      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
        if (w[i] === 0) continue;
        res = res.mul(q);
      }
    }
    return res;
  };

  // Shift-left in-place
  BN.prototype.iushln = function iushln(bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = 0x3ffffff >>> 26 - r << 26 - r;
    var i;
    if (r !== 0) {
      var carry = 0;
      for (i = 0; i < this.length; i++) {
        var newCarry = this.words[i] & carryMask;
        var c = (this.words[i] | 0) - newCarry << r;
        this.words[i] = c | carry;
        carry = newCarry >>> 26 - r;
      }
      if (carry) {
        this.words[i] = carry;
        this.length++;
      }
    }
    if (s !== 0) {
      for (i = this.length - 1; i >= 0; i--) {
        this.words[i + s] = this.words[i];
      }
      for (i = 0; i < s; i++) {
        this.words[i] = 0;
      }
      this.length += s;
    }
    return this._strip();
  };
  BN.prototype.ishln = function ishln(bits) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushln(bits);
  };

  // Shift-right in-place
  // NOTE: `hint` is a lowest bit before trailing zeroes
  // NOTE: if `extended` is present - it will be filled with destroyed bits
  BN.prototype.iushrn = function iushrn(bits, hint, extended) {
    assert(typeof bits === 'number' && bits >= 0);
    var h;
    if (hint) {
      h = (hint - hint % 26) / 26;
    } else {
      h = 0;
    }
    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ 0x3ffffff >>> r << r;
    var maskedWords = extended;
    h -= s;
    h = Math.max(0, h);

    // Extended mode, copy masked part
    if (maskedWords) {
      for (var i = 0; i < s; i++) {
        maskedWords.words[i] = this.words[i];
      }
      maskedWords.length = s;
    }
    if (s === 0) {
      // No-op, we should not move anything at all
    } else if (this.length > s) {
      this.length -= s;
      for (i = 0; i < this.length; i++) {
        this.words[i] = this.words[i + s];
      }
    } else {
      this.words[0] = 0;
      this.length = 1;
    }
    var carry = 0;
    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
      var word = this.words[i] | 0;
      this.words[i] = carry << 26 - r | word >>> r;
      carry = word & mask;
    }

    // Push carried bits as a mask
    if (maskedWords && carry !== 0) {
      maskedWords.words[maskedWords.length++] = carry;
    }
    if (this.length === 0) {
      this.words[0] = 0;
      this.length = 1;
    }
    return this._strip();
  };
  BN.prototype.ishrn = function ishrn(bits, hint, extended) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushrn(bits, hint, extended);
  };

  // Shift-left
  BN.prototype.shln = function shln(bits) {
    return this.clone().ishln(bits);
  };
  BN.prototype.ushln = function ushln(bits) {
    return this.clone().iushln(bits);
  };

  // Shift-right
  BN.prototype.shrn = function shrn(bits) {
    return this.clone().ishrn(bits);
  };
  BN.prototype.ushrn = function ushrn(bits) {
    return this.clone().iushrn(bits);
  };

  // Test if n bit is set
  BN.prototype.testn = function testn(bit) {
    assert(typeof bit === 'number' && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) return false;

    // Check bit and return
    var w = this.words[s];
    return !!(w & q);
  };

  // Return only lowers bits of number (in-place)
  BN.prototype.imaskn = function imaskn(bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    assert(this.negative === 0, 'imaskn works only with positive numbers');
    if (this.length <= s) {
      return this;
    }
    if (r !== 0) {
      s++;
    }
    this.length = Math.min(s, this.length);
    if (r !== 0) {
      var mask = 0x3ffffff ^ 0x3ffffff >>> r << r;
      this.words[this.length - 1] &= mask;
    }
    return this._strip();
  };

  // Return only lowers bits of number
  BN.prototype.maskn = function maskn(bits) {
    return this.clone().imaskn(bits);
  };

  // Add plain number `num` to `this`
  BN.prototype.iaddn = function iaddn(num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.isubn(-num);

    // Possible sign change
    if (this.negative !== 0) {
      if (this.length === 1 && (this.words[0] | 0) <= num) {
        this.words[0] = num - (this.words[0] | 0);
        this.negative = 0;
        return this;
      }
      this.negative = 0;
      this.isubn(num);
      this.negative = 1;
      return this;
    }

    // Add without checks
    return this._iaddn(num);
  };
  BN.prototype._iaddn = function _iaddn(num) {
    this.words[0] += num;

    // Carry
    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
      this.words[i] -= 0x4000000;
      if (i === this.length - 1) {
        this.words[i + 1] = 1;
      } else {
        this.words[i + 1]++;
      }
    }
    this.length = Math.max(this.length, i + 1);
    return this;
  };

  // Subtract plain number `num` from `this`
  BN.prototype.isubn = function isubn(num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);
    if (this.negative !== 0) {
      this.negative = 0;
      this.iaddn(num);
      this.negative = 1;
      return this;
    }
    this.words[0] -= num;
    if (this.length === 1 && this.words[0] < 0) {
      this.words[0] = -this.words[0];
      this.negative = 1;
    } else {
      // Carry
      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
        this.words[i] += 0x4000000;
        this.words[i + 1] -= 1;
      }
    }
    return this._strip();
  };
  BN.prototype.addn = function addn(num) {
    return this.clone().iaddn(num);
  };
  BN.prototype.subn = function subn(num) {
    return this.clone().isubn(num);
  };
  BN.prototype.iabs = function iabs() {
    this.negative = 0;
    return this;
  };
  BN.prototype.abs = function abs() {
    return this.clone().iabs();
  };
  BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
    var len = num.length + shift;
    var i;
    this._expand(len);
    var w;
    var carry = 0;
    for (i = 0; i < num.length; i++) {
      w = (this.words[i + shift] | 0) + carry;
      var right = (num.words[i] | 0) * mul;
      w -= right & 0x3ffffff;
      carry = (w >> 26) - (right / 0x4000000 | 0);
      this.words[i + shift] = w & 0x3ffffff;
    }
    for (; i < this.length - shift; i++) {
      w = (this.words[i + shift] | 0) + carry;
      carry = w >> 26;
      this.words[i + shift] = w & 0x3ffffff;
    }
    if (carry === 0) return this._strip();

    // Subtraction overflow
    assert(carry === -1);
    carry = 0;
    for (i = 0; i < this.length; i++) {
      w = -(this.words[i] | 0) + carry;
      carry = w >> 26;
      this.words[i] = w & 0x3ffffff;
    }
    this.negative = 1;
    return this._strip();
  };
  BN.prototype._wordDiv = function _wordDiv(num, mode) {
    var shift = this.length - num.length;
    var a = this.clone();
    var b = num;

    // Normalize
    var bhi = b.words[b.length - 1] | 0;
    var bhiBits = this._countBits(bhi);
    shift = 26 - bhiBits;
    if (shift !== 0) {
      b = b.ushln(shift);
      a.iushln(shift);
      bhi = b.words[b.length - 1] | 0;
    }

    // Initialize quotient
    var m = a.length - b.length;
    var q;
    if (mode !== 'mod') {
      q = new BN(null);
      q.length = m + 1;
      q.words = new Array(q.length);
      for (var i = 0; i < q.length; i++) {
        q.words[i] = 0;
      }
    }
    var diff = a.clone()._ishlnsubmul(b, 1, m);
    if (diff.negative === 0) {
      a = diff;
      if (q) {
        q.words[m] = 1;
      }
    }
    for (var j = m - 1; j >= 0; j--) {
      var qj = (a.words[b.length + j] | 0) * 0x4000000 + (a.words[b.length + j - 1] | 0);

      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
      // (0x7ffffff)
      qj = Math.min(qj / bhi | 0, 0x3ffffff);
      a._ishlnsubmul(b, qj, j);
      while (a.negative !== 0) {
        qj--;
        a.negative = 0;
        a._ishlnsubmul(b, 1, j);
        if (!a.isZero()) {
          a.negative ^= 1;
        }
      }
      if (q) {
        q.words[j] = qj;
      }
    }
    if (q) {
      q._strip();
    }
    a._strip();

    // Denormalize
    if (mode !== 'div' && shift !== 0) {
      a.iushrn(shift);
    }
    return {
      div: q || null,
      mod: a
    };
  };

  // NOTE: 1) `mode` can be set to `mod` to request mod only,
  //       to `div` to request div only, or be absent to
  //       request both div & mod
  //       2) `positive` is true if unsigned mod is requested
  BN.prototype.divmod = function divmod(num, mode, positive) {
    assert(!num.isZero());
    if (this.isZero()) {
      return {
        div: new BN(0),
        mod: new BN(0)
      };
    }
    var div, mod, res;
    if (this.negative !== 0 && num.negative === 0) {
      res = this.neg().divmod(num, mode);
      if (mode !== 'mod') {
        div = res.div.neg();
      }
      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.iadd(num);
        }
      }
      return {
        div: div,
        mod: mod
      };
    }
    if (this.negative === 0 && num.negative !== 0) {
      res = this.divmod(num.neg(), mode);
      if (mode !== 'mod') {
        div = res.div.neg();
      }
      return {
        div: div,
        mod: res.mod
      };
    }
    if ((this.negative & num.negative) !== 0) {
      res = this.neg().divmod(num.neg(), mode);
      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.isub(num);
        }
      }
      return {
        div: res.div,
        mod: mod
      };
    }

    // Both numbers are positive at this point

    // Strip both numbers to approximate shift value
    if (num.length > this.length || this.cmp(num) < 0) {
      return {
        div: new BN(0),
        mod: this
      };
    }

    // Very short reduction
    if (num.length === 1) {
      if (mode === 'div') {
        return {
          div: this.divn(num.words[0]),
          mod: null
        };
      }
      if (mode === 'mod') {
        return {
          div: null,
          mod: new BN(this.modrn(num.words[0]))
        };
      }
      return {
        div: this.divn(num.words[0]),
        mod: new BN(this.modrn(num.words[0]))
      };
    }
    return this._wordDiv(num, mode);
  };

  // Find `this` / `num`
  BN.prototype.div = function div(num) {
    return this.divmod(num, 'div', false).div;
  };

  // Find `this` % `num`
  BN.prototype.mod = function mod(num) {
    return this.divmod(num, 'mod', false).mod;
  };
  BN.prototype.umod = function umod(num) {
    return this.divmod(num, 'mod', true).mod;
  };

  // Find Round(`this` / `num`)
  BN.prototype.divRound = function divRound(num) {
    var dm = this.divmod(num);

    // Fast case - exact division
    if (dm.mod.isZero()) return dm.div;
    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod.cmp(half);

    // Round down
    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;

    // Round up
    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
  };
  BN.prototype.modrn = function modrn(num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;
    assert(num <= 0x3ffffff);
    var p = (1 << 26) % num;
    var acc = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      acc = (p * acc + (this.words[i] | 0)) % num;
    }
    return isNegNum ? -acc : acc;
  };

  // WARNING: DEPRECATED
  BN.prototype.modn = function modn(num) {
    return this.modrn(num);
  };

  // In-place division by number
  BN.prototype.idivn = function idivn(num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;
    assert(num <= 0x3ffffff);
    var carry = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var w = (this.words[i] | 0) + carry * 0x4000000;
      this.words[i] = w / num | 0;
      carry = w % num;
    }
    this._strip();
    return isNegNum ? this.ineg() : this;
  };
  BN.prototype.divn = function divn(num) {
    return this.clone().idivn(num);
  };
  BN.prototype.egcd = function egcd(p) {
    assert(p.negative === 0);
    assert(!p.isZero());
    var x = this;
    var y = p.clone();
    if (x.negative !== 0) {
      x = x.umod(p);
    } else {
      x = x.clone();
    }

    // A * x + B * y = x
    var A = new BN(1);
    var B = new BN(0);

    // C * x + D * y = y
    var C = new BN(0);
    var D = new BN(1);
    var g = 0;
    while (x.isEven() && y.isEven()) {
      x.iushrn(1);
      y.iushrn(1);
      ++g;
    }
    var yp = y.clone();
    var xp = x.clone();
    while (!x.isZero()) {
      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        x.iushrn(i);
        while (i-- > 0) {
          if (A.isOdd() || B.isOdd()) {
            A.iadd(yp);
            B.isub(xp);
          }
          A.iushrn(1);
          B.iushrn(1);
        }
      }
      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        y.iushrn(j);
        while (j-- > 0) {
          if (C.isOdd() || D.isOdd()) {
            C.iadd(yp);
            D.isub(xp);
          }
          C.iushrn(1);
          D.iushrn(1);
        }
      }
      if (x.cmp(y) >= 0) {
        x.isub(y);
        A.isub(C);
        B.isub(D);
      } else {
        y.isub(x);
        C.isub(A);
        D.isub(B);
      }
    }
    return {
      a: C,
      b: D,
      gcd: y.iushln(g)
    };
  };

  // This is reduced incarnation of the binary EEA
  // above, designated to invert members of the
  // _prime_ fields F(p) at a maximal speed
  BN.prototype._invmp = function _invmp(p) {
    assert(p.negative === 0);
    assert(!p.isZero());
    var a = this;
    var b = p.clone();
    if (a.negative !== 0) {
      a = a.umod(p);
    } else {
      a = a.clone();
    }
    var x1 = new BN(1);
    var x2 = new BN(0);
    var delta = b.clone();
    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        a.iushrn(i);
        while (i-- > 0) {
          if (x1.isOdd()) {
            x1.iadd(delta);
          }
          x1.iushrn(1);
        }
      }
      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        b.iushrn(j);
        while (j-- > 0) {
          if (x2.isOdd()) {
            x2.iadd(delta);
          }
          x2.iushrn(1);
        }
      }
      if (a.cmp(b) >= 0) {
        a.isub(b);
        x1.isub(x2);
      } else {
        b.isub(a);
        x2.isub(x1);
      }
    }
    var res;
    if (a.cmpn(1) === 0) {
      res = x1;
    } else {
      res = x2;
    }
    if (res.cmpn(0) < 0) {
      res.iadd(p);
    }
    return res;
  };
  BN.prototype.gcd = function gcd(num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();
    var a = this.clone();
    var b = num.clone();
    a.negative = 0;
    b.negative = 0;

    // Remove common factor of two
    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
      a.iushrn(1);
      b.iushrn(1);
    }
    do {
      while (a.isEven()) {
        a.iushrn(1);
      }
      while (b.isEven()) {
        b.iushrn(1);
      }
      var r = a.cmp(b);
      if (r < 0) {
        // Swap `a` and `b` to make `a` always bigger than `b`
        var t = a;
        a = b;
        b = t;
      } else if (r === 0 || b.cmpn(1) === 0) {
        break;
      }
      a.isub(b);
    } while (true);
    return b.iushln(shift);
  };

  // Invert number in the field F(num)
  BN.prototype.invm = function invm(num) {
    return this.egcd(num).a.umod(num);
  };
  BN.prototype.isEven = function isEven() {
    return (this.words[0] & 1) === 0;
  };
  BN.prototype.isOdd = function isOdd() {
    return (this.words[0] & 1) === 1;
  };

  // And first word and num
  BN.prototype.andln = function andln(num) {
    return this.words[0] & num;
  };

  // Increment at the bit position in-line
  BN.prototype.bincn = function bincn(bit) {
    assert(typeof bit === 'number');
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) {
      this._expand(s + 1);
      this.words[s] |= q;
      return this;
    }

    // Add bit and propagate, if needed
    var carry = q;
    for (var i = s; carry !== 0 && i < this.length; i++) {
      var w = this.words[i] | 0;
      w += carry;
      carry = w >>> 26;
      w &= 0x3ffffff;
      this.words[i] = w;
    }
    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    return this;
  };
  BN.prototype.isZero = function isZero() {
    return this.length === 1 && this.words[0] === 0;
  };
  BN.prototype.cmpn = function cmpn(num) {
    var negative = num < 0;
    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;
    this._strip();
    var res;
    if (this.length > 1) {
      res = 1;
    } else {
      if (negative) {
        num = -num;
      }
      assert(num <= 0x3ffffff, 'Number is too big');
      var w = this.words[0] | 0;
      res = w === num ? 0 : w < num ? -1 : 1;
    }
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Compare two numbers and return:
  // 1 - if `this` > `num`
  // 0 - if `this` == `num`
  // -1 - if `this` < `num`
  BN.prototype.cmp = function cmp(num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;
    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Unsigned comparison
  BN.prototype.ucmp = function ucmp(num) {
    // At this point both numbers have the same sign
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;
    var res = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var a = this.words[i] | 0;
      var b = num.words[i] | 0;
      if (a === b) continue;
      if (a < b) {
        res = -1;
      } else if (a > b) {
        res = 1;
      }
      break;
    }
    return res;
  };
  BN.prototype.gtn = function gtn(num) {
    return this.cmpn(num) === 1;
  };
  BN.prototype.gt = function gt(num) {
    return this.cmp(num) === 1;
  };
  BN.prototype.gten = function gten(num) {
    return this.cmpn(num) >= 0;
  };
  BN.prototype.gte = function gte(num) {
    return this.cmp(num) >= 0;
  };
  BN.prototype.ltn = function ltn(num) {
    return this.cmpn(num) === -1;
  };
  BN.prototype.lt = function lt(num) {
    return this.cmp(num) === -1;
  };
  BN.prototype.lten = function lten(num) {
    return this.cmpn(num) <= 0;
  };
  BN.prototype.lte = function lte(num) {
    return this.cmp(num) <= 0;
  };
  BN.prototype.eqn = function eqn(num) {
    return this.cmpn(num) === 0;
  };
  BN.prototype.eq = function eq(num) {
    return this.cmp(num) === 0;
  };

  //
  // A reduce context, could be using montgomery or something better, depending
  // on the `m` itself.
  //
  BN.red = function red(num) {
    return new Red(num);
  };
  BN.prototype.toRed = function toRed(ctx) {
    assert(!this.red, 'Already a number in reduction context');
    assert(this.negative === 0, 'red works only with positives');
    return ctx.convertTo(this)._forceRed(ctx);
  };
  BN.prototype.fromRed = function fromRed() {
    assert(this.red, 'fromRed works only with numbers in reduction context');
    return this.red.convertFrom(this);
  };
  BN.prototype._forceRed = function _forceRed(ctx) {
    this.red = ctx;
    return this;
  };
  BN.prototype.forceRed = function forceRed(ctx) {
    assert(!this.red, 'Already a number in reduction context');
    return this._forceRed(ctx);
  };
  BN.prototype.redAdd = function redAdd(num) {
    assert(this.red, 'redAdd works only with red numbers');
    return this.red.add(this, num);
  };
  BN.prototype.redIAdd = function redIAdd(num) {
    assert(this.red, 'redIAdd works only with red numbers');
    return this.red.iadd(this, num);
  };
  BN.prototype.redSub = function redSub(num) {
    assert(this.red, 'redSub works only with red numbers');
    return this.red.sub(this, num);
  };
  BN.prototype.redISub = function redISub(num) {
    assert(this.red, 'redISub works only with red numbers');
    return this.red.isub(this, num);
  };
  BN.prototype.redShl = function redShl(num) {
    assert(this.red, 'redShl works only with red numbers');
    return this.red.shl(this, num);
  };
  BN.prototype.redMul = function redMul(num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.mul(this, num);
  };
  BN.prototype.redIMul = function redIMul(num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.imul(this, num);
  };
  BN.prototype.redSqr = function redSqr() {
    assert(this.red, 'redSqr works only with red numbers');
    this.red._verify1(this);
    return this.red.sqr(this);
  };
  BN.prototype.redISqr = function redISqr() {
    assert(this.red, 'redISqr works only with red numbers');
    this.red._verify1(this);
    return this.red.isqr(this);
  };

  // Square root over p
  BN.prototype.redSqrt = function redSqrt() {
    assert(this.red, 'redSqrt works only with red numbers');
    this.red._verify1(this);
    return this.red.sqrt(this);
  };
  BN.prototype.redInvm = function redInvm() {
    assert(this.red, 'redInvm works only with red numbers');
    this.red._verify1(this);
    return this.red.invm(this);
  };

  // Return negative clone of `this` % `red modulo`
  BN.prototype.redNeg = function redNeg() {
    assert(this.red, 'redNeg works only with red numbers');
    this.red._verify1(this);
    return this.red.neg(this);
  };
  BN.prototype.redPow = function redPow(num) {
    assert(this.red && !num.red, 'redPow(normalNum)');
    this.red._verify1(this);
    return this.red.pow(this, num);
  };

  // Prime numbers with efficient reduction
  var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
  };

  // Pseudo-Mersenne prime
  function MPrime(name, p) {
    // P = 2 ^ N - K
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);
    this.tmp = this._tmp();
  }
  MPrime.prototype._tmp = function _tmp() {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
  };
  MPrime.prototype.ireduce = function ireduce(num) {
    // Assumes that `num` is less than `P^2`
    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
    var r = num;
    var rlen;
    do {
      this.split(r, this.tmp);
      r = this.imulK(r);
      r = r.iadd(this.tmp);
      rlen = r.bitLength();
    } while (rlen > this.n);
    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
    if (cmp === 0) {
      r.words[0] = 0;
      r.length = 1;
    } else if (cmp > 0) {
      r.isub(this.p);
    } else {
      if (r.strip !== undefined) {
        // r is a BN v4 instance
        r.strip();
      } else {
        // r is a BN v5 instance
        r._strip();
      }
    }
    return r;
  };
  MPrime.prototype.split = function split(input, out) {
    input.iushrn(this.n, 0, out);
  };
  MPrime.prototype.imulK = function imulK(num) {
    return num.imul(this.k);
  };
  function K256() {
    MPrime.call(this, 'k256', 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
  }
  inherits(K256, MPrime);
  K256.prototype.split = function split(input, output) {
    // 256 = 9 * 26 + 22
    var mask = 0x3fffff;
    var outLen = Math.min(input.length, 9);
    for (var i = 0; i < outLen; i++) {
      output.words[i] = input.words[i];
    }
    output.length = outLen;
    if (input.length <= 9) {
      input.words[0] = 0;
      input.length = 1;
      return;
    }

    // Shift by 9 limbs
    var prev = input.words[9];
    output.words[output.length++] = prev & mask;
    for (i = 10; i < input.length; i++) {
      var next = input.words[i] | 0;
      input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
      prev = next;
    }
    prev >>>= 22;
    input.words[i - 10] = prev;
    if (prev === 0 && input.length > 10) {
      input.length -= 10;
    } else {
      input.length -= 9;
    }
  };
  K256.prototype.imulK = function imulK(num) {
    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2;

    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
    var lo = 0;
    for (var i = 0; i < num.length; i++) {
      var w = num.words[i] | 0;
      lo += w * 0x3d1;
      num.words[i] = lo & 0x3ffffff;
      lo = w * 0x40 + (lo / 0x4000000 | 0);
    }

    // Fast length reduction
    if (num.words[num.length - 1] === 0) {
      num.length--;
      if (num.words[num.length - 1] === 0) {
        num.length--;
      }
    }
    return num;
  };
  function P224() {
    MPrime.call(this, 'p224', 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
  }
  inherits(P224, MPrime);
  function P192() {
    MPrime.call(this, 'p192', 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
  }
  inherits(P192, MPrime);
  function P25519() {
    // 2 ^ 255 - 19
    MPrime.call(this, '25519', '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
  }
  inherits(P25519, MPrime);
  P25519.prototype.imulK = function imulK(num) {
    // K = 0x13
    var carry = 0;
    for (var i = 0; i < num.length; i++) {
      var hi = (num.words[i] | 0) * 0x13 + carry;
      var lo = hi & 0x3ffffff;
      hi >>>= 26;
      num.words[i] = lo;
      carry = hi;
    }
    if (carry !== 0) {
      num.words[num.length++] = carry;
    }
    return num;
  };

  // Exported mostly for testing purposes, use plain name instead
  BN._prime = function prime(name) {
    // Cached version of prime
    if (primes[name]) return primes[name];
    var prime;
    if (name === 'k256') {
      prime = new K256();
    } else if (name === 'p224') {
      prime = new P224();
    } else if (name === 'p192') {
      prime = new P192();
    } else if (name === 'p25519') {
      prime = new P25519();
    } else {
      throw new Error('Unknown prime ' + name);
    }
    primes[name] = prime;
    return prime;
  };

  //
  // Base reduction engine
  //
  function Red(m) {
    if (typeof m === 'string') {
      var prime = BN._prime(m);
      this.m = prime.p;
      this.prime = prime;
    } else {
      assert(m.gtn(1), 'modulus must be greater than 1');
      this.m = m;
      this.prime = null;
    }
  }
  Red.prototype._verify1 = function _verify1(a) {
    assert(a.negative === 0, 'red works only with positives');
    assert(a.red, 'red works only with red numbers');
  };
  Red.prototype._verify2 = function _verify2(a, b) {
    assert((a.negative | b.negative) === 0, 'red works only with positives');
    assert(a.red && a.red === b.red, 'red works only with red numbers');
  };
  Red.prototype.imod = function imod(a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
    move(a, a.umod(this.m)._forceRed(this));
    return a;
  };
  Red.prototype.neg = function neg(a) {
    if (a.isZero()) {
      return a.clone();
    }
    return this.m.sub(a)._forceRed(this);
  };
  Red.prototype.add = function add(a, b) {
    this._verify2(a, b);
    var res = a.add(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res._forceRed(this);
  };
  Red.prototype.iadd = function iadd(a, b) {
    this._verify2(a, b);
    var res = a.iadd(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res;
  };
  Red.prototype.sub = function sub(a, b) {
    this._verify2(a, b);
    var res = a.sub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res._forceRed(this);
  };
  Red.prototype.isub = function isub(a, b) {
    this._verify2(a, b);
    var res = a.isub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res;
  };
  Red.prototype.shl = function shl(a, num) {
    this._verify1(a);
    return this.imod(a.ushln(num));
  };
  Red.prototype.imul = function imul(a, b) {
    this._verify2(a, b);
    return this.imod(a.imul(b));
  };
  Red.prototype.mul = function mul(a, b) {
    this._verify2(a, b);
    return this.imod(a.mul(b));
  };
  Red.prototype.isqr = function isqr(a) {
    return this.imul(a, a.clone());
  };
  Red.prototype.sqr = function sqr(a) {
    return this.mul(a, a);
  };
  Red.prototype.sqrt = function sqrt(a) {
    if (a.isZero()) return a.clone();
    var mod3 = this.m.andln(3);
    assert(mod3 % 2 === 1);

    // Fast case
    if (mod3 === 3) {
      var pow = this.m.add(new BN(1)).iushrn(2);
      return this.pow(a, pow);
    }

    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
    //
    // Find Q and S, that Q * 2 ^ S = (P - 1)
    var q = this.m.subn(1);
    var s = 0;
    while (!q.isZero() && q.andln(1) === 0) {
      s++;
      q.iushrn(1);
    }
    assert(!q.isZero());
    var one = new BN(1).toRed(this);
    var nOne = one.redNeg();

    // Find quadratic non-residue
    // NOTE: Max is such because of generalized Riemann hypothesis.
    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);
    while (this.pow(z, lpow).cmp(nOne) !== 0) {
      z.redIAdd(nOne);
    }
    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;
    while (t.cmp(one) !== 0) {
      var tmp = t;
      for (var i = 0; tmp.cmp(one) !== 0; i++) {
        tmp = tmp.redSqr();
      }
      assert(i < m);
      var b = this.pow(c, new BN(1).iushln(m - i - 1));
      r = r.redMul(b);
      c = b.redSqr();
      t = t.redMul(c);
      m = i;
    }
    return r;
  };
  Red.prototype.invm = function invm(a) {
    var inv = a._invmp(this.m);
    if (inv.negative !== 0) {
      inv.negative = 0;
      return this.imod(inv).redNeg();
    } else {
      return this.imod(inv);
    }
  };
  Red.prototype.pow = function pow(a, num) {
    if (num.isZero()) return new BN(1).toRed(this);
    if (num.cmpn(1) === 0) return a.clone();
    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;
    for (var i = 2; i < wnd.length; i++) {
      wnd[i] = this.mul(wnd[i - 1], a);
    }
    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;
    if (start === 0) {
      start = 26;
    }
    for (i = num.length - 1; i >= 0; i--) {
      var word = num.words[i];
      for (var j = start - 1; j >= 0; j--) {
        var bit = word >> j & 1;
        if (res !== wnd[0]) {
          res = this.sqr(res);
        }
        if (bit === 0 && current === 0) {
          currentLen = 0;
          continue;
        }
        current <<= 1;
        current |= bit;
        currentLen++;
        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;
        res = this.mul(res, wnd[current]);
        currentLen = 0;
        current = 0;
      }
      start = 26;
    }
    return res;
  };
  Red.prototype.convertTo = function convertTo(num) {
    var r = num.umod(this.m);
    return r === num ? r.clone() : r;
  };
  Red.prototype.convertFrom = function convertFrom(num) {
    var res = num.clone();
    res.red = null;
    return res;
  };

  //
  // Montgomery method engine
  //

  BN.mont = function mont(num) {
    return new Mont(num);
  };
  function Mont(m) {
    Red.call(this, m);
    this.shift = this.m.bitLength();
    if (this.shift % 26 !== 0) {
      this.shift += 26 - this.shift % 26;
    }
    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);
    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
  }
  inherits(Mont, Red);
  Mont.prototype.convertTo = function convertTo(num) {
    return this.imod(num.ushln(this.shift));
  };
  Mont.prototype.convertFrom = function convertFrom(num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
  };
  Mont.prototype.imul = function imul(a, b) {
    if (a.isZero() || b.isZero()) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }
    var t = a.imul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }
    return res._forceRed(this);
  };
  Mont.prototype.mul = function mul(a, b) {
    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);
    var t = a.mul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }
    return res._forceRed(this);
  };
  Mont.prototype.invm = function invm(a) {
    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
  };
})(typeof module === 'undefined' || module, void 0);

},{"buffer":105}],27:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.version = void 0;
exports.version = "bytes/5.7.0";

},{}],28:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.joinSignature = exports.splitSignature = exports.hexZeroPad = exports.hexStripZeros = exports.hexValue = exports.hexConcat = exports.hexDataSlice = exports.hexDataLength = exports.hexlify = exports.isHexString = exports.zeroPad = exports.stripZeros = exports.concat = exports.arrayify = exports.isBytes = exports.isBytesLike = void 0;
var logger_1 = require("@ethersproject/logger");
var _version_1 = require("./_version");
var logger = new logger_1.Logger(_version_1.version);
///////////////////////////////
function isHexable(value) {
  return !!value.toHexString;
}
function addSlice(array) {
  if (array.slice) {
    return array;
  }
  array.slice = function () {
    var args = Array.prototype.slice.call(arguments);
    return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));
  };
  return array;
}
function isBytesLike(value) {
  return isHexString(value) && !(value.length % 2) || isBytes(value);
}
exports.isBytesLike = isBytesLike;
function isInteger(value) {
  return typeof value === "number" && value == value && value % 1 === 0;
}
function isBytes(value) {
  if (value == null) {
    return false;
  }
  if (value.constructor === Uint8Array) {
    return true;
  }
  if (typeof value === "string") {
    return false;
  }
  if (!isInteger(value.length) || value.length < 0) {
    return false;
  }
  for (var i = 0; i < value.length; i++) {
    var v = value[i];
    if (!isInteger(v) || v < 0 || v >= 256) {
      return false;
    }
  }
  return true;
}
exports.isBytes = isBytes;
function arrayify(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger.checkSafeUint53(value, "invalid arrayify value");
    var result = [];
    while (value) {
      result.unshift(value & 0xff);
      value = parseInt(String(value / 256));
    }
    if (result.length === 0) {
      result.push(0);
    }
    return addSlice(new Uint8Array(result));
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable(value)) {
    value = value.toHexString();
  }
  if (isHexString(value)) {
    var hex = value.substring(2);
    if (hex.length % 2) {
      if (options.hexPad === "left") {
        hex = "0" + hex;
      } else if (options.hexPad === "right") {
        hex += "0";
      } else {
        logger.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    var result = [];
    for (var i = 0; i < hex.length; i += 2) {
      result.push(parseInt(hex.substring(i, i + 2), 16));
    }
    return addSlice(new Uint8Array(result));
  }
  if (isBytes(value)) {
    return addSlice(new Uint8Array(value));
  }
  return logger.throwArgumentError("invalid arrayify value", "value", value);
}
exports.arrayify = arrayify;
function concat(items) {
  var objects = items.map(function (item) {
    return arrayify(item);
  });
  var length = objects.reduce(function (accum, item) {
    return accum + item.length;
  }, 0);
  var result = new Uint8Array(length);
  objects.reduce(function (offset, object) {
    result.set(object, offset);
    return offset + object.length;
  }, 0);
  return addSlice(result);
}
exports.concat = concat;
function stripZeros(value) {
  var result = arrayify(value);
  if (result.length === 0) {
    return result;
  }
  // Find the first non-zero entry
  var start = 0;
  while (start < result.length && result[start] === 0) {
    start++;
  }
  // If we started with zeros, strip them
  if (start) {
    result = result.slice(start);
  }
  return result;
}
exports.stripZeros = stripZeros;
function zeroPad(value, length) {
  value = arrayify(value);
  if (value.length > length) {
    logger.throwArgumentError("value out of range", "value", arguments[0]);
  }
  var result = new Uint8Array(length);
  result.set(value, length - value.length);
  return addSlice(result);
}
exports.zeroPad = zeroPad;
function isHexString(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length && value.length !== 2 + 2 * length) {
    return false;
  }
  return true;
}
exports.isHexString = isHexString;
var HexCharacters = "0123456789abcdef";
function hexlify(value, options) {
  if (!options) {
    options = {};
  }
  if (typeof value === "number") {
    logger.checkSafeUint53(value, "invalid hexlify value");
    var hex = "";
    while (value) {
      hex = HexCharacters[value & 0xf] + hex;
      value = Math.floor(value / 16);
    }
    if (hex.length) {
      if (hex.length % 2) {
        hex = "0" + hex;
      }
      return "0x" + hex;
    }
    return "0x00";
  }
  if (typeof value === "bigint") {
    value = value.toString(16);
    if (value.length % 2) {
      return "0x0" + value;
    }
    return "0x" + value;
  }
  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }
  if (isHexable(value)) {
    return value.toHexString();
  }
  if (isHexString(value)) {
    if (value.length % 2) {
      if (options.hexPad === "left") {
        value = "0x0" + value.substring(2);
      } else if (options.hexPad === "right") {
        value += "0";
      } else {
        logger.throwArgumentError("hex data is odd-length", "value", value);
      }
    }
    return value.toLowerCase();
  }
  if (isBytes(value)) {
    var result = "0x";
    for (var i = 0; i < value.length; i++) {
      var v = value[i];
      result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];
    }
    return result;
  }
  return logger.throwArgumentError("invalid hexlify value", "value", value);
}
exports.hexlify = hexlify;
/*
function unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {
    if (typeof(value) === "string" && value.length % 2 && value.substring(0, 2) === "0x") {
        return "0x0" + value.substring(2);
    }
    return value;
}
*/
function hexDataLength(data) {
  if (typeof data !== "string") {
    data = hexlify(data);
  } else if (!isHexString(data) || data.length % 2) {
    return null;
  }
  return (data.length - 2) / 2;
}
exports.hexDataLength = hexDataLength;
function hexDataSlice(data, offset, endOffset) {
  if (typeof data !== "string") {
    data = hexlify(data);
  } else if (!isHexString(data) || data.length % 2) {
    logger.throwArgumentError("invalid hexData", "value", data);
  }
  offset = 2 + 2 * offset;
  if (endOffset != null) {
    return "0x" + data.substring(offset, 2 + 2 * endOffset);
  }
  return "0x" + data.substring(offset);
}
exports.hexDataSlice = hexDataSlice;
function hexConcat(items) {
  var result = "0x";
  items.forEach(function (item) {
    result += hexlify(item).substring(2);
  });
  return result;
}
exports.hexConcat = hexConcat;
function hexValue(value) {
  var trimmed = hexStripZeros(hexlify(value, {
    hexPad: "left"
  }));
  if (trimmed === "0x") {
    return "0x0";
  }
  return trimmed;
}
exports.hexValue = hexValue;
function hexStripZeros(value) {
  if (typeof value !== "string") {
    value = hexlify(value);
  }
  if (!isHexString(value)) {
    logger.throwArgumentError("invalid hex string", "value", value);
  }
  value = value.substring(2);
  var offset = 0;
  while (offset < value.length && value[offset] === "0") {
    offset++;
  }
  return "0x" + value.substring(offset);
}
exports.hexStripZeros = hexStripZeros;
function hexZeroPad(value, length) {
  if (typeof value !== "string") {
    value = hexlify(value);
  } else if (!isHexString(value)) {
    logger.throwArgumentError("invalid hex string", "value", value);
  }
  if (value.length > 2 * length + 2) {
    logger.throwArgumentError("value out of range", "value", arguments[1]);
  }
  while (value.length < 2 * length + 2) {
    value = "0x0" + value.substring(2);
  }
  return value;
}
exports.hexZeroPad = hexZeroPad;
function splitSignature(signature) {
  var result = {
    r: "0x",
    s: "0x",
    _vs: "0x",
    recoveryParam: 0,
    v: 0,
    yParityAndS: "0x",
    compact: "0x"
  };
  if (isBytesLike(signature)) {
    var bytes = arrayify(signature);
    // Get the r, s and v
    if (bytes.length === 64) {
      // EIP-2098; pull the v from the top bit of s and clear it
      result.v = 27 + (bytes[32] >> 7);
      bytes[32] &= 0x7f;
      result.r = hexlify(bytes.slice(0, 32));
      result.s = hexlify(bytes.slice(32, 64));
    } else if (bytes.length === 65) {
      result.r = hexlify(bytes.slice(0, 32));
      result.s = hexlify(bytes.slice(32, 64));
      result.v = bytes[64];
    } else {
      logger.throwArgumentError("invalid signature string", "signature", signature);
    }
    // Allow a recid to be used as the v
    if (result.v < 27) {
      if (result.v === 0 || result.v === 1) {
        result.v += 27;
      } else {
        logger.throwArgumentError("signature invalid v byte", "signature", signature);
      }
    }
    // Compute recoveryParam from v
    result.recoveryParam = 1 - result.v % 2;
    // Compute _vs from recoveryParam and s
    if (result.recoveryParam) {
      bytes[32] |= 0x80;
    }
    result._vs = hexlify(bytes.slice(32, 64));
  } else {
    result.r = signature.r;
    result.s = signature.s;
    result.v = signature.v;
    result.recoveryParam = signature.recoveryParam;
    result._vs = signature._vs;
    // If the _vs is available, use it to populate missing s, v and recoveryParam
    // and verify non-missing s, v and recoveryParam
    if (result._vs != null) {
      var vs_1 = zeroPad(arrayify(result._vs), 32);
      result._vs = hexlify(vs_1);
      // Set or check the recid
      var recoveryParam = vs_1[0] >= 128 ? 1 : 0;
      if (result.recoveryParam == null) {
        result.recoveryParam = recoveryParam;
      } else if (result.recoveryParam !== recoveryParam) {
        logger.throwArgumentError("signature recoveryParam mismatch _vs", "signature", signature);
      }
      // Set or check the s
      vs_1[0] &= 0x7f;
      var s = hexlify(vs_1);
      if (result.s == null) {
        result.s = s;
      } else if (result.s !== s) {
        logger.throwArgumentError("signature v mismatch _vs", "signature", signature);
      }
    }
    // Use recid and v to populate each other
    if (result.recoveryParam == null) {
      if (result.v == null) {
        logger.throwArgumentError("signature missing v and recoveryParam", "signature", signature);
      } else if (result.v === 0 || result.v === 1) {
        result.recoveryParam = result.v;
      } else {
        result.recoveryParam = 1 - result.v % 2;
      }
    } else {
      if (result.v == null) {
        result.v = 27 + result.recoveryParam;
      } else {
        var recId = result.v === 0 || result.v === 1 ? result.v : 1 - result.v % 2;
        if (result.recoveryParam !== recId) {
          logger.throwArgumentError("signature recoveryParam mismatch v", "signature", signature);
        }
      }
    }
    if (result.r == null || !isHexString(result.r)) {
      logger.throwArgumentError("signature missing or invalid r", "signature", signature);
    } else {
      result.r = hexZeroPad(result.r, 32);
    }
    if (result.s == null || !isHexString(result.s)) {
      logger.throwArgumentError("signature missing or invalid s", "signature", signature);
    } else {
      result.s = hexZeroPad(result.s, 32);
    }
    var vs = arrayify(result.s);
    if (vs[0] >= 128) {
      logger.throwArgumentError("signature s out of range", "signature", signature);
    }
    if (result.recoveryParam) {
      vs[0] |= 0x80;
    }
    var _vs = hexlify(vs);
    if (result._vs) {
      if (!isHexString(result._vs)) {
        logger.throwArgumentError("signature invalid _vs", "signature", signature);
      }
      result._vs = hexZeroPad(result._vs, 32);
    }
    // Set or check the _vs
    if (result._vs == null) {
      result._vs = _vs;
    } else if (result._vs !== _vs) {
      logger.throwArgumentError("signature _vs mismatch v and s", "signature", signature);
    }
  }
  result.yParityAndS = result._vs;
  result.compact = result.r + result.yParityAndS.substring(2);
  return result;
}
exports.splitSignature = splitSignature;
function joinSignature(signature) {
  signature = splitSignature(signature);
  return hexlify(concat([signature.r, signature.s, signature.recoveryParam ? "0x1c" : "0x1b"]));
}
exports.joinSignature = joinSignature;

},{"./_version":27,"@ethersproject/logger":45}],29:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AddressZero = void 0;
exports.AddressZero = "0x0000000000000000000000000000000000000000";

},{}],30:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MaxInt256 = exports.MinInt256 = exports.MaxUint256 = exports.WeiPerEther = exports.Two = exports.One = exports.Zero = exports.NegativeOne = void 0;
var bignumber_1 = require("@ethersproject/bignumber");
var NegativeOne = /*#__PURE__*/bignumber_1.BigNumber.from(-1);
exports.NegativeOne = NegativeOne;
var Zero = /*#__PURE__*/bignumber_1.BigNumber.from(0);
exports.Zero = Zero;
var One = /*#__PURE__*/bignumber_1.BigNumber.from(1);
exports.One = One;
var Two = /*#__PURE__*/bignumber_1.BigNumber.from(2);
exports.Two = Two;
var WeiPerEther = /*#__PURE__*/bignumber_1.BigNumber.from("1000000000000000000");
exports.WeiPerEther = WeiPerEther;
var MaxUint256 = /*#__PURE__*/bignumber_1.BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
exports.MaxUint256 = MaxUint256;
var MinInt256 = /*#__PURE__*/bignumber_1.BigNumber.from("-0x8000000000000000000000000000000000000000000000000000000000000000");
exports.MinInt256 = MinInt256;
var MaxInt256 = /*#__PURE__*/bignumber_1.BigNumber.from("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
exports.MaxInt256 = MaxInt256;

},{"@ethersproject/bignumber":25}],31:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.HashZero = void 0;
exports.HashZero = "0x0000000000000000000000000000000000000000000000000000000000000000";

},{}],32:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EtherSymbol = exports.HashZero = exports.MaxInt256 = exports.MinInt256 = exports.MaxUint256 = exports.WeiPerEther = exports.Two = exports.One = exports.Zero = exports.NegativeOne = exports.AddressZero = void 0;
var addresses_1 = require("./addresses");
Object.defineProperty(exports, "AddressZero", {
  enumerable: true,
  get: function get() {
    return addresses_1.AddressZero;
  }
});
var bignumbers_1 = require("./bignumbers");
Object.defineProperty(exports, "NegativeOne", {
  enumerable: true,
  get: function get() {
    return bignumbers_1.NegativeOne;
  }
});
Object.defineProperty(exports, "Zero", {
  enumerable: true,
  get: function get() {
    return bignumbers_1.Zero;
  }
});
Object.defineProperty(exports, "One", {
  enumerable: true,
  get: function get() {
    return bignumbers_1.One;
  }
});
Object.defineProperty(exports, "Two", {
  enumerable: true,
  get: function get() {
    return bignumbers_1.Two;
  }
});
Object.defineProperty(exports, "WeiPerEther", {
  enumerable: true,
  get: function get() {
    return bignumbers_1.WeiPerEther;
  }
});
Object.defineProperty(exports, "MaxUint256", {
  enumerable: true,
  get: function get() {
    return bignumbers_1.MaxUint256;
  }
});
Object.defineProperty(exports, "MinInt256", {
  enumerable: true,
  get: function get() {
    return bignumbers_1.MinInt256;
  }
});
Object.defineProperty(exports, "MaxInt256", {
  enumerable: true,
  get: function get() {
    return bignumbers_1.MaxInt256;
  }
});
var hashes_1 = require("./hashes");
Object.defineProperty(exports, "HashZero", {
  enumerable: true,
  get: function get() {
    return hashes_1.HashZero;
  }
});
var strings_1 = require("./strings");
Object.defineProperty(exports, "EtherSymbol", {
  enumerable: true,
  get: function get() {
    return strings_1.EtherSymbol;
  }
});

},{"./addresses":29,"./bignumbers":30,"./hashes":31,"./strings":33}],33:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EtherSymbol = void 0;
// NFKC (composed)             // (decomposed)
exports.EtherSymbol = "\u039E"; // "\uD835\uDF63";

},{}],34:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.version = void 0;
exports.version = "hash/5.7.0";

},{}],35:[function(require,module,exports){
"use strict";

/**
 * MIT License
 *
 * Copyright (c) 2021 Andrew Raffensperger
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * This is a near carbon-copy of the original source (link below) with the
 * TypeScript typings added and a few tweaks to make it ES3-compatible.
 *
 * See: https://github.com/adraffy/ens-normalize.js
 */
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.read_emoji_trie = exports.read_zero_terminated_array = exports.read_mapped_map = exports.read_member_array = exports.signed = exports.read_compressed_payload = exports.read_payload = exports.decode_arithmetic = void 0;
// https://github.com/behnammodi/polyfill/blob/master/array.polyfill.js
function flat(array, depth) {
  if (depth == null) {
    depth = 1;
  }
  var result = [];
  var forEach = result.forEach;
  var flatDeep = function flatDeep(arr, depth) {
    forEach.call(arr, function (val) {
      if (depth > 0 && Array.isArray(val)) {
        flatDeep(val, depth - 1);
      } else {
        result.push(val);
      }
    });
  };
  flatDeep(array, depth);
  return result;
}
function fromEntries(array) {
  var result = {};
  for (var i = 0; i < array.length; i++) {
    var value = array[i];
    result[value[0]] = value[1];
  }
  return result;
}
function decode_arithmetic(bytes) {
  var pos = 0;
  function u16() {
    return bytes[pos++] << 8 | bytes[pos++];
  }
  // decode the frequency table
  var symbol_count = u16();
  var total = 1;
  var acc = [0, 1]; // first symbol has frequency 1
  for (var i = 1; i < symbol_count; i++) {
    acc.push(total += u16());
  }
  // skip the sized-payload that the last 3 symbols index into
  var skip = u16();
  var pos_payload = pos;
  pos += skip;
  var read_width = 0;
  var read_buffer = 0;
  function read_bit() {
    if (read_width == 0) {
      // this will read beyond end of buffer
      // but (undefined|0) => zero pad
      read_buffer = read_buffer << 8 | bytes[pos++];
      read_width = 8;
    }
    return read_buffer >> --read_width & 1;
  }
  var N = 31;
  var FULL = Math.pow(2, N);
  var HALF = FULL >>> 1;
  var QRTR = HALF >> 1;
  var MASK = FULL - 1;
  // fill register
  var register = 0;
  for (var i = 0; i < N; i++) register = register << 1 | read_bit();
  var symbols = [];
  var low = 0;
  var range = FULL; // treat like a float
  while (true) {
    var value = Math.floor(((register - low + 1) * total - 1) / range);
    var start = 0;
    var end = symbol_count;
    while (end - start > 1) {
      // binary search
      var mid = start + end >>> 1;
      if (value < acc[mid]) {
        end = mid;
      } else {
        start = mid;
      }
    }
    if (start == 0) break; // first symbol is end mark
    symbols.push(start);
    var a = low + Math.floor(range * acc[start] / total);
    var b = low + Math.floor(range * acc[start + 1] / total) - 1;
    while (((a ^ b) & HALF) == 0) {
      register = register << 1 & MASK | read_bit();
      a = a << 1 & MASK;
      b = b << 1 & MASK | 1;
    }
    while (a & ~b & QRTR) {
      register = register & HALF | register << 1 & MASK >>> 1 | read_bit();
      a = a << 1 ^ HALF;
      b = (b ^ HALF) << 1 | HALF | 1;
    }
    low = a;
    range = 1 + b - a;
  }
  var offset = symbol_count - 4;
  return symbols.map(function (x) {
    switch (x - offset) {
      case 3:
        return offset + 0x10100 + (bytes[pos_payload++] << 16 | bytes[pos_payload++] << 8 | bytes[pos_payload++]);
      case 2:
        return offset + 0x100 + (bytes[pos_payload++] << 8 | bytes[pos_payload++]);
      case 1:
        return offset + bytes[pos_payload++];
      default:
        return x - 1;
    }
  });
}
exports.decode_arithmetic = decode_arithmetic;
// returns an iterator which returns the next symbol
function read_payload(v) {
  var pos = 0;
  return function () {
    return v[pos++];
  };
}
exports.read_payload = read_payload;
function read_compressed_payload(bytes) {
  return read_payload(decode_arithmetic(bytes));
}
exports.read_compressed_payload = read_compressed_payload;
// eg. [0,1,2,3...] => [0,-1,1,-2,...]
function signed(i) {
  return i & 1 ? ~i >> 1 : i >> 1;
}
exports.signed = signed;
function read_counts(n, next) {
  var v = Array(n);
  for (var i = 0; i < n; i++) v[i] = 1 + next();
  return v;
}
function read_ascending(n, next) {
  var v = Array(n);
  for (var i = 0, x = -1; i < n; i++) v[i] = x += 1 + next();
  return v;
}
function read_deltas(n, next) {
  var v = Array(n);
  for (var i = 0, x = 0; i < n; i++) v[i] = x += signed(next());
  return v;
}
function read_member_array(next, lookup) {
  var v = read_ascending(next(), next);
  var n = next();
  var vX = read_ascending(n, next);
  var vN = read_counts(n, next);
  for (var i = 0; i < n; i++) {
    for (var j = 0; j < vN[i]; j++) {
      v.push(vX[i] + j);
    }
  }
  return lookup ? v.map(function (x) {
    return lookup[x];
  }) : v;
}
exports.read_member_array = read_member_array;
// returns array of 
// [x, ys] => single replacement rule
// [x, ys, n, dx, dx] => linear map
function read_mapped_map(next) {
  var ret = [];
  while (true) {
    var w = next();
    if (w == 0) break;
    ret.push(read_linear_table(w, next));
  }
  while (true) {
    var w = next() - 1;
    if (w < 0) break;
    ret.push(read_replacement_table(w, next));
  }
  return fromEntries(flat(ret));
}
exports.read_mapped_map = read_mapped_map;
function read_zero_terminated_array(next) {
  var v = [];
  while (true) {
    var i = next();
    if (i == 0) break;
    v.push(i);
  }
  return v;
}
exports.read_zero_terminated_array = read_zero_terminated_array;
function read_transposed(n, w, next) {
  var m = Array(n).fill(undefined).map(function () {
    return [];
  });
  for (var i = 0; i < w; i++) {
    read_deltas(n, next).forEach(function (x, j) {
      return m[j].push(x);
    });
  }
  return m;
}
function read_linear_table(w, next) {
  var dx = 1 + next();
  var dy = next();
  var vN = read_zero_terminated_array(next);
  var m = read_transposed(vN.length, 1 + w, next);
  return flat(m.map(function (v, i) {
    var x = v[0],
      ys = v.slice(1);
    //let [x, ...ys] = v;
    //return Array(vN[i]).fill().map((_, j) => {
    return Array(vN[i]).fill(undefined).map(function (_, j) {
      var j_dy = j * dy;
      return [x + j * dx, ys.map(function (y) {
        return y + j_dy;
      })];
    });
  }));
}
function read_replacement_table(w, next) {
  var n = 1 + next();
  var m = read_transposed(n, 1 + w, next);
  return m.map(function (v) {
    return [v[0], v.slice(1)];
  });
}
function read_emoji_trie(next) {
  var sorted = read_member_array(next).sort(function (a, b) {
    return a - b;
  });
  return read();
  function read() {
    var branches = [];
    while (true) {
      var keys = read_member_array(next, sorted);
      if (keys.length == 0) break;
      branches.push({
        set: new Set(keys),
        node: read()
      });
    }
    branches.sort(function (a, b) {
      return b.set.size - a.set.size;
    }); // sort by likelihood
    var temp = next();
    var valid = temp % 3;
    temp = temp / 3 | 0;
    var fe0f = !!(temp & 1);
    temp >>= 1;
    var save = temp == 1;
    var check = temp == 2;
    return {
      branches: branches,
      valid: valid,
      fe0f: fe0f,
      save: save,
      check: check
    };
  }
}
exports.read_emoji_trie = read_emoji_trie;

},{}],36:[function(require,module,exports){
"use strict";

/**
 * MIT License
 *
 * Copyright (c) 2021 Andrew Raffensperger
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * This is a near carbon-copy of the original source (link below) with the
 * TypeScript typings added and a few tweaks to make it ES3-compatible.
 *
 * See: https://github.com/adraffy/ens-normalize.js
 */
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getData = void 0;
var base64_1 = require("@ethersproject/base64");
var decoder_js_1 = require("./decoder.js");
function getData() {
  return (0, decoder_js_1.read_compressed_payload)((0, base64_1.decode)('AEQF2AO2DEsA2wIrAGsBRABxAN8AZwCcAEwAqgA0AGwAUgByADcATAAVAFYAIQAyACEAKAAYAFgAGwAjABQAMAAmADIAFAAfABQAKwATACoADgAbAA8AHQAYABoAGQAxADgALAAoADwAEwA9ABMAGgARAA4ADwAWABMAFgAIAA8AHgQXBYMA5BHJAS8JtAYoAe4AExozi0UAH21tAaMnBT8CrnIyhrMDhRgDygIBUAEHcoFHUPe8AXBjAewCjgDQR8IICIcEcQLwATXCDgzvHwBmBoHNAqsBdBcUAykgDhAMShskMgo8AY8jqAQfAUAfHw8BDw87MioGlCIPBwZCa4ELatMAAMspJVgsDl8AIhckSg8XAHdvTwBcIQEiDT4OPhUqbyECAEoAS34Aej8Ybx83JgT/Xw8gHxZ/7w8RICxPHA9vBw+Pfw8PHwAPFv+fAsAvCc8vEr8ivwD/EQ8Bol8OEBa/A78hrwAPCU8vESNvvwWfHwNfAVoDHr+ZAAED34YaAdJPAK7PLwSEgDLHAGo1Pz8Pvx9fUwMrpb8O/58VTzAPIBoXIyQJNF8hpwIVAT8YGAUADDNBaX3RAMomJCg9EhUeA29MABsZBTMNJipjOhc19gcIDR8bBwQHEggCWi6DIgLuAQYA+BAFCha3A5XiAEsqM7UFFgFLhAMjFTMYE1Klnw74nRVBG/ASCm0BYRN/BrsU3VoWy+S0vV8LQx+vN8gF2AC2AK5EAWwApgYDKmAAroQ0NDQ0AT+OCg7wAAIHRAbpNgVcBV0APTA5BfbPFgMLzcYL/QqqA82eBALKCjQCjqYCht0/k2+OAsXQAoP3ASTKDgDw6ACKAUYCMpIKJpRaAE4A5womABzZvs0REEKiACIQAd5QdAECAj4Ywg/wGqY2AVgAYADYvAoCGAEubA0gvAY2ALAAbpbvqpyEAGAEpgQAJgAG7gAgAEACmghUFwCqAMpAINQIwC4DthRAAPcycKgApoIdABwBfCisABoATwBqASIAvhnSBP8aH/ECeAKXAq40NjgDBTwFYQU6AXs3oABgAD4XNgmcCY1eCl5tIFZeUqGgyoNHABgAEQAaABNwWQAmABMATPMa3T34ADldyprmM1M2XociUQgLzvwAXT3xABgAEQAaABNwIGFAnADD8AAgAD4BBJWzaCcIAIEBFMAWwKoAAdq9BWAF5wLQpALEtQAKUSGkahR4GnJM+gsAwCgeFAiUAECQ0BQuL8AAIAAAADKeIheclvFqQAAETr4iAMxIARMgAMIoHhQIAn0E0pDQFC4HhznoAAAAIAI2C0/4lvFqQAAETgBJJwYCAy4ABgYAFAA8MBKYEH4eRhTkAjYeFcgACAYAeABsOqyQ5gRwDayqugEgaIIAtgoACgDmEABmBAWGme5OBJJA2m4cDeoAmITWAXwrMgOgAGwBCh6CBXYF1Tzg1wKAAFdiuABRAFwAXQBsAG8AdgBrAHYAbwCEAHEwfxQBVE5TEQADVFhTBwBDANILAqcCzgLTApQCrQL6vAAMAL8APLhNBKkE6glGKTAU4Dr4N2EYEwBCkABKk8rHAbYBmwIoAiU4Ajf/Aq4CowCAANIChzgaNBsCsTgeODcFXrgClQKdAqQBiQGYAqsCsjTsNHsfNPA0ixsAWTWiOAMFPDQSNCk2BDZHNow2TTZUNhk28Jk9VzI3QkEoAoICoQKwAqcAQAAxBV4FXbS9BW47YkIXP1ciUqs05DS/FwABUwJW11e6nHuYZmSh/RAYA8oMKvZ8KASoUAJYWAJ6ILAsAZSoqjpgA0ocBIhmDgDWAAawRDQoAAcuAj5iAHABZiR2AIgiHgCaAU68ACxuHAG0ygM8MiZIAlgBdF4GagJqAPZOHAMuBgoATkYAsABiAHgAMLoGDPj0HpKEBAAOJgAuALggTAHWAeAMEDbd20Uege0ADwAWADkAQgA9OHd+2MUQZBBhBgNNDkxxPxUQArEPqwvqERoM1irQ090ANK4H8ANYB/ADWANYB/AH8ANYB/ADWANYA1gDWBwP8B/YxRBkD00EcgWTBZAE2wiIJk4RhgctCNdUEnQjHEwDSgEBIypJITuYMxAlR0wRTQgIATZHbKx9PQNMMbBU+pCnA9AyVDlxBgMedhKlAC8PeCE1uk6DekxxpQpQT7NX9wBFBgASqwAS5gBJDSgAUCwGPQBI4zTYABNGAE2bAE3KAExdGABKaAbgAFBXAFCOAFBJABI2SWdObALDOq0//QomCZhvwHdTBkIQHCemEPgMNAG2ATwN7kvZBPIGPATKH34ZGg/OlZ0Ipi3eDO4m5C6igFsj9iqEBe5L9TzeC05RaQ9aC2YJ5DpkgU8DIgEOIowK3g06CG4Q9ArKbA3mEUYHOgPWSZsApgcCCxIdNhW2JhFirQsKOXgG/Br3C5AmsBMqev0F1BoiBk4BKhsAANAu6IWxWjJcHU9gBgQLJiPIFKlQIQ0mQLh4SRocBxYlqgKSQ3FKiFE3HpQh9zw+DWcuFFF9B/Y8BhlQC4I8n0asRQ8R0z6OPUkiSkwtBDaALDAnjAnQD4YMunxzAVoJIgmyDHITMhEYN8YIOgcaLpclJxYIIkaWYJsE+KAD9BPSAwwFQAlCBxQDthwuEy8VKgUOgSXYAvQ21i60ApBWgQEYBcwPJh/gEFFH4Q7qCJwCZgOEJewALhUiABginAhEZABgj9lTBi7MCMhqbSN1A2gU6GIRdAeSDlgHqBw0FcAc4nDJXgyGCSiksAlcAXYJmgFgBOQICjVcjKEgQmdUi1kYnCBiQUBd/QIyDGYVoES+h3kCjA9sEhwBNgF0BzoNAgJ4Ee4RbBCWCOyGBTW2M/k6JgRQIYQgEgooA1BszwsoJvoM+WoBpBJjAw00PnfvZ6xgtyUX/gcaMsZBYSHyC5NPzgydGsIYQ1QvGeUHwAP0GvQn60FYBgADpAQUOk4z7wS+C2oIjAlAAEoOpBgH2BhrCnKM0QEyjAG4mgNYkoQCcJAGOAcMAGgMiAV65gAeAqgIpAAGANADWAA6Aq4HngAaAIZCAT4DKDABIuYCkAOUCDLMAZYwAfQqBBzEDBYA+DhuSwLDsgKAa2ajBd5ZAo8CSjYBTiYEBk9IUgOwcuIA3ABMBhTgSAEWrEvMG+REAeBwLADIAPwABjYHBkIBzgH0bgC4AWALMgmjtLYBTuoqAIQAFmwB2AKKAN4ANgCA8gFUAE4FWvoF1AJQSgESMhksWGIBvAMgATQBDgB6BsyOpsoIIARuB9QCEBwV4gLvLwe2AgMi4BPOQsYCvd9WADIXUu5eZwqoCqdeaAC0YTQHMnM9UQAPH6k+yAdy/BZIiQImSwBQ5gBQQzSaNTFWSTYBpwGqKQK38AFtqwBI/wK37gK3rQK3sAK6280C0gK33AK3zxAAUEIAUD9SklKDArekArw5AEQAzAHCO147WTteO1k7XjtZO147WTteO1kDmChYI03AVU0oJqkKbV9GYewMpw3VRMk6ShPcYFJgMxPJLbgUwhXPJVcZPhq9JwYl5VUKDwUt1GYxCC00dhe9AEApaYNCY4ceMQpMHOhTklT5LRwAskujM7ANrRsWREEFSHXuYisWDwojAmSCAmJDXE6wXDchAqH4AmiZAmYKAp+FOBwMAmY8AmYnBG8EgAN/FAN+kzkHOXgYOYM6JCQCbB4CMjc4CwJtyAJtr/CLADRoRiwBaADfAOIASwYHmQyOAP8MwwAOtgJ3MAJ2o0ACeUxEAni7Hl3cRa9G9AJ8QAJ6yQJ9CgJ88UgBSH5kJQAsFklZSlwWGErNAtECAtDNSygDiFADh+dExpEzAvKiXQQDA69Lz0wuJgTQTU1NsAKLQAKK2cIcCB5EaAa4Ao44Ao5dQZiCAo7aAo5deVG1UzYLUtVUhgKT/AKTDQDqAB1VH1WwVdEHLBwplocy4nhnRTw6ApegAu+zWCKpAFomApaQApZ9nQCqWa1aCoJOADwClrYClk9cRVzSApnMApllXMtdCBoCnJw5wzqeApwXAp+cAp65iwAeEDIrEAKd8gKekwC2PmE1YfACntQCoG8BqgKeoCACnk+mY8lkKCYsAiewAiZ/AqD8AqBN2AKmMAKlzwKoAAB+AqfzaH1osgAESmodatICrOQCrK8CrWgCrQMCVx4CVd0CseLYAx9PbJgCsr4OArLpGGzhbWRtSWADJc4Ctl08QG6RAylGArhfArlIFgK5K3hwN3DiAr0aAy2zAzISAr6JcgMDM3ICvhtzI3NQAsPMAsMFc4N0TDZGdOEDPKgDPJsDPcACxX0CxkgCxhGKAshqUgLIRQLJUALJLwJkngLd03h6YniveSZL0QMYpGcDAmH1GfSVJXsMXpNevBICz2wCz20wTFTT9BSgAMeuAs90ASrrA04TfkwGAtwoAtuLAtJQA1JdA1NgAQIDVY2AikABzBfuYUZ2AILPg44C2sgC2d+EEYRKpz0DhqYAMANkD4ZyWvoAVgLfZgLeuXR4AuIw7RUB8zEoAfScAfLTiALr9ALpcXoAAur6AurlAPpIAboC7ooC652Wq5cEAu5AA4XhmHpw4XGiAvMEAGoDjheZlAL3FAORbwOSiAL3mQL52gL4Z5odmqy8OJsfA52EAv77ARwAOp8dn7QDBY4DpmsDptoA0sYDBmuhiaIGCgMMSgFgASACtgNGAJwEgLpoBgC8BGzAEowcggCEDC6kdjoAJAM0C5IKRoABZCgiAIzw3AYBLACkfng9ogigkgNmWAN6AEQCvrkEVqTGAwCsBRbAA+4iQkMCHR072jI2PTbUNsk2RjY5NvA23TZKNiU3EDcZN5I+RTxDRTBCJkK5VBYKFhZfwQCWygU3AJBRHpu+OytgNxa61A40GMsYjsn7BVwFXQVcBV0FaAVdBVwFXQVcBV0FXAVdBVwFXUsaCNyKAK4AAQUHBwKU7oICoW1e7jAEzgPxA+YDwgCkBFDAwADABKzAAOxFLhitA1UFTDeyPkM+bj51QkRCuwTQWWQ8X+0AWBYzsACNA8xwzAGm7EZ/QisoCTAbLDs6fnLfb8H2GccsbgFw13M1HAVkBW/Jxsm9CNRO8E8FDD0FBQw9FkcClOYCoMFegpDfADgcMiA2AJQACB8AsigKAIzIEAJKeBIApY5yPZQIAKQiHb4fvj5BKSRPQrZCOz0oXyxgOywfKAnGbgMClQaCAkILXgdeCD9IIGUgQj5fPoY+dT52Ao5CM0dAX9BTVG9SDzFwWTQAbxBzJF/lOEIQQglCCkKJIAls5AcClQICoKPMODEFxhi6KSAbiyfIRrMjtCgdWCAkPlFBIitCsEJRzAbMAV/OEyQzDg0OAQQEJ36i328/Mk9AybDJsQlq3tDRApUKAkFzXf1d/j9uALYP6hCoFgCTGD8kPsFKQiobrm0+zj0KSD8kPnVCRBwMDyJRTHFgMTJa5rwXQiQ2YfI/JD7BMEJEHGINTw4TOFlIRzwJO0icMQpyPyQ+wzJCRBv6DVgnKB01NgUKj2bwYzMqCoBkznBgEF+zYDIocwRIX+NgHj4HICNfh2C4CwdwFWpTG/lgUhYGAwRfv2Ts8mAaXzVgml/XYIJfuWC4HI1gUF9pYJZgMR6ilQHMAOwLAlDRefC0in4AXAEJA6PjCwc0IamOANMMCAECRQDFNRTZBgd+CwQlRA+r6+gLBDEFBnwUBXgKATIArwAGRAAHA3cDdAN2A3kDdwN9A3oDdQN7A30DfAN4A3oDfQAYEAAlAtYASwMAUAFsAHcKAHcAmgB3AHUAdQB2AHVu8UgAygDAAHcAdQB1AHYAdQALCgB3AAsAmgB3AAsCOwB3AAtu8UgAygDAAHgKAJoAdwB3AHUAdQB2AHUAeAB1AHUAdgB1bvFIAMoAwAALCgCaAHcACwB3AAsCOwB3AAtu8UgAygDAAH4ACwGgALcBpwC6AahdAu0COwLtbvFIAMoAwAALCgCaAu0ACwLtAAsCOwLtAAtu8UgAygDAA24ACwNvAAu0VsQAAzsAABCkjUIpAAsAUIusOggWcgMeBxVsGwL67U/2HlzmWOEeOgALASvuAAseAfpKUpnpGgYJDCIZM6YyARUE9ThqAD5iXQgnAJYJPnOzw0ZAEZxEKsIAkA4DhAHnTAIDxxUDK0lxCQlPYgIvIQVYJQBVqE1GakUAKGYiDToSBA1EtAYAXQJYAIF8GgMHRyAAIAjOe9YncekRAA0KACUrjwE7Ayc6AAYWAqaiKG4McEcqANoN3+Mg9TwCBhIkuCny+JwUQ29L008JluRxu3K+oAdqiHOqFH0AG5SUIfUJ5SxCGfxdipRzqTmT4V5Zb+r1Uo4Vm+NqSSEl2mNvR2JhIa8SpYO6ntdwFXHCWTCK8f2+Hxo7uiG3drDycAuKIMP5bhi06ACnqArH1rz4Rqg//lm6SgJGEVbF9xJHISaR6HxqxSnkw6shDnelHKNEfGUXSJRJ1GcsmtJw25xrZMDK9gXSm1/YMkdX4/6NKYOdtk/NQ3/NnDASjTc3fPjIjW/5sVfVObX2oTDWkr1dF9f3kxBsD3/3aQO8hPfRz+e0uEiJqt1161griu7gz8hDDwtpy+F+BWtefnKHZPAxcZoWbnznhJpy0e842j36bcNzGnIEusgGX0a8ZxsnjcSsPDZ09yZ36fCQbriHeQ72JRMILNl6ePPf2HWoVwgWAm1fb3V2sAY0+B6rAXqSwPBgseVmoqsBTSrm91+XasMYYySI8eeRxH3ZvHkMz3BQ5aJ3iUVbYPNM3/7emRtjlsMgv/9VyTsyt/mK+8fgWeT6SoFaclXqn42dAIsvAarF5vNNWHzKSkKQ/8Hfk5ZWK7r9yliOsooyBjRhfkHP4Q2DkWXQi6FG/9r/IwbmkV5T7JSopHKn1pJwm9tb5Ot0oyN1Z2mPpKXHTxx2nlK08fKk1hEYA8WgVVWL5lgx0iTv+KdojJeU23ZDjmiubXOxVXJKKi2Wjuh2HLZOFLiSC7Tls5SMh4f+Pj6xUSrNjFqLGehRNB8lC0QSLNmkJJx/wSG3MnjE9T1CkPwJI0wH2lfzwETIiVqUxg0dfu5q39Gt+hwdcxkhhNvQ4TyrBceof3Mhs/IxFci1HmHr4FMZgXEEczPiGCx0HRwzAqDq2j9AVm1kwN0mRVLWLylgtoPNapF5cY4Y1wJh/e0BBwZj44YgZrDNqvD/9Hv7GFYdUQeDJuQ3EWI4HaKqavU1XjC/n41kT4L79kqGq0kLhdTZvgP3TA3fS0ozVz+5piZsoOtIvBUFoMKbNcmBL6YxxaUAusHB38XrS8dQMnQwJfUUkpRoGr5AUeWicvBTzyK9g77+yCkf5PAysL7r/JjcZgrbvRpMW9iyaxZvKO6ceZN2EwIxKwVFPuvFuiEPGCoagbMo+SpydLrXqBzNCDGFCrO/rkcwa2xhokQZ5CdZ0AsU3JfSqJ6n5I14YA+P/uAgfhPU84Tlw7cEFfp7AEE8ey4sP12PTt4Cods1GRgDOB5xvyiR5m+Bx8O5nBCNctU8BevfV5A08x6RHd5jcwPTMDSZJOedIZ1cGQ704lxbAzqZOP05ZxaOghzSdvFBHYqomATARyAADK4elP8Ly3IrUZKfWh23Xy20uBUmLS4Pfagu9+oyVa2iPgqRP3F2CTUsvJ7+RYnN8fFZbU/HVvxvcFFDKkiTqV5UBZ3Gz54JAKByi9hkKMZJvuGgcSYXFmw08UyoQyVdfTD1/dMkCHXcTGAKeROgArsvmRrQTLUOXioOHGK2QkjHuoYFgXciZoTJd6Fs5q1QX1G+p/e26hYsEf7QZD1nnIyl/SFkNtYYmmBhpBrxl9WbY0YpHWRuw2Ll/tj9mD8P4snVzJl4F9J+1arVeTb9E5r2ILH04qStjxQNwn3m4YNqxmaNbLAqW2TN6LidwuJRqS+NXbtqxoeDXpxeGWmxzSkWxjkyCkX4NQRme6q5SAcC+M7+9ETfA/EwrzQajKakCwYyeunP6ZFlxU2oMEn1Pz31zeStW74G406ZJFCl1wAXIoUKkWotYEpOuXB1uVNxJ63dpJEqfxBeptwIHNrPz8BllZoIcBoXwgfJ+8VAUnVPvRvexnw0Ma/WiGYuJO5y8QTvEYBigFmhUxY5RqzE8OcywN/8m4UYrlaniJO75XQ6KSo9+tWHlu+hMi0UVdiKQp7NelnoZUzNaIyBPVeOwK6GNp+FfHuPOoyhaWuNvTYFkvxscMQWDh+zeFCFkgwbXftiV23ywJ4+uwRqmg9k3KzwIQpzppt8DBBOMbrqwQM5Gb05sEwdKzMiAqOloaA/lr0KA+1pr0/+HiWoiIjHA/wir2nIuS3PeU/ji3O6ZwoxcR1SZ9FhtLC5S0FIzFhbBWcGVP/KpxOPSiUoAdWUpqKH++6Scz507iCcxYI6rdMBICPJZea7OcmeFw5mObJSiqpjg2UoWNIs+cFhyDSt6geV5qgi3FunmwwDoGSMgerFOZGX1m0dMCYo5XOruxO063dwENK9DbnVM9wYFREzh4vyU1WYYJ/LRRp6oxgjqP/X5a8/4Af6p6NWkQferzBmXme0zY/4nwMJm/wd1tIqSwGz+E3xPEAOoZlJit3XddD7/BT1pllzOx+8bmQtANQ/S6fZexc6qi3W+Q2xcmXTUhuS5mpHQRvcxZUN0S5+PL9lXWUAaRZhEH8hTdAcuNMMCuVNKTEGtSUKNi3O6KhSaTzck8csZ2vWRZ+d7mW8c4IKwXIYd25S/zIftPkwPzufjEvOHWVD1m+FjpDVUTV0DGDuHj6QnaEwLu/dEgdLQOg9E1Sro9XHJ8ykLAwtPu+pxqKDuFexqON1sKQm7rwbE1E68UCfA/erovrTCG+DBSNg0l4goDQvZN6uNlbyLpcZAwj2UclycvLpIZMgv4yRlpb3YuMftozorbcGVHt/VeDV3+Fdf1TP0iuaCsPi2G4XeGhsyF1ubVDxkoJhmniQ0/jSg/eYML9KLfnCFgISWkp91eauR3IQvED0nAPXK+6hPCYs+n3+hCZbiskmVMG2da+0EsZPonUeIY8EbfusQXjsK/eFDaosbPjEfQS0RKG7yj5GG69M7MeO1HmiUYocgygJHL6M1qzUDDwUSmr99V7Sdr2F3JjQAJY+F0yH33Iv3+C9M38eML7gTgmNu/r2bUMiPvpYbZ6v1/IaESirBHNa7mPKn4dEmYg7v/+HQgPN1G79jBQ1+soydfDC2r+h2Bl/KIc5KjMK7OH6nb1jLsNf0EHVe2KBiE51ox636uyG6Lho0t3J34L5QY/ilE3mikaF4HKXG1mG1rCevT1Vv6GavltxoQe/bMrpZvRggnBxSEPEeEzkEdOxTnPXHVjUYdw8JYvjB/o7Eegc3Ma+NUxLLnsK0kJlinPmUHzHGtrk5+CAbVzFOBqpyy3QVUnzTDfC/0XD94/okH+OB+i7g9lolhWIjSnfIb+Eq43ZXOWmwvjyV/qqD+t0e+7mTEM74qP/Ozt8nmC7mRpyu63OB4KnUzFc074SqoyPUAgM+/TJGFo6T44EHnQU4X4z6qannVqgw/U7zCpwcmXV1AubIrvOmkKHazJAR55ePjp5tLBsN8vAqs3NAHdcEHOR2xQ0lsNAFzSUuxFQCFYvXLZJdOj9p4fNq6p0HBGUik2YzaI4xySy91KzhQ0+q1hjxvImRwPRf76tChlRkhRCi74NXZ9qUNeIwP+s5p+3m5nwPdNOHgSLD79n7O9m1n1uDHiMntq4nkYwV5OZ1ENbXxFd4PgrlvavZsyUO4MqYlqqn1O8W/I1dEZq5dXhrbETLaZIbC2Kj/Aa/QM+fqUOHdf0tXAQ1huZ3cmWECWSXy/43j35+Mvq9xws7JKseriZ1pEWKc8qlzNrGPUGcVgOa9cPJYIJsGnJTAUsEcDOEVULO5x0rXBijc1lgXEzQQKhROf8zIV82w8eswc78YX11KYLWQRcgHNJElBxfXr72lS2RBSl07qTKorO2uUDZr3sFhYsvnhLZn0A94KRzJ/7DEGIAhW5ZWFpL8gEwu1aLA9MuWZzNwl8Oze9Y+bX+v9gywRVnoB5I/8kXTXU3141yRLYrIOOz6SOnyHNy4SieqzkBXharjfjqq1q6tklaEbA8Qfm2DaIPs7OTq/nvJBjKfO2H9bH2cCMh1+5gspfycu8f/cuuRmtDjyqZ7uCIMyjdV3a+p3fqmXsRx4C8lujezIFHnQiVTXLXuI1XrwN3+siYYj2HHTvESUx8DlOTXpak9qFRK+L3mgJ1WsD7F4cu1aJoFoYQnu+wGDMOjJM3kiBQWHCcvhJ/HRdxodOQp45YZaOTA22Nb4XKCVxqkbwMYFhzYQYIAnCW8FW14uf98jhUG2zrKhQQ0q0CEq0t5nXyvUyvR8DvD69LU+g3i+HFWQMQ8PqZuHD+sNKAV0+M6EJC0szq7rEr7B5bQ8BcNHzvDMc9eqB5ZCQdTf80Obn4uzjwpYU7SISdtV0QGa9D3Wrh2BDQtpBKxaNFV+/Cy2P/Sv+8s7Ud0Fd74X4+o/TNztWgETUapy+majNQ68Lq3ee0ZO48VEbTZYiH1Co4OlfWef82RWeyUXo7woM03PyapGfikTnQinoNq5z5veLpeMV3HCAMTaZmA1oGLAn7XS3XYsz+XK7VMQsc4XKrmDXOLU/pSXVNUq8dIqTba///3x6LiLS6xs1xuCAYSfcQ3+rQgmu7uvf3THKt5Ooo97TqcbRqxx7EASizaQCBQllG/rYxVapMLgtLbZS64w1MDBMXX+PQpBKNwqUKOf2DDRDUXQf9EhOS0Qj4nTmlA8dzSLz/G1d+Ud8MTy/6ghhdiLpeerGY/UlDOfiuqFsMUU5/UYlP+BAmgRLuNpvrUaLlVkrqDievNVEAwF+4CoM1MZTmjxjJMsKJq+u8Zd7tNCUFy6LiyYXRJQ4VyvEQFFaCGKsxIwQkk7EzZ6LTJq2hUuPhvAW+gQnSG6J+MszC+7QCRHcnqDdyNRJ6T9xyS87A6MDutbzKGvGktpbXqtzWtXb9HsfK2cBMomjN9a4y+TaJLnXxAeX/HWzmf4cR4vALt/P4w4qgKY04ml4ZdLOinFYS6cup3G/1ie4+t1eOnpBNlqGqs75ilzkT4+DsZQxNvaSKJ//6zIbbk/M7LOhFmRc/1R+kBtz7JFGdZm/COotIdvQoXpTqP/1uqEUmCb/QWoGLMwO5ANcHzxdY48IGP5+J+zKOTBFZ4Pid+GTM+Wq12MV/H86xEJptBa6T+p3kgpwLedManBHC2GgNrFpoN2xnrMz9WFWX/8/ygSBkavq2Uv7FdCsLEYLu9LLIvAU0bNRDtzYl+/vXmjpIvuJFYjmI0im6QEYqnIeMsNjXG4vIutIGHijeAG/9EDBozKV5cldkHbLxHh25vT+ZEzbhXlqvpzKJwcEgfNwLAKFeo0/pvEE10XDB+EXRTXtSzJozQKFFAJhMxYkVaCW+E9AL7tMeU8acxidHqzb6lX4691UsDpy/LLRmT+epgW56+5Cw8tB4kMUv6s9lh3eRKbyGs+H/4mQMaYzPTf2OOdokEn+zzgvoD3FqNKk8QqGAXVsqcGdXrT62fSPkR2vROFi68A6se86UxRUk4cajfPyCC4G5wDhD+zNq4jodQ4u4n/m37Lr36n4LIAAsVr02dFi9AiwA81MYs2rm4eDlDNmdMRvEKRHfBwW5DdMNp0jPFZMeARqF/wL4XBfd+EMLBfMzpH5GH6NaW+1vrvMdg+VxDzatk3MXgO3ro3P/DpcC6+Mo4MySJhKJhSR01SGGGp5hPWmrrUgrv3lDnP+HhcI3nt3YqBoVAVTBAQT5iuhTg8nvPtd8ZeYj6w1x6RqGUBrSku7+N1+BaasZvjTk64RoIDlL8brpEcJx3OmY7jLoZsswdtmhfC/G21llXhITOwmvRDDeTTPbyASOa16cF5/A1fZAidJpqju3wYAy9avPR1ya6eNp9K8XYrrtuxlqi+bDKwlfrYdR0RRiKRVTLOH85+ZY7XSmzRpfZBJjaTa81VDcJHpZnZnSQLASGYW9l51ZV/h7eVzTi3Hv6hUsgc/51AqJRTkpbFVLXXszoBL8nBX0u/0jBLT8nH+fJePbrwURT58OY+UieRjd1vs04w0VG5VN2U6MoGZkQzKN/ptz0Q366dxoTGmj7i1NQGHi9GgnquXFYdrCfZBmeb7s0T6yrdlZH5cZuwHFyIJ/kAtGsTg0xH5taAAq44BAk1CPk9KVVbqQzrCUiFdF/6gtlPQ8bHHc1G1W92MXGZ5HEHftyLYs8mbD/9xYRUWkHmlM0zC2ilJlnNgV4bfALpQghxOUoZL7VTqtCHIaQSXm+YUMnpkXybnV+A6xlm2CVy8fn0Xlm2XRa0+zzOa21JWWmixfiPMSCZ7qA4rS93VN3pkpF1s5TonQjisHf7iU9ZGvUPOAKZcR1pbeVf/Ul7OhepGCaId9wOtqo7pJ7yLcBZ0pFkOF28y4zEI/kcUNmutBHaQpBdNM8vjCS6HZRokkeo88TBAjGyG7SR+6vUgTcyK9Imalj0kuxz0wmK+byQU11AiJFk/ya5dNduRClcnU64yGu/ieWSeOos1t3ep+RPIWQ2pyTYVbZltTbsb7NiwSi3AV+8KLWk7LxCnfZUetEM8ThnsSoGH38/nyAwFguJp8FjvlHtcWZuU4hPva0rHfr0UhOOJ/F6vS62FW7KzkmRll2HEc7oUq4fyi5T70Vl7YVIfsPHUCdHesf9Lk7WNVWO75JDkYbMI8TOW8JKVtLY9d6UJRITO8oKo0xS+o99Yy04iniGHAaGj88kEWgwv0OrHdY/nr76DOGNS59hXCGXzTKUvDl9iKpLSWYN1lxIeyywdNpTkhay74w2jFT6NS8qkjo5CxA1yfSYwp6AJIZNKIeEK5PJAW7ORgWgwp0VgzYpqovMrWxbu+DGZ6Lhie1RAqpzm8VUzKJOH3mCzWuTOLsN3VT/dv2eeYe9UjbR8YTBsLz7q60VN1sU51k+um1f8JxD5pPhbhSC8rRaB454tmh6YUWrJI3+GWY0qeWioj/tbkYITOkJaeuGt4JrJvHA+l0Gu7kY7XOaa05alMnRWVCXqFgLIwSY4uF59Ue5SU4QKuc/HamDxbr0x6csCetXGoP7Qn1Bk/J9DsynO/UD6iZ1Hyrz+jit0hDCwi/E9OjgKTbB3ZQKQ/0ZOvevfNHG0NK4Aj3Cp7NpRk07RT1i/S0EL93Ag8GRgKI9CfpajKyK6+Jj/PI1KO5/85VAwz2AwzP8FTBb075IxCXv6T9RVvWT2tUaqxDS92zrGUbWzUYk9mSs82pECH+fkqsDt93VW++4YsR/dHCYcQSYTO/KaBMDj9LSD/J/+z20Kq8XvZUAIHtm9hRPP3ItbuAu2Hm5lkPs92pd7kCxgRs0xOVBnZ13ccdA0aunrwv9SdqElJRC3g+oCu+nXyCgmXUs9yMjTMAIHfxZV+aPKcZeUBWt057Xo85Ks1Ir5gzEHCWqZEhrLZMuF11ziGtFQUds/EESajhagzcKsxamcSZxGth4UII+adPhQkUnx2WyN+4YWR+r3f8MnkyGFuR4zjzxJS8WsQYR5PTyRaD9ixa6Mh741nBHbzfjXHskGDq179xaRNrCIB1z1xRfWfjqw2pHc1zk9xlPpL8sQWAIuETZZhbnmL54rceXVNRvUiKrrqIkeogsl0XXb17ylNb0f4GA9Wd44vffEG8FSZGHEL2fbaTGRcSiCeA8PmA/f6Hz8HCS76fXUHwgwkzSwlI71ekZ7Fapmlk/KC+Hs8hUcw3N2LN5LhkVYyizYFl/uPeVP5lsoJHhhfWvvSWruCUW1ZcJOeuTbrDgywJ/qG07gZJplnTvLcYdNaH0KMYOYMGX+rB4NGPFmQsNaIwlWrfCezxre8zXBrsMT+edVLbLqN1BqB76JH4BvZTqUIMfGwPGEn+EnmTV86fPBaYbFL3DFEhjB45CewkXEAtJxk4/Ms2pPXnaRqdky0HOYdcUcE2zcXq4vaIvW2/v0nHFJH2XXe22ueDmq/18XGtELSq85j9X8q0tcNSSKJIX8FTuJF/Pf8j5PhqG2u+osvsLxYrvvfeVJL+4tkcXcr9JV7v0ERmj/X6fM3NC4j6dS1+9Umr2oPavqiAydTZPLMNRGY23LO9zAVDly7jD+70G5TPPLdhRIl4WxcYjLnM+SNcJ26FOrkrISUtPObIz5Zb3AG612krnpy15RMW+1cQjlnWFI6538qky9axd2oJmHIHP08KyP0ubGO+TQNOYuv2uh17yCIvR8VcStw7o1g0NM60sk+8Tq7YfIBJrtp53GkvzXH7OA0p8/n/u1satf/VJhtR1l8Wa6Gmaug7haSpaCaYQax6ta0mkutlb+eAOSG1aobM81D9A4iS1RRlzBBoVX6tU1S6WE2N9ORY6DfeLRC4l9Rvr5h95XDWB2mR1d4WFudpsgVYwiTwT31ljskD8ZyDOlm5DkGh9N/UB/0AI5Xvb8ZBmai2hQ4BWMqFwYnzxwB26YHSOv9WgY3JXnvoN+2R4rqGVh/LLDMtpFP+SpMGJNWvbIl5SOodbCczW2RKleksPoUeGEzrjtKHVdtZA+kfqO+rVx/iclCqwoopepvJpSTDjT+b9GWylGRF8EDbGlw6eUzmJM95Ovoz+kwLX3c2fTjFeYEsE7vUZm3mqdGJuKh2w9/QGSaqRHs99aScGOdDqkFcACoqdbBoQqqjamhH6Q9ng39JCg3lrGJwd50Qk9ovnqBTr8MME7Ps2wiVfygUmPoUBJJfJWX5Nda0nuncbFkA=='));
}
exports.getData = getData;

},{"./decoder.js":35,"@ethersproject/base64":21}],37:[function(require,module,exports){
"use strict";

/**
 * MIT License
 *
 * Copyright (c) 2021 Andrew Raffensperger
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * This is a near carbon-copy of the original source (link below) with the
 * TypeScript typings added and a few tweaks to make it ES3-compatible.
 *
 * See: https://github.com/adraffy/ens-normalize.js
 */
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ens_normalize = exports.ens_normalize_post_check = void 0;
var strings_1 = require("@ethersproject/strings");
var include_js_1 = require("./include.js");
var r = (0, include_js_1.getData)();
var decoder_js_1 = require("./decoder.js");
// @TODO: This should be lazily loaded
var VALID = new Set((0, decoder_js_1.read_member_array)(r));
var IGNORED = new Set((0, decoder_js_1.read_member_array)(r));
var MAPPED = (0, decoder_js_1.read_mapped_map)(r);
var EMOJI_ROOT = (0, decoder_js_1.read_emoji_trie)(r);
//const NFC_CHECK = new Set(read_member_array(r, Array.from(VALID.values()).sort((a, b) => a - b)));
//const STOP = 0x2E;
var HYPHEN = 0x2D;
var UNDERSCORE = 0x5F;
function explode_cp(name) {
  return (0, strings_1.toUtf8CodePoints)(name);
}
function filter_fe0f(cps) {
  return cps.filter(function (cp) {
    return cp != 0xFE0F;
  });
}
function ens_normalize_post_check(name) {
  for (var _i = 0, _a = name.split('.'); _i < _a.length; _i++) {
    var label = _a[_i];
    var cps = explode_cp(label);
    try {
      for (var i = cps.lastIndexOf(UNDERSCORE) - 1; i >= 0; i--) {
        if (cps[i] !== UNDERSCORE) {
          throw new Error("underscore only allowed at start");
        }
      }
      if (cps.length >= 4 && cps.every(function (cp) {
        return cp < 0x80;
      }) && cps[2] === HYPHEN && cps[3] === HYPHEN) {
        throw new Error("invalid label extension");
      }
    } catch (err) {
      throw new Error("Invalid label \"" + label + "\": " + err.message);
    }
  }
  return name;
}
exports.ens_normalize_post_check = ens_normalize_post_check;
function ens_normalize(name) {
  return ens_normalize_post_check(normalize(name, filter_fe0f));
}
exports.ens_normalize = ens_normalize;
function normalize(name, emoji_filter) {
  var input = explode_cp(name).reverse(); // flip for pop
  var output = [];
  while (input.length) {
    var emoji = consume_emoji_reversed(input);
    if (emoji) {
      output.push.apply(output, emoji_filter(emoji));
      continue;
    }
    var cp = input.pop();
    if (VALID.has(cp)) {
      output.push(cp);
      continue;
    }
    if (IGNORED.has(cp)) {
      continue;
    }
    var cps = MAPPED[cp];
    if (cps) {
      output.push.apply(output, cps);
      continue;
    }
    throw new Error("Disallowed codepoint: 0x" + cp.toString(16).toUpperCase());
  }
  return ens_normalize_post_check(nfc(String.fromCodePoint.apply(String, output)));
}
function nfc(s) {
  return s.normalize('NFC');
}
function consume_emoji_reversed(cps, eaten) {
  var _a;
  var node = EMOJI_ROOT;
  var emoji;
  var saved;
  var stack = [];
  var pos = cps.length;
  if (eaten) eaten.length = 0; // clear input buffer (if needed)
  var _loop_1 = function _loop_1() {
    var cp = cps[--pos];
    node = (_a = node.branches.find(function (x) {
      return x.set.has(cp);
    })) === null || _a === void 0 ? void 0 : _a.node;
    if (!node) return "break";
    if (node.save) {
      // remember
      saved = cp;
    } else if (node.check) {
      // check exclusion
      if (cp === saved) return "break";
    }
    stack.push(cp);
    if (node.fe0f) {
      stack.push(0xFE0F);
      if (pos > 0 && cps[pos - 1] == 0xFE0F) pos--; // consume optional FE0F
    }
    if (node.valid) {
      // this is a valid emoji (so far)
      emoji = stack.slice(); // copy stack
      if (node.valid == 2) emoji.splice(1, 1); // delete FE0F at position 1 (RGI ZWJ don't follow spec!)
      if (eaten) eaten.push.apply(eaten, cps.slice(pos).reverse()); // copy input (if needed)
      cps.length = pos; // truncate
    }
  };
  while (pos) {
    var state_1 = _loop_1();
    if (state_1 === "break") break;
  }
  return emoji;
}

},{"./decoder.js":35,"./include.js":36,"@ethersproject/strings":53}],38:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.id = void 0;
var keccak256_1 = require("@ethersproject/keccak256");
var strings_1 = require("@ethersproject/strings");
function id(text) {
  return (0, keccak256_1.keccak256)((0, strings_1.toUtf8Bytes)(text));
}
exports.id = id;

},{"@ethersproject/keccak256":43,"@ethersproject/strings":53}],39:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._TypedDataEncoder = exports.hashMessage = exports.messagePrefix = exports.ensNormalize = exports.isValidName = exports.namehash = exports.dnsEncode = exports.id = void 0;
var id_1 = require("./id");
Object.defineProperty(exports, "id", {
  enumerable: true,
  get: function get() {
    return id_1.id;
  }
});
var namehash_1 = require("./namehash");
Object.defineProperty(exports, "dnsEncode", {
  enumerable: true,
  get: function get() {
    return namehash_1.dnsEncode;
  }
});
Object.defineProperty(exports, "isValidName", {
  enumerable: true,
  get: function get() {
    return namehash_1.isValidName;
  }
});
Object.defineProperty(exports, "namehash", {
  enumerable: true,
  get: function get() {
    return namehash_1.namehash;
  }
});
var message_1 = require("./message");
Object.defineProperty(exports, "hashMessage", {
  enumerable: true,
  get: function get() {
    return message_1.hashMessage;
  }
});
Object.defineProperty(exports, "messagePrefix", {
  enumerable: true,
  get: function get() {
    return message_1.messagePrefix;
  }
});
var namehash_2 = require("./namehash");
Object.defineProperty(exports, "ensNormalize", {
  enumerable: true,
  get: function get() {
    return namehash_2.ensNormalize;
  }
});
var typed_data_1 = require("./typed-data");
Object.defineProperty(exports, "_TypedDataEncoder", {
  enumerable: true,
  get: function get() {
    return typed_data_1.TypedDataEncoder;
  }
});

},{"./id":38,"./message":40,"./namehash":41,"./typed-data":42}],40:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hashMessage = exports.messagePrefix = void 0;
var bytes_1 = require("@ethersproject/bytes");
var keccak256_1 = require("@ethersproject/keccak256");
var strings_1 = require("@ethersproject/strings");
exports.messagePrefix = "\x19Ethereum Signed Message:\n";
function hashMessage(message) {
  if (typeof message === "string") {
    message = (0, strings_1.toUtf8Bytes)(message);
  }
  return (0, keccak256_1.keccak256)((0, bytes_1.concat)([(0, strings_1.toUtf8Bytes)(exports.messagePrefix), (0, strings_1.toUtf8Bytes)(String(message.length)), message]));
}
exports.hashMessage = hashMessage;

},{"@ethersproject/bytes":28,"@ethersproject/keccak256":43,"@ethersproject/strings":53}],41:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.dnsEncode = exports.namehash = exports.isValidName = exports.ensNormalize = void 0;
var bytes_1 = require("@ethersproject/bytes");
var strings_1 = require("@ethersproject/strings");
var keccak256_1 = require("@ethersproject/keccak256");
var logger_1 = require("@ethersproject/logger");
var _version_1 = require("./_version");
var logger = new logger_1.Logger(_version_1.version);
var lib_1 = require("./ens-normalize/lib");
var Zeros = new Uint8Array(32);
Zeros.fill(0);
function checkComponent(comp) {
  if (comp.length === 0) {
    throw new Error("invalid ENS name; empty component");
  }
  return comp;
}
function ensNameSplit(name) {
  var bytes = (0, strings_1.toUtf8Bytes)((0, lib_1.ens_normalize)(name));
  var comps = [];
  if (name.length === 0) {
    return comps;
  }
  var last = 0;
  for (var i = 0; i < bytes.length; i++) {
    var d = bytes[i];
    // A separator (i.e. "."); copy this component
    if (d === 0x2e) {
      comps.push(checkComponent(bytes.slice(last, i)));
      last = i + 1;
    }
  }
  // There was a stray separator at the end of the name
  if (last >= bytes.length) {
    throw new Error("invalid ENS name; empty component");
  }
  comps.push(checkComponent(bytes.slice(last)));
  return comps;
}
function ensNormalize(name) {
  return ensNameSplit(name).map(function (comp) {
    return (0, strings_1.toUtf8String)(comp);
  }).join(".");
}
exports.ensNormalize = ensNormalize;
function isValidName(name) {
  try {
    return ensNameSplit(name).length !== 0;
  } catch (error) {}
  return false;
}
exports.isValidName = isValidName;
function namehash(name) {
  /* istanbul ignore if */
  if (typeof name !== "string") {
    logger.throwArgumentError("invalid ENS name; not a string", "name", name);
  }
  var result = Zeros;
  var comps = ensNameSplit(name);
  while (comps.length) {
    result = (0, keccak256_1.keccak256)((0, bytes_1.concat)([result, (0, keccak256_1.keccak256)(comps.pop())]));
  }
  return (0, bytes_1.hexlify)(result);
}
exports.namehash = namehash;
function dnsEncode(name) {
  return (0, bytes_1.hexlify)((0, bytes_1.concat)(ensNameSplit(name).map(function (comp) {
    // DNS does not allow components over 63 bytes in length
    if (comp.length > 63) {
      throw new Error("invalid DNS encoded entry; length exceeds 63 bytes");
    }
    var bytes = new Uint8Array(comp.length + 1);
    bytes.set(comp, 1);
    bytes[0] = bytes.length - 1;
    return bytes;
  }))) + "00";
}
exports.dnsEncode = dnsEncode;

},{"./_version":34,"./ens-normalize/lib":37,"@ethersproject/bytes":28,"@ethersproject/keccak256":43,"@ethersproject/logger":45,"@ethersproject/strings":53}],42:[function(require,module,exports){
"use strict";

var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator = void 0 && (void 0).__generator || function (thisArg, body) {
  var _ = {
      label: 0,
      sent: function sent() {
        if (t[0] & 1) throw t[1];
        return t[1];
      },
      trys: [],
      ops: []
    },
    f,
    y,
    t,
    g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;
  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (_) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return {
            value: op[1],
            done: false
          };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TypedDataEncoder = void 0;
var address_1 = require("@ethersproject/address");
var bignumber_1 = require("@ethersproject/bignumber");
var bytes_1 = require("@ethersproject/bytes");
var keccak256_1 = require("@ethersproject/keccak256");
var properties_1 = require("@ethersproject/properties");
var logger_1 = require("@ethersproject/logger");
var _version_1 = require("./_version");
var logger = new logger_1.Logger(_version_1.version);
var id_1 = require("./id");
var padding = new Uint8Array(32);
padding.fill(0);
var NegativeOne = bignumber_1.BigNumber.from(-1);
var Zero = bignumber_1.BigNumber.from(0);
var One = bignumber_1.BigNumber.from(1);
var MaxUint256 = bignumber_1.BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function hexPadRight(value) {
  var bytes = (0, bytes_1.arrayify)(value);
  var padOffset = bytes.length % 32;
  if (padOffset) {
    return (0, bytes_1.hexConcat)([bytes, padding.slice(padOffset)]);
  }
  return (0, bytes_1.hexlify)(bytes);
}
var hexTrue = (0, bytes_1.hexZeroPad)(One.toHexString(), 32);
var hexFalse = (0, bytes_1.hexZeroPad)(Zero.toHexString(), 32);
var domainFieldTypes = {
  name: "string",
  version: "string",
  chainId: "uint256",
  verifyingContract: "address",
  salt: "bytes32"
};
var domainFieldNames = ["name", "version", "chainId", "verifyingContract", "salt"];
function checkString(key) {
  return function (value) {
    if (typeof value !== "string") {
      logger.throwArgumentError("invalid domain value for " + JSON.stringify(key), "domain." + key, value);
    }
    return value;
  };
}
var domainChecks = {
  name: checkString("name"),
  version: checkString("version"),
  chainId: function chainId(value) {
    try {
      return bignumber_1.BigNumber.from(value).toString();
    } catch (error) {}
    return logger.throwArgumentError("invalid domain value for \"chainId\"", "domain.chainId", value);
  },
  verifyingContract: function verifyingContract(value) {
    try {
      return (0, address_1.getAddress)(value).toLowerCase();
    } catch (error) {}
    return logger.throwArgumentError("invalid domain value \"verifyingContract\"", "domain.verifyingContract", value);
  },
  salt: function salt(value) {
    try {
      var bytes = (0, bytes_1.arrayify)(value);
      if (bytes.length !== 32) {
        throw new Error("bad length");
      }
      return (0, bytes_1.hexlify)(bytes);
    } catch (error) {}
    return logger.throwArgumentError("invalid domain value \"salt\"", "domain.salt", value);
  }
};
function getBaseEncoder(type) {
  // intXX and uintXX
  {
    var match = type.match(/^(u?)int(\d*)$/);
    if (match) {
      var signed = match[1] === "";
      var width = parseInt(match[2] || "256");
      if (width % 8 !== 0 || width > 256 || match[2] && match[2] !== String(width)) {
        logger.throwArgumentError("invalid numeric width", "type", type);
      }
      var boundsUpper_1 = MaxUint256.mask(signed ? width - 1 : width);
      var boundsLower_1 = signed ? boundsUpper_1.add(One).mul(NegativeOne) : Zero;
      return function (value) {
        var v = bignumber_1.BigNumber.from(value);
        if (v.lt(boundsLower_1) || v.gt(boundsUpper_1)) {
          logger.throwArgumentError("value out-of-bounds for " + type, "value", value);
        }
        return (0, bytes_1.hexZeroPad)(v.toTwos(256).toHexString(), 32);
      };
    }
  }
  // bytesXX
  {
    var match = type.match(/^bytes(\d+)$/);
    if (match) {
      var width_1 = parseInt(match[1]);
      if (width_1 === 0 || width_1 > 32 || match[1] !== String(width_1)) {
        logger.throwArgumentError("invalid bytes width", "type", type);
      }
      return function (value) {
        var bytes = (0, bytes_1.arrayify)(value);
        if (bytes.length !== width_1) {
          logger.throwArgumentError("invalid length for " + type, "value", value);
        }
        return hexPadRight(value);
      };
    }
  }
  switch (type) {
    case "address":
      return function (value) {
        return (0, bytes_1.hexZeroPad)((0, address_1.getAddress)(value), 32);
      };
    case "bool":
      return function (value) {
        return !value ? hexFalse : hexTrue;
      };
    case "bytes":
      return function (value) {
        return (0, keccak256_1.keccak256)(value);
      };
    case "string":
      return function (value) {
        return (0, id_1.id)(value);
      };
  }
  return null;
}
function encodeType(name, fields) {
  return name + "(" + fields.map(function (_a) {
    var name = _a.name,
      type = _a.type;
    return type + " " + name;
  }).join(",") + ")";
}
var TypedDataEncoder = /** @class */function () {
  function TypedDataEncoder(types) {
    (0, properties_1.defineReadOnly)(this, "types", Object.freeze((0, properties_1.deepCopy)(types)));
    (0, properties_1.defineReadOnly)(this, "_encoderCache", {});
    (0, properties_1.defineReadOnly)(this, "_types", {});
    // Link struct types to their direct child structs
    var links = {};
    // Link structs to structs which contain them as a child
    var parents = {};
    // Link all subtypes within a given struct
    var subtypes = {};
    Object.keys(types).forEach(function (type) {
      links[type] = {};
      parents[type] = [];
      subtypes[type] = {};
    });
    var _loop_1 = function _loop_1(name_1) {
      var uniqueNames = {};
      types[name_1].forEach(function (field) {
        // Check each field has a unique name
        if (uniqueNames[field.name]) {
          logger.throwArgumentError("duplicate variable name " + JSON.stringify(field.name) + " in " + JSON.stringify(name_1), "types", types);
        }
        uniqueNames[field.name] = true;
        // Get the base type (drop any array specifiers)
        var baseType = field.type.match(/^([^\x5b]*)(\x5b|$)/)[1];
        if (baseType === name_1) {
          logger.throwArgumentError("circular type reference to " + JSON.stringify(baseType), "types", types);
        }
        // Is this a base encoding type?
        var encoder = getBaseEncoder(baseType);
        if (encoder) {
          return;
        }
        if (!parents[baseType]) {
          logger.throwArgumentError("unknown type " + JSON.stringify(baseType), "types", types);
        }
        // Add linkage
        parents[baseType].push(name_1);
        links[name_1][baseType] = true;
      });
    };
    for (var name_1 in types) {
      _loop_1(name_1);
    }
    // Deduce the primary type
    var primaryTypes = Object.keys(parents).filter(function (n) {
      return parents[n].length === 0;
    });
    if (primaryTypes.length === 0) {
      logger.throwArgumentError("missing primary type", "types", types);
    } else if (primaryTypes.length > 1) {
      logger.throwArgumentError("ambiguous primary types or unused types: " + primaryTypes.map(function (t) {
        return JSON.stringify(t);
      }).join(", "), "types", types);
    }
    (0, properties_1.defineReadOnly)(this, "primaryType", primaryTypes[0]);
    // Check for circular type references
    function checkCircular(type, found) {
      if (found[type]) {
        logger.throwArgumentError("circular type reference to " + JSON.stringify(type), "types", types);
      }
      found[type] = true;
      Object.keys(links[type]).forEach(function (child) {
        if (!parents[child]) {
          return;
        }
        // Recursively check children
        checkCircular(child, found);
        // Mark all ancestors as having this decendant
        Object.keys(found).forEach(function (subtype) {
          subtypes[subtype][child] = true;
        });
      });
      delete found[type];
    }
    checkCircular(this.primaryType, {});
    // Compute each fully describe type
    for (var name_2 in subtypes) {
      var st = Object.keys(subtypes[name_2]);
      st.sort();
      this._types[name_2] = encodeType(name_2, types[name_2]) + st.map(function (t) {
        return encodeType(t, types[t]);
      }).join("");
    }
  }
  TypedDataEncoder.prototype.getEncoder = function (type) {
    var encoder = this._encoderCache[type];
    if (!encoder) {
      encoder = this._encoderCache[type] = this._getEncoder(type);
    }
    return encoder;
  };
  TypedDataEncoder.prototype._getEncoder = function (type) {
    var _this = this;
    // Basic encoder type (address, bool, uint256, etc)
    {
      var encoder = getBaseEncoder(type);
      if (encoder) {
        return encoder;
      }
    }
    // Array
    var match = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
    if (match) {
      var subtype_1 = match[1];
      var subEncoder_1 = this.getEncoder(subtype_1);
      var length_1 = parseInt(match[3]);
      return function (value) {
        if (length_1 >= 0 && value.length !== length_1) {
          logger.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", value);
        }
        var result = value.map(subEncoder_1);
        if (_this._types[subtype_1]) {
          result = result.map(keccak256_1.keccak256);
        }
        return (0, keccak256_1.keccak256)((0, bytes_1.hexConcat)(result));
      };
    }
    // Struct
    var fields = this.types[type];
    if (fields) {
      var encodedType_1 = (0, id_1.id)(this._types[type]);
      return function (value) {
        var values = fields.map(function (_a) {
          var name = _a.name,
            type = _a.type;
          var result = _this.getEncoder(type)(value[name]);
          if (_this._types[type]) {
            return (0, keccak256_1.keccak256)(result);
          }
          return result;
        });
        values.unshift(encodedType_1);
        return (0, bytes_1.hexConcat)(values);
      };
    }
    return logger.throwArgumentError("unknown type: " + type, "type", type);
  };
  TypedDataEncoder.prototype.encodeType = function (name) {
    var result = this._types[name];
    if (!result) {
      logger.throwArgumentError("unknown type: " + JSON.stringify(name), "name", name);
    }
    return result;
  };
  TypedDataEncoder.prototype.encodeData = function (type, value) {
    return this.getEncoder(type)(value);
  };
  TypedDataEncoder.prototype.hashStruct = function (name, value) {
    return (0, keccak256_1.keccak256)(this.encodeData(name, value));
  };
  TypedDataEncoder.prototype.encode = function (value) {
    return this.encodeData(this.primaryType, value);
  };
  TypedDataEncoder.prototype.hash = function (value) {
    return this.hashStruct(this.primaryType, value);
  };
  TypedDataEncoder.prototype._visit = function (type, value, callback) {
    var _this = this;
    // Basic encoder type (address, bool, uint256, etc)
    {
      var encoder = getBaseEncoder(type);
      if (encoder) {
        return callback(type, value);
      }
    }
    // Array
    var match = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
    if (match) {
      var subtype_2 = match[1];
      var length_2 = parseInt(match[3]);
      if (length_2 >= 0 && value.length !== length_2) {
        logger.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", value);
      }
      return value.map(function (v) {
        return _this._visit(subtype_2, v, callback);
      });
    }
    // Struct
    var fields = this.types[type];
    if (fields) {
      return fields.reduce(function (accum, _a) {
        var name = _a.name,
          type = _a.type;
        accum[name] = _this._visit(type, value[name], callback);
        return accum;
      }, {});
    }
    return logger.throwArgumentError("unknown type: " + type, "type", type);
  };
  TypedDataEncoder.prototype.visit = function (value, callback) {
    return this._visit(this.primaryType, value, callback);
  };
  TypedDataEncoder.from = function (types) {
    return new TypedDataEncoder(types);
  };
  TypedDataEncoder.getPrimaryType = function (types) {
    return TypedDataEncoder.from(types).primaryType;
  };
  TypedDataEncoder.hashStruct = function (name, types, value) {
    return TypedDataEncoder.from(types).hashStruct(name, value);
  };
  TypedDataEncoder.hashDomain = function (domain) {
    var domainFields = [];
    for (var name_3 in domain) {
      var type = domainFieldTypes[name_3];
      if (!type) {
        logger.throwArgumentError("invalid typed-data domain key: " + JSON.stringify(name_3), "domain", domain);
      }
      domainFields.push({
        name: name_3,
        type: type
      });
    }
    domainFields.sort(function (a, b) {
      return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b.name);
    });
    return TypedDataEncoder.hashStruct("EIP712Domain", {
      EIP712Domain: domainFields
    }, domain);
  };
  TypedDataEncoder.encode = function (domain, types, value) {
    return (0, bytes_1.hexConcat)(["0x1901", TypedDataEncoder.hashDomain(domain), TypedDataEncoder.from(types).hash(value)]);
  };
  TypedDataEncoder.hash = function (domain, types, value) {
    return (0, keccak256_1.keccak256)(TypedDataEncoder.encode(domain, types, value));
  };
  // Replaces all address types with ENS names with their looked up address
  TypedDataEncoder.resolveNames = function (domain, types, value, resolveName) {
    return __awaiter(this, void 0, void 0, function () {
      var ensCache, encoder, _a, _b, _i, name_4, _c, _d;
      return __generator(this, function (_e) {
        switch (_e.label) {
          case 0:
            // Make a copy to isolate it from the object passed in
            domain = (0, properties_1.shallowCopy)(domain);
            ensCache = {};
            // Do we need to look up the domain's verifyingContract?
            if (domain.verifyingContract && !(0, bytes_1.isHexString)(domain.verifyingContract, 20)) {
              ensCache[domain.verifyingContract] = "0x";
            }
            encoder = TypedDataEncoder.from(types);
            // Get a list of all the addresses
            encoder.visit(value, function (type, value) {
              if (type === "address" && !(0, bytes_1.isHexString)(value, 20)) {
                ensCache[value] = "0x";
              }
              return value;
            });
            _a = [];
            for (_b in ensCache) _a.push(_b);
            _i = 0;
            _e.label = 1;
          case 1:
            if (!(_i < _a.length)) return [3 /*break*/, 4];
            name_4 = _a[_i];
            _c = ensCache;
            _d = name_4;
            return [4 /*yield*/, resolveName(name_4)];
          case 2:
            _c[_d] = _e.sent();
            _e.label = 3;
          case 3:
            _i++;
            return [3 /*break*/, 1];
          case 4:
            // Replace the domain verifyingContract if needed
            if (domain.verifyingContract && ensCache[domain.verifyingContract]) {
              domain.verifyingContract = ensCache[domain.verifyingContract];
            }
            // Replace all ENS names with their address
            value = encoder.visit(value, function (type, value) {
              if (type === "address" && ensCache[value]) {
                return ensCache[value];
              }
              return value;
            });
            return [2 /*return*/, {
              domain: domain,
              value: value
            }];
        }
      });
    });
  };
  TypedDataEncoder.getPayload = function (domain, types, value) {
    // Validate the domain fields
    TypedDataEncoder.hashDomain(domain);
    // Derive the EIP712Domain Struct reference type
    var domainValues = {};
    var domainTypes = [];
    domainFieldNames.forEach(function (name) {
      var value = domain[name];
      if (value == null) {
        return;
      }
      domainValues[name] = domainChecks[name](value);
      domainTypes.push({
        name: name,
        type: domainFieldTypes[name]
      });
    });
    var encoder = TypedDataEncoder.from(types);
    var typesWithDomain = (0, properties_1.shallowCopy)(types);
    if (typesWithDomain.EIP712Domain) {
      logger.throwArgumentError("types must not contain EIP712Domain type", "types.EIP712Domain", types);
    } else {
      typesWithDomain.EIP712Domain = domainTypes;
    }
    // Validate the data structures and types
    encoder.encode(value);
    return {
      types: typesWithDomain,
      domain: domainValues,
      primaryType: encoder.primaryType,
      message: encoder.visit(value, function (type, value) {
        // bytes
        if (type.match(/^bytes(\d*)/)) {
          return (0, bytes_1.hexlify)((0, bytes_1.arrayify)(value));
        }
        // uint or int
        if (type.match(/^u?int/)) {
          return bignumber_1.BigNumber.from(value).toString();
        }
        switch (type) {
          case "address":
            return value.toLowerCase();
          case "bool":
            return !!value;
          case "string":
            if (typeof value !== "string") {
              logger.throwArgumentError("invalid string", "value", value);
            }
            return value;
        }
        return logger.throwArgumentError("unsupported type", "type", type);
      })
    };
  };
  return TypedDataEncoder;
}();
exports.TypedDataEncoder = TypedDataEncoder;

},{"./_version":34,"./id":38,"@ethersproject/address":19,"@ethersproject/bignumber":25,"@ethersproject/bytes":28,"@ethersproject/keccak256":43,"@ethersproject/logger":45,"@ethersproject/properties":47}],43:[function(require,module,exports){
"use strict";

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.keccak256 = void 0;
var js_sha3_1 = __importDefault(require("js-sha3"));
var bytes_1 = require("@ethersproject/bytes");
function keccak256(data) {
  return '0x' + js_sha3_1["default"].keccak_256((0, bytes_1.arrayify)(data));
}
exports.keccak256 = keccak256;

},{"@ethersproject/bytes":28,"js-sha3":331}],44:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.version = void 0;
exports.version = "logger/5.7.0";

},{}],45:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Logger = exports.ErrorCode = exports.LogLevel = void 0;
var _permanentCensorErrors = false;
var _censorErrors = false;
var LogLevels = {
  debug: 1,
  "default": 2,
  info: 2,
  warning: 3,
  error: 4,
  off: 5
};
var _logLevel = LogLevels["default"];
var _version_1 = require("./_version");
var _globalLogger = null;
function _checkNormalize() {
  try {
    var missing_1 = [];
    // Make sure all forms of normalization are supported
    ["NFD", "NFC", "NFKD", "NFKC"].forEach(function (form) {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }
        ;
      } catch (error) {
        missing_1.push(form);
      }
    });
    if (missing_1.length) {
      throw new Error("missing " + missing_1.join(", "));
    }
    if (String.fromCharCode(0xe9).normalize("NFD") !== String.fromCharCode(0x65, 0x0301)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    return error.message;
  }
  return null;
}
var _normalizeError = _checkNormalize();
var LogLevel;
(function (LogLevel) {
  LogLevel["DEBUG"] = "DEBUG";
  LogLevel["INFO"] = "INFO";
  LogLevel["WARNING"] = "WARNING";
  LogLevel["ERROR"] = "ERROR";
  LogLevel["OFF"] = "OFF";
})(LogLevel = exports.LogLevel || (exports.LogLevel = {}));
var ErrorCode;
(function (ErrorCode) {
  ///////////////////
  // Generic Errors
  // Unknown Error
  ErrorCode["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
  // Not Implemented
  ErrorCode["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
  // Unsupported Operation
  //   - operation
  ErrorCode["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
  // Network Error (i.e. Ethereum Network, such as an invalid chain ID)
  //   - event ("noNetwork" is not re-thrown in provider.ready; otherwise thrown)
  ErrorCode["NETWORK_ERROR"] = "NETWORK_ERROR";
  // Some sort of bad response from the server
  ErrorCode["SERVER_ERROR"] = "SERVER_ERROR";
  // Timeout
  ErrorCode["TIMEOUT"] = "TIMEOUT";
  ///////////////////
  // Operational  Errors
  // Buffer Overrun
  ErrorCode["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
  // Numeric Fault
  //   - operation: the operation being executed
  //   - fault: the reason this faulted
  ErrorCode["NUMERIC_FAULT"] = "NUMERIC_FAULT";
  ///////////////////
  // Argument Errors
  // Missing new operator to an object
  //  - name: The name of the class
  ErrorCode["MISSING_NEW"] = "MISSING_NEW";
  // Invalid argument (e.g. value is incompatible with type) to a function:
  //   - argument: The argument name that was invalid
  //   - value: The value of the argument
  ErrorCode["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
  // Missing argument to a function:
  //   - count: The number of arguments received
  //   - expectedCount: The number of arguments expected
  ErrorCode["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
  // Too many arguments
  //   - count: The number of arguments received
  //   - expectedCount: The number of arguments expected
  ErrorCode["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
  ///////////////////
  // Blockchain Errors
  // Call exception
  //  - transaction: the transaction
  //  - address?: the contract address
  //  - args?: The arguments passed into the function
  //  - method?: The Solidity method signature
  //  - errorSignature?: The EIP848 error signature
  //  - errorArgs?: The EIP848 error parameters
  //  - reason: The reason (only for EIP848 "Error(string)")
  ErrorCode["CALL_EXCEPTION"] = "CALL_EXCEPTION";
  // Insufficient funds (< value + gasLimit * gasPrice)
  //   - transaction: the transaction attempted
  ErrorCode["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
  // Nonce has already been used
  //   - transaction: the transaction attempted
  ErrorCode["NONCE_EXPIRED"] = "NONCE_EXPIRED";
  // The replacement fee for the transaction is too low
  //   - transaction: the transaction attempted
  ErrorCode["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
  // The gas limit could not be estimated
  //   - transaction: the transaction passed to estimateGas
  ErrorCode["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
  // The transaction was replaced by one with a higher gas price
  //   - reason: "cancelled", "replaced" or "repriced"
  //   - cancelled: true if reason == "cancelled" or reason == "replaced")
  //   - hash: original transaction hash
  //   - replacement: the full TransactionsResponse for the replacement
  //   - receipt: the receipt of the replacement
  ErrorCode["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
  ///////////////////
  // Interaction Errors
  // The user rejected the action, such as signing a message or sending
  // a transaction
  ErrorCode["ACTION_REJECTED"] = "ACTION_REJECTED";
})(ErrorCode = exports.ErrorCode || (exports.ErrorCode = {}));
;
var HEX = "0123456789abcdef";
var Logger = /** @class */function () {
  function Logger(version) {
    Object.defineProperty(this, "version", {
      enumerable: true,
      value: version,
      writable: false
    });
  }
  Logger.prototype._log = function (logLevel, args) {
    var level = logLevel.toLowerCase();
    if (LogLevels[level] == null) {
      this.throwArgumentError("invalid log level name", "logLevel", logLevel);
    }
    if (_logLevel > LogLevels[level]) {
      return;
    }
    console.log.apply(console, args);
  };
  Logger.prototype.debug = function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    this._log(Logger.levels.DEBUG, args);
  };
  Logger.prototype.info = function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    this._log(Logger.levels.INFO, args);
  };
  Logger.prototype.warn = function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    this._log(Logger.levels.WARNING, args);
  };
  Logger.prototype.makeError = function (message, code, params) {
    // Errors are being censored
    if (_censorErrors) {
      return this.makeError("censored error", code, {});
    }
    if (!code) {
      code = Logger.errors.UNKNOWN_ERROR;
    }
    if (!params) {
      params = {};
    }
    var messageDetails = [];
    Object.keys(params).forEach(function (key) {
      var value = params[key];
      try {
        if (value instanceof Uint8Array) {
          var hex = "";
          for (var i = 0; i < value.length; i++) {
            hex += HEX[value[i] >> 4];
            hex += HEX[value[i] & 0x0f];
          }
          messageDetails.push(key + "=Uint8Array(0x" + hex + ")");
        } else {
          messageDetails.push(key + "=" + JSON.stringify(value));
        }
      } catch (error) {
        messageDetails.push(key + "=" + JSON.stringify(params[key].toString()));
      }
    });
    messageDetails.push("code=" + code);
    messageDetails.push("version=" + this.version);
    var reason = message;
    var url = "";
    switch (code) {
      case ErrorCode.NUMERIC_FAULT:
        {
          url = "NUMERIC_FAULT";
          var fault = message;
          switch (fault) {
            case "overflow":
            case "underflow":
            case "division-by-zero":
              url += "-" + fault;
              break;
            case "negative-power":
            case "negative-width":
              url += "-unsupported";
              break;
            case "unbound-bitwise-result":
              url += "-unbound-result";
              break;
          }
          break;
        }
      case ErrorCode.CALL_EXCEPTION:
      case ErrorCode.INSUFFICIENT_FUNDS:
      case ErrorCode.MISSING_NEW:
      case ErrorCode.NONCE_EXPIRED:
      case ErrorCode.REPLACEMENT_UNDERPRICED:
      case ErrorCode.TRANSACTION_REPLACED:
      case ErrorCode.UNPREDICTABLE_GAS_LIMIT:
        url = code;
        break;
    }
    if (url) {
      message += " [ See: https:/\/links.ethers.org/v5-errors-" + url + " ]";
    }
    if (messageDetails.length) {
      message += " (" + messageDetails.join(", ") + ")";
    }
    // @TODO: Any??
    var error = new Error(message);
    error.reason = reason;
    error.code = code;
    Object.keys(params).forEach(function (key) {
      error[key] = params[key];
    });
    return error;
  };
  Logger.prototype.throwError = function (message, code, params) {
    throw this.makeError(message, code, params);
  };
  Logger.prototype.throwArgumentError = function (message, name, value) {
    return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {
      argument: name,
      value: value
    });
  };
  Logger.prototype.assert = function (condition, message, code, params) {
    if (!!condition) {
      return;
    }
    this.throwError(message, code, params);
  };
  Logger.prototype.assertArgument = function (condition, message, name, value) {
    if (!!condition) {
      return;
    }
    this.throwArgumentError(message, name, value);
  };
  Logger.prototype.checkNormalize = function (message) {
    if (message == null) {
      message = "platform missing String.prototype.normalize";
    }
    if (_normalizeError) {
      this.throwError("platform missing String.prototype.normalize", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "String.prototype.normalize",
        form: _normalizeError
      });
    }
  };
  Logger.prototype.checkSafeUint53 = function (value, message) {
    if (typeof value !== "number") {
      return;
    }
    if (message == null) {
      message = "value not safe";
    }
    if (value < 0 || value >= 0x1fffffffffffff) {
      this.throwError(message, Logger.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "out-of-safe-range",
        value: value
      });
    }
    if (value % 1) {
      this.throwError(message, Logger.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "non-integer",
        value: value
      });
    }
  };
  Logger.prototype.checkArgumentCount = function (count, expectedCount, message) {
    if (message) {
      message = ": " + message;
    } else {
      message = "";
    }
    if (count < expectedCount) {
      this.throwError("missing argument" + message, Logger.errors.MISSING_ARGUMENT, {
        count: count,
        expectedCount: expectedCount
      });
    }
    if (count > expectedCount) {
      this.throwError("too many arguments" + message, Logger.errors.UNEXPECTED_ARGUMENT, {
        count: count,
        expectedCount: expectedCount
      });
    }
  };
  Logger.prototype.checkNew = function (target, kind) {
    if (target === Object || target == null) {
      this.throwError("missing new", Logger.errors.MISSING_NEW, {
        name: kind.name
      });
    }
  };
  Logger.prototype.checkAbstract = function (target, kind) {
    if (target === kind) {
      this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger.errors.UNSUPPORTED_OPERATION, {
        name: target.name,
        operation: "new"
      });
    } else if (target === Object || target == null) {
      this.throwError("missing new", Logger.errors.MISSING_NEW, {
        name: kind.name
      });
    }
  };
  Logger.globalLogger = function () {
    if (!_globalLogger) {
      _globalLogger = new Logger(_version_1.version);
    }
    return _globalLogger;
  };
  Logger.setCensorship = function (censorship, permanent) {
    if (!censorship && permanent) {
      this.globalLogger().throwError("cannot permanently disable censorship", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    if (_permanentCensorErrors) {
      if (!censorship) {
        return;
      }
      this.globalLogger().throwError("error censorship permanent", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    _censorErrors = !!censorship;
    _permanentCensorErrors = !!permanent;
  };
  Logger.setLogLevel = function (logLevel) {
    var level = LogLevels[logLevel.toLowerCase()];
    if (level == null) {
      Logger.globalLogger().warn("invalid log level - " + logLevel);
      return;
    }
    _logLevel = level;
  };
  Logger.from = function (version) {
    return new Logger(version);
  };
  Logger.errors = ErrorCode;
  Logger.levels = LogLevel;
  return Logger;
}();
exports.Logger = Logger;

},{"./_version":44}],46:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.version = void 0;
exports.version = "properties/5.7.0";

},{}],47:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator = void 0 && (void 0).__generator || function (thisArg, body) {
  var _ = {
      label: 0,
      sent: function sent() {
        if (t[0] & 1) throw t[1];
        return t[1];
      },
      trys: [],
      ops: []
    },
    f,
    y,
    t,
    g;
  return g = {
    next: verb(0),
    "throw": verb(1),
    "return": verb(2)
  }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
    return this;
  }), g;
  function verb(n) {
    return function (v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (_) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return {
            value: op[1],
            done: false
          };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return {
      value: op[0] ? op[1] : void 0,
      done: true
    };
  }
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Description = exports.deepCopy = exports.shallowCopy = exports.checkProperties = exports.resolveProperties = exports.getStatic = exports.defineReadOnly = void 0;
var logger_1 = require("@ethersproject/logger");
var _version_1 = require("./_version");
var logger = new logger_1.Logger(_version_1.version);
function defineReadOnly(object, name, value) {
  Object.defineProperty(object, name, {
    enumerable: true,
    value: value,
    writable: false
  });
}
exports.defineReadOnly = defineReadOnly;
// Crawl up the constructor chain to find a static method
function getStatic(ctor, key) {
  for (var i = 0; i < 32; i++) {
    if (ctor[key]) {
      return ctor[key];
    }
    if (!ctor.prototype || _typeof(ctor.prototype) !== "object") {
      break;
    }
    ctor = Object.getPrototypeOf(ctor.prototype).constructor;
  }
  return null;
}
exports.getStatic = getStatic;
function resolveProperties(object) {
  return __awaiter(this, void 0, void 0, function () {
    var promises, results;
    return __generator(this, function (_a) {
      switch (_a.label) {
        case 0:
          promises = Object.keys(object).map(function (key) {
            var value = object[key];
            return Promise.resolve(value).then(function (v) {
              return {
                key: key,
                value: v
              };
            });
          });
          return [4 /*yield*/, Promise.all(promises)];
        case 1:
          results = _a.sent();
          return [2 /*return*/, results.reduce(function (accum, result) {
            accum[result.key] = result.value;
            return accum;
          }, {})];
      }
    });
  });
}
exports.resolveProperties = resolveProperties;
function checkProperties(object, properties) {
  if (!object || _typeof(object) !== "object") {
    logger.throwArgumentError("invalid object", "object", object);
  }
  Object.keys(object).forEach(function (key) {
    if (!properties[key]) {
      logger.throwArgumentError("invalid object key - " + key, "transaction:" + key, object);
    }
  });
}
exports.checkProperties = checkProperties;
function shallowCopy(object) {
  var result = {};
  for (var key in object) {
    result[key] = object[key];
  }
  return result;
}
exports.shallowCopy = shallowCopy;
var opaque = {
  bigint: true,
  "boolean": true,
  "function": true,
  number: true,
  string: true
};
function _isFrozen(object) {
  // Opaque objects are not mutable, so safe to copy by assignment
  if (object === undefined || object === null || opaque[_typeof(object)]) {
    return true;
  }
  if (Array.isArray(object) || _typeof(object) === "object") {
    if (!Object.isFrozen(object)) {
      return false;
    }
    var keys = Object.keys(object);
    for (var i = 0; i < keys.length; i++) {
      var value = null;
      try {
        value = object[keys[i]];
      } catch (error) {
        // If accessing a value triggers an error, it is a getter
        // designed to do so (e.g. Result) and is therefore "frozen"
        continue;
      }
      if (!_isFrozen(value)) {
        return false;
      }
    }
    return true;
  }
  return logger.throwArgumentError("Cannot deepCopy " + _typeof(object), "object", object);
}
// Returns a new copy of object, such that no properties may be replaced.
// New properties may be added only to objects.
function _deepCopy(object) {
  if (_isFrozen(object)) {
    return object;
  }
  // Arrays are mutable, so we need to create a copy
  if (Array.isArray(object)) {
    return Object.freeze(object.map(function (item) {
      return deepCopy(item);
    }));
  }
  if (_typeof(object) === "object") {
    var result = {};
    for (var key in object) {
      var value = object[key];
      if (value === undefined) {
        continue;
      }
      defineReadOnly(result, key, deepCopy(value));
    }
    return result;
  }
  return logger.throwArgumentError("Cannot deepCopy " + _typeof(object), "object", object);
}
function deepCopy(object) {
  return _deepCopy(object);
}
exports.deepCopy = deepCopy;
var Description = /** @class */function () {
  function Description(info) {
    for (var key in info) {
      this[key] = deepCopy(info[key]);
    }
  }
  return Description;
}();
exports.Description = Description;

},{"./_version":46,"@ethersproject/logger":45}],48:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.version = void 0;
exports.version = "rlp/5.7.0";

},{}],49:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.decode = exports.encode = void 0;
//See: https://github.com/ethereum/wiki/wiki/RLP
var bytes_1 = require("@ethersproject/bytes");
var logger_1 = require("@ethersproject/logger");
var _version_1 = require("./_version");
var logger = new logger_1.Logger(_version_1.version);
function arrayifyInteger(value) {
  var result = [];
  while (value) {
    result.unshift(value & 0xff);
    value >>= 8;
  }
  return result;
}
function unarrayifyInteger(data, offset, length) {
  var result = 0;
  for (var i = 0; i < length; i++) {
    result = result * 256 + data[offset + i];
  }
  return result;
}
function _encode(object) {
  if (Array.isArray(object)) {
    var payload_1 = [];
    object.forEach(function (child) {
      payload_1 = payload_1.concat(_encode(child));
    });
    if (payload_1.length <= 55) {
      payload_1.unshift(0xc0 + payload_1.length);
      return payload_1;
    }
    var length_1 = arrayifyInteger(payload_1.length);
    length_1.unshift(0xf7 + length_1.length);
    return length_1.concat(payload_1);
  }
  if (!(0, bytes_1.isBytesLike)(object)) {
    logger.throwArgumentError("RLP object must be BytesLike", "object", object);
  }
  var data = Array.prototype.slice.call((0, bytes_1.arrayify)(object));
  if (data.length === 1 && data[0] <= 0x7f) {
    return data;
  } else if (data.length <= 55) {
    data.unshift(0x80 + data.length);
    return data;
  }
  var length = arrayifyInteger(data.length);
  length.unshift(0xb7 + length.length);
  return length.concat(data);
}
function encode(object) {
  return (0, bytes_1.hexlify)(_encode(object));
}
exports.encode = encode;
function _decodeChildren(data, offset, childOffset, length) {
  var result = [];
  while (childOffset < offset + 1 + length) {
    var decoded = _decode(data, childOffset);
    result.push(decoded.result);
    childOffset += decoded.consumed;
    if (childOffset > offset + 1 + length) {
      logger.throwError("child data too short", logger_1.Logger.errors.BUFFER_OVERRUN, {});
    }
  }
  return {
    consumed: 1 + length,
    result: result
  };
}
// returns { consumed: number, result: Object }
function _decode(data, offset) {
  if (data.length === 0) {
    logger.throwError("data too short", logger_1.Logger.errors.BUFFER_OVERRUN, {});
  }
  // Array with extra length prefix
  if (data[offset] >= 0xf8) {
    var lengthLength = data[offset] - 0xf7;
    if (offset + 1 + lengthLength > data.length) {
      logger.throwError("data short segment too short", logger_1.Logger.errors.BUFFER_OVERRUN, {});
    }
    var length_2 = unarrayifyInteger(data, offset + 1, lengthLength);
    if (offset + 1 + lengthLength + length_2 > data.length) {
      logger.throwError("data long segment too short", logger_1.Logger.errors.BUFFER_OVERRUN, {});
    }
    return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length_2);
  } else if (data[offset] >= 0xc0) {
    var length_3 = data[offset] - 0xc0;
    if (offset + 1 + length_3 > data.length) {
      logger.throwError("data array too short", logger_1.Logger.errors.BUFFER_OVERRUN, {});
    }
    return _decodeChildren(data, offset, offset + 1, length_3);
  } else if (data[offset] >= 0xb8) {
    var lengthLength = data[offset] - 0xb7;
    if (offset + 1 + lengthLength > data.length) {
      logger.throwError("data array too short", logger_1.Logger.errors.BUFFER_OVERRUN, {});
    }
    var length_4 = unarrayifyInteger(data, offset + 1, lengthLength);
    if (offset + 1 + lengthLength + length_4 > data.length) {
      logger.throwError("data array too short", logger_1.Logger.errors.BUFFER_OVERRUN, {});
    }
    var result = (0, bytes_1.hexlify)(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length_4));
    return {
      consumed: 1 + lengthLength + length_4,
      result: result
    };
  } else if (data[offset] >= 0x80) {
    var length_5 = data[offset] - 0x80;
    if (offset + 1 + length_5 > data.length) {
      logger.throwError("data too short", logger_1.Logger.errors.BUFFER_OVERRUN, {});
    }
    var result = (0, bytes_1.hexlify)(data.slice(offset + 1, offset + 1 + length_5));
    return {
      consumed: 1 + length_5,
      result: result
    };
  }
  return {
    consumed: 1,
    result: (0, bytes_1.hexlify)(data[offset])
  };
}
function decode(data) {
  var bytes = (0, bytes_1.arrayify)(data);
  var decoded = _decode(bytes, 0);
  if (decoded.consumed !== bytes.length) {
    logger.throwArgumentError("invalid rlp data", "data", data);
  }
  return decoded.result;
}
exports.decode = decode;

},{"./_version":48,"@ethersproject/bytes":28,"@ethersproject/logger":45}],50:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.version = void 0;
exports.version = "strings/5.7.0";

},{}],51:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseBytes32String = exports.formatBytes32String = void 0;
var constants_1 = require("@ethersproject/constants");
var bytes_1 = require("@ethersproject/bytes");
var utf8_1 = require("./utf8");
function formatBytes32String(text) {
  // Get the bytes
  var bytes = (0, utf8_1.toUtf8Bytes)(text);
  // Check we have room for null-termination
  if (bytes.length > 31) {
    throw new Error("bytes32 string must be less than 32 bytes");
  }
  // Zero-pad (implicitly null-terminates)
  return (0, bytes_1.hexlify)((0, bytes_1.concat)([bytes, constants_1.HashZero]).slice(0, 32));
}
exports.formatBytes32String = formatBytes32String;
function parseBytes32String(bytes) {
  var data = (0, bytes_1.arrayify)(bytes);
  // Must be 32 bytes with a null-termination
  if (data.length !== 32) {
    throw new Error("invalid bytes32 - not 32 bytes long");
  }
  if (data[31] !== 0) {
    throw new Error("invalid bytes32 string - no null terminator");
  }
  // Find the null termination
  var length = 31;
  while (data[length - 1] === 0) {
    length--;
  }
  // Determine the string value
  return (0, utf8_1.toUtf8String)(data.slice(0, length));
}
exports.parseBytes32String = parseBytes32String;

},{"./utf8":54,"@ethersproject/bytes":28,"@ethersproject/constants":32}],52:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.nameprep = exports._nameprepTableC = exports._nameprepTableB2 = exports._nameprepTableA1 = void 0;
var utf8_1 = require("./utf8");
function bytes2(data) {
  if (data.length % 4 !== 0) {
    throw new Error("bad data");
  }
  var result = [];
  for (var i = 0; i < data.length; i += 4) {
    result.push(parseInt(data.substring(i, i + 4), 16));
  }
  return result;
}
function createTable(data, func) {
  if (!func) {
    func = function func(value) {
      return [parseInt(value, 16)];
    };
  }
  var lo = 0;
  var result = {};
  data.split(",").forEach(function (pair) {
    var comps = pair.split(":");
    lo += parseInt(comps[0], 16);
    result[lo] = func(comps[1]);
  });
  return result;
}
function createRangeTable(data) {
  var hi = 0;
  return data.split(",").map(function (v) {
    var comps = v.split("-");
    if (comps.length === 1) {
      comps[1] = "0";
    } else if (comps[1] === "") {
      comps[1] = "1";
    }
    var lo = hi + parseInt(comps[0], 16);
    hi = parseInt(comps[1], 16);
    return {
      l: lo,
      h: hi
    };
  });
}
function matchMap(value, ranges) {
  var lo = 0;
  for (var i = 0; i < ranges.length; i++) {
    var range = ranges[i];
    lo += range.l;
    if (value >= lo && value <= lo + range.h && (value - lo) % (range.d || 1) === 0) {
      if (range.e && range.e.indexOf(value - lo) !== -1) {
        continue;
      }
      return range;
    }
  }
  return null;
}
var Table_A_1_ranges = createRangeTable("221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d");
// @TODO: Make this relative...
var Table_B_1_flags = "ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff".split(",").map(function (v) {
  return parseInt(v, 16);
});
var Table_B_2_ranges = [{
  h: 25,
  s: 32,
  l: 65
}, {
  h: 30,
  s: 32,
  e: [23],
  l: 127
}, {
  h: 54,
  s: 1,
  e: [48],
  l: 64,
  d: 2
}, {
  h: 14,
  s: 1,
  l: 57,
  d: 2
}, {
  h: 44,
  s: 1,
  l: 17,
  d: 2
}, {
  h: 10,
  s: 1,
  e: [2, 6, 8],
  l: 61,
  d: 2
}, {
  h: 16,
  s: 1,
  l: 68,
  d: 2
}, {
  h: 84,
  s: 1,
  e: [18, 24, 66],
  l: 19,
  d: 2
}, {
  h: 26,
  s: 32,
  e: [17],
  l: 435
}, {
  h: 22,
  s: 1,
  l: 71,
  d: 2
}, {
  h: 15,
  s: 80,
  l: 40
}, {
  h: 31,
  s: 32,
  l: 16
}, {
  h: 32,
  s: 1,
  l: 80,
  d: 2
}, {
  h: 52,
  s: 1,
  l: 42,
  d: 2
}, {
  h: 12,
  s: 1,
  l: 55,
  d: 2
}, {
  h: 40,
  s: 1,
  e: [38],
  l: 15,
  d: 2
}, {
  h: 14,
  s: 1,
  l: 48,
  d: 2
}, {
  h: 37,
  s: 48,
  l: 49
}, {
  h: 148,
  s: 1,
  l: 6351,
  d: 2
}, {
  h: 88,
  s: 1,
  l: 160,
  d: 2
}, {
  h: 15,
  s: 16,
  l: 704
}, {
  h: 25,
  s: 26,
  l: 854
}, {
  h: 25,
  s: 32,
  l: 55915
}, {
  h: 37,
  s: 40,
  l: 1247
}, {
  h: 25,
  s: -119711,
  l: 53248
}, {
  h: 25,
  s: -119763,
  l: 52
}, {
  h: 25,
  s: -119815,
  l: 52
}, {
  h: 25,
  s: -119867,
  e: [1, 4, 5, 7, 8, 11, 12, 17],
  l: 52
}, {
  h: 25,
  s: -119919,
  l: 52
}, {
  h: 24,
  s: -119971,
  e: [2, 7, 8, 17],
  l: 52
}, {
  h: 24,
  s: -120023,
  e: [2, 7, 13, 15, 16, 17],
  l: 52
}, {
  h: 25,
  s: -120075,
  l: 52
}, {
  h: 25,
  s: -120127,
  l: 52
}, {
  h: 25,
  s: -120179,
  l: 52
}, {
  h: 25,
  s: -120231,
  l: 52
}, {
  h: 25,
  s: -120283,
  l: 52
}, {
  h: 25,
  s: -120335,
  l: 52
}, {
  h: 24,
  s: -119543,
  e: [17],
  l: 56
}, {
  h: 24,
  s: -119601,
  e: [17],
  l: 58
}, {
  h: 24,
  s: -119659,
  e: [17],
  l: 58
}, {
  h: 24,
  s: -119717,
  e: [17],
  l: 58
}, {
  h: 24,
  s: -119775,
  e: [17],
  l: 58
}];
var Table_B_2_lut_abs = createTable("b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3");
var Table_B_2_lut_rel = createTable("179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7");
var Table_B_2_complex = createTable("df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D", bytes2);
var Table_C_ranges = createRangeTable("80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001");
function flatten(values) {
  return values.reduce(function (accum, value) {
    value.forEach(function (value) {
      accum.push(value);
    });
    return accum;
  }, []);
}
function _nameprepTableA1(codepoint) {
  return !!matchMap(codepoint, Table_A_1_ranges);
}
exports._nameprepTableA1 = _nameprepTableA1;
function _nameprepTableB2(codepoint) {
  var range = matchMap(codepoint, Table_B_2_ranges);
  if (range) {
    return [codepoint + range.s];
  }
  var codes = Table_B_2_lut_abs[codepoint];
  if (codes) {
    return codes;
  }
  var shift = Table_B_2_lut_rel[codepoint];
  if (shift) {
    return [codepoint + shift[0]];
  }
  var complex = Table_B_2_complex[codepoint];
  if (complex) {
    return complex;
  }
  return null;
}
exports._nameprepTableB2 = _nameprepTableB2;
function _nameprepTableC(codepoint) {
  return !!matchMap(codepoint, Table_C_ranges);
}
exports._nameprepTableC = _nameprepTableC;
function nameprep(value) {
  // This allows platforms with incomplete normalize to bypass
  // it for very basic names which the built-in toLowerCase
  // will certainly handle correctly
  if (value.match(/^[a-z0-9-]*$/i) && value.length <= 59) {
    return value.toLowerCase();
  }
  // Get the code points (keeping the current normalization)
  var codes = (0, utf8_1.toUtf8CodePoints)(value);
  codes = flatten(codes.map(function (code) {
    // Substitute Table B.1 (Maps to Nothing)
    if (Table_B_1_flags.indexOf(code) >= 0) {
      return [];
    }
    if (code >= 0xfe00 && code <= 0xfe0f) {
      return [];
    }
    // Substitute Table B.2 (Case Folding)
    var codesTableB2 = _nameprepTableB2(code);
    if (codesTableB2) {
      return codesTableB2;
    }
    // No Substitution
    return [code];
  }));
  // Normalize using form KC
  codes = (0, utf8_1.toUtf8CodePoints)((0, utf8_1._toUtf8String)(codes), utf8_1.UnicodeNormalizationForm.NFKC);
  // Prohibit Tables C.1.2, C.2.2, C.3, C.4, C.5, C.6, C.7, C.8, C.9
  codes.forEach(function (code) {
    if (_nameprepTableC(code)) {
      throw new Error("STRINGPREP_CONTAINS_PROHIBITED");
    }
  });
  // Prohibit Unassigned Code Points (Table A.1)
  codes.forEach(function (code) {
    if (_nameprepTableA1(code)) {
      throw new Error("STRINGPREP_CONTAINS_UNASSIGNED");
    }
  });
  // IDNA extras
  var name = (0, utf8_1._toUtf8String)(codes);
  // IDNA: 4.2.3.1
  if (name.substring(0, 1) === "-" || name.substring(2, 4) === "--" || name.substring(name.length - 1) === "-") {
    throw new Error("invalid hyphen");
  }
  return name;
}
exports.nameprep = nameprep;

},{"./utf8":54}],53:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.nameprep = exports.parseBytes32String = exports.formatBytes32String = exports.UnicodeNormalizationForm = exports.Utf8ErrorReason = exports.Utf8ErrorFuncs = exports.toUtf8String = exports.toUtf8CodePoints = exports.toUtf8Bytes = exports._toEscapedUtf8String = void 0;
var bytes32_1 = require("./bytes32");
Object.defineProperty(exports, "formatBytes32String", {
  enumerable: true,
  get: function get() {
    return bytes32_1.formatBytes32String;
  }
});
Object.defineProperty(exports, "parseBytes32String", {
  enumerable: true,
  get: function get() {
    return bytes32_1.parseBytes32String;
  }
});
var idna_1 = require("./idna");
Object.defineProperty(exports, "nameprep", {
  enumerable: true,
  get: function get() {
    return idna_1.nameprep;
  }
});
var utf8_1 = require("./utf8");
Object.defineProperty(exports, "_toEscapedUtf8String", {
  enumerable: true,
  get: function get() {
    return utf8_1._toEscapedUtf8String;
  }
});
Object.defineProperty(exports, "toUtf8Bytes", {
  enumerable: true,
  get: function get() {
    return utf8_1.toUtf8Bytes;
  }
});
Object.defineProperty(exports, "toUtf8CodePoints", {
  enumerable: true,
  get: function get() {
    return utf8_1.toUtf8CodePoints;
  }
});
Object.defineProperty(exports, "toUtf8String", {
  enumerable: true,
  get: function get() {
    return utf8_1.toUtf8String;
  }
});
Object.defineProperty(exports, "UnicodeNormalizationForm", {
  enumerable: true,
  get: function get() {
    return utf8_1.UnicodeNormalizationForm;
  }
});
Object.defineProperty(exports, "Utf8ErrorFuncs", {
  enumerable: true,
  get: function get() {
    return utf8_1.Utf8ErrorFuncs;
  }
});
Object.defineProperty(exports, "Utf8ErrorReason", {
  enumerable: true,
  get: function get() {
    return utf8_1.Utf8ErrorReason;
  }
});

},{"./bytes32":51,"./idna":52,"./utf8":54}],54:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toUtf8CodePoints = exports.toUtf8String = exports._toUtf8String = exports._toEscapedUtf8String = exports.toUtf8Bytes = exports.Utf8ErrorFuncs = exports.Utf8ErrorReason = exports.UnicodeNormalizationForm = void 0;
var bytes_1 = require("@ethersproject/bytes");
var logger_1 = require("@ethersproject/logger");
var _version_1 = require("./_version");
var logger = new logger_1.Logger(_version_1.version);
///////////////////////////////
var UnicodeNormalizationForm;
(function (UnicodeNormalizationForm) {
  UnicodeNormalizationForm["current"] = "";
  UnicodeNormalizationForm["NFC"] = "NFC";
  UnicodeNormalizationForm["NFD"] = "NFD";
  UnicodeNormalizationForm["NFKC"] = "NFKC";
  UnicodeNormalizationForm["NFKD"] = "NFKD";
})(UnicodeNormalizationForm = exports.UnicodeNormalizationForm || (exports.UnicodeNormalizationForm = {}));
;
var Utf8ErrorReason;
(function (Utf8ErrorReason) {
  // A continuation byte was present where there was nothing to continue
  // - offset = the index the codepoint began in
  Utf8ErrorReason["UNEXPECTED_CONTINUE"] = "unexpected continuation byte";
  // An invalid (non-continuation) byte to start a UTF-8 codepoint was found
  // - offset = the index the codepoint began in
  Utf8ErrorReason["BAD_PREFIX"] = "bad codepoint prefix";
  // The string is too short to process the expected codepoint
  // - offset = the index the codepoint began in
  Utf8ErrorReason["OVERRUN"] = "string overrun";
  // A missing continuation byte was expected but not found
  // - offset = the index the continuation byte was expected at
  Utf8ErrorReason["MISSING_CONTINUE"] = "missing continuation byte";
  // The computed code point is outside the range for UTF-8
  // - offset       = start of this codepoint
  // - badCodepoint = the computed codepoint; outside the UTF-8 range
  Utf8ErrorReason["OUT_OF_RANGE"] = "out of UTF-8 range";
  // UTF-8 strings may not contain UTF-16 surrogate pairs
  // - offset       = start of this codepoint
  // - badCodepoint = the computed codepoint; inside the UTF-16 surrogate range
  Utf8ErrorReason["UTF16_SURROGATE"] = "UTF-16 surrogate";
  // The string is an overlong representation
  // - offset       = start of this codepoint
  // - badCodepoint = the computed codepoint; already bounds checked
  Utf8ErrorReason["OVERLONG"] = "overlong representation";
})(Utf8ErrorReason = exports.Utf8ErrorReason || (exports.Utf8ErrorReason = {}));
;
function errorFunc(reason, offset, bytes, output, badCodepoint) {
  return logger.throwArgumentError("invalid codepoint at offset " + offset + "; " + reason, "bytes", bytes);
}
function ignoreFunc(reason, offset, bytes, output, badCodepoint) {
  // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes
  if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {
    var i = 0;
    for (var o = offset + 1; o < bytes.length; o++) {
      if (bytes[o] >> 6 !== 0x02) {
        break;
      }
      i++;
    }
    return i;
  }
  // This byte runs us past the end of the string, so just jump to the end
  // (but the first byte was read already read and therefore skipped)
  if (reason === Utf8ErrorReason.OVERRUN) {
    return bytes.length - offset - 1;
  }
  // Nothing to skip
  return 0;
}
function replaceFunc(reason, offset, bytes, output, badCodepoint) {
  // Overlong representations are otherwise "valid" code points; just non-deistingtished
  if (reason === Utf8ErrorReason.OVERLONG) {
    output.push(badCodepoint);
    return 0;
  }
  // Put the replacement character into the output
  output.push(0xfffd);
  // Otherwise, process as if ignoring errors
  return ignoreFunc(reason, offset, bytes, output, badCodepoint);
}
// Common error handing strategies
exports.Utf8ErrorFuncs = Object.freeze({
  error: errorFunc,
  ignore: ignoreFunc,
  replace: replaceFunc
});
// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499
function getUtf8CodePoints(bytes, onError) {
  if (onError == null) {
    onError = exports.Utf8ErrorFuncs.error;
  }
  bytes = (0, bytes_1.arrayify)(bytes);
  var result = [];
  var i = 0;
  // Invalid bytes are ignored
  while (i < bytes.length) {
    var c = bytes[i++];
    // 0xxx xxxx
    if (c >> 7 === 0) {
      result.push(c);
      continue;
    }
    // Multibyte; how many bytes left for this character?
    var extraLength = null;
    var overlongMask = null;
    // 110x xxxx 10xx xxxx
    if ((c & 0xe0) === 0xc0) {
      extraLength = 1;
      overlongMask = 0x7f;
      // 1110 xxxx 10xx xxxx 10xx xxxx
    } else if ((c & 0xf0) === 0xe0) {
      extraLength = 2;
      overlongMask = 0x7ff;
      // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx
    } else if ((c & 0xf8) === 0xf0) {
      extraLength = 3;
      overlongMask = 0xffff;
    } else {
      if ((c & 0xc0) === 0x80) {
        i += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i - 1, bytes, result);
      } else {
        i += onError(Utf8ErrorReason.BAD_PREFIX, i - 1, bytes, result);
      }
      continue;
    }
    // Do we have enough bytes in our data?
    if (i - 1 + extraLength >= bytes.length) {
      i += onError(Utf8ErrorReason.OVERRUN, i - 1, bytes, result);
      continue;
    }
    // Remove the length prefix from the char
    var res = c & (1 << 8 - extraLength - 1) - 1;
    for (var j = 0; j < extraLength; j++) {
      var nextChar = bytes[i];
      // Invalid continuation byte
      if ((nextChar & 0xc0) != 0x80) {
        i += onError(Utf8ErrorReason.MISSING_CONTINUE, i, bytes, result);
        res = null;
        break;
      }
      ;
      res = res << 6 | nextChar & 0x3f;
      i++;
    }
    // See above loop for invalid continuation byte
    if (res === null) {
      continue;
    }
    // Maximum code point
    if (res > 0x10ffff) {
      i += onError(Utf8ErrorReason.OUT_OF_RANGE, i - 1 - extraLength, bytes, result, res);
      continue;
    }
    // Reserved for UTF-16 surrogate halves
    if (res >= 0xd800 && res <= 0xdfff) {
      i += onError(Utf8ErrorReason.UTF16_SURROGATE, i - 1 - extraLength, bytes, result, res);
      continue;
    }
    // Check for overlong sequences (more bytes than needed)
    if (res <= overlongMask) {
      i += onError(Utf8ErrorReason.OVERLONG, i - 1 - extraLength, bytes, result, res);
      continue;
    }
    result.push(res);
  }
  return result;
}
// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array
function toUtf8Bytes(str, form) {
  if (form === void 0) {
    form = UnicodeNormalizationForm.current;
  }
  if (form != UnicodeNormalizationForm.current) {
    logger.checkNormalize();
    str = str.normalize(form);
  }
  var result = [];
  for (var i = 0; i < str.length; i++) {
    var c = str.charCodeAt(i);
    if (c < 0x80) {
      result.push(c);
    } else if (c < 0x800) {
      result.push(c >> 6 | 0xc0);
      result.push(c & 0x3f | 0x80);
    } else if ((c & 0xfc00) == 0xd800) {
      i++;
      var c2 = str.charCodeAt(i);
      if (i >= str.length || (c2 & 0xfc00) !== 0xdc00) {
        throw new Error("invalid utf-8 string");
      }
      // Surrogate Pair
      var pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);
      result.push(pair >> 18 | 0xf0);
      result.push(pair >> 12 & 0x3f | 0x80);
      result.push(pair >> 6 & 0x3f | 0x80);
      result.push(pair & 0x3f | 0x80);
    } else {
      result.push(c >> 12 | 0xe0);
      result.push(c >> 6 & 0x3f | 0x80);
      result.push(c & 0x3f | 0x80);
    }
  }
  return (0, bytes_1.arrayify)(result);
}
exports.toUtf8Bytes = toUtf8Bytes;
;
function escapeChar(value) {
  var hex = "0000" + value.toString(16);
  return "\\u" + hex.substring(hex.length - 4);
}
function _toEscapedUtf8String(bytes, onError) {
  return '"' + getUtf8CodePoints(bytes, onError).map(function (codePoint) {
    if (codePoint < 256) {
      switch (codePoint) {
        case 8:
          return "\\b";
        case 9:
          return "\\t";
        case 10:
          return "\\n";
        case 13:
          return "\\r";
        case 34:
          return "\\\"";
        case 92:
          return "\\\\";
      }
      if (codePoint >= 32 && codePoint < 127) {
        return String.fromCharCode(codePoint);
      }
    }
    if (codePoint <= 0xffff) {
      return escapeChar(codePoint);
    }
    codePoint -= 0x10000;
    return escapeChar((codePoint >> 10 & 0x3ff) + 0xd800) + escapeChar((codePoint & 0x3ff) + 0xdc00);
  }).join("") + '"';
}
exports._toEscapedUtf8String = _toEscapedUtf8String;
function _toUtf8String(codePoints) {
  return codePoints.map(function (codePoint) {
    if (codePoint <= 0xffff) {
      return String.fromCharCode(codePoint);
    }
    codePoint -= 0x10000;
    return String.fromCharCode((codePoint >> 10 & 0x3ff) + 0xd800, (codePoint & 0x3ff) + 0xdc00);
  }).join("");
}
exports._toUtf8String = _toUtf8String;
function toUtf8String(bytes, onError) {
  return _toUtf8String(getUtf8CodePoints(bytes, onError));
}
exports.toUtf8String = toUtf8String;
function toUtf8CodePoints(str, form) {
  if (form === void 0) {
    form = UnicodeNormalizationForm.current;
  }
  return getUtf8CodePoints(toUtf8Bytes(str, form));
}
exports.toUtf8CodePoints = toUtf8CodePoints;

},{"./_version":50,"@ethersproject/bytes":28,"@ethersproject/logger":45}],55:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createCurve = exports.getHash = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
var hmac_1 = require("@noble/hashes/hmac");
var utils_1 = require("@noble/hashes/utils");
var weierstrass_js_1 = require("./abstract/weierstrass.js");
// connects noble-curves to noble-hashes
function getHash(hash) {
  return {
    hash: hash,
    hmac: function hmac(key) {
      for (var _len = arguments.length, msgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        msgs[_key - 1] = arguments[_key];
      }
      return (0, hmac_1.hmac)(hash, key, (0, utils_1.concatBytes).apply(void 0, msgs));
    },
    randomBytes: utils_1.randomBytes
  };
}
exports.getHash = getHash;
function createCurve(curveDef, defHash) {
  var create = function create(hash) {
    return (0, weierstrass_js_1.weierstrass)(_objectSpread(_objectSpread({}, curveDef), getHash(hash)));
  };
  return Object.freeze(_objectSpread(_objectSpread({}, create(defHash)), {}, {
    create: create
  }));
}
exports.createCurve = createCurve;

},{"./abstract/weierstrass.js":60,"@noble/hashes/hmac":66,"@noble/hashes/utils":73}],56:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.validateBasic = exports.wNAF = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
// Abelian group utilities
var modular_js_1 = require("./modular.js");
var utils_js_1 = require("./utils.js");
var _0n = BigInt(0);
var _1n = BigInt(1);
// Elliptic curve multiplication of Point by scalar. Fragile.
// Scalars should always be less than curve order: this should be checked inside of a curve itself.
// Creates precomputation tables for fast multiplication:
// - private scalar is split by fixed size windows of W bits
// - every window point is collected from window's table & added to accumulator
// - since windows are different, same point inside tables won't be accessed more than once per calc
// - each multiplication is 'Math.ceil(CURVE_ORDER / ) + 1' point additions (fixed for any scalar)
// - +1 window is neccessary for wNAF
// - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication
// TODO: Research returning 2d JS array of windows, instead of a single window. This would allow
// windows to be in different memory locations
function wNAF(c, bits) {
  var constTimeNegate = function constTimeNegate(condition, item) {
    var neg = item.negate();
    return condition ? neg : item;
  };
  var opts = function opts(W) {
    var windows = Math.ceil(bits / W) + 1; // +1, because
    var windowSize = Math.pow(2, W - 1); // -1 because we skip zero
    return {
      windows: windows,
      windowSize: windowSize
    };
  };
  return {
    constTimeNegate: constTimeNegate,
    // non-const time multiplication ladder
    unsafeLadder: function unsafeLadder(elm, n) {
      var p = c.ZERO;
      var d = elm;
      while (n > _0n) {
        if (n & _1n) p = p.add(d);
        d = d["double"]();
        n >>= _1n;
      }
      return p;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(1) * (Math.ceil( / ) + 1), where:
     * -  is the window size
     * -  is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow: function precomputeWindow(elm, W) {
      var _opts = opts(W),
        windows = _opts.windows,
        windowSize = _opts.windowSize;
      var points = [];
      var p = elm;
      var base = p;
      for (var window = 0; window < windows; window++) {
        base = p;
        points.push(base);
        // =1, because we skip zero
        for (var i = 1; i < windowSize; i++) {
          base = base.add(p);
          points.push(base);
        }
        p = base["double"]();
      }
      return points;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF: function wNAF(W, precomputes, n) {
      // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise
      // But need to carefully remove other checks before wNAF. ORDER == bits here
      var _opts2 = opts(W),
        windows = _opts2.windows,
        windowSize = _opts2.windowSize;
      var p = c.ZERO;
      var f = c.BASE;
      var mask = BigInt(Math.pow(2, W) - 1); // Create mask with W ones: 0b1111 for W=4 etc.
      var maxNumber = Math.pow(2, W);
      var shiftBy = BigInt(W);
      for (var window = 0; window < windows; window++) {
        var offset = window * windowSize;
        // Extract W bits.
        var wbits = Number(n & mask);
        // Shift number by W bits.
        n >>= shiftBy;
        // If the bits are bigger than max size, we'll split those.
        // +224 => 256 - 32
        if (wbits > windowSize) {
          wbits -= maxNumber;
          n += _1n;
        }
        // This code was first written with assumption that 'f' and 'p' will never be infinity point:
        // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,
        // there is negate now: it is possible that negated element from low value
        // would be the same as high element, which will create carry into next window.
        // It's not obvious how this can fail, but still worth investigating later.
        // Check if we're onto Zero point.
        // Add random point inside current window to f.
        var offset1 = offset;
        var offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero
        var cond1 = window % 2 !== 0;
        var cond2 = wbits < 0;
        if (wbits === 0) {
          // The most important part for const-time getPublicKey
          f = f.add(constTimeNegate(cond1, precomputes[offset1]));
        } else {
          p = p.add(constTimeNegate(cond2, precomputes[offset2]));
        }
      }
      // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()
      // Even if the variable is still unused, there are some checks which will
      // throw an exception, so compiler needs to prove they won't happen, which is hard.
      // At this point there is a way to F be infinity-point even if p is not,
      // which makes it less const-time: around 1 bigint multiply.
      return {
        p: p,
        f: f
      };
    },
    wNAFCached: function wNAFCached(P, precomputesMap, n, transform) {
      // @ts-ignore
      var W = P._WINDOW_SIZE || 1;
      // Calculate precomputes on a first run, reuse them after
      var comp = precomputesMap.get(P);
      if (!comp) {
        comp = this.precomputeWindow(P, W);
        if (W !== 1) {
          precomputesMap.set(P, transform(comp));
        }
      }
      return this.wNAF(W, comp, n);
    }
  };
}
exports.wNAF = wNAF;
function validateBasic(curve) {
  (0, modular_js_1.validateField)(curve.Fp);
  (0, utils_js_1.validateObject)(curve, {
    n: 'bigint',
    h: 'bigint',
    Gx: 'field',
    Gy: 'field'
  }, {
    nBitLength: 'isSafeInteger',
    nByteLength: 'isSafeInteger'
  });
  // Set defaults
  return Object.freeze(_objectSpread(_objectSpread(_objectSpread({}, (0, modular_js_1.nLength)(curve.n, curve.nBitLength)), curve), {
    p: curve.Fp.ORDER
  }));
}
exports.validateBasic = validateBasic;

},{"./modular.js":58,"./utils.js":59}],57:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createHasher = exports.isogenyMap = exports.hash_to_field = exports.expand_message_xof = exports.expand_message_xmd = void 0;
var modular_js_1 = require("./modular.js");
var utils_js_1 = require("./utils.js");
function validateDST(dst) {
  if (dst instanceof Uint8Array) return dst;
  if (typeof dst === 'string') return (0, utils_js_1.utf8ToBytes)(dst);
  throw new Error('DST must be Uint8Array or string');
}
// Octet Stream to Integer. "spec" implementation of os2ip is 2.5x slower vs bytesToNumberBE.
var os2ip = utils_js_1.bytesToNumberBE;
// Integer to Octet Stream (numberToBytesBE)
function i2osp(value, length) {
  if (value < 0 || value >= 1 << 8 * length) {
    throw new Error("bad I2OSP call: value=".concat(value, " length=").concat(length));
  }
  var res = Array.from({
    length: length
  }).fill(0);
  for (var i = length - 1; i >= 0; i--) {
    res[i] = value & 0xff;
    value >>>= 8;
  }
  return new Uint8Array(res);
}
function strxor(a, b) {
  var arr = new Uint8Array(a.length);
  for (var i = 0; i < a.length; i++) {
    arr[i] = a[i] ^ b[i];
  }
  return arr;
}
function isBytes(item) {
  if (!(item instanceof Uint8Array)) throw new Error('Uint8Array expected');
}
function isNum(item) {
  if (!Number.isSafeInteger(item)) throw new Error('number expected');
}
// Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits
// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1
function expand_message_xmd(msg, DST, lenInBytes, H) {
  isBytes(msg);
  isBytes(DST);
  isNum(lenInBytes);
  // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3
  if (DST.length > 255) DST = H((0, utils_js_1.concatBytes)((0, utils_js_1.utf8ToBytes)('H2C-OVERSIZE-DST-'), DST));
  var b_in_bytes = H.outputLen,
    r_in_bytes = H.blockLen;
  var ell = Math.ceil(lenInBytes / b_in_bytes);
  if (ell > 255) throw new Error('Invalid xmd length');
  var DST_prime = (0, utils_js_1.concatBytes)(DST, i2osp(DST.length, 1));
  var Z_pad = i2osp(0, r_in_bytes);
  var l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str
  var b = new Array(ell);
  var b_0 = H((0, utils_js_1.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
  b[0] = H((0, utils_js_1.concatBytes)(b_0, i2osp(1, 1), DST_prime));
  for (var i = 1; i <= ell; i++) {
    var args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];
    b[i] = H((0, utils_js_1.concatBytes).apply(void 0, args));
  }
  var pseudo_random_bytes = (0, utils_js_1.concatBytes).apply(void 0, b);
  return pseudo_random_bytes.slice(0, lenInBytes);
}
exports.expand_message_xmd = expand_message_xmd;
// Produces a uniformly random byte string using an extendable-output function (XOF) H.
// 1. The collision resistance of H MUST be at least k bits.
// 2. H MUST be an XOF that has been proved indifferentiable from
//    a random oracle under a reasonable cryptographic assumption.
// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2
function expand_message_xof(msg, DST, lenInBytes, k, H) {
  isBytes(msg);
  isBytes(DST);
  isNum(lenInBytes);
  // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3
  // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));
  if (DST.length > 255) {
    var dkLen = Math.ceil(2 * k / 8);
    DST = H.create({
      dkLen: dkLen
    }).update((0, utils_js_1.utf8ToBytes)('H2C-OVERSIZE-DST-')).update(DST).digest();
  }
  if (lenInBytes > 65535 || DST.length > 255) throw new Error('expand_message_xof: invalid lenInBytes');
  return H.create({
    dkLen: lenInBytes
  }).update(msg).update(i2osp(lenInBytes, 2))
  // 2. DST_prime = DST || I2OSP(len(DST), 1)
  .update(DST).update(i2osp(DST.length, 1)).digest();
}
exports.expand_message_xof = expand_message_xof;
/**
 * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F
 * https://www.rfc-editor.org/rfc/rfc9380#section-5.2
 * @param msg a byte string containing the message to hash
 * @param count the number of elements of F to output
 * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above
 * @returns [u_0, ..., u_(count - 1)], a list of field elements.
 */
function hash_to_field(msg, count, options) {
  (0, utils_js_1.validateObject)(options, {
    DST: 'stringOrUint8Array',
    p: 'bigint',
    m: 'isSafeInteger',
    k: 'isSafeInteger',
    hash: 'hash'
  });
  var p = options.p,
    k = options.k,
    m = options.m,
    hash = options.hash,
    expand = options.expand,
    _DST = options.DST;
  isBytes(msg);
  isNum(count);
  var DST = validateDST(_DST);
  var log2p = p.toString(2).length;
  var L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above
  var len_in_bytes = count * m * L;
  var prb; // pseudo_random_bytes
  if (expand === 'xmd') {
    prb = expand_message_xmd(msg, DST, len_in_bytes, hash);
  } else if (expand === 'xof') {
    prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);
  } else if (expand === '_internal_pass') {
    // for internal tests only
    prb = msg;
  } else {
    throw new Error('expand must be "xmd" or "xof"');
  }
  var u = new Array(count);
  for (var i = 0; i < count; i++) {
    var e = new Array(m);
    for (var j = 0; j < m; j++) {
      var elm_offset = L * (j + i * m);
      var tv = prb.subarray(elm_offset, elm_offset + L);
      e[j] = (0, modular_js_1.mod)(os2ip(tv), p);
    }
    u[i] = e;
  }
  return u;
}
exports.hash_to_field = hash_to_field;
function isogenyMap(field, map) {
  // Make same order as in spec
  var COEFF = map.map(function (i) {
    return Array.from(i).reverse();
  });
  return function (x, y) {
    var _COEFF$map = COEFF.map(function (val) {
        return val.reduce(function (acc, i) {
          return field.add(field.mul(acc, x), i);
        });
      }),
      _COEFF$map2 = _slicedToArray(_COEFF$map, 4),
      xNum = _COEFF$map2[0],
      xDen = _COEFF$map2[1],
      yNum = _COEFF$map2[2],
      yDen = _COEFF$map2[3];
    x = field.div(xNum, xDen); // xNum / xDen
    y = field.mul(y, field.div(yNum, yDen)); // y * (yNum / yDev)
    return {
      x: x,
      y: y
    };
  };
}
exports.isogenyMap = isogenyMap;
function createHasher(Point, mapToCurve, def) {
  if (typeof mapToCurve !== 'function') throw new Error('mapToCurve() must be defined');
  return {
    // Encodes byte string to elliptic curve.
    // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
    hashToCurve: function hashToCurve(msg, options) {
      var u = hash_to_field(msg, 2, _objectSpread(_objectSpread({}, def), {}, {
        DST: def.DST
      }, options));
      var u0 = Point.fromAffine(mapToCurve(u[0]));
      var u1 = Point.fromAffine(mapToCurve(u[1]));
      var P = u0.add(u1).clearCofactor();
      P.assertValidity();
      return P;
    },
    // Encodes byte string to elliptic curve.
    // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
    encodeToCurve: function encodeToCurve(msg, options) {
      var u = hash_to_field(msg, 1, _objectSpread(_objectSpread({}, def), {}, {
        DST: def.encodeDST
      }, options));
      var P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();
      P.assertValidity();
      return P;
    }
  };
}
exports.createHasher = createHasher;

},{"./modular.js":58,"./utils.js":59}],58:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mapHashToField = exports.getMinHashLength = exports.getFieldBytesLength = exports.hashToPrivateScalar = exports.FpSqrtEven = exports.FpSqrtOdd = exports.Field = exports.nLength = exports.FpIsSquare = exports.FpDiv = exports.FpInvertBatch = exports.FpPow = exports.validateField = exports.isNegativeLE = exports.FpSqrt = exports.tonelliShanks = exports.invert = exports.pow2 = exports.pow = exports.mod = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
// Utilities for modular arithmetics and finite fields
var utils_js_1 = require("./utils.js");
// prettier-ignore
var _0n = BigInt(0),
  _1n = BigInt(1),
  _2n = BigInt(2),
  _3n = BigInt(3);
// prettier-ignore
var _4n = BigInt(4),
  _5n = BigInt(5),
  _8n = BigInt(8);
// prettier-ignore
var _9n = BigInt(9),
  _16n = BigInt(16);
// Calculates a modulo b
function mod(a, b) {
  var result = a % b;
  return result >= _0n ? result : b + result;
}
exports.mod = mod;
/**
 * Efficiently raise num to power and do modular division.
 * Unsafe in some contexts: uses ladder, so can expose bigint bits.
 * @example
 * pow(2n, 6n, 11n) // 64n % 11n == 9n
 */
// TODO: use field version && remove
function pow(num, power, modulo) {
  if (modulo <= _0n || power < _0n) throw new Error('Expected power/modulo > 0');
  if (modulo === _1n) return _0n;
  var res = _1n;
  while (power > _0n) {
    if (power & _1n) res = res * num % modulo;
    num = num * num % modulo;
    power >>= _1n;
  }
  return res;
}
exports.pow = pow;
// Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)
function pow2(x, power, modulo) {
  var res = x;
  while (power-- > _0n) {
    res *= res;
    res %= modulo;
  }
  return res;
}
exports.pow2 = pow2;
// Inverses number over modulo
function invert(number, modulo) {
  if (number === _0n || modulo <= _0n) {
    throw new Error("invert: expected positive integers, got n=".concat(number, " mod=").concat(modulo));
  }
  // Euclidean GCD https://brilliant.org/wiki/extended-euclidean-algorithm/
  // Fermat's little theorem "CT-like" version inv(n) = n^(m-2) mod m is 30x slower.
  var a = mod(number, modulo);
  var b = modulo;
  // prettier-ignore
  var x = _0n,
    y = _1n,
    u = _1n,
    v = _0n;
  while (a !== _0n) {
    // JIT applies optimization if those two lines follow each other
    var q = b / a;
    var r = b % a;
    var m = x - u * q;
    var n = y - v * q;
    // prettier-ignore
    b = a, a = r, x = u, y = v, u = m, v = n;
  }
  var gcd = b;
  if (gcd !== _1n) throw new Error('invert: does not exist');
  return mod(x, modulo);
}
exports.invert = invert;
/**
 * Tonelli-Shanks square root search algorithm.
 * 1. https://eprint.iacr.org/2012/685.pdf (page 12)
 * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks
 * Will start an infinite loop if field order P is not prime.
 * @param P field order
 * @returns function that takes field Fp (created from P) and number n
 */
function tonelliShanks(P) {
  // Legendre constant: used to calculate Legendre symbol (a | p),
  // which denotes the value of a^((p-1)/2) (mod p).
  // (a | p)  1    if a is a square (mod p)
  // (a | p)  -1   if a is not a square (mod p)
  // (a | p)  0    if a  0 (mod p)
  var legendreC = (P - _1n) / _2n;
  var Q, S, Z;
  // Step 1: By factoring out powers of 2 from p - 1,
  // find q and s such that p - 1 = q*(2^s) with q odd
  for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++);
  // Step 2: Select a non-square z such that (z | p)  -1 and set c  zq
  for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++);
  // Fast-path
  if (S === 1) {
    var p1div4 = (P + _1n) / _4n;
    return function tonelliFast(Fp, n) {
      var root = Fp.pow(n, p1div4);
      if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');
      return root;
    };
  }
  // Slow-path
  var Q1div2 = (Q + _1n) / _2n;
  return function tonelliSlow(Fp, n) {
    // Step 0: Check that n is indeed a square: (n | p) should not be  -1
    if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE)) throw new Error('Cannot find square root');
    var r = S;
    // TODO: will fail at Fp2/etc
    var g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b
    var x = Fp.pow(n, Q1div2); // first guess at the square root
    var b = Fp.pow(n, Q); // first guess at the fudge factor
    while (!Fp.eql(b, Fp.ONE)) {
      if (Fp.eql(b, Fp.ZERO)) return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)
      // Find m such b^(2^m)==1
      var m = 1;
      for (var t2 = Fp.sqr(b); m < r; m++) {
        if (Fp.eql(t2, Fp.ONE)) break;
        t2 = Fp.sqr(t2); // t2 *= t2
      }
      // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow
      var ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)
      g = Fp.sqr(ge); // g = ge * ge
      x = Fp.mul(x, ge); // x *= ge
      b = Fp.mul(b, g); // b *= g
      r = m;
    }
    return x;
  };
}
exports.tonelliShanks = tonelliShanks;
function FpSqrt(P) {
  // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.
  // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).
  // P  3 (mod 4)
  // n = n^((P+1)/4)
  if (P % _4n === _3n) {
    // Not all roots possible!
    // const ORDER =
    //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;
    // const NUM = 72057594037927816n;
    var p1div4 = (P + _1n) / _4n;
    return function sqrt3mod4(Fp, n) {
      var root = Fp.pow(n, p1div4);
      // Throw if root**2 != n
      if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');
      return root;
    };
  }
  // Atkin algorithm for q  5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)
  if (P % _8n === _5n) {
    var c1 = (P - _5n) / _8n;
    return function sqrt5mod8(Fp, n) {
      var n2 = Fp.mul(n, _2n);
      var v = Fp.pow(n2, c1);
      var nv = Fp.mul(n, v);
      var i = Fp.mul(Fp.mul(nv, _2n), v);
      var root = Fp.mul(nv, Fp.sub(i, Fp.ONE));
      if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');
      return root;
    };
  }
  // P  9 (mod 16)
  if (P % _16n === _9n) {
    // NOTE: tonelli is too slow for bls-Fp2 calculations even on start
    // Means we cannot use sqrt for constants at all!
    //
    // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F
    // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F
    // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F
    // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic
    // sqrt = (x) => {
    //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4
    //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1
    //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1
    //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1
    //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x
    //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x
    //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x
    //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x
    //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x
    //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2
    // }
  }
  // Other cases: Tonelli-Shanks algorithm
  return tonelliShanks(P);
}
exports.FpSqrt = FpSqrt;
// Little-endian check for first LE bit (last BE bit);
var isNegativeLE = function isNegativeLE(num, modulo) {
  return (mod(num, modulo) & _1n) === _1n;
};
exports.isNegativeLE = isNegativeLE;
// prettier-ignore
var FIELD_FIELDS = ['create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr', 'eql', 'add', 'sub', 'mul', 'pow', 'div', 'addN', 'subN', 'mulN', 'sqrN'];
function validateField(field) {
  var initial = {
    ORDER: 'bigint',
    MASK: 'bigint',
    BYTES: 'isSafeInteger',
    BITS: 'isSafeInteger'
  };
  var opts = FIELD_FIELDS.reduce(function (map, val) {
    map[val] = 'function';
    return map;
  }, initial);
  return (0, utils_js_1.validateObject)(field, opts);
}
exports.validateField = validateField;
// Generic field functions
/**
 * Same as `pow` but for Fp: non-constant-time.
 * Unsafe in some contexts: uses ladder, so can expose bigint bits.
 */
function FpPow(f, num, power) {
  // Should have same speed as pow for bigints
  // TODO: benchmark!
  if (power < _0n) throw new Error('Expected power > 0');
  if (power === _0n) return f.ONE;
  if (power === _1n) return num;
  var p = f.ONE;
  var d = num;
  while (power > _0n) {
    if (power & _1n) p = f.mul(p, d);
    d = f.sqr(d);
    power >>= _1n;
  }
  return p;
}
exports.FpPow = FpPow;
/**
 * Efficiently invert an array of Field elements.
 * `inv(0)` will return `undefined` here: make sure to throw an error.
 */
function FpInvertBatch(f, nums) {
  var tmp = new Array(nums.length);
  // Walk from first to last, multiply them by each other MOD p
  var lastMultiplied = nums.reduce(function (acc, num, i) {
    if (f.is0(num)) return acc;
    tmp[i] = acc;
    return f.mul(acc, num);
  }, f.ONE);
  // Invert last element
  var inverted = f.inv(lastMultiplied);
  // Walk from last to first, multiply them by inverted each other MOD p
  nums.reduceRight(function (acc, num, i) {
    if (f.is0(num)) return acc;
    tmp[i] = f.mul(acc, tmp[i]);
    return f.mul(acc, num);
  }, inverted);
  return tmp;
}
exports.FpInvertBatch = FpInvertBatch;
function FpDiv(f, lhs, rhs) {
  return f.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, f.ORDER) : f.inv(rhs));
}
exports.FpDiv = FpDiv;
// This function returns True whenever the value x is a square in the field F.
function FpIsSquare(f) {
  var legendreConst = (f.ORDER - _1n) / _2n; // Integer arithmetic
  return function (x) {
    var p = f.pow(x, legendreConst);
    return f.eql(p, f.ZERO) || f.eql(p, f.ONE);
  };
}
exports.FpIsSquare = FpIsSquare;
// CURVE.n lengths
function nLength(n, nBitLength) {
  // Bit size, byte size of CURVE.n
  var _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;
  var nByteLength = Math.ceil(_nBitLength / 8);
  return {
    nBitLength: _nBitLength,
    nByteLength: nByteLength
  };
}
exports.nLength = nLength;
/**
 * Initializes a finite field over prime. **Non-primes are not supported.**
 * Do not init in loop: slow. Very fragile: always run a benchmark on a change.
 * Major performance optimizations:
 * * a) denormalized operations like mulN instead of mul
 * * b) same object shape: never add or remove keys
 * * c) Object.freeze
 * @param ORDER prime positive bigint
 * @param bitLen how many bits the field consumes
 * @param isLE (def: false) if encoding / decoding should be in little-endian
 * @param redef optional faster redefinitions of sqrt and other methods
 */
function Field(ORDER, bitLen) {
  var isLE = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var redef = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  if (ORDER <= _0n) throw new Error("Expected Field ORDER > 0, got ".concat(ORDER));
  var _nLength = nLength(ORDER, bitLen),
    BITS = _nLength.nBitLength,
    BYTES = _nLength.nByteLength;
  if (BYTES > 2048) throw new Error('Field lengths over 2048 bytes are not supported');
  var sqrtP = FpSqrt(ORDER);
  var f = Object.freeze({
    ORDER: ORDER,
    BITS: BITS,
    BYTES: BYTES,
    MASK: (0, utils_js_1.bitMask)(BITS),
    ZERO: _0n,
    ONE: _1n,
    create: function create(num) {
      return mod(num, ORDER);
    },
    isValid: function isValid(num) {
      if (typeof num !== 'bigint') throw new Error("Invalid field element: expected bigint, got ".concat(_typeof(num)));
      return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible
    },
    is0: function is0(num) {
      return num === _0n;
    },
    isOdd: function isOdd(num) {
      return (num & _1n) === _1n;
    },
    neg: function neg(num) {
      return mod(-num, ORDER);
    },
    eql: function eql(lhs, rhs) {
      return lhs === rhs;
    },
    sqr: function sqr(num) {
      return mod(num * num, ORDER);
    },
    add: function add(lhs, rhs) {
      return mod(lhs + rhs, ORDER);
    },
    sub: function sub(lhs, rhs) {
      return mod(lhs - rhs, ORDER);
    },
    mul: function mul(lhs, rhs) {
      return mod(lhs * rhs, ORDER);
    },
    pow: function pow(num, power) {
      return FpPow(f, num, power);
    },
    div: function div(lhs, rhs) {
      return mod(lhs * invert(rhs, ORDER), ORDER);
    },
    // Same as above, but doesn't normalize
    sqrN: function sqrN(num) {
      return num * num;
    },
    addN: function addN(lhs, rhs) {
      return lhs + rhs;
    },
    subN: function subN(lhs, rhs) {
      return lhs - rhs;
    },
    mulN: function mulN(lhs, rhs) {
      return lhs * rhs;
    },
    inv: function inv(num) {
      return invert(num, ORDER);
    },
    sqrt: redef.sqrt || function (n) {
      return sqrtP(f, n);
    },
    invertBatch: function invertBatch(lst) {
      return FpInvertBatch(f, lst);
    },
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: function cmov(a, b, c) {
      return c ? b : a;
    },
    toBytes: function toBytes(num) {
      return isLE ? (0, utils_js_1.numberToBytesLE)(num, BYTES) : (0, utils_js_1.numberToBytesBE)(num, BYTES);
    },
    fromBytes: function fromBytes(bytes) {
      if (bytes.length !== BYTES) throw new Error("Fp.fromBytes: expected ".concat(BYTES, ", got ").concat(bytes.length));
      return isLE ? (0, utils_js_1.bytesToNumberLE)(bytes) : (0, utils_js_1.bytesToNumberBE)(bytes);
    }
  });
  return Object.freeze(f);
}
exports.Field = Field;
function FpSqrtOdd(Fp, elm) {
  if (!Fp.isOdd) throw new Error("Field doesn't have isOdd");
  var root = Fp.sqrt(elm);
  return Fp.isOdd(root) ? root : Fp.neg(root);
}
exports.FpSqrtOdd = FpSqrtOdd;
function FpSqrtEven(Fp, elm) {
  if (!Fp.isOdd) throw new Error("Field doesn't have isOdd");
  var root = Fp.sqrt(elm);
  return Fp.isOdd(root) ? Fp.neg(root) : root;
}
exports.FpSqrtEven = FpSqrtEven;
/**
 * "Constant-time" private key generation utility.
 * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).
 * Which makes it slightly more biased, less secure.
 * @deprecated use mapKeyToField instead
 */
function hashToPrivateScalar(hash, groupOrder) {
  var isLE = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  hash = (0, utils_js_1.ensureBytes)('privateHash', hash);
  var hashLen = hash.length;
  var minLen = nLength(groupOrder).nByteLength + 8;
  if (minLen < 24 || hashLen < minLen || hashLen > 1024) throw new Error("hashToPrivateScalar: expected ".concat(minLen, "-1024 bytes of input, got ").concat(hashLen));
  var num = isLE ? (0, utils_js_1.bytesToNumberLE)(hash) : (0, utils_js_1.bytesToNumberBE)(hash);
  return mod(num, groupOrder - _1n) + _1n;
}
exports.hashToPrivateScalar = hashToPrivateScalar;
/**
 * Returns total number of bytes consumed by the field element.
 * For example, 32 bytes for usual 256-bit weierstrass curve.
 * @param fieldOrder number of field elements, usually CURVE.n
 * @returns byte length of field
 */
function getFieldBytesLength(fieldOrder) {
  if (typeof fieldOrder !== 'bigint') throw new Error('field order must be bigint');
  var bitLength = fieldOrder.toString(2).length;
  return Math.ceil(bitLength / 8);
}
exports.getFieldBytesLength = getFieldBytesLength;
/**
 * Returns minimal amount of bytes that can be safely reduced
 * by field order.
 * Should be 2^-128 for 128-bit curve such as P256.
 * @param fieldOrder number of field elements, usually CURVE.n
 * @returns byte length of target hash
 */
function getMinHashLength(fieldOrder) {
  var length = getFieldBytesLength(fieldOrder);
  return length + Math.ceil(length / 2);
}
exports.getMinHashLength = getMinHashLength;
/**
 * "Constant-time" private key generation utility.
 * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF
 * and convert them into private scalar, with the modulo bias being negligible.
 * Needs at least 48 bytes of input for 32-byte private key.
 * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/
 * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final
 * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5
 * @param hash hash output from SHA3 or a similar function
 * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)
 * @param isLE interpret hash bytes as LE num
 * @returns valid private scalar
 */
function mapHashToField(key, fieldOrder) {
  var isLE = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var len = key.length;
  var fieldLen = getFieldBytesLength(fieldOrder);
  var minLen = getMinHashLength(fieldOrder);
  // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.
  if (len < 16 || len < minLen || len > 1024) throw new Error("expected ".concat(minLen, "-1024 bytes of input, got ").concat(len));
  var num = isLE ? (0, utils_js_1.bytesToNumberBE)(key) : (0, utils_js_1.bytesToNumberLE)(key);
  // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0
  var reduced = mod(num, fieldOrder - _1n) + _1n;
  return isLE ? (0, utils_js_1.numberToBytesLE)(reduced, fieldLen) : (0, utils_js_1.numberToBytesBE)(reduced, fieldLen);
}
exports.mapHashToField = mapHashToField;

},{"./utils.js":59}],59:[function(require,module,exports){
"use strict";

function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.validateObject = exports.createHmacDrbg = exports.bitMask = exports.bitSet = exports.bitGet = exports.bitLen = exports.utf8ToBytes = exports.equalBytes = exports.concatBytes = exports.ensureBytes = exports.numberToVarBytesBE = exports.numberToBytesLE = exports.numberToBytesBE = exports.bytesToNumberLE = exports.bytesToNumberBE = exports.hexToBytes = exports.hexToNumber = exports.numberToHexUnpadded = exports.bytesToHex = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
// 100 lines of code in the file are duplicated from noble-hashes (utils).
// This is OK: `abstract` directory does not use noble-hashes.
// User may opt-in into using different hashing library. This way, noble-hashes
// won't be included into their bundle.
var _0n = BigInt(0);
var _1n = BigInt(1);
var _2n = BigInt(2);
var u8a = function u8a(a) {
  return a instanceof Uint8Array;
};
var hexes = /* @__PURE__ */Array.from({
  length: 256
}, function (_, i) {
  return i.toString(16).padStart(2, '0');
});
/**
 * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'
 */
function bytesToHex(bytes) {
  if (!u8a(bytes)) throw new Error('Uint8Array expected');
  // pre-caching improves the speed 6x
  var hex = '';
  for (var i = 0; i < bytes.length; i++) {
    hex += hexes[bytes[i]];
  }
  return hex;
}
exports.bytesToHex = bytesToHex;
function numberToHexUnpadded(num) {
  var hex = num.toString(16);
  return hex.length & 1 ? "0".concat(hex) : hex;
}
exports.numberToHexUnpadded = numberToHexUnpadded;
function hexToNumber(hex) {
  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + _typeof(hex));
  // Big Endian
  return BigInt(hex === '' ? '0' : "0x".concat(hex));
}
exports.hexToNumber = hexToNumber;
/**
 * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])
 */
function hexToBytes(hex) {
  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + _typeof(hex));
  var len = hex.length;
  if (len % 2) throw new Error('padded hex string expected, got unpadded hex of length ' + len);
  var array = new Uint8Array(len / 2);
  for (var i = 0; i < array.length; i++) {
    var j = i * 2;
    var hexByte = hex.slice(j, j + 2);
    var _byte = Number.parseInt(hexByte, 16);
    if (Number.isNaN(_byte) || _byte < 0) throw new Error('Invalid byte sequence');
    array[i] = _byte;
  }
  return array;
}
exports.hexToBytes = hexToBytes;
// BE: Big Endian, LE: Little Endian
function bytesToNumberBE(bytes) {
  return hexToNumber(bytesToHex(bytes));
}
exports.bytesToNumberBE = bytesToNumberBE;
function bytesToNumberLE(bytes) {
  if (!u8a(bytes)) throw new Error('Uint8Array expected');
  return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));
}
exports.bytesToNumberLE = bytesToNumberLE;
function numberToBytesBE(n, len) {
  return hexToBytes(n.toString(16).padStart(len * 2, '0'));
}
exports.numberToBytesBE = numberToBytesBE;
function numberToBytesLE(n, len) {
  return numberToBytesBE(n, len).reverse();
}
exports.numberToBytesLE = numberToBytesLE;
// Unpadded, rarely used
function numberToVarBytesBE(n) {
  return hexToBytes(numberToHexUnpadded(n));
}
exports.numberToVarBytesBE = numberToVarBytesBE;
/**
 * Takes hex string or Uint8Array, converts to Uint8Array.
 * Validates output length.
 * Will throw error for other types.
 * @param title descriptive title for an error e.g. 'private key'
 * @param hex hex string or Uint8Array
 * @param expectedLength optional, will compare to result array's length
 * @returns
 */
function ensureBytes(title, hex, expectedLength) {
  var res;
  if (typeof hex === 'string') {
    try {
      res = hexToBytes(hex);
    } catch (e) {
      throw new Error("".concat(title, " must be valid hex string, got \"").concat(hex, "\". Cause: ").concat(e));
    }
  } else if (u8a(hex)) {
    // Uint8Array.from() instead of hash.slice() because node.js Buffer
    // is instance of Uint8Array, and its slice() creates **mutable** copy
    res = Uint8Array.from(hex);
  } else {
    throw new Error("".concat(title, " must be hex string or Uint8Array"));
  }
  var len = res.length;
  if (typeof expectedLength === 'number' && len !== expectedLength) throw new Error("".concat(title, " expected ").concat(expectedLength, " bytes, got ").concat(len));
  return res;
}
exports.ensureBytes = ensureBytes;
/**
 * Copies several Uint8Arrays into one.
 */
function concatBytes() {
  for (var _len = arguments.length, arrays = new Array(_len), _key = 0; _key < _len; _key++) {
    arrays[_key] = arguments[_key];
  }
  var r = new Uint8Array(arrays.reduce(function (sum, a) {
    return sum + a.length;
  }, 0));
  var pad = 0; // walk through each item, ensure they have proper type
  arrays.forEach(function (a) {
    if (!u8a(a)) throw new Error('Uint8Array expected');
    r.set(a, pad);
    pad += a.length;
  });
  return r;
}
exports.concatBytes = concatBytes;
function equalBytes(b1, b2) {
  // We don't care about timing attacks here
  if (b1.length !== b2.length) return false;
  for (var i = 0; i < b1.length; i++) if (b1[i] !== b2[i]) return false;
  return true;
}
exports.equalBytes = equalBytes;
/**
 * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])
 */
function utf8ToBytes(str) {
  if (typeof str !== 'string') throw new Error("utf8ToBytes expected string, got ".concat(_typeof(str)));
  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
}
exports.utf8ToBytes = utf8ToBytes;
// Bit operations
/**
 * Calculates amount of bits in a bigint.
 * Same as `n.toString(2).length`
 */
function bitLen(n) {
  var len;
  for (len = 0; n > _0n; n >>= _1n, len += 1);
  return len;
}
exports.bitLen = bitLen;
/**
 * Gets single bit at position.
 * NOTE: first bit position is 0 (same as arrays)
 * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`
 */
function bitGet(n, pos) {
  return n >> BigInt(pos) & _1n;
}
exports.bitGet = bitGet;
/**
 * Sets single bit at position.
 */
var bitSet = function bitSet(n, pos, value) {
  return n | (value ? _1n : _0n) << BigInt(pos);
};
exports.bitSet = bitSet;
/**
 * Calculate mask for N bits. Not using ** operator with bigints because of old engines.
 * Same as BigInt(`0b${Array(i).fill('1').join('')}`)
 */
var bitMask = function bitMask(n) {
  return (_2n << BigInt(n - 1)) - _1n;
};
exports.bitMask = bitMask;
// DRBG
var u8n = function u8n(data) {
  return new Uint8Array(data);
}; // creates Uint8Array
var u8fr = function u8fr(arr) {
  return Uint8Array.from(arr);
}; // another shortcut
/**
 * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.
 * @returns function that will call DRBG until 2nd arg returns something meaningful
 * @example
 *   const drbg = createHmacDRBG<Key>(32, 32, hmac);
 *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined
 */
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
  if (typeof hashLen !== 'number' || hashLen < 2) throw new Error('hashLen must be a number');
  if (typeof qByteLen !== 'number' || qByteLen < 2) throw new Error('qByteLen must be a number');
  if (typeof hmacFn !== 'function') throw new Error('hmacFn must be a function');
  // Step B, Step C: set hashLen to 8*ceil(hlen/8)
  var v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.
  var k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same
  var i = 0; // Iterations counter, will throw when over 1000
  var reset = function reset() {
    v.fill(1);
    k.fill(0);
    i = 0;
  };
  var h = function h() {
    for (var _len2 = arguments.length, b = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      b[_key2] = arguments[_key2];
    }
    return hmacFn.apply(void 0, [k, v].concat(b));
  }; // hmac(k)(v, ...values)
  var reseed = function reseed() {
    var seed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : u8n();
    // HMAC-DRBG reseed() function. Steps D-G
    k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)
    v = h(); // v = hmac(k || v)
    if (seed.length === 0) return;
    k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)
    v = h(); // v = hmac(k || v)
  };
  var gen = function gen() {
    // HMAC-DRBG generate() function
    if (i++ >= 1000) throw new Error('drbg: tried 1000 values');
    var len = 0;
    var out = [];
    while (len < qByteLen) {
      v = h();
      var sl = v.slice();
      out.push(sl);
      len += v.length;
    }
    return concatBytes.apply(void 0, out);
  };
  var genUntil = function genUntil(seed, pred) {
    reset();
    reseed(seed); // Steps D-G
    var res = undefined; // Step H: grind until k is in [1..n-1]
    while (!(res = pred(gen()))) reseed();
    reset();
    return res;
  };
  return genUntil;
}
exports.createHmacDrbg = createHmacDrbg;
// Validating curves and fields
var validatorFns = {
  bigint: function bigint(val) {
    return typeof val === 'bigint';
  },
  "function": function _function(val) {
    return typeof val === 'function';
  },
  "boolean": function boolean(val) {
    return typeof val === 'boolean';
  },
  string: function string(val) {
    return typeof val === 'string';
  },
  stringOrUint8Array: function stringOrUint8Array(val) {
    return typeof val === 'string' || val instanceof Uint8Array;
  },
  isSafeInteger: function isSafeInteger(val) {
    return Number.isSafeInteger(val);
  },
  array: function array(val) {
    return Array.isArray(val);
  },
  field: function field(val, object) {
    return object.Fp.isValid(val);
  },
  hash: function hash(val) {
    return typeof val === 'function' && Number.isSafeInteger(val.outputLen);
  }
};
// type Record<K extends string | number | symbol, T> = { [P in K]: T; }
function validateObject(object, validators) {
  var optValidators = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var checkField = function checkField(fieldName, type, isOptional) {
    var checkVal = validatorFns[type];
    if (typeof checkVal !== 'function') throw new Error("Invalid validator \"".concat(type, "\", expected function"));
    var val = object[fieldName];
    if (isOptional && val === undefined) return;
    if (!checkVal(val, object)) {
      throw new Error("Invalid param ".concat(String(fieldName), "=").concat(val, " (").concat(_typeof(val), "), expected ").concat(type));
    }
  };
  for (var _i = 0, _Object$entries = Object.entries(validators); _i < _Object$entries.length; _i++) {
    var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
      fieldName = _Object$entries$_i[0],
      type = _Object$entries$_i[1];
    checkField(fieldName, type, false);
  }
  for (var _i2 = 0, _Object$entries2 = Object.entries(optValidators); _i2 < _Object$entries2.length; _i2++) {
    var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i2], 2),
      _fieldName = _Object$entries2$_i[0],
      _type = _Object$entries2$_i[1];
    checkField(_fieldName, _type, true);
  }
  return object;
}
exports.validateObject = validateObject;
// validate type tests
// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };
// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!
// // Should fail type-check
// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });
// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });
// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });
// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });

},{}],60:[function(require,module,exports){
"use strict";

function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _wrapNativeSuper(t) { var r = "function" == typeof Map ? new Map() : void 0; return _wrapNativeSuper = function _wrapNativeSuper(t) { if (null === t || !_isNativeFunction(t)) return t; if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function"); if (void 0 !== r) { if (r.has(t)) return r.get(t); r.set(t, Wrapper); } function Wrapper() { return _construct(t, arguments, _getPrototypeOf(this).constructor); } return Wrapper.prototype = Object.create(t.prototype, { constructor: { value: Wrapper, enumerable: !1, writable: !0, configurable: !0 } }), _setPrototypeOf(Wrapper, t); }, _wrapNativeSuper(t); }
function _construct(t, e, r) { if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments); var o = [null]; o.push.apply(o, e); var p = new (t.bind.apply(t, o))(); return r && _setPrototypeOf(p, r.prototype), p; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _isNativeFunction(t) { try { return -1 !== Function.toString.call(t).indexOf("[native code]"); } catch (n) { return "function" == typeof t; } }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mapToCurveSimpleSWU = exports.SWUFpSqrtRatio = exports.weierstrass = exports.weierstrassPoints = exports.DER = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
// Short Weierstrass curve. The formula is: y = x + ax + b
var mod = require("./modular.js");
var ut = require("./utils.js");
var utils_js_1 = require("./utils.js");
var curve_js_1 = require("./curve.js");
function validatePointOpts(curve) {
  var opts = (0, curve_js_1.validateBasic)(curve);
  ut.validateObject(opts, {
    a: 'field',
    b: 'field'
  }, {
    allowedPrivateKeyLengths: 'array',
    wrapPrivateKey: 'boolean',
    isTorsionFree: 'function',
    clearCofactor: 'function',
    allowInfinityPoint: 'boolean',
    fromBytes: 'function',
    toBytes: 'function'
  });
  var endo = opts.endo,
    Fp = opts.Fp,
    a = opts.a;
  if (endo) {
    if (!Fp.eql(a, Fp.ZERO)) {
      throw new Error('Endomorphism can only be defined for Koblitz curves that have a=0');
    }
    if (_typeof(endo) !== 'object' || typeof endo.beta !== 'bigint' || typeof endo.splitScalar !== 'function') {
      throw new Error('Expected endomorphism with beta: bigint and splitScalar: function');
    }
  }
  return Object.freeze(_objectSpread({}, opts));
}
// ASN.1 DER encoding utilities
var b2n = ut.bytesToNumberBE,
  h2b = ut.hexToBytes;
exports.DER = {
  // asn.1 DER encoding utils
  Err: /*#__PURE__*/function (_Error) {
    function DERErr() {
      var m = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      _classCallCheck(this, DERErr);
      return _callSuper(this, DERErr, [m]);
    }
    _inherits(DERErr, _Error);
    return _createClass(DERErr);
  }( /*#__PURE__*/_wrapNativeSuper(Error)),
  _parseInt: function _parseInt(data) {
    var E = exports.DER.Err;
    if (data.length < 2 || data[0] !== 0x02) throw new E('Invalid signature integer tag');
    var len = data[1];
    var res = data.subarray(2, len + 2);
    if (!len || res.length !== len) throw new E('Invalid signature integer: wrong length');
    // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
    // since we always use positive integers here. It must always be empty:
    // - add zero byte if exists
    // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
    if (res[0] & 128) throw new E('Invalid signature integer: negative');
    if (res[0] === 0x00 && !(res[1] & 128)) throw new E('Invalid signature integer: unnecessary leading zero');
    return {
      d: b2n(res),
      l: data.subarray(len + 2)
    }; // d is data, l is left
  },
  toSig: function toSig(hex) {
    // parse DER signature
    var E = exports.DER.Err;
    var data = typeof hex === 'string' ? h2b(hex) : hex;
    if (!(data instanceof Uint8Array)) throw new Error('ui8a expected');
    var l = data.length;
    if (l < 2 || data[0] != 0x30) throw new E('Invalid signature tag');
    if (data[1] !== l - 2) throw new E('Invalid signature: incorrect length');
    var _exports$DER$_parseIn = exports.DER._parseInt(data.subarray(2)),
      r = _exports$DER$_parseIn.d,
      sBytes = _exports$DER$_parseIn.l;
    var _exports$DER$_parseIn2 = exports.DER._parseInt(sBytes),
      s = _exports$DER$_parseIn2.d,
      rBytesLeft = _exports$DER$_parseIn2.l;
    if (rBytesLeft.length) throw new E('Invalid signature: left bytes after parsing');
    return {
      r: r,
      s: s
    };
  },
  hexFromSig: function hexFromSig(sig) {
    // Add leading zero if first byte has negative bit enabled. More details in '_parseInt'
    var slice = function slice(s) {
      return Number.parseInt(s[0], 16) & 8 ? '00' + s : s;
    };
    var h = function h(num) {
      var hex = num.toString(16);
      return hex.length & 1 ? "0".concat(hex) : hex;
    };
    var s = slice(h(sig.s));
    var r = slice(h(sig.r));
    var shl = s.length / 2;
    var rhl = r.length / 2;
    var sl = h(shl);
    var rl = h(rhl);
    return "30".concat(h(rhl + shl + 4), "02").concat(rl).concat(r, "02").concat(sl).concat(s);
  }
};
// Be friendly to bad ECMAScript parsers by not using bigint literals
// prettier-ignore
var _0n = BigInt(0),
  _1n = BigInt(1),
  _2n = BigInt(2),
  _3n = BigInt(3),
  _4n = BigInt(4);
function weierstrassPoints(opts) {
  var CURVE = validatePointOpts(opts);
  var Fp = CURVE.Fp; // All curves has same field / group length as for now, but they can differ
  var toBytes = CURVE.toBytes || function (_c, point, _isCompressed) {
    var a = point.toAffine();
    return ut.concatBytes(Uint8Array.from([0x04]), Fp.toBytes(a.x), Fp.toBytes(a.y));
  };
  var fromBytes = CURVE.fromBytes || function (bytes) {
    // const head = bytes[0];
    var tail = bytes.subarray(1);
    // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');
    var x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
    var y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
    return {
      x: x,
      y: y
    };
  };
  /**
   * y = x + ax + b: Short weierstrass curve formula
   * @returns y
   */
  function weierstrassEquation(x) {
    var a = CURVE.a,
      b = CURVE.b;
    var x2 = Fp.sqr(x); // x * x
    var x3 = Fp.mul(x2, x); // x2 * x
    return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b
  }
  // Validate whether the passed curve params are valid.
  // We check if curve equation works for generator point.
  // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.
  // ProjectivePoint class has not been initialized yet.
  if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx))) throw new Error('bad generator point: equation left != right');
  // Valid group elements reside in range 1..n-1
  function isWithinCurveOrder(num) {
    return typeof num === 'bigint' && _0n < num && num < CURVE.n;
  }
  function assertGE(num) {
    if (!isWithinCurveOrder(num)) throw new Error('Expected valid bigint: 0 < bigint < curve.n');
  }
  // Validates if priv key is valid and converts it to bigint.
  // Supports options allowedPrivateKeyLengths and wrapPrivateKey.
  function normPrivateKeyToScalar(key) {
    var lengths = CURVE.allowedPrivateKeyLengths,
      nByteLength = CURVE.nByteLength,
      wrapPrivateKey = CURVE.wrapPrivateKey,
      n = CURVE.n;
    if (lengths && typeof key !== 'bigint') {
      if (key instanceof Uint8Array) key = ut.bytesToHex(key);
      // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes
      if (typeof key !== 'string' || !lengths.includes(key.length)) throw new Error('Invalid key');
      key = key.padStart(nByteLength * 2, '0');
    }
    var num;
    try {
      num = typeof key === 'bigint' ? key : ut.bytesToNumberBE((0, utils_js_1.ensureBytes)('private key', key, nByteLength));
    } catch (error) {
      throw new Error("private key must be ".concat(nByteLength, " bytes, hex or bigint, not ").concat(_typeof(key)));
    }
    if (wrapPrivateKey) num = mod.mod(num, n); // disabled by default, enabled for BLS
    assertGE(num); // num in range [1..N-1]
    return num;
  }
  var pointPrecomputes = new Map();
  function assertPrjPoint(other) {
    if (!(other instanceof Point)) throw new Error('ProjectivePoint expected');
  }
  /**
   * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z)  (x=x/z, y=y/z)
   * Default Point works in 2d / affine coordinates: (x, y)
   * We're doing calculations in projective, because its operations don't require costly inversion.
   */
  var Point = /*#__PURE__*/function () {
    function Point(px, py, pz) {
      _classCallCheck(this, Point);
      this.px = px;
      this.py = py;
      this.pz = pz;
      if (px == null || !Fp.isValid(px)) throw new Error('x required');
      if (py == null || !Fp.isValid(py)) throw new Error('y required');
      if (pz == null || !Fp.isValid(pz)) throw new Error('z required');
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    return _createClass(Point, [{
      key: "x",
      get: function get() {
        return this.toAffine().x;
      }
    }, {
      key: "y",
      get: function get() {
        return this.toAffine().y;
      }
      /**
       * Takes a bunch of Projective Points but executes only one
       * inversion on all of them. Inversion is very slow operation,
       * so this improves performance massively.
       * Optimization: converts a list of projective points to a list of identical points with Z=1.
       */
    }, {
      key: "_setWindowSize",
      value:
      // "Private method", don't use it directly
      function _setWindowSize(windowSize) {
        this._WINDOW_SIZE = windowSize;
        pointPrecomputes["delete"](this);
      }
      // A point on curve is valid if it conforms to equation.
    }, {
      key: "assertValidity",
      value: function assertValidity() {
        if (this.is0()) {
          // (0, 1, 0) aka ZERO is invalid in most contexts.
          // In BLS, ZERO can be serialized, so we allow it.
          // (0, 0, 0) is wrong representation of ZERO and is always invalid.
          if (CURVE.allowInfinityPoint && !Fp.is0(this.py)) return;
          throw new Error('bad point: ZERO');
        }
        // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`
        var _this$toAffine = this.toAffine(),
          x = _this$toAffine.x,
          y = _this$toAffine.y;
        // Check if x, y are valid field elements
        if (!Fp.isValid(x) || !Fp.isValid(y)) throw new Error('bad point: x or y not FE');
        var left = Fp.sqr(y); // y
        var right = weierstrassEquation(x); // x + ax + b
        if (!Fp.eql(left, right)) throw new Error('bad point: equation left != right');
        if (!this.isTorsionFree()) throw new Error('bad point: not in prime-order subgroup');
      }
    }, {
      key: "hasEvenY",
      value: function hasEvenY() {
        var _this$toAffine2 = this.toAffine(),
          y = _this$toAffine2.y;
        if (Fp.isOdd) return !Fp.isOdd(y);
        throw new Error("Field doesn't support isOdd");
      }
      /**
       * Compare one point to another.
       */
    }, {
      key: "equals",
      value: function equals(other) {
        assertPrjPoint(other);
        var X1 = this.px,
          Y1 = this.py,
          Z1 = this.pz;
        var X2 = other.px,
          Y2 = other.py,
          Z2 = other.pz;
        var U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));
        var U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
        return U1 && U2;
      }
      /**
       * Flips point to one corresponding to (x, -y) in Affine coordinates.
       */
    }, {
      key: "negate",
      value: function negate() {
        return new Point(this.px, Fp.neg(this.py), this.pz);
      }
      // Renes-Costello-Batina exception-free doubling formula.
      // There is 30% faster Jacobian formula, but it is not complete.
      // https://eprint.iacr.org/2015/1060, algorithm 3
      // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    }, {
      key: "double",
      value: function double() {
        var a = CURVE.a,
          b = CURVE.b;
        var b3 = Fp.mul(b, _3n);
        var X1 = this.px,
          Y1 = this.py,
          Z1 = this.pz;
        var X3 = Fp.ZERO,
          Y3 = Fp.ZERO,
          Z3 = Fp.ZERO; // prettier-ignore
        var t0 = Fp.mul(X1, X1); // step 1
        var t1 = Fp.mul(Y1, Y1);
        var t2 = Fp.mul(Z1, Z1);
        var t3 = Fp.mul(X1, Y1);
        t3 = Fp.add(t3, t3); // step 5
        Z3 = Fp.mul(X1, Z1);
        Z3 = Fp.add(Z3, Z3);
        X3 = Fp.mul(a, Z3);
        Y3 = Fp.mul(b3, t2);
        Y3 = Fp.add(X3, Y3); // step 10
        X3 = Fp.sub(t1, Y3);
        Y3 = Fp.add(t1, Y3);
        Y3 = Fp.mul(X3, Y3);
        X3 = Fp.mul(t3, X3);
        Z3 = Fp.mul(b3, Z3); // step 15
        t2 = Fp.mul(a, t2);
        t3 = Fp.sub(t0, t2);
        t3 = Fp.mul(a, t3);
        t3 = Fp.add(t3, Z3);
        Z3 = Fp.add(t0, t0); // step 20
        t0 = Fp.add(Z3, t0);
        t0 = Fp.add(t0, t2);
        t0 = Fp.mul(t0, t3);
        Y3 = Fp.add(Y3, t0);
        t2 = Fp.mul(Y1, Z1); // step 25
        t2 = Fp.add(t2, t2);
        t0 = Fp.mul(t2, t3);
        X3 = Fp.sub(X3, t0);
        Z3 = Fp.mul(t2, t1);
        Z3 = Fp.add(Z3, Z3); // step 30
        Z3 = Fp.add(Z3, Z3);
        return new Point(X3, Y3, Z3);
      }
      // Renes-Costello-Batina exception-free addition formula.
      // There is 30% faster Jacobian formula, but it is not complete.
      // https://eprint.iacr.org/2015/1060, algorithm 1
      // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    }, {
      key: "add",
      value: function add(other) {
        assertPrjPoint(other);
        var X1 = this.px,
          Y1 = this.py,
          Z1 = this.pz;
        var X2 = other.px,
          Y2 = other.py,
          Z2 = other.pz;
        var X3 = Fp.ZERO,
          Y3 = Fp.ZERO,
          Z3 = Fp.ZERO; // prettier-ignore
        var a = CURVE.a;
        var b3 = Fp.mul(CURVE.b, _3n);
        var t0 = Fp.mul(X1, X2); // step 1
        var t1 = Fp.mul(Y1, Y2);
        var t2 = Fp.mul(Z1, Z2);
        var t3 = Fp.add(X1, Y1);
        var t4 = Fp.add(X2, Y2); // step 5
        t3 = Fp.mul(t3, t4);
        t4 = Fp.add(t0, t1);
        t3 = Fp.sub(t3, t4);
        t4 = Fp.add(X1, Z1);
        var t5 = Fp.add(X2, Z2); // step 10
        t4 = Fp.mul(t4, t5);
        t5 = Fp.add(t0, t2);
        t4 = Fp.sub(t4, t5);
        t5 = Fp.add(Y1, Z1);
        X3 = Fp.add(Y2, Z2); // step 15
        t5 = Fp.mul(t5, X3);
        X3 = Fp.add(t1, t2);
        t5 = Fp.sub(t5, X3);
        Z3 = Fp.mul(a, t4);
        X3 = Fp.mul(b3, t2); // step 20
        Z3 = Fp.add(X3, Z3);
        X3 = Fp.sub(t1, Z3);
        Z3 = Fp.add(t1, Z3);
        Y3 = Fp.mul(X3, Z3);
        t1 = Fp.add(t0, t0); // step 25
        t1 = Fp.add(t1, t0);
        t2 = Fp.mul(a, t2);
        t4 = Fp.mul(b3, t4);
        t1 = Fp.add(t1, t2);
        t2 = Fp.sub(t0, t2); // step 30
        t2 = Fp.mul(a, t2);
        t4 = Fp.add(t4, t2);
        t0 = Fp.mul(t1, t4);
        Y3 = Fp.add(Y3, t0);
        t0 = Fp.mul(t5, t4); // step 35
        X3 = Fp.mul(t3, X3);
        X3 = Fp.sub(X3, t0);
        t0 = Fp.mul(t3, t1);
        Z3 = Fp.mul(t5, Z3);
        Z3 = Fp.add(Z3, t0); // step 40
        return new Point(X3, Y3, Z3);
      }
    }, {
      key: "subtract",
      value: function subtract(other) {
        return this.add(other.negate());
      }
    }, {
      key: "is0",
      value: function is0() {
        return this.equals(Point.ZERO);
      }
    }, {
      key: "wNAF",
      value: function wNAF(n) {
        return wnaf.wNAFCached(this, pointPrecomputes, n, function (comp) {
          var toInv = Fp.invertBatch(comp.map(function (p) {
            return p.pz;
          }));
          return comp.map(function (p, i) {
            return p.toAffine(toInv[i]);
          }).map(Point.fromAffine);
        });
      }
      /**
       * Non-constant-time multiplication. Uses double-and-add algorithm.
       * It's faster, but should only be used when you don't care about
       * an exposed private key e.g. sig verification, which works over *public* keys.
       */
    }, {
      key: "multiplyUnsafe",
      value: function multiplyUnsafe(n) {
        var I = Point.ZERO;
        if (n === _0n) return I;
        assertGE(n); // Will throw on 0
        if (n === _1n) return this;
        var endo = CURVE.endo;
        if (!endo) return wnaf.unsafeLadder(this, n);
        // Apply endomorphism
        var _endo$splitScalar = endo.splitScalar(n),
          k1neg = _endo$splitScalar.k1neg,
          k1 = _endo$splitScalar.k1,
          k2neg = _endo$splitScalar.k2neg,
          k2 = _endo$splitScalar.k2;
        var k1p = I;
        var k2p = I;
        var d = this;
        while (k1 > _0n || k2 > _0n) {
          if (k1 & _1n) k1p = k1p.add(d);
          if (k2 & _1n) k2p = k2p.add(d);
          d = d["double"]();
          k1 >>= _1n;
          k2 >>= _1n;
        }
        if (k1neg) k1p = k1p.negate();
        if (k2neg) k2p = k2p.negate();
        k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
        return k1p.add(k2p);
      }
      /**
       * Constant time multiplication.
       * Uses wNAF method. Windowed method may be 10% faster,
       * but takes 2x longer to generate and consumes 2x memory.
       * Uses precomputes when available.
       * Uses endomorphism for Koblitz curves.
       * @param scalar by which the point would be multiplied
       * @returns New point
       */
    }, {
      key: "multiply",
      value: function multiply(scalar) {
        assertGE(scalar);
        var n = scalar;
        var point, fake; // Fake point is used to const-time mult
        var endo = CURVE.endo;
        if (endo) {
          var _endo$splitScalar2 = endo.splitScalar(n),
            k1neg = _endo$splitScalar2.k1neg,
            k1 = _endo$splitScalar2.k1,
            k2neg = _endo$splitScalar2.k2neg,
            k2 = _endo$splitScalar2.k2;
          var _this$wNAF = this.wNAF(k1),
            k1p = _this$wNAF.p,
            f1p = _this$wNAF.f;
          var _this$wNAF2 = this.wNAF(k2),
            k2p = _this$wNAF2.p,
            f2p = _this$wNAF2.f;
          k1p = wnaf.constTimeNegate(k1neg, k1p);
          k2p = wnaf.constTimeNegate(k2neg, k2p);
          k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
          point = k1p.add(k2p);
          fake = f1p.add(f2p);
        } else {
          var _this$wNAF3 = this.wNAF(n),
            p = _this$wNAF3.p,
            f = _this$wNAF3.f;
          point = p;
          fake = f;
        }
        // Normalize `z` for both points, but return only real one
        return Point.normalizeZ([point, fake])[0];
      }
      /**
       * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
       * Not using Strauss-Shamir trick: precomputation tables are faster.
       * The trick could be useful if both P and Q are not G (not in our case).
       * @returns non-zero affine point
       */
    }, {
      key: "multiplyAndAddUnsafe",
      value: function multiplyAndAddUnsafe(Q, a, b) {
        var G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes
        var mul = function mul(P, a // Select faster multiply() method
        ) {
          return a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a);
        };
        var sum = mul(this, a).add(mul(Q, b));
        return sum.is0() ? undefined : sum;
      }
      // Converts Projective point to affine (x, y) coordinates.
      // Can accept precomputed Z^-1 - for example, from invertBatch.
      // (x, y, z)  (x=x/z, y=y/z)
    }, {
      key: "toAffine",
      value: function toAffine(iz) {
        var x = this.px,
          y = this.py,
          z = this.pz;
        var is0 = this.is0();
        // If invZ was 0, we return zero point. However we still want to execute
        // all operations, so we replace invZ with a random number, 1.
        if (iz == null) iz = is0 ? Fp.ONE : Fp.inv(z);
        var ax = Fp.mul(x, iz);
        var ay = Fp.mul(y, iz);
        var zz = Fp.mul(z, iz);
        if (is0) return {
          x: Fp.ZERO,
          y: Fp.ZERO
        };
        if (!Fp.eql(zz, Fp.ONE)) throw new Error('invZ was invalid');
        return {
          x: ax,
          y: ay
        };
      }
    }, {
      key: "isTorsionFree",
      value: function isTorsionFree() {
        var cofactor = CURVE.h,
          isTorsionFree = CURVE.isTorsionFree;
        if (cofactor === _1n) return true; // No subgroups, always torsion-free
        if (isTorsionFree) return isTorsionFree(Point, this);
        throw new Error('isTorsionFree() has not been declared for the elliptic curve');
      }
    }, {
      key: "clearCofactor",
      value: function clearCofactor() {
        var cofactor = CURVE.h,
          clearCofactor = CURVE.clearCofactor;
        if (cofactor === _1n) return this; // Fast-path
        if (clearCofactor) return clearCofactor(Point, this);
        return this.multiplyUnsafe(CURVE.h);
      }
    }, {
      key: "toRawBytes",
      value: function toRawBytes() {
        var isCompressed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        this.assertValidity();
        return toBytes(Point, this, isCompressed);
      }
    }, {
      key: "toHex",
      value: function toHex() {
        var isCompressed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        return ut.bytesToHex(this.toRawBytes(isCompressed));
      }
    }], [{
      key: "fromAffine",
      value: function fromAffine(p) {
        var _ref = p || {},
          x = _ref.x,
          y = _ref.y;
        if (!p || !Fp.isValid(x) || !Fp.isValid(y)) throw new Error('invalid affine point');
        if (p instanceof Point) throw new Error('projective point not allowed');
        var is0 = function is0(i) {
          return Fp.eql(i, Fp.ZERO);
        };
        // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)
        if (is0(x) && is0(y)) return Point.ZERO;
        return new Point(x, y, Fp.ONE);
      }
    }, {
      key: "normalizeZ",
      value: function normalizeZ(points) {
        var toInv = Fp.invertBatch(points.map(function (p) {
          return p.pz;
        }));
        return points.map(function (p, i) {
          return p.toAffine(toInv[i]);
        }).map(Point.fromAffine);
      }
      /**
       * Converts hash string or Uint8Array to Point.
       * @param hex short/long ECDSA hex
       */
    }, {
      key: "fromHex",
      value: function fromHex(hex) {
        var P = Point.fromAffine(fromBytes((0, utils_js_1.ensureBytes)('pointHex', hex)));
        P.assertValidity();
        return P;
      }
      // Multiplies generator point by privateKey.
    }, {
      key: "fromPrivateKey",
      value: function fromPrivateKey(privateKey) {
        return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));
      }
    }]);
  }();
  Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);
  Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);
  var _bits = CURVE.nBitLength;
  var wnaf = (0, curve_js_1.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
  // Validate if generator point is on curve
  return {
    CURVE: CURVE,
    ProjectivePoint: Point,
    normPrivateKeyToScalar: normPrivateKeyToScalar,
    weierstrassEquation: weierstrassEquation,
    isWithinCurveOrder: isWithinCurveOrder
  };
}
exports.weierstrassPoints = weierstrassPoints;
function validateOpts(curve) {
  var opts = (0, curve_js_1.validateBasic)(curve);
  ut.validateObject(opts, {
    hash: 'hash',
    hmac: 'function',
    randomBytes: 'function'
  }, {
    bits2int: 'function',
    bits2int_modN: 'function',
    lowS: 'boolean'
  });
  return Object.freeze(_objectSpread({
    lowS: true
  }, opts));
}
function weierstrass(curveDef) {
  var CURVE = validateOpts(curveDef);
  var Fp = CURVE.Fp,
    CURVE_ORDER = CURVE.n;
  var compressedLen = Fp.BYTES + 1; // e.g. 33 for 32
  var uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32
  function isValidFieldElement(num) {
    return _0n < num && num < Fp.ORDER; // 0 is banned since it's not invertible FE
  }
  function modN(a) {
    return mod.mod(a, CURVE_ORDER);
  }
  function invN(a) {
    return mod.invert(a, CURVE_ORDER);
  }
  var _weierstrassPoints = weierstrassPoints(_objectSpread(_objectSpread({}, CURVE), {}, {
      toBytes: function toBytes(_c, point, isCompressed) {
        var a = point.toAffine();
        var x = Fp.toBytes(a.x);
        var cat = ut.concatBytes;
        if (isCompressed) {
          return cat(Uint8Array.from([point.hasEvenY() ? 0x02 : 0x03]), x);
        } else {
          return cat(Uint8Array.from([0x04]), x, Fp.toBytes(a.y));
        }
      },
      fromBytes: function fromBytes(bytes) {
        var len = bytes.length;
        var head = bytes[0];
        var tail = bytes.subarray(1);
        // this.assertValidity() is done inside of fromHex
        if (len === compressedLen && (head === 0x02 || head === 0x03)) {
          var x = ut.bytesToNumberBE(tail);
          if (!isValidFieldElement(x)) throw new Error('Point is not on curve');
          var y2 = weierstrassEquation(x); // y = x + ax + b
          var y = Fp.sqrt(y2); // y = y ^ (p+1)/4
          var isYOdd = (y & _1n) === _1n;
          // ECDSA
          var isHeadOdd = (head & 1) === 1;
          if (isHeadOdd !== isYOdd) y = Fp.neg(y);
          return {
            x: x,
            y: y
          };
        } else if (len === uncompressedLen && head === 0x04) {
          var _x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
          var _y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
          return {
            x: _x,
            y: _y
          };
        } else {
          throw new Error("Point of length ".concat(len, " was invalid. Expected ").concat(compressedLen, " compressed bytes or ").concat(uncompressedLen, " uncompressed bytes"));
        }
      }
    })),
    Point = _weierstrassPoints.ProjectivePoint,
    normPrivateKeyToScalar = _weierstrassPoints.normPrivateKeyToScalar,
    weierstrassEquation = _weierstrassPoints.weierstrassEquation,
    isWithinCurveOrder = _weierstrassPoints.isWithinCurveOrder;
  var numToNByteStr = function numToNByteStr(num) {
    return ut.bytesToHex(ut.numberToBytesBE(num, CURVE.nByteLength));
  };
  function isBiggerThanHalfOrder(number) {
    var HALF = CURVE_ORDER >> _1n;
    return number > HALF;
  }
  function normalizeS(s) {
    return isBiggerThanHalfOrder(s) ? modN(-s) : s;
  }
  // slice bytes num
  var slcNum = function slcNum(b, from, to) {
    return ut.bytesToNumberBE(b.slice(from, to));
  };
  /**
   * ECDSA signature with its (r, s) properties. Supports DER & compact representations.
   */
  var Signature = /*#__PURE__*/function () {
    function Signature(r, s, recovery) {
      _classCallCheck(this, Signature);
      this.r = r;
      this.s = s;
      this.recovery = recovery;
      this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    return _createClass(Signature, [{
      key: "assertValidity",
      value: function assertValidity() {
        // can use assertGE here
        if (!isWithinCurveOrder(this.r)) throw new Error('r must be 0 < r < CURVE.n');
        if (!isWithinCurveOrder(this.s)) throw new Error('s must be 0 < s < CURVE.n');
      }
    }, {
      key: "addRecoveryBit",
      value: function addRecoveryBit(recovery) {
        return new Signature(this.r, this.s, recovery);
      }
    }, {
      key: "recoverPublicKey",
      value: function recoverPublicKey(msgHash) {
        var r = this.r,
          s = this.s,
          rec = this.recovery;
        var h = bits2int_modN((0, utils_js_1.ensureBytes)('msgHash', msgHash)); // Truncate hash
        if (rec == null || ![0, 1, 2, 3].includes(rec)) throw new Error('recovery id invalid');
        var radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
        if (radj >= Fp.ORDER) throw new Error('recovery id 2 or 3 invalid');
        var prefix = (rec & 1) === 0 ? '02' : '03';
        var R = Point.fromHex(prefix + numToNByteStr(radj));
        var ir = invN(radj); // r^-1
        var u1 = modN(-h * ir); // -hr^-1
        var u2 = modN(s * ir); // sr^-1
        var Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)
        if (!Q) throw new Error('point at infinify'); // unsafe is fine: no priv data leaked
        Q.assertValidity();
        return Q;
      }
      // Signatures should be low-s, to prevent malleability.
    }, {
      key: "hasHighS",
      value: function hasHighS() {
        return isBiggerThanHalfOrder(this.s);
      }
    }, {
      key: "normalizeS",
      value: function normalizeS() {
        return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;
      }
      // DER-encoded
    }, {
      key: "toDERRawBytes",
      value: function toDERRawBytes() {
        return ut.hexToBytes(this.toDERHex());
      }
    }, {
      key: "toDERHex",
      value: function toDERHex() {
        return exports.DER.hexFromSig({
          r: this.r,
          s: this.s
        });
      }
      // padded bytes of r, then padded bytes of s
    }, {
      key: "toCompactRawBytes",
      value: function toCompactRawBytes() {
        return ut.hexToBytes(this.toCompactHex());
      }
    }, {
      key: "toCompactHex",
      value: function toCompactHex() {
        return numToNByteStr(this.r) + numToNByteStr(this.s);
      }
    }], [{
      key: "fromCompact",
      value: function fromCompact(hex) {
        var l = CURVE.nByteLength;
        hex = (0, utils_js_1.ensureBytes)('compactSignature', hex, l * 2);
        return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
      }
      // DER encoded ECDSA signature
      // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    }, {
      key: "fromDER",
      value: function fromDER(hex) {
        var _exports$DER$toSig = exports.DER.toSig((0, utils_js_1.ensureBytes)('DER', hex)),
          r = _exports$DER$toSig.r,
          s = _exports$DER$toSig.s;
        return new Signature(r, s);
      }
    }]);
  }();
  var utils = {
    isValidPrivateKey: function isValidPrivateKey(privateKey) {
      try {
        normPrivateKeyToScalar(privateKey);
        return true;
      } catch (error) {
        return false;
      }
    },
    normPrivateKeyToScalar: normPrivateKeyToScalar,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: function randomPrivateKey() {
      var length = mod.getMinHashLength(CURVE.n);
      return mod.mapHashToField(CURVE.randomBytes(length), CURVE.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute: function precompute() {
      var windowSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 8;
      var point = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Point.BASE;
      point._setWindowSize(windowSize);
      point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here
      return point;
    }
  };
  /**
   * Computes public key for a private key. Checks for validity of the private key.
   * @param privateKey private key
   * @param isCompressed whether to return compact (default), or full key
   * @returns Public key, full when isCompressed=false; short when isCompressed=true
   */
  function getPublicKey(privateKey) {
    var isCompressed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
  }
  /**
   * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.
   */
  function isProbPub(item) {
    var arr = item instanceof Uint8Array;
    var str = typeof item === 'string';
    var len = (arr || str) && item.length;
    if (arr) return len === compressedLen || len === uncompressedLen;
    if (str) return len === 2 * compressedLen || len === 2 * uncompressedLen;
    if (item instanceof Point) return true;
    return false;
  }
  /**
   * ECDH (Elliptic Curve Diffie Hellman).
   * Computes shared public key from private key and public key.
   * Checks: 1) private key validity 2) shared key is on-curve.
   * Does NOT hash the result.
   * @param privateA private key
   * @param publicB different public key
   * @param isCompressed whether to return compact (default), or full key
   * @returns shared public key
   */
  function getSharedSecret(privateA, publicB) {
    var isCompressed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
    if (isProbPub(privateA)) throw new Error('first arg must be private key');
    if (!isProbPub(publicB)) throw new Error('second arg must be public key');
    var b = Point.fromHex(publicB); // check for being on-curve
    return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
  }
  // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.
  // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.
  // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.
  // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors
  var bits2int = CURVE.bits2int || function (bytes) {
    // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)
    // for some cases, since bytes.length * 8 is not actual bitLength.
    var num = ut.bytesToNumberBE(bytes); // check for == u8 done here
    var delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits
    return delta > 0 ? num >> BigInt(delta) : num;
  };
  var bits2int_modN = CURVE.bits2int_modN || function (bytes) {
    return modN(bits2int(bytes)); // can't use bytesToNumberBE here
  };
  // NOTE: pads output with zero as per spec
  var ORDER_MASK = ut.bitMask(CURVE.nBitLength);
  /**
   * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.
   */
  function int2octets(num) {
    if (typeof num !== 'bigint') throw new Error('bigint expected');
    if (!(_0n <= num && num < ORDER_MASK)) throw new Error("bigint expected < 2^".concat(CURVE.nBitLength));
    // works with order, can have different size than numToField!
    return ut.numberToBytesBE(num, CURVE.nByteLength);
  }
  // Steps A, D of RFC6979 3.2
  // Creates RFC6979 seed; converts msg/privKey to numbers.
  // Used only in sign, not in verify.
  // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order, this will be wrong at least for P521.
  // Also it can be bigger for P224 + SHA256
  function prepSig(msgHash, privateKey) {
    var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultSigOpts;
    if (['recovered', 'canonical'].some(function (k) {
      return k in opts;
    })) throw new Error('sign() legacy options not supported');
    var hash = CURVE.hash,
      randomBytes = CURVE.randomBytes;
    var lowS = opts.lowS,
      prehash = opts.prehash,
      ent = opts.extraEntropy; // generates low-s sigs by default
    if (lowS == null) lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash
    msgHash = (0, utils_js_1.ensureBytes)('msgHash', msgHash);
    if (prehash) msgHash = (0, utils_js_1.ensureBytes)('prehashed msgHash', hash(msgHash));
    // We can't later call bits2octets, since nested bits2int is broken for curves
    // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.
    // const bits2octets = (bits) => int2octets(bits2int_modN(bits))
    var h1int = bits2int_modN(msgHash);
    var d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint
    var seedArgs = [int2octets(d), int2octets(h1int)];
    // extraEntropy. RFC6979 3.6: additional k' (optional).
    if (ent != null) {
      // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')
      var e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is
      seedArgs.push((0, utils_js_1.ensureBytes)('extraEntropy', e)); // check for being bytes
    }
    var seed = ut.concatBytes.apply(ut, seedArgs); // Step D of RFC6979 3.2
    var m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!
    // Converts signature params into point w r/s, checks result for validity.
    function k2sig(kBytes) {
      // RFC 6979 Section 3.2, step 3: k = bits2int(T)
      var k = bits2int(kBytes); // Cannot use fields methods, since it is group element
      if (!isWithinCurveOrder(k)) return; // Important: all mod() calls here must be done over N
      var ik = invN(k); // k^-1 mod n
      var q = Point.BASE.multiply(k).toAffine(); // q = Gk
      var r = modN(q.x); // r = q.x mod n
      if (r === _0n) return;
      // Can use scalar blinding b^-1(bm + bdr) where b  [1,q1] according to
      // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:
      // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT
      var s = modN(ik * modN(m + r * d)); // Not using blinding here
      if (s === _0n) return;
      var recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)
      var normS = s;
      if (lowS && isBiggerThanHalfOrder(s)) {
        normS = normalizeS(s); // if lowS was passed, ensure s is always
        recovery ^= 1; // // in the bottom half of N
      }
      return new Signature(r, normS, recovery); // use normS, not s
    }
    return {
      seed: seed,
      k2sig: k2sig
    };
  }
  var defaultSigOpts = {
    lowS: CURVE.lowS,
    prehash: false
  };
  var defaultVerOpts = {
    lowS: CURVE.lowS,
    prehash: false
  };
  /**
   * Signs message hash with a private key.
   * ```
   * sign(m, d, k) where
   *   (x, y) = G  k
   *   r = x mod n
   *   s = (m + dr)/k mod n
   * ```
   * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.
   * @param privKey private key
   * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.
   * @returns signature with recovery param
   */
  function sign(msgHash, privKey) {
    var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultSigOpts;
    var _prepSig = prepSig(msgHash, privKey, opts),
      seed = _prepSig.seed,
      k2sig = _prepSig.k2sig; // Steps A, D of RFC6979 3.2.
    var C = CURVE;
    var drbg = ut.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
    return drbg(seed, k2sig); // Steps B, C, D, E, F, G
  }
  // Enable precomputes. Slows down first publicKey computation by 20ms.
  Point.BASE._setWindowSize(8);
  // utils.precompute(8, ProjectivePoint.BASE)
  /**
   * Verifies a signature against message hash and public key.
   * Rejects lowS signatures by default: to override,
   * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:
   *
   * ```
   * verify(r, s, h, P) where
   *   U1 = hs^-1 mod n
   *   U2 = rs^-1 mod n
   *   R = U1G - U2P
   *   mod(R.x, n) == r
   * ```
   */
  function verify(signature, msgHash, publicKey) {
    var _Point$BASE$multiplyA;
    var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : defaultVerOpts;
    var sg = signature;
    msgHash = (0, utils_js_1.ensureBytes)('msgHash', msgHash);
    publicKey = (0, utils_js_1.ensureBytes)('publicKey', publicKey);
    if ('strict' in opts) throw new Error('options.strict was renamed to lowS');
    var lowS = opts.lowS,
      prehash = opts.prehash;
    var _sig = undefined;
    var P;
    try {
      if (typeof sg === 'string' || sg instanceof Uint8Array) {
        // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).
        // Since DER can also be 2*nByteLength bytes, we check for it first.
        try {
          _sig = Signature.fromDER(sg);
        } catch (derError) {
          if (!(derError instanceof exports.DER.Err)) throw derError;
          _sig = Signature.fromCompact(sg);
        }
      } else if (_typeof(sg) === 'object' && typeof sg.r === 'bigint' && typeof sg.s === 'bigint') {
        var _r = sg.r,
          _s = sg.s;
        _sig = new Signature(_r, _s);
      } else {
        throw new Error('PARSE');
      }
      P = Point.fromHex(publicKey);
    } catch (error) {
      if (error.message === 'PARSE') throw new Error("signature must be Signature instance, Uint8Array or hex string");
      return false;
    }
    if (lowS && _sig.hasHighS()) return false;
    if (prehash) msgHash = CURVE.hash(msgHash);
    var _sig2 = _sig,
      r = _sig2.r,
      s = _sig2.s;
    var h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element
    var is = invN(s); // s^-1
    var u1 = modN(h * is); // u1 = hs^-1 mod n
    var u2 = modN(r * is); // u2 = rs^-1 mod n
    var R = (_Point$BASE$multiplyA = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)) === null || _Point$BASE$multiplyA === void 0 ? void 0 : _Point$BASE$multiplyA.toAffine(); // R = u1G + u2P
    if (!R) return false;
    var v = modN(R.x);
    return v === r;
  }
  return {
    CURVE: CURVE,
    getPublicKey: getPublicKey,
    getSharedSecret: getSharedSecret,
    sign: sign,
    verify: verify,
    ProjectivePoint: Point,
    Signature: Signature,
    utils: utils
  };
}
exports.weierstrass = weierstrass;
/**
 * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.
 * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.
 * b = True and y = sqrt(u / v) if (u / v) is square in F, and
 * b = False and y = sqrt(Z * (u / v)) otherwise.
 * @param Fp
 * @param Z
 * @returns
 */
function SWUFpSqrtRatio(Fp, Z) {
  // Generic implementation
  var q = Fp.ORDER;
  var l = _0n;
  for (var o = q - _1n; o % _2n === _0n; o /= _2n) l += _1n;
  var c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.
  // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.
  // 2n ** c1 == 2n << (c1-1)
  var _2n_pow_c1_1 = _2n << c1 - _1n - _1n;
  var _2n_pow_c1 = _2n_pow_c1_1 * _2n;
  var c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic
  var c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic
  var c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic
  var c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic
  var c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2
  var c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)
  var sqrtRatio = function sqrtRatio(u, v) {
    var tv1 = c6; // 1. tv1 = c6
    var tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4
    var tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2
    tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v
    var tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3
    tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3
    tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2
    tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v
    tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u
    var tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2
    tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5
    var isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1
    tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7
    tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1
    tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)
    tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)
    // 17. for i in (c1, c1 - 1, ..., 2):
    for (var i = c1; i > _1n; i--) {
      var _tv = i - _2n; // 18.    tv5 = i - 2
      _tv = _2n << _tv - _1n; // 19.    tv5 = 2^tv5
      var tvv5 = Fp.pow(tv4, _tv); // 20.    tv5 = tv4^tv5
      var e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1
      tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1
      tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1
      tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1
      tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)
      tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)
    }
    return {
      isValid: isQR,
      value: tv3
    };
  };
  if (Fp.ORDER % _4n === _3n) {
    // sqrt_ratio_3mod4(u, v)
    var _c2 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic
    var _c3 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)
    sqrtRatio = function sqrtRatio(u, v) {
      var tv1 = Fp.sqr(v); // 1. tv1 = v^2
      var tv2 = Fp.mul(u, v); // 2. tv2 = u * v
      tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2
      var y1 = Fp.pow(tv1, _c2); // 4. y1 = tv1^c1
      y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2
      var y2 = Fp.mul(y1, _c3); // 6. y2 = y1 * c2
      var tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v
      var isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u
      var y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)
      return {
        isValid: isQR,
        value: y
      }; // 11. return (isQR, y) isQR ? y : y*c2
    };
  }
  // No curves uses that
  // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8
  return sqrtRatio;
}
exports.SWUFpSqrtRatio = SWUFpSqrtRatio;
/**
 * Simplified Shallue-van de Woestijne-Ulas Method
 * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2
 */
function mapToCurveSimpleSWU(Fp, opts) {
  mod.validateField(Fp);
  if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z)) throw new Error('mapToCurveSimpleSWU: invalid opts');
  var sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);
  if (!Fp.isOdd) throw new Error('Fp.isOdd is not implemented!');
  // Input: u, an element of F.
  // Output: (x, y), a point on E.
  return function (u) {
    // prettier-ignore
    var tv1, tv2, tv3, tv4, tv5, tv6, x, y;
    tv1 = Fp.sqr(u); // 1.  tv1 = u^2
    tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1
    tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2
    tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1
    tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1
    tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3
    tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)
    tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4
    tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2
    tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2
    tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6
    tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5
    tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3
    tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4
    tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6
    tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5
    x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3
    var _sqrtRatio = sqrtRatio(tv2, tv6),
      isValid = _sqrtRatio.isValid,
      value = _sqrtRatio.value; // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)
    y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1
    y = Fp.mul(y, value); // 20.   y = y * y1
    x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)
    y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)
    var e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)
    y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)
    x = Fp.div(x, tv4); // 25.   x = x / tv4
    return {
      x: x,
      y: y
    };
  };
}
exports.mapToCurveSimpleSWU = mapToCurveSimpleSWU;

},{"./curve.js":56,"./modular.js":58,"./utils.js":59}],61:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.encodeToCurve = exports.hashToCurve = exports.schnorr = exports.secp256k1 = void 0;
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
var sha256_1 = require("@noble/hashes/sha256");
var utils_1 = require("@noble/hashes/utils");
var modular_js_1 = require("./abstract/modular.js");
var weierstrass_js_1 = require("./abstract/weierstrass.js");
var utils_js_1 = require("./abstract/utils.js");
var hash_to_curve_js_1 = require("./abstract/hash-to-curve.js");
var _shortw_utils_js_1 = require("./_shortw_utils.js");
var secp256k1P = BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f');
var secp256k1N = BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141');
var _1n = BigInt(1);
var _2n = BigInt(2);
var divNearest = function divNearest(a, b) {
  return (a + b / _2n) / b;
};
/**
 * n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.
 * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]
 */
function sqrtMod(y) {
  var P = secp256k1P;
  // prettier-ignore
  var _3n = BigInt(3),
    _6n = BigInt(6),
    _11n = BigInt(11),
    _22n = BigInt(22);
  // prettier-ignore
  var _23n = BigInt(23),
    _44n = BigInt(44),
    _88n = BigInt(88);
  var b2 = y * y * y % P; // x^3, 11
  var b3 = b2 * b2 * y % P; // x^7
  var b6 = (0, modular_js_1.pow2)(b3, _3n, P) * b3 % P;
  var b9 = (0, modular_js_1.pow2)(b6, _3n, P) * b3 % P;
  var b11 = (0, modular_js_1.pow2)(b9, _2n, P) * b2 % P;
  var b22 = (0, modular_js_1.pow2)(b11, _11n, P) * b11 % P;
  var b44 = (0, modular_js_1.pow2)(b22, _22n, P) * b22 % P;
  var b88 = (0, modular_js_1.pow2)(b44, _44n, P) * b44 % P;
  var b176 = (0, modular_js_1.pow2)(b88, _88n, P) * b88 % P;
  var b220 = (0, modular_js_1.pow2)(b176, _44n, P) * b44 % P;
  var b223 = (0, modular_js_1.pow2)(b220, _3n, P) * b3 % P;
  var t1 = (0, modular_js_1.pow2)(b223, _23n, P) * b22 % P;
  var t2 = (0, modular_js_1.pow2)(t1, _6n, P) * b2 % P;
  var root = (0, modular_js_1.pow2)(t2, _2n, P);
  if (!Fp.eql(Fp.sqr(root), y)) throw new Error('Cannot find square root');
  return root;
}
var Fp = (0, modular_js_1.Field)(secp256k1P, undefined, undefined, {
  sqrt: sqrtMod
});
exports.secp256k1 = (0, _shortw_utils_js_1.createCurve)({
  a: BigInt(0),
  b: BigInt(7),
  Fp: Fp,
  n: secp256k1N,
  // Base point (x, y) aka generator point
  Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),
  Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),
  h: BigInt(1),
  lowS: true,
  /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */
  endo: {
    beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),
    splitScalar: function splitScalar(k) {
      var n = secp256k1N;
      var a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');
      var b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');
      var a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');
      var b2 = a1;
      var POW_2_128 = BigInt('0x100000000000000000000000000000000'); // (2n**128n).toString(16)
      var c1 = divNearest(b2 * k, n);
      var c2 = divNearest(-b1 * k, n);
      var k1 = (0, modular_js_1.mod)(k - c1 * a1 - c2 * a2, n);
      var k2 = (0, modular_js_1.mod)(-c1 * b1 - c2 * b2, n);
      var k1neg = k1 > POW_2_128;
      var k2neg = k2 > POW_2_128;
      if (k1neg) k1 = n - k1;
      if (k2neg) k2 = n - k2;
      if (k1 > POW_2_128 || k2 > POW_2_128) {
        throw new Error('splitScalar: Endomorphism failed, k=' + k);
      }
      return {
        k1neg: k1neg,
        k1: k1,
        k2neg: k2neg,
        k2: k2
      };
    }
  }
}, sha256_1.sha256);
// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.
// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki
var _0n = BigInt(0);
var fe = function fe(x) {
  return typeof x === 'bigint' && _0n < x && x < secp256k1P;
};
var ge = function ge(x) {
  return typeof x === 'bigint' && _0n < x && x < secp256k1N;
};
/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */
var TAGGED_HASH_PREFIXES = {};
function taggedHash(tag) {
  var tagP = TAGGED_HASH_PREFIXES[tag];
  if (tagP === undefined) {
    var tagH = (0, sha256_1.sha256)(Uint8Array.from(tag, function (c) {
      return c.charCodeAt(0);
    }));
    tagP = (0, utils_js_1.concatBytes)(tagH, tagH);
    TAGGED_HASH_PREFIXES[tag] = tagP;
  }
  for (var _len = arguments.length, messages = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    messages[_key - 1] = arguments[_key];
  }
  return (0, sha256_1.sha256)((0, utils_js_1.concatBytes).apply(void 0, [tagP].concat(messages)));
}
// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03
var pointToBytes = function pointToBytes(point) {
  return point.toRawBytes(true).slice(1);
};
var numTo32b = function numTo32b(n) {
  return (0, utils_js_1.numberToBytesBE)(n, 32);
};
var modP = function modP(x) {
  return (0, modular_js_1.mod)(x, secp256k1P);
};
var modN = function modN(x) {
  return (0, modular_js_1.mod)(x, secp256k1N);
};
var Point = exports.secp256k1.ProjectivePoint;
var GmulAdd = function GmulAdd(Q, a, b) {
  return Point.BASE.multiplyAndAddUnsafe(Q, a, b);
};
// Calculate point, scalar and bytes
function schnorrGetExtPubKey(priv) {
  var d_ = exports.secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey
  var p = Point.fromPrivateKey(d_); // P = d'G; 0 < d' < n check is done inside
  var scalar = p.hasEvenY() ? d_ : modN(-d_);
  return {
    scalar: scalar,
    bytes: pointToBytes(p)
  };
}
/**
 * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.
 * @returns valid point checked for being on-curve
 */
function lift_x(x) {
  if (!fe(x)) throw new Error('bad x: need 0 < x < p'); // Fail if x  p.
  var xx = modP(x * x);
  var c = modP(xx * x + BigInt(7)); // Let c = x + 7 mod p.
  var y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.
  if (y % _2n !== _0n) y = modP(-y); // Return the unique point P such that x(P) = x and
  var p = new Point(x, y, _1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.
  p.assertValidity();
  return p;
}
/**
 * Create tagged hash, convert it to bigint, reduce modulo-n.
 */
function challenge() {
  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }
  return modN((0, utils_js_1.bytesToNumberBE)(taggedHash.apply(void 0, ['BIP0340/challenge'].concat(args))));
}
/**
 * Schnorr public key is just `x` coordinate of Point as per BIP340.
 */
function schnorrGetPublicKey(privateKey) {
  return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'n. Ret bytes(d'G)
}
/**
 * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.
 * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.
 */
function schnorrSign(message, privateKey) {
  var auxRand = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : (0, utils_1.randomBytes)(32);
  var m = (0, utils_js_1.ensureBytes)('message', message);
  var _schnorrGetExtPubKey = schnorrGetExtPubKey(privateKey),
    px = _schnorrGetExtPubKey.bytes,
    d = _schnorrGetExtPubKey.scalar; // checks for isWithinCurveOrder
  var a = (0, utils_js_1.ensureBytes)('auxRand', auxRand, 32); // Auxiliary random data a: a 32-byte array
  var t = numTo32b(d ^ (0, utils_js_1.bytesToNumberBE)(taggedHash('BIP0340/aux', a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)
  var rand = taggedHash('BIP0340/nonce', t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)
  var k_ = modN((0, utils_js_1.bytesToNumberBE)(rand)); // Let k' = int(rand) mod n
  if (k_ === _0n) throw new Error('sign failed: k is zero'); // Fail if k' = 0.
  var _schnorrGetExtPubKey2 = schnorrGetExtPubKey(k_),
    rx = _schnorrGetExtPubKey2.bytes,
    k = _schnorrGetExtPubKey2.scalar; // Let R = k'G.
  var e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.
  var sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).
  sig.set(rx, 0);
  sig.set(numTo32b(modN(k + e * d)), 32);
  // If Verify(bytes(P), m, sig) (see below) returns failure, abort
  if (!schnorrVerify(sig, m, px)) throw new Error('sign: Invalid signature produced');
  return sig;
}
/**
 * Verifies Schnorr signature.
 * Will swallow errors & return false except for initial type validation of arguments.
 */
function schnorrVerify(signature, message, publicKey) {
  var sig = (0, utils_js_1.ensureBytes)('signature', signature, 64);
  var m = (0, utils_js_1.ensureBytes)('message', message);
  var pub = (0, utils_js_1.ensureBytes)('publicKey', publicKey, 32);
  try {
    var P = lift_x((0, utils_js_1.bytesToNumberBE)(pub)); // P = lift_x(int(pk)); fail if that fails
    var r = (0, utils_js_1.bytesToNumberBE)(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r  p.
    if (!fe(r)) return false;
    var s = (0, utils_js_1.bytesToNumberBE)(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s  n.
    if (!ge(s)) return false;
    var e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n
    var R = GmulAdd(P, s, modN(-e)); // R = sG - eP
    if (!R || !R.hasEvenY() || R.toAffine().x !== r) return false; // -eP == (n-e)P
    return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R)  r.
  } catch (error) {
    return false;
  }
}
exports.schnorr = function () {
  return {
    getPublicKey: schnorrGetPublicKey,
    sign: schnorrSign,
    verify: schnorrVerify,
    utils: {
      randomPrivateKey: exports.secp256k1.utils.randomPrivateKey,
      lift_x: lift_x,
      pointToBytes: pointToBytes,
      numberToBytesBE: utils_js_1.numberToBytesBE,
      bytesToNumberBE: utils_js_1.bytesToNumberBE,
      taggedHash: taggedHash,
      mod: modular_js_1.mod
    }
  };
}();
var isoMap = /* @__PURE__ */function () {
  return (0, hash_to_curve_js_1.isogenyMap)(Fp, [
  // xNum
  ['0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7', '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581', '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262', '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c'],
  // xDen
  ['0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b', '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14', '0x0000000000000000000000000000000000000000000000000000000000000001' // LAST 1
  ],
  // yNum
  ['0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c', '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3', '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931', '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84'],
  // yDen
  ['0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b', '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573', '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f', '0x0000000000000000000000000000000000000000000000000000000000000001' // LAST 1
  ]].map(function (i) {
    return i.map(function (j) {
      return BigInt(j);
    });
  }));
}();
var mapSWU = /* @__PURE__ */function () {
  return (0, weierstrass_js_1.mapToCurveSimpleSWU)(Fp, {
    A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),
    B: BigInt('1771'),
    Z: Fp.create(BigInt('-11'))
  });
}();
var htf = /* @__PURE__ */function () {
  return (0, hash_to_curve_js_1.createHasher)(exports.secp256k1.ProjectivePoint, function (scalars) {
    var _mapSWU = mapSWU(Fp.create(scalars[0])),
      x = _mapSWU.x,
      y = _mapSWU.y;
    return isoMap(x, y);
  }, {
    DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',
    encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',
    p: Fp.ORDER,
    m: 1,
    k: 128,
    expand: 'xmd',
    hash: sha256_1.sha256
  });
}();
exports.hashToCurve = function () {
  return htf.hashToCurve;
}();
exports.encodeToCurve = function () {
  return htf.encodeToCurve;
}();

},{"./_shortw_utils.js":55,"./abstract/hash-to-curve.js":57,"./abstract/modular.js":58,"./abstract/utils.js":59,"./abstract/weierstrass.js":60,"@noble/hashes/sha256":70,"@noble/hashes/utils":73}],62:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = void 0;
function number(n) {
  if (!Number.isSafeInteger(n) || n < 0) throw new Error("Wrong positive integer: ".concat(n));
}
exports.number = number;
function bool(b) {
  if (typeof b !== 'boolean') throw new Error("Expected boolean, not ".concat(b));
}
exports.bool = bool;
function bytes(b) {
  if (!(b instanceof Uint8Array)) throw new Error('Expected Uint8Array');
  for (var _len = arguments.length, lengths = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    lengths[_key - 1] = arguments[_key];
  }
  if (lengths.length > 0 && !lengths.includes(b.length)) throw new Error("Expected Uint8Array of length ".concat(lengths, ", not of length=").concat(b.length));
}
exports.bytes = bytes;
function hash(hash) {
  if (typeof hash !== 'function' || typeof hash.create !== 'function') throw new Error('Hash should be wrapped by utils.wrapConstructor');
  number(hash.outputLen);
  number(hash.blockLen);
}
exports.hash = hash;
function exists(instance) {
  var checkFinished = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  if (instance.destroyed) throw new Error('Hash instance has been destroyed');
  if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');
}
exports.exists = exists;
function output(out, instance) {
  bytes(out);
  var min = instance.outputLen;
  if (out.length < min) {
    throw new Error("digestInto() expects output buffer of length at least ".concat(min));
  }
}
exports.output = output;
var assert = {
  number: number,
  bool: bool,
  bytes: bytes,
  hash: hash,
  exists: exists,
  output: output
};
exports["default"] = assert;

},{}],63:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SHA2 = void 0;
var _assert_js_1 = require("./_assert.js");
var utils_js_1 = require("./utils.js");
// Polyfill for Safari 14
function setBigUint64(view, byteOffset, value, isLE) {
  if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);
  var _32n = BigInt(32);
  var _u32_max = BigInt(0xffffffff);
  var wh = Number(value >> _32n & _u32_max);
  var wl = Number(value & _u32_max);
  var h = isLE ? 4 : 0;
  var l = isLE ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE);
  view.setUint32(byteOffset + l, wl, isLE);
}
// Base SHA2 class (RFC 6234)
var SHA2 = /*#__PURE__*/function (_utils_js_1$Hash) {
  function SHA2(blockLen, outputLen, padOffset, isLE) {
    var _this;
    _classCallCheck(this, SHA2);
    _this = _callSuper(this, SHA2);
    _this.blockLen = blockLen;
    _this.outputLen = outputLen;
    _this.padOffset = padOffset;
    _this.isLE = isLE;
    _this.finished = false;
    _this.length = 0;
    _this.pos = 0;
    _this.destroyed = false;
    _this.buffer = new Uint8Array(blockLen);
    _this.view = (0, utils_js_1.createView)(_this.buffer);
    return _this;
  }
  _inherits(SHA2, _utils_js_1$Hash);
  return _createClass(SHA2, [{
    key: "update",
    value: function update(data) {
      (0, _assert_js_1.exists)(this);
      var view = this.view,
        buffer = this.buffer,
        blockLen = this.blockLen;
      data = (0, utils_js_1.toBytes)(data);
      var len = data.length;
      for (var pos = 0; pos < len;) {
        var take = Math.min(blockLen - this.pos, len - pos);
        // Fast path: we have at least one block in input, cast it to view and process
        if (take === blockLen) {
          var dataView = (0, utils_js_1.createView)(data);
          for (; blockLen <= len - pos; pos += blockLen) this.process(dataView, pos);
          continue;
        }
        buffer.set(data.subarray(pos, pos + take), this.pos);
        this.pos += take;
        pos += take;
        if (this.pos === blockLen) {
          this.process(view, 0);
          this.pos = 0;
        }
      }
      this.length += data.length;
      this.roundClean();
      return this;
    }
  }, {
    key: "digestInto",
    value: function digestInto(out) {
      (0, _assert_js_1.exists)(this);
      (0, _assert_js_1.output)(out, this);
      this.finished = true;
      // Padding
      // We can avoid allocation of buffer for padding completely if it
      // was previously not allocated here. But it won't change performance.
      var buffer = this.buffer,
        view = this.view,
        blockLen = this.blockLen,
        isLE = this.isLE;
      var pos = this.pos;
      // append the bit '1' to the message
      buffer[pos++] = 128;
      this.buffer.subarray(pos).fill(0);
      // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again
      if (this.padOffset > blockLen - pos) {
        this.process(view, 0);
        pos = 0;
      }
      // Pad until full block byte with zeros
      for (var i = pos; i < blockLen; i++) buffer[i] = 0;
      // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that
      // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.
      // So we just write lowest 64 bits of that value.
      setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
      this.process(view, 0);
      var oview = (0, utils_js_1.createView)(out);
      var len = this.outputLen;
      // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT
      if (len % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');
      var outLen = len / 4;
      var state = this.get();
      if (outLen > state.length) throw new Error('_sha2: outputLen bigger than state');
      for (var _i = 0; _i < outLen; _i++) oview.setUint32(4 * _i, state[_i], isLE);
    }
  }, {
    key: "digest",
    value: function digest() {
      var buffer = this.buffer,
        outputLen = this.outputLen;
      this.digestInto(buffer);
      var res = buffer.slice(0, outputLen);
      this.destroy();
      return res;
    }
  }, {
    key: "_cloneInto",
    value: function _cloneInto(to) {
      var _to;
      to || (to = new this.constructor());
      (_to = to).set.apply(_to, _toConsumableArray(this.get()));
      var blockLen = this.blockLen,
        buffer = this.buffer,
        length = this.length,
        finished = this.finished,
        destroyed = this.destroyed,
        pos = this.pos;
      to.length = length;
      to.pos = pos;
      to.finished = finished;
      to.destroyed = destroyed;
      if (length % blockLen) to.buffer.set(buffer);
      return to;
    }
  }]);
}(utils_js_1.Hash);
exports.SHA2 = SHA2;

},{"./_assert.js":62,"./utils.js":73}],64:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.add5L = exports.add5H = exports.add4H = exports.add4L = exports.add3H = exports.add3L = exports.add = exports.rotlBL = exports.rotlBH = exports.rotlSL = exports.rotlSH = exports.rotr32L = exports.rotr32H = exports.rotrBL = exports.rotrBH = exports.rotrSL = exports.rotrSH = exports.shrSL = exports.shrSH = exports.toBig = exports.split = exports.fromBig = void 0;
var U32_MASK64 = /* @__PURE__ */BigInt(Math.pow(2, 32) - 1);
var _32n = /* @__PURE__ */BigInt(32);
// We are not using BigUint64Array, because they are extremely slow as per 2022
function fromBig(n) {
  var le = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  if (le) return {
    h: Number(n & U32_MASK64),
    l: Number(n >> _32n & U32_MASK64)
  };
  return {
    h: Number(n >> _32n & U32_MASK64) | 0,
    l: Number(n & U32_MASK64) | 0
  };
}
exports.fromBig = fromBig;
function split(lst) {
  var le = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var Ah = new Uint32Array(lst.length);
  var Al = new Uint32Array(lst.length);
  for (var i = 0; i < lst.length; i++) {
    var _fromBig = fromBig(lst[i], le),
      h = _fromBig.h,
      l = _fromBig.l;
    var _ref = [h, l];
    Ah[i] = _ref[0];
    Al[i] = _ref[1];
  }
  return [Ah, Al];
}
exports.split = split;
var toBig = function toBig(h, l) {
  return BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
};
exports.toBig = toBig;
// for Shift in [0, 32)
var shrSH = function shrSH(h, _l, s) {
  return h >>> s;
};
exports.shrSH = shrSH;
var shrSL = function shrSL(h, l, s) {
  return h << 32 - s | l >>> s;
};
exports.shrSL = shrSL;
// Right rotate for Shift in [1, 32)
var rotrSH = function rotrSH(h, l, s) {
  return h >>> s | l << 32 - s;
};
exports.rotrSH = rotrSH;
var rotrSL = function rotrSL(h, l, s) {
  return h << 32 - s | l >>> s;
};
exports.rotrSL = rotrSL;
// Right rotate for Shift in (32, 64), NOTE: 32 is special case.
var rotrBH = function rotrBH(h, l, s) {
  return h << 64 - s | l >>> s - 32;
};
exports.rotrBH = rotrBH;
var rotrBL = function rotrBL(h, l, s) {
  return h >>> s - 32 | l << 64 - s;
};
exports.rotrBL = rotrBL;
// Right rotate for shift===32 (just swaps l&h)
var rotr32H = function rotr32H(_h, l) {
  return l;
};
exports.rotr32H = rotr32H;
var rotr32L = function rotr32L(h, _l) {
  return h;
};
exports.rotr32L = rotr32L;
// Left rotate for Shift in [1, 32)
var rotlSH = function rotlSH(h, l, s) {
  return h << s | l >>> 32 - s;
};
exports.rotlSH = rotlSH;
var rotlSL = function rotlSL(h, l, s) {
  return l << s | h >>> 32 - s;
};
exports.rotlSL = rotlSL;
// Left rotate for Shift in (32, 64), NOTE: 32 is special case.
var rotlBH = function rotlBH(h, l, s) {
  return l << s - 32 | h >>> 64 - s;
};
exports.rotlBH = rotlBH;
var rotlBL = function rotlBL(h, l, s) {
  return h << s - 32 | l >>> 64 - s;
};
exports.rotlBL = rotlBL;
// JS uses 32-bit signed integers for bitwise operations which means we cannot
// simple take carry out of low bit sum by shift, we need to use division.
function add(Ah, Al, Bh, Bl) {
  var l = (Al >>> 0) + (Bl >>> 0);
  return {
    h: Ah + Bh + (l / Math.pow(2, 32) | 0) | 0,
    l: l | 0
  };
}
exports.add = add;
// Addition with more than 2 elements
var add3L = function add3L(Al, Bl, Cl) {
  return (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
};
exports.add3L = add3L;
var add3H = function add3H(low, Ah, Bh, Ch) {
  return Ah + Bh + Ch + (low / Math.pow(2, 32) | 0) | 0;
};
exports.add3H = add3H;
var add4L = function add4L(Al, Bl, Cl, Dl) {
  return (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
};
exports.add4L = add4L;
var add4H = function add4H(low, Ah, Bh, Ch, Dh) {
  return Ah + Bh + Ch + Dh + (low / Math.pow(2, 32) | 0) | 0;
};
exports.add4H = add4H;
var add5L = function add5L(Al, Bl, Cl, Dl, El) {
  return (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
};
exports.add5L = add5L;
var add5H = function add5H(low, Ah, Bh, Ch, Dh, Eh) {
  return Ah + Bh + Ch + Dh + Eh + (low / Math.pow(2, 32) | 0) | 0;
};
exports.add5H = add5H;
// prettier-ignore
var u64 = {
  fromBig: fromBig,
  split: split,
  toBig: toBig,
  shrSH: shrSH,
  shrSL: shrSL,
  rotrSH: rotrSH,
  rotrSL: rotrSL,
  rotrBH: rotrBH,
  rotrBL: rotrBL,
  rotr32H: rotr32H,
  rotr32L: rotr32L,
  rotlSH: rotlSH,
  rotlSL: rotlSL,
  rotlBH: rotlBH,
  rotlBL: rotlBL,
  add: add,
  add3L: add3L,
  add3H: add3H,
  add4L: add4L,
  add4H: add4H,
  add5H: add5H,
  add5L: add5L
};
exports["default"] = u64;

},{}],65:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.crypto = void 0;
exports.crypto = (typeof globalThis === "undefined" ? "undefined" : _typeof(globalThis)) === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;

},{}],66:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hmac = exports.HMAC = void 0;
var _assert_js_1 = require("./_assert.js");
var utils_js_1 = require("./utils.js");
// HMAC (RFC 2104)
var HMAC = /*#__PURE__*/function (_utils_js_1$Hash) {
  function HMAC(hash, _key) {
    var _this;
    _classCallCheck(this, HMAC);
    _this = _callSuper(this, HMAC);
    _this.finished = false;
    _this.destroyed = false;
    (0, _assert_js_1.hash)(hash);
    var key = (0, utils_js_1.toBytes)(_key);
    _this.iHash = hash.create();
    if (typeof _this.iHash.update !== 'function') throw new Error('Expected instance of class which extends utils.Hash');
    _this.blockLen = _this.iHash.blockLen;
    _this.outputLen = _this.iHash.outputLen;
    var blockLen = _this.blockLen;
    var pad = new Uint8Array(blockLen);
    // blockLen can be bigger than outputLen
    pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
    for (var i = 0; i < pad.length; i++) pad[i] ^= 0x36;
    _this.iHash.update(pad);
    // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone
    _this.oHash = hash.create();
    // Undo internal XOR && apply outer XOR
    for (var _i = 0; _i < pad.length; _i++) pad[_i] ^= 0x36 ^ 0x5c;
    _this.oHash.update(pad);
    pad.fill(0);
    return _this;
  }
  _inherits(HMAC, _utils_js_1$Hash);
  return _createClass(HMAC, [{
    key: "update",
    value: function update(buf) {
      (0, _assert_js_1.exists)(this);
      this.iHash.update(buf);
      return this;
    }
  }, {
    key: "digestInto",
    value: function digestInto(out) {
      (0, _assert_js_1.exists)(this);
      (0, _assert_js_1.bytes)(out, this.outputLen);
      this.finished = true;
      this.iHash.digestInto(out);
      this.oHash.update(out);
      this.oHash.digestInto(out);
      this.destroy();
    }
  }, {
    key: "digest",
    value: function digest() {
      var out = new Uint8Array(this.oHash.outputLen);
      this.digestInto(out);
      return out;
    }
  }, {
    key: "_cloneInto",
    value: function _cloneInto(to) {
      // Create new instance without calling constructor since key already in state and we don't know it.
      to || (to = Object.create(Object.getPrototypeOf(this), {}));
      var oHash = this.oHash,
        iHash = this.iHash,
        finished = this.finished,
        destroyed = this.destroyed,
        blockLen = this.blockLen,
        outputLen = this.outputLen;
      to = to;
      to.finished = finished;
      to.destroyed = destroyed;
      to.blockLen = blockLen;
      to.outputLen = outputLen;
      to.oHash = oHash._cloneInto(to.oHash);
      to.iHash = iHash._cloneInto(to.iHash);
      return to;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.destroyed = true;
      this.oHash.destroy();
      this.iHash.destroy();
    }
  }]);
}(utils_js_1.Hash);
exports.HMAC = HMAC;
/**
 * HMAC: RFC2104 message authentication code.
 * @param hash - function that would be used e.g. sha256
 * @param key - message key
 * @param message - message data
 */
var hmac = function hmac(hash, key, message) {
  return new HMAC(hash, key).update(message).digest();
};
exports.hmac = hmac;
exports.hmac.create = function (hash, key) {
  return new HMAC(hash, key);
};

},{"./_assert.js":62,"./utils.js":73}],67:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pbkdf2Async = exports.pbkdf2 = void 0;
var _assert_js_1 = require("./_assert.js");
var hmac_js_1 = require("./hmac.js");
var utils_js_1 = require("./utils.js");
// Common prologue and epilogue for sync/async functions
function pbkdf2Init(hash, _password, _salt, _opts) {
  (0, _assert_js_1.hash)(hash);
  var opts = (0, utils_js_1.checkOpts)({
    dkLen: 32,
    asyncTick: 10
  }, _opts);
  var c = opts.c,
    dkLen = opts.dkLen,
    asyncTick = opts.asyncTick;
  (0, _assert_js_1.number)(c);
  (0, _assert_js_1.number)(dkLen);
  (0, _assert_js_1.number)(asyncTick);
  if (c < 1) throw new Error('PBKDF2: iterations (c) should be >= 1');
  var password = (0, utils_js_1.toBytes)(_password);
  var salt = (0, utils_js_1.toBytes)(_salt);
  // DK = PBKDF2(PRF, Password, Salt, c, dkLen);
  var DK = new Uint8Array(dkLen);
  // U1 = PRF(Password, Salt + INT_32_BE(i))
  var PRF = hmac_js_1.hmac.create(hash, password);
  var PRFSalt = PRF._cloneInto().update(salt);
  return {
    c: c,
    dkLen: dkLen,
    asyncTick: asyncTick,
    DK: DK,
    PRF: PRF,
    PRFSalt: PRFSalt
  };
}
function pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {
  PRF.destroy();
  PRFSalt.destroy();
  if (prfW) prfW.destroy();
  u.fill(0);
  return DK;
}
/**
 * PBKDF2-HMAC: RFC 2898 key derivation function
 * @param hash - hash function that would be used e.g. sha256
 * @param password - password from which a derived key is generated
 * @param salt - cryptographic salt
 * @param opts - {c, dkLen} where c is work factor and dkLen is output message size
 */
function pbkdf2(hash, password, salt, opts) {
  var _pbkdf2Init = pbkdf2Init(hash, password, salt, opts),
    c = _pbkdf2Init.c,
    dkLen = _pbkdf2Init.dkLen,
    DK = _pbkdf2Init.DK,
    PRF = _pbkdf2Init.PRF,
    PRFSalt = _pbkdf2Init.PRFSalt;
  var prfW; // Working copy
  var arr = new Uint8Array(4);
  var view = (0, utils_js_1.createView)(arr);
  var u = new Uint8Array(PRF.outputLen);
  // DK = T1 + T2 +  + Tdklen/hlen
  for (var ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
    // Ti = F(Password, Salt, c, i)
    var Ti = DK.subarray(pos, pos + PRF.outputLen);
    view.setInt32(0, ti, false);
    // F(Password, Salt, c, i) = U1 ^ U2 ^  ^ Uc
    // U1 = PRF(Password, Salt + INT_32_BE(i))
    (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
    Ti.set(u.subarray(0, Ti.length));
    for (var ui = 1; ui < c; ui++) {
      // Uc = PRF(Password, Uc1)
      PRF._cloneInto(prfW).update(u).digestInto(u);
      for (var i = 0; i < Ti.length; i++) Ti[i] ^= u[i];
    }
  }
  return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
}
exports.pbkdf2 = pbkdf2;
function pbkdf2Async(_x, _x2, _x3, _x4) {
  return _pbkdf2Async.apply(this, arguments);
}
function _pbkdf2Async() {
  _pbkdf2Async = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(hash, password, salt, opts) {
    var _pbkdf2Init2, c, dkLen, asyncTick, DK, PRF, PRFSalt, prfW, arr, view, u, _loop, ti, pos;
    return _regeneratorRuntime().wrap(function _callee$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          _pbkdf2Init2 = pbkdf2Init(hash, password, salt, opts), c = _pbkdf2Init2.c, dkLen = _pbkdf2Init2.dkLen, asyncTick = _pbkdf2Init2.asyncTick, DK = _pbkdf2Init2.DK, PRF = _pbkdf2Init2.PRF, PRFSalt = _pbkdf2Init2.PRFSalt;
          // Working copy
          arr = new Uint8Array(4);
          view = (0, utils_js_1.createView)(arr);
          u = new Uint8Array(PRF.outputLen); // DK = T1 + T2 +  + Tdklen/hlen
          _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop() {
            var Ti;
            return _regeneratorRuntime().wrap(function _loop$(_context) {
              while (1) switch (_context.prev = _context.next) {
                case 0:
                  // Ti = F(Password, Salt, c, i)
                  Ti = DK.subarray(pos, pos + PRF.outputLen);
                  view.setInt32(0, ti, false);
                  // F(Password, Salt, c, i) = U1 ^ U2 ^  ^ Uc
                  // U1 = PRF(Password, Salt + INT_32_BE(i))
                  (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
                  Ti.set(u.subarray(0, Ti.length));
                  _context.next = 6;
                  return (0, utils_js_1.asyncLoop)(c - 1, asyncTick, function () {
                    // Uc = PRF(Password, Uc1)
                    PRF._cloneInto(prfW).update(u).digestInto(u);
                    for (var i = 0; i < Ti.length; i++) Ti[i] ^= u[i];
                  });
                case 6:
                case "end":
                  return _context.stop();
              }
            }, _loop);
          });
          ti = 1, pos = 0;
        case 6:
          if (!(pos < dkLen)) {
            _context2.next = 11;
            break;
          }
          return _context2.delegateYield(_loop(), "t0", 8);
        case 8:
          ti++, pos += PRF.outputLen;
          _context2.next = 6;
          break;
        case 11:
          return _context2.abrupt("return", pbkdf2Output(PRF, PRFSalt, DK, prfW, u));
        case 12:
        case "end":
          return _context2.stop();
      }
    }, _callee);
  }));
  return _pbkdf2Async.apply(this, arguments);
}
exports.pbkdf2Async = pbkdf2Async;

},{"./_assert.js":62,"./hmac.js":66,"./utils.js":73}],68:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ripemd160 = exports.RIPEMD160 = void 0;
var _sha2_js_1 = require("./_sha2.js");
var utils_js_1 = require("./utils.js");
// https://homes.esat.kuleuven.be/~bosselae/ripemd160.html
// https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf
var Rho = /* @__PURE__ */new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
var Id = /* @__PURE__ */Uint8Array.from({
  length: 16
}, function (_, i) {
  return i;
});
var Pi = /* @__PURE__ */Id.map(function (i) {
  return (9 * i + 5) % 16;
});
var idxL = [Id];
var idxR = [Pi];
for (var i = 0; i < 4; i++) for (var _i = 0, _arr = [idxL, idxR]; _i < _arr.length; _i++) {
  var j = _arr[_i];
  j.push(j[i].map(function (k) {
    return Rho[k];
  }));
}
var shifts = /* @__PURE__ */[[11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8], [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7], [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9], [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6], [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]].map(function (i) {
  return new Uint8Array(i);
});
var shiftsL = /* @__PURE__ */idxL.map(function (idx, i) {
  return idx.map(function (j) {
    return shifts[i][j];
  });
});
var shiftsR = /* @__PURE__ */idxR.map(function (idx, i) {
  return idx.map(function (j) {
    return shifts[i][j];
  });
});
var Kl = /* @__PURE__ */new Uint32Array([0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e]);
var Kr = /* @__PURE__ */new Uint32Array([0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000]);
// The rotate left (circular left shift) operation for uint32
var rotl = function rotl(word, shift) {
  return word << shift | word >>> 32 - shift;
};
// It's called f() in spec.
function f(group, x, y, z) {
  if (group === 0) return x ^ y ^ z;else if (group === 1) return x & y | ~x & z;else if (group === 2) return (x | ~y) ^ z;else if (group === 3) return x & z | y & ~z;else return x ^ (y | ~z);
}
// Temporary buffer, not used to store anything between runs
var BUF = /* @__PURE__ */new Uint32Array(16);
var RIPEMD160 = /*#__PURE__*/function (_sha2_js_1$SHA) {
  function RIPEMD160() {
    var _this;
    _classCallCheck(this, RIPEMD160);
    _this = _callSuper(this, RIPEMD160, [64, 20, 8, true]);
    _this.h0 = 0x67452301 | 0;
    _this.h1 = 0xefcdab89 | 0;
    _this.h2 = 0x98badcfe | 0;
    _this.h3 = 0x10325476 | 0;
    _this.h4 = 0xc3d2e1f0 | 0;
    return _this;
  }
  _inherits(RIPEMD160, _sha2_js_1$SHA);
  return _createClass(RIPEMD160, [{
    key: "get",
    value: function get() {
      var h0 = this.h0,
        h1 = this.h1,
        h2 = this.h2,
        h3 = this.h3,
        h4 = this.h4;
      return [h0, h1, h2, h3, h4];
    }
  }, {
    key: "set",
    value: function set(h0, h1, h2, h3, h4) {
      this.h0 = h0 | 0;
      this.h1 = h1 | 0;
      this.h2 = h2 | 0;
      this.h3 = h3 | 0;
      this.h4 = h4 | 0;
    }
  }, {
    key: "process",
    value: function process(view, offset) {
      for (var _i2 = 0; _i2 < 16; _i2++, offset += 4) BUF[_i2] = view.getUint32(offset, true);
      // prettier-ignore
      var al = this.h0 | 0,
        ar = al,
        bl = this.h1 | 0,
        br = bl,
        cl = this.h2 | 0,
        cr = cl,
        dl = this.h3 | 0,
        dr = dl,
        el = this.h4 | 0,
        er = el;
      // Instead of iterating 0 to 80, we split it into 5 groups
      // And use the groups in constants, functions, etc. Much simpler
      for (var group = 0; group < 5; group++) {
        var rGroup = 4 - group;
        var hbl = Kl[group],
          hbr = Kr[group]; // prettier-ignore
        var rl = idxL[group],
          rr = idxR[group]; // prettier-ignore
        var sl = shiftsL[group],
          sr = shiftsR[group]; // prettier-ignore
        for (var _i3 = 0; _i3 < 16; _i3++) {
          var tl = rotl(al + f(group, bl, cl, dl) + BUF[rl[_i3]] + hbl, sl[_i3]) + el | 0;
          al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore
        }
        // 2 loops are 10% faster
        for (var _i4 = 0; _i4 < 16; _i4++) {
          var tr = rotl(ar + f(rGroup, br, cr, dr) + BUF[rr[_i4]] + hbr, sr[_i4]) + er | 0;
          ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr; // prettier-ignore
        }
      }
      // Add the compressed chunk to the current hash value
      this.set(this.h1 + cl + dr | 0, this.h2 + dl + er | 0, this.h3 + el + ar | 0, this.h4 + al + br | 0, this.h0 + bl + cr | 0);
    }
  }, {
    key: "roundClean",
    value: function roundClean() {
      BUF.fill(0);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.destroyed = true;
      this.buffer.fill(0);
      this.set(0, 0, 0, 0, 0);
    }
  }]);
}(_sha2_js_1.SHA2);
exports.RIPEMD160 = RIPEMD160;
/**
 * RIPEMD-160 - a hash function from 1990s.
 * @param message - msg that would be hashed
 */
exports.ripemd160 = (0, utils_js_1.wrapConstructor)(function () {
  return new RIPEMD160();
});

},{"./_sha2.js":63,"./utils.js":73}],69:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.scryptAsync = exports.scrypt = void 0;
var _assert_js_1 = require("./_assert.js");
var sha256_js_1 = require("./sha256.js");
var pbkdf2_js_1 = require("./pbkdf2.js");
var utils_js_1 = require("./utils.js");
// RFC 7914 Scrypt KDF
// Left rotate for uint32
var rotl = function rotl(a, b) {
  return a << b | a >>> 32 - b;
};
// The main Scrypt loop: uses Salsa extensively.
// Six versions of the function were tried, this is the fastest one.
// prettier-ignore
function XorAndSalsa(prev, pi, input, ii, out, oi) {
  // Based on https://cr.yp.to/salsa20.html
  // Xor blocks
  var y00 = prev[pi++] ^ input[ii++],
    y01 = prev[pi++] ^ input[ii++];
  var y02 = prev[pi++] ^ input[ii++],
    y03 = prev[pi++] ^ input[ii++];
  var y04 = prev[pi++] ^ input[ii++],
    y05 = prev[pi++] ^ input[ii++];
  var y06 = prev[pi++] ^ input[ii++],
    y07 = prev[pi++] ^ input[ii++];
  var y08 = prev[pi++] ^ input[ii++],
    y09 = prev[pi++] ^ input[ii++];
  var y10 = prev[pi++] ^ input[ii++],
    y11 = prev[pi++] ^ input[ii++];
  var y12 = prev[pi++] ^ input[ii++],
    y13 = prev[pi++] ^ input[ii++];
  var y14 = prev[pi++] ^ input[ii++],
    y15 = prev[pi++] ^ input[ii++];
  // Save state to temporary variables (salsa)
  var x00 = y00,
    x01 = y01,
    x02 = y02,
    x03 = y03,
    x04 = y04,
    x05 = y05,
    x06 = y06,
    x07 = y07,
    x08 = y08,
    x09 = y09,
    x10 = y10,
    x11 = y11,
    x12 = y12,
    x13 = y13,
    x14 = y14,
    x15 = y15;
  // Main loop (salsa)
  for (var i = 0; i < 8; i += 2) {
    x04 ^= rotl(x00 + x12 | 0, 7);
    x08 ^= rotl(x04 + x00 | 0, 9);
    x12 ^= rotl(x08 + x04 | 0, 13);
    x00 ^= rotl(x12 + x08 | 0, 18);
    x09 ^= rotl(x05 + x01 | 0, 7);
    x13 ^= rotl(x09 + x05 | 0, 9);
    x01 ^= rotl(x13 + x09 | 0, 13);
    x05 ^= rotl(x01 + x13 | 0, 18);
    x14 ^= rotl(x10 + x06 | 0, 7);
    x02 ^= rotl(x14 + x10 | 0, 9);
    x06 ^= rotl(x02 + x14 | 0, 13);
    x10 ^= rotl(x06 + x02 | 0, 18);
    x03 ^= rotl(x15 + x11 | 0, 7);
    x07 ^= rotl(x03 + x15 | 0, 9);
    x11 ^= rotl(x07 + x03 | 0, 13);
    x15 ^= rotl(x11 + x07 | 0, 18);
    x01 ^= rotl(x00 + x03 | 0, 7);
    x02 ^= rotl(x01 + x00 | 0, 9);
    x03 ^= rotl(x02 + x01 | 0, 13);
    x00 ^= rotl(x03 + x02 | 0, 18);
    x06 ^= rotl(x05 + x04 | 0, 7);
    x07 ^= rotl(x06 + x05 | 0, 9);
    x04 ^= rotl(x07 + x06 | 0, 13);
    x05 ^= rotl(x04 + x07 | 0, 18);
    x11 ^= rotl(x10 + x09 | 0, 7);
    x08 ^= rotl(x11 + x10 | 0, 9);
    x09 ^= rotl(x08 + x11 | 0, 13);
    x10 ^= rotl(x09 + x08 | 0, 18);
    x12 ^= rotl(x15 + x14 | 0, 7);
    x13 ^= rotl(x12 + x15 | 0, 9);
    x14 ^= rotl(x13 + x12 | 0, 13);
    x15 ^= rotl(x14 + x13 | 0, 18);
  }
  // Write output (salsa)
  out[oi++] = y00 + x00 | 0;
  out[oi++] = y01 + x01 | 0;
  out[oi++] = y02 + x02 | 0;
  out[oi++] = y03 + x03 | 0;
  out[oi++] = y04 + x04 | 0;
  out[oi++] = y05 + x05 | 0;
  out[oi++] = y06 + x06 | 0;
  out[oi++] = y07 + x07 | 0;
  out[oi++] = y08 + x08 | 0;
  out[oi++] = y09 + x09 | 0;
  out[oi++] = y10 + x10 | 0;
  out[oi++] = y11 + x11 | 0;
  out[oi++] = y12 + x12 | 0;
  out[oi++] = y13 + x13 | 0;
  out[oi++] = y14 + x14 | 0;
  out[oi++] = y15 + x15 | 0;
}
function BlockMix(input, ii, out, oi, r) {
  // The block B is r 128-byte chunks (which is equivalent of 2r 64-byte chunks)
  var head = oi + 0;
  var tail = oi + 16 * r;
  for (var i = 0; i < 16; i++) out[tail + i] = input[ii + (2 * r - 1) * 16 + i]; // X  B[2r1]
  for (var _i = 0; _i < r; _i++, head += 16, ii += 16) {
    // We write odd & even Yi at same time. Even: 0bXXXXX0 Odd:  0bXXXXX1
    XorAndSalsa(out, tail, input, ii, out, head); // head[i] = Salsa(blockIn[2*i] ^ tail[i-1])
    if (_i > 0) tail += 16; // First iteration overwrites tmp value in tail
    XorAndSalsa(out, head, input, ii += 16, out, tail); // tail[i] = Salsa(blockIn[2*i+1] ^ head[i])
  }
}
// Common prologue and epilogue for sync/async functions
function scryptInit(password, salt, _opts) {
  // Maxmem - 1GB+1KB by default
  var opts = (0, utils_js_1.checkOpts)({
    dkLen: 32,
    asyncTick: 10,
    maxmem: Math.pow(1024, 3) + 1024
  }, _opts);
  var N = opts.N,
    r = opts.r,
    p = opts.p,
    dkLen = opts.dkLen,
    asyncTick = opts.asyncTick,
    maxmem = opts.maxmem,
    onProgress = opts.onProgress;
  (0, _assert_js_1.number)(N);
  (0, _assert_js_1.number)(r);
  (0, _assert_js_1.number)(p);
  (0, _assert_js_1.number)(dkLen);
  (0, _assert_js_1.number)(asyncTick);
  (0, _assert_js_1.number)(maxmem);
  if (onProgress !== undefined && typeof onProgress !== 'function') throw new Error('progressCb should be function');
  var blockSize = 128 * r;
  var blockSize32 = blockSize / 4;
  if (N <= 1 || (N & N - 1) !== 0 || N >= Math.pow(2, blockSize / 8) || N > Math.pow(2, 32)) {
    // NOTE: we limit N to be less than 2**32 because of 32 bit variant of Integrify function
    // There is no JS engines that allows alocate more than 4GB per single Uint8Array for now, but can change in future.
    throw new Error('Scrypt: N must be larger than 1, a power of 2, less than 2^(128 * r / 8) and less than 2^32');
  }
  if (p < 0 || p > (Math.pow(2, 32) - 1) * 32 / blockSize) {
    throw new Error('Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)');
  }
  if (dkLen < 0 || dkLen > (Math.pow(2, 32) - 1) * 32) {
    throw new Error('Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32');
  }
  var memUsed = blockSize * (N + p);
  if (memUsed > maxmem) {
    throw new Error("Scrypt: parameters too large, ".concat(memUsed, " (128 * r * (N + p)) > ").concat(maxmem, " (maxmem)"));
  }
  // [B0...Bp1]  PBKDF2HMAC-SHA256(Passphrase, Salt, 1, blockSize*ParallelizationFactor)
  // Since it has only one iteration there is no reason to use async variant
  var B = (0, pbkdf2_js_1.pbkdf2)(sha256_js_1.sha256, password, salt, {
    c: 1,
    dkLen: blockSize * p
  });
  var B32 = (0, utils_js_1.u32)(B);
  // Re-used between parallel iterations. Array(iterations) of B
  var V = (0, utils_js_1.u32)(new Uint8Array(blockSize * N));
  var tmp = (0, utils_js_1.u32)(new Uint8Array(blockSize));
  var blockMixCb = function blockMixCb() {};
  if (onProgress) {
    var totalBlockMix = 2 * N * p;
    // Invoke callback if progress changes from 10.01 to 10.02
    // Allows to draw smooth progress bar on up to 8K screen
    var callbackPer = Math.max(Math.floor(totalBlockMix / 10000), 1);
    var blockMixCnt = 0;
    blockMixCb = function blockMixCb() {
      blockMixCnt++;
      if (onProgress && (!(blockMixCnt % callbackPer) || blockMixCnt === totalBlockMix)) onProgress(blockMixCnt / totalBlockMix);
    };
  }
  return {
    N: N,
    r: r,
    p: p,
    dkLen: dkLen,
    blockSize32: blockSize32,
    V: V,
    B32: B32,
    B: B,
    tmp: tmp,
    blockMixCb: blockMixCb,
    asyncTick: asyncTick
  };
}
function scryptOutput(password, dkLen, B, V, tmp) {
  var res = (0, pbkdf2_js_1.pbkdf2)(sha256_js_1.sha256, password, B, {
    c: 1,
    dkLen: dkLen
  });
  B.fill(0);
  V.fill(0);
  tmp.fill(0);
  return res;
}
/**
 * Scrypt KDF from RFC 7914.
 * @param password - pass
 * @param salt - salt
 * @param opts - parameters
 * - `N` is cpu/mem work factor (power of 2 e.g. 2**18)
 * - `r` is block size (8 is common), fine-tunes sequential memory read size and performance
 * - `p` is parallelization factor (1 is common)
 * - `dkLen` is output key length in bytes e.g. 32.
 * - `asyncTick` - (default: 10) max time in ms for which async function can block execution
 * - `maxmem` - (default: `1024 ** 3 + 1024` aka 1GB+1KB). A limit that the app could use for scrypt
 * - `onProgress` - callback function that would be executed for progress report
 * @returns Derived key
 */
function scrypt(password, salt, opts) {
  var _scryptInit = scryptInit(password, salt, opts),
    N = _scryptInit.N,
    r = _scryptInit.r,
    p = _scryptInit.p,
    dkLen = _scryptInit.dkLen,
    blockSize32 = _scryptInit.blockSize32,
    V = _scryptInit.V,
    B32 = _scryptInit.B32,
    B = _scryptInit.B,
    tmp = _scryptInit.tmp,
    blockMixCb = _scryptInit.blockMixCb;
  for (var pi = 0; pi < p; pi++) {
    var Pi = blockSize32 * pi;
    for (var i = 0; i < blockSize32; i++) V[i] = B32[Pi + i]; // V[0] = B[i]
    for (var _i2 = 0, pos = 0; _i2 < N - 1; _i2++) {
      BlockMix(V, pos, V, pos += blockSize32, r); // V[i] = BlockMix(V[i-1]);
      blockMixCb();
    }
    BlockMix(V, (N - 1) * blockSize32, B32, Pi, r); // Process last element
    blockMixCb();
    for (var _i3 = 0; _i3 < N; _i3++) {
      // First u32 of the last 64-byte block (u32 is LE)
      var j = B32[Pi + blockSize32 - 16] % N; // j = Integrify(X) % iterations
      for (var k = 0; k < blockSize32; k++) tmp[k] = B32[Pi + k] ^ V[j * blockSize32 + k]; // tmp = B ^ V[j]
      BlockMix(tmp, 0, B32, Pi, r); // B = BlockMix(B ^ V[j])
      blockMixCb();
    }
  }
  return scryptOutput(password, dkLen, B, V, tmp);
}
exports.scrypt = scrypt;
/**
 * Scrypt KDF from RFC 7914.
 */
function scryptAsync(_x, _x2, _x3) {
  return _scryptAsync.apply(this, arguments);
}
function _scryptAsync() {
  _scryptAsync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(password, salt, opts) {
    var _scryptInit2, N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick, _loop, pi;
    return _regeneratorRuntime().wrap(function _callee$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          _scryptInit2 = scryptInit(password, salt, opts), N = _scryptInit2.N, r = _scryptInit2.r, p = _scryptInit2.p, dkLen = _scryptInit2.dkLen, blockSize32 = _scryptInit2.blockSize32, V = _scryptInit2.V, B32 = _scryptInit2.B32, B = _scryptInit2.B, tmp = _scryptInit2.tmp, blockMixCb = _scryptInit2.blockMixCb, asyncTick = _scryptInit2.asyncTick;
          _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop() {
            var Pi, i, pos;
            return _regeneratorRuntime().wrap(function _loop$(_context) {
              while (1) switch (_context.prev = _context.next) {
                case 0:
                  Pi = blockSize32 * pi;
                  for (i = 0; i < blockSize32; i++) V[i] = B32[Pi + i]; // V[0] = B[i]
                  pos = 0;
                  _context.next = 5;
                  return (0, utils_js_1.asyncLoop)(N - 1, asyncTick, function () {
                    BlockMix(V, pos, V, pos += blockSize32, r); // V[i] = BlockMix(V[i-1]);
                    blockMixCb();
                  });
                case 5:
                  BlockMix(V, (N - 1) * blockSize32, B32, Pi, r); // Process last element
                  blockMixCb();
                  _context.next = 9;
                  return (0, utils_js_1.asyncLoop)(N, asyncTick, function () {
                    // First u32 of the last 64-byte block (u32 is LE)
                    var j = B32[Pi + blockSize32 - 16] % N; // j = Integrify(X) % iterations
                    for (var k = 0; k < blockSize32; k++) tmp[k] = B32[Pi + k] ^ V[j * blockSize32 + k]; // tmp = B ^ V[j]
                    BlockMix(tmp, 0, B32, Pi, r); // B = BlockMix(B ^ V[j])
                    blockMixCb();
                  });
                case 9:
                case "end":
                  return _context.stop();
              }
            }, _loop);
          });
          pi = 0;
        case 3:
          if (!(pi < p)) {
            _context2.next = 8;
            break;
          }
          return _context2.delegateYield(_loop(), "t0", 5);
        case 5:
          pi++;
          _context2.next = 3;
          break;
        case 8:
          return _context2.abrupt("return", scryptOutput(password, dkLen, B, V, tmp));
        case 9:
        case "end":
          return _context2.stop();
      }
    }, _callee);
  }));
  return _scryptAsync.apply(this, arguments);
}
exports.scryptAsync = scryptAsync;

},{"./_assert.js":62,"./pbkdf2.js":67,"./sha256.js":70,"./utils.js":73}],70:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sha224 = exports.sha256 = void 0;
var _sha2_js_1 = require("./_sha2.js");
var utils_js_1 = require("./utils.js");
// SHA2-256 need to try 2^128 hashes to execute birthday attack.
// BTC network is doing 2^67 hashes/sec as per early 2023.
// Choice: a ? b : c
var Chi = function Chi(a, b, c) {
  return a & b ^ ~a & c;
};
// Majority function, true if any two inpust is true
var Maj = function Maj(a, b, c) {
  return a & b ^ a & c ^ b & c;
};
// Round constants:
// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)
// prettier-ignore
var SHA256_K = /* @__PURE__ */new Uint32Array([0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2]);
// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):
// prettier-ignore
var IV = /* @__PURE__ */new Uint32Array([0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19]);
// Temporary buffer, not used to store anything between runs
// Named this way because it matches specification.
var SHA256_W = /* @__PURE__ */new Uint32Array(64);
var SHA256 = /*#__PURE__*/function (_sha2_js_1$SHA) {
  function SHA256() {
    var _this;
    _classCallCheck(this, SHA256);
    _this = _callSuper(this, SHA256, [64, 32, 8, false]);
    // We cannot use array here since array allows indexing by variable
    // which means optimizer/compiler cannot use registers.
    _this.A = IV[0] | 0;
    _this.B = IV[1] | 0;
    _this.C = IV[2] | 0;
    _this.D = IV[3] | 0;
    _this.E = IV[4] | 0;
    _this.F = IV[5] | 0;
    _this.G = IV[6] | 0;
    _this.H = IV[7] | 0;
    return _this;
  }
  _inherits(SHA256, _sha2_js_1$SHA);
  return _createClass(SHA256, [{
    key: "get",
    value: function get() {
      var A = this.A,
        B = this.B,
        C = this.C,
        D = this.D,
        E = this.E,
        F = this.F,
        G = this.G,
        H = this.H;
      return [A, B, C, D, E, F, G, H];
    }
    // prettier-ignore
  }, {
    key: "set",
    value: function set(A, B, C, D, E, F, G, H) {
      this.A = A | 0;
      this.B = B | 0;
      this.C = C | 0;
      this.D = D | 0;
      this.E = E | 0;
      this.F = F | 0;
      this.G = G | 0;
      this.H = H | 0;
    }
  }, {
    key: "process",
    value: function process(view, offset) {
      // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array
      for (var i = 0; i < 16; i++, offset += 4) SHA256_W[i] = view.getUint32(offset, false);
      for (var _i = 16; _i < 64; _i++) {
        var W15 = SHA256_W[_i - 15];
        var W2 = SHA256_W[_i - 2];
        var s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ W15 >>> 3;
        var s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ W2 >>> 10;
        SHA256_W[_i] = s1 + SHA256_W[_i - 7] + s0 + SHA256_W[_i - 16] | 0;
      }
      // Compression function main loop, 64 rounds
      var A = this.A,
        B = this.B,
        C = this.C,
        D = this.D,
        E = this.E,
        F = this.F,
        G = this.G,
        H = this.H;
      for (var _i2 = 0; _i2 < 64; _i2++) {
        var sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);
        var T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[_i2] + SHA256_W[_i2] | 0;
        var sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);
        var T2 = sigma0 + Maj(A, B, C) | 0;
        H = G;
        G = F;
        F = E;
        E = D + T1 | 0;
        D = C;
        C = B;
        B = A;
        A = T1 + T2 | 0;
      }
      // Add the compressed chunk to the current hash value
      A = A + this.A | 0;
      B = B + this.B | 0;
      C = C + this.C | 0;
      D = D + this.D | 0;
      E = E + this.E | 0;
      F = F + this.F | 0;
      G = G + this.G | 0;
      H = H + this.H | 0;
      this.set(A, B, C, D, E, F, G, H);
    }
  }, {
    key: "roundClean",
    value: function roundClean() {
      SHA256_W.fill(0);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.set(0, 0, 0, 0, 0, 0, 0, 0);
      this.buffer.fill(0);
    }
  }]);
}(_sha2_js_1.SHA2); // Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf
var SHA224 = /*#__PURE__*/function (_SHA) {
  function SHA224() {
    var _this2;
    _classCallCheck(this, SHA224);
    _this2 = _callSuper(this, SHA224);
    _this2.A = 0xc1059ed8 | 0;
    _this2.B = 0x367cd507 | 0;
    _this2.C = 0x3070dd17 | 0;
    _this2.D = 0xf70e5939 | 0;
    _this2.E = 0xffc00b31 | 0;
    _this2.F = 0x68581511 | 0;
    _this2.G = 0x64f98fa7 | 0;
    _this2.H = 0xbefa4fa4 | 0;
    _this2.outputLen = 28;
    return _this2;
  }
  _inherits(SHA224, _SHA);
  return _createClass(SHA224);
}(SHA256);
/**
 * SHA2-256 hash function
 * @param message - data that would be hashed
 */
exports.sha256 = (0, utils_js_1.wrapConstructor)(function () {
  return new SHA256();
});
exports.sha224 = (0, utils_js_1.wrapConstructor)(function () {
  return new SHA224();
});

},{"./_sha2.js":63,"./utils.js":73}],71:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.shake256 = exports.shake128 = exports.keccak_512 = exports.keccak_384 = exports.keccak_256 = exports.keccak_224 = exports.sha3_512 = exports.sha3_384 = exports.sha3_256 = exports.sha3_224 = exports.Keccak = exports.keccakP = void 0;
var _assert_js_1 = require("./_assert.js");
var _u64_js_1 = require("./_u64.js");
var utils_js_1 = require("./utils.js");
// SHA3 (keccak) is based on a new design: basically, the internal state is bigger than output size.
// It's called a sponge function.
// Various per round constants calculations
var SHA3_PI = [],
  SHA3_ROTL = [],
  _SHA3_IOTA = [];
var _0n = /* @__PURE__ */BigInt(0);
var _1n = /* @__PURE__ */BigInt(1);
var _2n = /* @__PURE__ */BigInt(2);
var _7n = /* @__PURE__ */BigInt(7);
var _256n = /* @__PURE__ */BigInt(256);
var _0x71n = /* @__PURE__ */BigInt(0x71);
for (var round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
  // Pi
  var _ref = [y, (2 * x + 3 * y) % 5];
  x = _ref[0];
  y = _ref[1];
  SHA3_PI.push(2 * (5 * y + x));
  // Rotational
  SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
  // Iota
  var t = _0n;
  for (var j = 0; j < 7; j++) {
    R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
    if (R & _2n) t ^= _1n << (_1n << /* @__PURE__ */BigInt(j)) - _1n;
  }
  _SHA3_IOTA.push(t);
}
var _ref2 = /* @__PURE__ */(0, _u64_js_1.split)(_SHA3_IOTA, true),
  _ref3 = _slicedToArray(_ref2, 2),
  SHA3_IOTA_H = _ref3[0],
  SHA3_IOTA_L = _ref3[1];
// Left rotation (without 0, 32, 64)
var rotlH = function rotlH(h, l, s) {
  return s > 32 ? (0, _u64_js_1.rotlBH)(h, l, s) : (0, _u64_js_1.rotlSH)(h, l, s);
};
var rotlL = function rotlL(h, l, s) {
  return s > 32 ? (0, _u64_js_1.rotlBL)(h, l, s) : (0, _u64_js_1.rotlSL)(h, l, s);
};
// Same as keccakf1600, but allows to skip some rounds
function keccakP(s) {
  var rounds = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 24;
  var B = new Uint32Array(5 * 2);
  // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)
  for (var _round = 24 - rounds; _round < 24; _round++) {
    // Theta 
    for (var _x = 0; _x < 10; _x++) B[_x] = s[_x] ^ s[_x + 10] ^ s[_x + 20] ^ s[_x + 30] ^ s[_x + 40];
    for (var _x2 = 0; _x2 < 10; _x2 += 2) {
      var idx1 = (_x2 + 8) % 10;
      var idx0 = (_x2 + 2) % 10;
      var B0 = B[idx0];
      var B1 = B[idx0 + 1];
      var Th = rotlH(B0, B1, 1) ^ B[idx1];
      var Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
      for (var _y = 0; _y < 50; _y += 10) {
        s[_x2 + _y] ^= Th;
        s[_x2 + _y + 1] ^= Tl;
      }
    }
    // Rho () and Pi ()
    var curH = s[2];
    var curL = s[3];
    for (var _t = 0; _t < 24; _t++) {
      var shift = SHA3_ROTL[_t];
      var _Th = rotlH(curH, curL, shift);
      var _Tl = rotlL(curH, curL, shift);
      var PI = SHA3_PI[_t];
      curH = s[PI];
      curL = s[PI + 1];
      s[PI] = _Th;
      s[PI + 1] = _Tl;
    }
    // Chi ()
    for (var _y2 = 0; _y2 < 50; _y2 += 10) {
      for (var _x3 = 0; _x3 < 10; _x3++) B[_x3] = s[_y2 + _x3];
      for (var _x4 = 0; _x4 < 10; _x4++) s[_y2 + _x4] ^= ~B[(_x4 + 2) % 10] & B[(_x4 + 4) % 10];
    }
    // Iota ()
    s[0] ^= SHA3_IOTA_H[_round];
    s[1] ^= SHA3_IOTA_L[_round];
  }
  B.fill(0);
}
exports.keccakP = keccakP;
var Keccak = /*#__PURE__*/function (_utils_js_1$Hash) {
  // NOTE: we accept arguments in bytes instead of bits here.
  function Keccak(blockLen, suffix, outputLen) {
    var _this;
    var enableXOF = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    var rounds = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 24;
    _classCallCheck(this, Keccak);
    _this = _callSuper(this, Keccak);
    _this.blockLen = blockLen;
    _this.suffix = suffix;
    _this.outputLen = outputLen;
    _this.enableXOF = enableXOF;
    _this.rounds = rounds;
    _this.pos = 0;
    _this.posOut = 0;
    _this.finished = false;
    _this.destroyed = false;
    // Can be passed from user as dkLen
    (0, _assert_js_1.number)(outputLen);
    // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes
    if (0 >= _this.blockLen || _this.blockLen >= 200) throw new Error('Sha3 supports only keccak-f1600 function');
    _this.state = new Uint8Array(200);
    _this.state32 = (0, utils_js_1.u32)(_this.state);
    return _this;
  }
  _inherits(Keccak, _utils_js_1$Hash);
  return _createClass(Keccak, [{
    key: "keccak",
    value: function keccak() {
      keccakP(this.state32, this.rounds);
      this.posOut = 0;
      this.pos = 0;
    }
  }, {
    key: "update",
    value: function update(data) {
      (0, _assert_js_1.exists)(this);
      var blockLen = this.blockLen,
        state = this.state;
      data = (0, utils_js_1.toBytes)(data);
      var len = data.length;
      for (var pos = 0; pos < len;) {
        var take = Math.min(blockLen - this.pos, len - pos);
        for (var i = 0; i < take; i++) state[this.pos++] ^= data[pos++];
        if (this.pos === blockLen) this.keccak();
      }
      return this;
    }
  }, {
    key: "finish",
    value: function finish() {
      if (this.finished) return;
      this.finished = true;
      var state = this.state,
        suffix = this.suffix,
        pos = this.pos,
        blockLen = this.blockLen;
      // Do the padding
      state[pos] ^= suffix;
      if ((suffix & 0x80) !== 0 && pos === blockLen - 1) this.keccak();
      state[blockLen - 1] ^= 0x80;
      this.keccak();
    }
  }, {
    key: "writeInto",
    value: function writeInto(out) {
      (0, _assert_js_1.exists)(this, false);
      (0, _assert_js_1.bytes)(out);
      this.finish();
      var bufferOut = this.state;
      var blockLen = this.blockLen;
      for (var pos = 0, len = out.length; pos < len;) {
        if (this.posOut >= blockLen) this.keccak();
        var take = Math.min(blockLen - this.posOut, len - pos);
        out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
        this.posOut += take;
        pos += take;
      }
      return out;
    }
  }, {
    key: "xofInto",
    value: function xofInto(out) {
      // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF
      if (!this.enableXOF) throw new Error('XOF is not possible for this instance');
      return this.writeInto(out);
    }
  }, {
    key: "xof",
    value: function xof(bytes) {
      (0, _assert_js_1.number)(bytes);
      return this.xofInto(new Uint8Array(bytes));
    }
  }, {
    key: "digestInto",
    value: function digestInto(out) {
      (0, _assert_js_1.output)(out, this);
      if (this.finished) throw new Error('digest() was already called');
      this.writeInto(out);
      this.destroy();
      return out;
    }
  }, {
    key: "digest",
    value: function digest() {
      return this.digestInto(new Uint8Array(this.outputLen));
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.destroyed = true;
      this.state.fill(0);
    }
  }, {
    key: "_cloneInto",
    value: function _cloneInto(to) {
      var blockLen = this.blockLen,
        suffix = this.suffix,
        outputLen = this.outputLen,
        rounds = this.rounds,
        enableXOF = this.enableXOF;
      to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
      to.state32.set(this.state32);
      to.pos = this.pos;
      to.posOut = this.posOut;
      to.finished = this.finished;
      to.rounds = rounds;
      // Suffix can change in cSHAKE
      to.suffix = suffix;
      to.outputLen = outputLen;
      to.enableXOF = enableXOF;
      to.destroyed = this.destroyed;
      return to;
    }
  }]);
}(utils_js_1.Hash);
exports.Keccak = Keccak;
var gen = function gen(suffix, blockLen, outputLen) {
  return (0, utils_js_1.wrapConstructor)(function () {
    return new Keccak(blockLen, suffix, outputLen);
  });
};
exports.sha3_224 = gen(0x06, 144, 224 / 8);
/**
 * SHA3-256 hash function
 * @param message - that would be hashed
 */
exports.sha3_256 = gen(0x06, 136, 256 / 8);
exports.sha3_384 = gen(0x06, 104, 384 / 8);
exports.sha3_512 = gen(0x06, 72, 512 / 8);
exports.keccak_224 = gen(0x01, 144, 224 / 8);
/**
 * keccak-256 hash function. Different from SHA3-256.
 * @param message - that would be hashed
 */
exports.keccak_256 = gen(0x01, 136, 256 / 8);
exports.keccak_384 = gen(0x01, 104, 384 / 8);
exports.keccak_512 = gen(0x01, 72, 512 / 8);
var genShake = function genShake(suffix, blockLen, outputLen) {
  return (0, utils_js_1.wrapXOFConstructorWithOpts)(function () {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true);
  });
};
exports.shake128 = genShake(0x1f, 168, 128 / 8);
exports.shake256 = genShake(0x1f, 136, 256 / 8);

},{"./_assert.js":62,"./_u64.js":64,"./utils.js":73}],72:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sha384 = exports.sha512_256 = exports.sha512_224 = exports.sha512 = exports.SHA512 = void 0;
var _sha2_js_1 = require("./_sha2.js");
var _u64_js_1 = require("./_u64.js");
var utils_js_1 = require("./utils.js");
// Round contants (first 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409):
// prettier-ignore
var _ref = /* @__PURE__ */function () {
    return _u64_js_1["default"].split(['0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc', '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118', '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2', '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694', '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65', '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5', '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4', '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70', '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df', '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b', '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30', '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8', '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8', '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3', '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec', '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b', '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178', '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b', '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c', '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'].map(function (n) {
      return BigInt(n);
    }));
  }(),
  _ref2 = _slicedToArray(_ref, 2),
  SHA512_Kh = _ref2[0],
  SHA512_Kl = _ref2[1];
// Temporary buffer, not used to store anything between runs
var SHA512_W_H = /* @__PURE__ */new Uint32Array(80);
var SHA512_W_L = /* @__PURE__ */new Uint32Array(80);
var SHA512 = /*#__PURE__*/function (_sha2_js_1$SHA) {
  function SHA512() {
    var _this;
    _classCallCheck(this, SHA512);
    _this = _callSuper(this, SHA512, [128, 64, 16, false]);
    // We cannot use array here since array allows indexing by variable which means optimizer/compiler cannot use registers.
    // Also looks cleaner and easier to verify with spec.
    // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):
    // h -- high 32 bits, l -- low 32 bits
    _this.Ah = 0x6a09e667 | 0;
    _this.Al = 0xf3bcc908 | 0;
    _this.Bh = 0xbb67ae85 | 0;
    _this.Bl = 0x84caa73b | 0;
    _this.Ch = 0x3c6ef372 | 0;
    _this.Cl = 0xfe94f82b | 0;
    _this.Dh = 0xa54ff53a | 0;
    _this.Dl = 0x5f1d36f1 | 0;
    _this.Eh = 0x510e527f | 0;
    _this.El = 0xade682d1 | 0;
    _this.Fh = 0x9b05688c | 0;
    _this.Fl = 0x2b3e6c1f | 0;
    _this.Gh = 0x1f83d9ab | 0;
    _this.Gl = 0xfb41bd6b | 0;
    _this.Hh = 0x5be0cd19 | 0;
    _this.Hl = 0x137e2179 | 0;
    return _this;
  }
  // prettier-ignore
  _inherits(SHA512, _sha2_js_1$SHA);
  return _createClass(SHA512, [{
    key: "get",
    value: function get() {
      var Ah = this.Ah,
        Al = this.Al,
        Bh = this.Bh,
        Bl = this.Bl,
        Ch = this.Ch,
        Cl = this.Cl,
        Dh = this.Dh,
        Dl = this.Dl,
        Eh = this.Eh,
        El = this.El,
        Fh = this.Fh,
        Fl = this.Fl,
        Gh = this.Gh,
        Gl = this.Gl,
        Hh = this.Hh,
        Hl = this.Hl;
      return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
    }
    // prettier-ignore
  }, {
    key: "set",
    value: function set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
      this.Ah = Ah | 0;
      this.Al = Al | 0;
      this.Bh = Bh | 0;
      this.Bl = Bl | 0;
      this.Ch = Ch | 0;
      this.Cl = Cl | 0;
      this.Dh = Dh | 0;
      this.Dl = Dl | 0;
      this.Eh = Eh | 0;
      this.El = El | 0;
      this.Fh = Fh | 0;
      this.Fl = Fl | 0;
      this.Gh = Gh | 0;
      this.Gl = Gl | 0;
      this.Hh = Hh | 0;
      this.Hl = Hl | 0;
    }
  }, {
    key: "process",
    value: function process(view, offset) {
      // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array
      for (var i = 0; i < 16; i++, offset += 4) {
        SHA512_W_H[i] = view.getUint32(offset);
        SHA512_W_L[i] = view.getUint32(offset += 4);
      }
      for (var _i = 16; _i < 80; _i++) {
        // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)
        var W15h = SHA512_W_H[_i - 15] | 0;
        var W15l = SHA512_W_L[_i - 15] | 0;
        var s0h = _u64_js_1["default"].rotrSH(W15h, W15l, 1) ^ _u64_js_1["default"].rotrSH(W15h, W15l, 8) ^ _u64_js_1["default"].shrSH(W15h, W15l, 7);
        var s0l = _u64_js_1["default"].rotrSL(W15h, W15l, 1) ^ _u64_js_1["default"].rotrSL(W15h, W15l, 8) ^ _u64_js_1["default"].shrSL(W15h, W15l, 7);
        // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)
        var W2h = SHA512_W_H[_i - 2] | 0;
        var W2l = SHA512_W_L[_i - 2] | 0;
        var s1h = _u64_js_1["default"].rotrSH(W2h, W2l, 19) ^ _u64_js_1["default"].rotrBH(W2h, W2l, 61) ^ _u64_js_1["default"].shrSH(W2h, W2l, 6);
        var s1l = _u64_js_1["default"].rotrSL(W2h, W2l, 19) ^ _u64_js_1["default"].rotrBL(W2h, W2l, 61) ^ _u64_js_1["default"].shrSL(W2h, W2l, 6);
        // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];
        var SUMl = _u64_js_1["default"].add4L(s0l, s1l, SHA512_W_L[_i - 7], SHA512_W_L[_i - 16]);
        var SUMh = _u64_js_1["default"].add4H(SUMl, s0h, s1h, SHA512_W_H[_i - 7], SHA512_W_H[_i - 16]);
        SHA512_W_H[_i] = SUMh | 0;
        SHA512_W_L[_i] = SUMl | 0;
      }
      var Ah = this.Ah,
        Al = this.Al,
        Bh = this.Bh,
        Bl = this.Bl,
        Ch = this.Ch,
        Cl = this.Cl,
        Dh = this.Dh,
        Dl = this.Dl,
        Eh = this.Eh,
        El = this.El,
        Fh = this.Fh,
        Fl = this.Fl,
        Gh = this.Gh,
        Gl = this.Gl,
        Hh = this.Hh,
        Hl = this.Hl;
      // Compression function main loop, 80 rounds
      for (var _i2 = 0; _i2 < 80; _i2++) {
        // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)
        var sigma1h = _u64_js_1["default"].rotrSH(Eh, El, 14) ^ _u64_js_1["default"].rotrSH(Eh, El, 18) ^ _u64_js_1["default"].rotrBH(Eh, El, 41);
        var sigma1l = _u64_js_1["default"].rotrSL(Eh, El, 14) ^ _u64_js_1["default"].rotrSL(Eh, El, 18) ^ _u64_js_1["default"].rotrBL(Eh, El, 41);
        //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;
        var CHIh = Eh & Fh ^ ~Eh & Gh;
        var CHIl = El & Fl ^ ~El & Gl;
        // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]
        // prettier-ignore
        var T1ll = _u64_js_1["default"].add5L(Hl, sigma1l, CHIl, SHA512_Kl[_i2], SHA512_W_L[_i2]);
        var T1h = _u64_js_1["default"].add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[_i2], SHA512_W_H[_i2]);
        var T1l = T1ll | 0;
        // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)
        var sigma0h = _u64_js_1["default"].rotrSH(Ah, Al, 28) ^ _u64_js_1["default"].rotrBH(Ah, Al, 34) ^ _u64_js_1["default"].rotrBH(Ah, Al, 39);
        var sigma0l = _u64_js_1["default"].rotrSL(Ah, Al, 28) ^ _u64_js_1["default"].rotrBL(Ah, Al, 34) ^ _u64_js_1["default"].rotrBL(Ah, Al, 39);
        var MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
        var MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
        Hh = Gh | 0;
        Hl = Gl | 0;
        Gh = Fh | 0;
        Gl = Fl | 0;
        Fh = Eh | 0;
        Fl = El | 0;
        var _u64_js_1$default$add = _u64_js_1["default"].add(Dh | 0, Dl | 0, T1h | 0, T1l | 0);
        Eh = _u64_js_1$default$add.h;
        El = _u64_js_1$default$add.l;
        Dh = Ch | 0;
        Dl = Cl | 0;
        Ch = Bh | 0;
        Cl = Bl | 0;
        Bh = Ah | 0;
        Bl = Al | 0;
        var All = _u64_js_1["default"].add3L(T1l, sigma0l, MAJl);
        Ah = _u64_js_1["default"].add3H(All, T1h, sigma0h, MAJh);
        Al = All | 0;
      }
      // Add the compressed chunk to the current hash value
      var _u64_js_1$default$add2 = _u64_js_1["default"].add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0);
      Ah = _u64_js_1$default$add2.h;
      Al = _u64_js_1$default$add2.l;
      var _u64_js_1$default$add3 = _u64_js_1["default"].add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0);
      Bh = _u64_js_1$default$add3.h;
      Bl = _u64_js_1$default$add3.l;
      var _u64_js_1$default$add4 = _u64_js_1["default"].add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0);
      Ch = _u64_js_1$default$add4.h;
      Cl = _u64_js_1$default$add4.l;
      var _u64_js_1$default$add5 = _u64_js_1["default"].add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0);
      Dh = _u64_js_1$default$add5.h;
      Dl = _u64_js_1$default$add5.l;
      var _u64_js_1$default$add6 = _u64_js_1["default"].add(this.Eh | 0, this.El | 0, Eh | 0, El | 0);
      Eh = _u64_js_1$default$add6.h;
      El = _u64_js_1$default$add6.l;
      var _u64_js_1$default$add7 = _u64_js_1["default"].add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0);
      Fh = _u64_js_1$default$add7.h;
      Fl = _u64_js_1$default$add7.l;
      var _u64_js_1$default$add8 = _u64_js_1["default"].add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0);
      Gh = _u64_js_1$default$add8.h;
      Gl = _u64_js_1$default$add8.l;
      var _u64_js_1$default$add9 = _u64_js_1["default"].add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0);
      Hh = _u64_js_1$default$add9.h;
      Hl = _u64_js_1$default$add9.l;
      this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
    }
  }, {
    key: "roundClean",
    value: function roundClean() {
      SHA512_W_H.fill(0);
      SHA512_W_L.fill(0);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.buffer.fill(0);
      this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
  }]);
}(_sha2_js_1.SHA2);
exports.SHA512 = SHA512;
var SHA512_224 = /*#__PURE__*/function (_SHA) {
  function SHA512_224() {
    var _this2;
    _classCallCheck(this, SHA512_224);
    _this2 = _callSuper(this, SHA512_224);
    // h -- high 32 bits, l -- low 32 bits
    _this2.Ah = 0x8c3d37c8 | 0;
    _this2.Al = 0x19544da2 | 0;
    _this2.Bh = 0x73e19966 | 0;
    _this2.Bl = 0x89dcd4d6 | 0;
    _this2.Ch = 0x1dfab7ae | 0;
    _this2.Cl = 0x32ff9c82 | 0;
    _this2.Dh = 0x679dd514 | 0;
    _this2.Dl = 0x582f9fcf | 0;
    _this2.Eh = 0x0f6d2b69 | 0;
    _this2.El = 0x7bd44da8 | 0;
    _this2.Fh = 0x77e36f73 | 0;
    _this2.Fl = 0x04c48942 | 0;
    _this2.Gh = 0x3f9d85a8 | 0;
    _this2.Gl = 0x6a1d36c8 | 0;
    _this2.Hh = 0x1112e6ad | 0;
    _this2.Hl = 0x91d692a1 | 0;
    _this2.outputLen = 28;
    return _this2;
  }
  _inherits(SHA512_224, _SHA);
  return _createClass(SHA512_224);
}(SHA512);
var SHA512_256 = /*#__PURE__*/function (_SHA2) {
  function SHA512_256() {
    var _this3;
    _classCallCheck(this, SHA512_256);
    _this3 = _callSuper(this, SHA512_256);
    // h -- high 32 bits, l -- low 32 bits
    _this3.Ah = 0x22312194 | 0;
    _this3.Al = 0xfc2bf72c | 0;
    _this3.Bh = 0x9f555fa3 | 0;
    _this3.Bl = 0xc84c64c2 | 0;
    _this3.Ch = 0x2393b86b | 0;
    _this3.Cl = 0x6f53b151 | 0;
    _this3.Dh = 0x96387719 | 0;
    _this3.Dl = 0x5940eabd | 0;
    _this3.Eh = 0x96283ee2 | 0;
    _this3.El = 0xa88effe3 | 0;
    _this3.Fh = 0xbe5e1e25 | 0;
    _this3.Fl = 0x53863992 | 0;
    _this3.Gh = 0x2b0199fc | 0;
    _this3.Gl = 0x2c85b8aa | 0;
    _this3.Hh = 0x0eb72ddc | 0;
    _this3.Hl = 0x81c52ca2 | 0;
    _this3.outputLen = 32;
    return _this3;
  }
  _inherits(SHA512_256, _SHA2);
  return _createClass(SHA512_256);
}(SHA512);
var SHA384 = /*#__PURE__*/function (_SHA3) {
  function SHA384() {
    var _this4;
    _classCallCheck(this, SHA384);
    _this4 = _callSuper(this, SHA384);
    // h -- high 32 bits, l -- low 32 bits
    _this4.Ah = 0xcbbb9d5d | 0;
    _this4.Al = 0xc1059ed8 | 0;
    _this4.Bh = 0x629a292a | 0;
    _this4.Bl = 0x367cd507 | 0;
    _this4.Ch = 0x9159015a | 0;
    _this4.Cl = 0x3070dd17 | 0;
    _this4.Dh = 0x152fecd8 | 0;
    _this4.Dl = 0xf70e5939 | 0;
    _this4.Eh = 0x67332667 | 0;
    _this4.El = 0xffc00b31 | 0;
    _this4.Fh = 0x8eb44a87 | 0;
    _this4.Fl = 0x68581511 | 0;
    _this4.Gh = 0xdb0c2e0d | 0;
    _this4.Gl = 0x64f98fa7 | 0;
    _this4.Hh = 0x47b5481d | 0;
    _this4.Hl = 0xbefa4fa4 | 0;
    _this4.outputLen = 48;
    return _this4;
  }
  _inherits(SHA384, _SHA3);
  return _createClass(SHA384);
}(SHA512);
exports.sha512 = (0, utils_js_1.wrapConstructor)(function () {
  return new SHA512();
});
exports.sha512_224 = (0, utils_js_1.wrapConstructor)(function () {
  return new SHA512_224();
});
exports.sha512_256 = (0, utils_js_1.wrapConstructor)(function () {
  return new SHA512_256();
});
exports.sha384 = (0, utils_js_1.wrapConstructor)(function () {
  return new SHA384();
});

},{"./_sha2.js":63,"./_u64.js":64,"./utils.js":73}],73:[function(require,module,exports){
"use strict";

/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.randomBytes = exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;
// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.
// node.js versions earlier than v19 don't declare it in global scope.
// For node.js, package.json#exports field mapping rewrites import
// from `crypto` to `cryptoNode`, which imports native module.
// Makes the utils un-importable in browsers without a bundler.
// Once node.js 18 is deprecated, we can just drop the import.
var crypto_1 = require("@noble/hashes/crypto");
var u8a = function u8a(a) {
  return a instanceof Uint8Array;
};
// Cast array to different type
var u8 = function u8(arr) {
  return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
};
exports.u8 = u8;
var u32 = function u32(arr) {
  return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
};
exports.u32 = u32;
// Cast array to view
var createView = function createView(arr) {
  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
};
exports.createView = createView;
// The rotate right (circular right shift) operation for uint32
var rotr = function rotr(word, shift) {
  return word << 32 - shift | word >>> shift;
};
exports.rotr = rotr;
// big-endian hardware is rare. Just in case someone still decides to run hashes:
// early-throw an error because we don't support BE yet.
exports.isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;
if (!exports.isLE) throw new Error('Non little-endian hardware is not supported');
var hexes = /* @__PURE__ */Array.from({
  length: 256
}, function (_, i) {
  return i.toString(16).padStart(2, '0');
});
/**
 * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'
 */
function bytesToHex(bytes) {
  if (!u8a(bytes)) throw new Error('Uint8Array expected');
  // pre-caching improves the speed 6x
  var hex = '';
  for (var i = 0; i < bytes.length; i++) {
    hex += hexes[bytes[i]];
  }
  return hex;
}
exports.bytesToHex = bytesToHex;
/**
 * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])
 */
function hexToBytes(hex) {
  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + _typeof(hex));
  var len = hex.length;
  if (len % 2) throw new Error('padded hex string expected, got unpadded hex of length ' + len);
  var array = new Uint8Array(len / 2);
  for (var i = 0; i < array.length; i++) {
    var j = i * 2;
    var hexByte = hex.slice(j, j + 2);
    var _byte = Number.parseInt(hexByte, 16);
    if (Number.isNaN(_byte) || _byte < 0) throw new Error('Invalid byte sequence');
    array[i] = _byte;
  }
  return array;
}
exports.hexToBytes = hexToBytes;
// There is no setImmediate in browser and setTimeout is slow.
// call of async fn will return Promise, which will be fullfiled only on
// next scheduler queue processing step and this is exactly what we need.
var nextTick = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return function nextTick() {
    return _ref.apply(this, arguments);
  };
}();
exports.nextTick = nextTick;
// Returns control to thread each 'tick' ms to avoid blocking
function asyncLoop(_x, _x2, _x3) {
  return _asyncLoop.apply(this, arguments);
}
function _asyncLoop() {
  _asyncLoop = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(iters, tick, cb) {
    var ts, i, diff;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          ts = Date.now();
          i = 0;
        case 2:
          if (!(i < iters)) {
            _context2.next = 13;
            break;
          }
          cb(i);
          // Date.now() is not monotonic, so in case if clock goes backwards we return return control too
          diff = Date.now() - ts;
          if (!(diff >= 0 && diff < tick)) {
            _context2.next = 7;
            break;
          }
          return _context2.abrupt("continue", 10);
        case 7:
          _context2.next = 9;
          return (0, exports.nextTick)();
        case 9:
          ts += diff;
        case 10:
          i++;
          _context2.next = 2;
          break;
        case 13:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
  return _asyncLoop.apply(this, arguments);
}
exports.asyncLoop = asyncLoop;
/**
 * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])
 */
function utf8ToBytes(str) {
  if (typeof str !== 'string') throw new Error("utf8ToBytes expected string, got ".concat(_typeof(str)));
  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
}
exports.utf8ToBytes = utf8ToBytes;
/**
 * Normalizes (non-hex) string or Uint8Array to Uint8Array.
 * Warning: when Uint8Array is passed, it would NOT get copied.
 * Keep in mind for future mutable operations.
 */
function toBytes(data) {
  if (typeof data === 'string') data = utf8ToBytes(data);
  if (!u8a(data)) throw new Error("expected Uint8Array, got ".concat(_typeof(data)));
  return data;
}
exports.toBytes = toBytes;
/**
 * Copies several Uint8Arrays into one.
 */
function concatBytes() {
  for (var _len = arguments.length, arrays = new Array(_len), _key = 0; _key < _len; _key++) {
    arrays[_key] = arguments[_key];
  }
  var r = new Uint8Array(arrays.reduce(function (sum, a) {
    return sum + a.length;
  }, 0));
  var pad = 0; // walk through each item, ensure they have proper type
  arrays.forEach(function (a) {
    if (!u8a(a)) throw new Error('Uint8Array expected');
    r.set(a, pad);
    pad += a.length;
  });
  return r;
}
exports.concatBytes = concatBytes;
// For runtime check if class implements interface
var Hash = /*#__PURE__*/function () {
  function Hash() {
    _classCallCheck(this, Hash);
  }
  return _createClass(Hash, [{
    key: "clone",
    value:
    // Safe version that clones internal state
    function clone() {
      return this._cloneInto();
    }
  }]);
}();
exports.Hash = Hash;
var toStr = {}.toString;
function checkOpts(defaults, opts) {
  if (opts !== undefined && toStr.call(opts) !== '[object Object]') throw new Error('Options should be object or undefined');
  var merged = Object.assign(defaults, opts);
  return merged;
}
exports.checkOpts = checkOpts;
function wrapConstructor(hashCons) {
  var hashC = function hashC(msg) {
    return hashCons().update(toBytes(msg)).digest();
  };
  var tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = function () {
    return hashCons();
  };
  return hashC;
}
exports.wrapConstructor = wrapConstructor;
function wrapConstructorWithOpts(hashCons) {
  var hashC = function hashC(msg, opts) {
    return hashCons(opts).update(toBytes(msg)).digest();
  };
  var tmp = hashCons({});
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = function (opts) {
    return hashCons(opts);
  };
  return hashC;
}
exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
function wrapXOFConstructorWithOpts(hashCons) {
  var hashC = function hashC(msg, opts) {
    return hashCons(opts).update(toBytes(msg)).digest();
  };
  var tmp = hashCons({});
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = function (opts) {
    return hashCons(opts);
  };
  return hashC;
}
exports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
/**
 * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.
 */
function randomBytes() {
  var bytesLength = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 32;
  if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === 'function') {
    return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
  }
  throw new Error('crypto.getRandomValues must be defined');
}
exports.randomBytes = randomBytes;

},{"@noble/hashes/crypto":65}],74:[function(require,module,exports){
"use strict";

/*! MIT License. Copyright 2015-2022 Richard Moore <me@ricmoo.com>. See LICENSE.txt. */
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var __classPrivateFieldGet = void 0 && (void 0).__classPrivateFieldGet || function (receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = void 0 && (void 0).__classPrivateFieldSet || function (receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var _AES_key, _AES_Kd, _AES_Ke;
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AES = void 0;
// Number of rounds by keysize
var numberOfRounds = {
  16: 10,
  24: 12,
  32: 14
};
// Round constant words
var rcon = [0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91];
// S-box and Inverse S-box (S is for Substitution)
var S = [0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16];
var Si = [0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb, 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e, 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73, 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4, 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d];
// Transformations for encryption
var T1 = [0xc66363a5, 0xf87c7c84, 0xee777799, 0xf67b7b8d, 0xfff2f20d, 0xd66b6bbd, 0xde6f6fb1, 0x91c5c554, 0x60303050, 0x02010103, 0xce6767a9, 0x562b2b7d, 0xe7fefe19, 0xb5d7d762, 0x4dababe6, 0xec76769a, 0x8fcaca45, 0x1f82829d, 0x89c9c940, 0xfa7d7d87, 0xeffafa15, 0xb25959eb, 0x8e4747c9, 0xfbf0f00b, 0x41adadec, 0xb3d4d467, 0x5fa2a2fd, 0x45afafea, 0x239c9cbf, 0x53a4a4f7, 0xe4727296, 0x9bc0c05b, 0x75b7b7c2, 0xe1fdfd1c, 0x3d9393ae, 0x4c26266a, 0x6c36365a, 0x7e3f3f41, 0xf5f7f702, 0x83cccc4f, 0x6834345c, 0x51a5a5f4, 0xd1e5e534, 0xf9f1f108, 0xe2717193, 0xabd8d873, 0x62313153, 0x2a15153f, 0x0804040c, 0x95c7c752, 0x46232365, 0x9dc3c35e, 0x30181828, 0x379696a1, 0x0a05050f, 0x2f9a9ab5, 0x0e070709, 0x24121236, 0x1b80809b, 0xdfe2e23d, 0xcdebeb26, 0x4e272769, 0x7fb2b2cd, 0xea75759f, 0x1209091b, 0x1d83839e, 0x582c2c74, 0x341a1a2e, 0x361b1b2d, 0xdc6e6eb2, 0xb45a5aee, 0x5ba0a0fb, 0xa45252f6, 0x763b3b4d, 0xb7d6d661, 0x7db3b3ce, 0x5229297b, 0xdde3e33e, 0x5e2f2f71, 0x13848497, 0xa65353f5, 0xb9d1d168, 0x00000000, 0xc1eded2c, 0x40202060, 0xe3fcfc1f, 0x79b1b1c8, 0xb65b5bed, 0xd46a6abe, 0x8dcbcb46, 0x67bebed9, 0x7239394b, 0x944a4ade, 0x984c4cd4, 0xb05858e8, 0x85cfcf4a, 0xbbd0d06b, 0xc5efef2a, 0x4faaaae5, 0xedfbfb16, 0x864343c5, 0x9a4d4dd7, 0x66333355, 0x11858594, 0x8a4545cf, 0xe9f9f910, 0x04020206, 0xfe7f7f81, 0xa05050f0, 0x783c3c44, 0x259f9fba, 0x4ba8a8e3, 0xa25151f3, 0x5da3a3fe, 0x804040c0, 0x058f8f8a, 0x3f9292ad, 0x219d9dbc, 0x70383848, 0xf1f5f504, 0x63bcbcdf, 0x77b6b6c1, 0xafdada75, 0x42212163, 0x20101030, 0xe5ffff1a, 0xfdf3f30e, 0xbfd2d26d, 0x81cdcd4c, 0x180c0c14, 0x26131335, 0xc3ecec2f, 0xbe5f5fe1, 0x359797a2, 0x884444cc, 0x2e171739, 0x93c4c457, 0x55a7a7f2, 0xfc7e7e82, 0x7a3d3d47, 0xc86464ac, 0xba5d5de7, 0x3219192b, 0xe6737395, 0xc06060a0, 0x19818198, 0x9e4f4fd1, 0xa3dcdc7f, 0x44222266, 0x542a2a7e, 0x3b9090ab, 0x0b888883, 0x8c4646ca, 0xc7eeee29, 0x6bb8b8d3, 0x2814143c, 0xa7dede79, 0xbc5e5ee2, 0x160b0b1d, 0xaddbdb76, 0xdbe0e03b, 0x64323256, 0x743a3a4e, 0x140a0a1e, 0x924949db, 0x0c06060a, 0x4824246c, 0xb85c5ce4, 0x9fc2c25d, 0xbdd3d36e, 0x43acacef, 0xc46262a6, 0x399191a8, 0x319595a4, 0xd3e4e437, 0xf279798b, 0xd5e7e732, 0x8bc8c843, 0x6e373759, 0xda6d6db7, 0x018d8d8c, 0xb1d5d564, 0x9c4e4ed2, 0x49a9a9e0, 0xd86c6cb4, 0xac5656fa, 0xf3f4f407, 0xcfeaea25, 0xca6565af, 0xf47a7a8e, 0x47aeaee9, 0x10080818, 0x6fbabad5, 0xf0787888, 0x4a25256f, 0x5c2e2e72, 0x381c1c24, 0x57a6a6f1, 0x73b4b4c7, 0x97c6c651, 0xcbe8e823, 0xa1dddd7c, 0xe874749c, 0x3e1f1f21, 0x964b4bdd, 0x61bdbddc, 0x0d8b8b86, 0x0f8a8a85, 0xe0707090, 0x7c3e3e42, 0x71b5b5c4, 0xcc6666aa, 0x904848d8, 0x06030305, 0xf7f6f601, 0x1c0e0e12, 0xc26161a3, 0x6a35355f, 0xae5757f9, 0x69b9b9d0, 0x17868691, 0x99c1c158, 0x3a1d1d27, 0x279e9eb9, 0xd9e1e138, 0xebf8f813, 0x2b9898b3, 0x22111133, 0xd26969bb, 0xa9d9d970, 0x078e8e89, 0x339494a7, 0x2d9b9bb6, 0x3c1e1e22, 0x15878792, 0xc9e9e920, 0x87cece49, 0xaa5555ff, 0x50282878, 0xa5dfdf7a, 0x038c8c8f, 0x59a1a1f8, 0x09898980, 0x1a0d0d17, 0x65bfbfda, 0xd7e6e631, 0x844242c6, 0xd06868b8, 0x824141c3, 0x299999b0, 0x5a2d2d77, 0x1e0f0f11, 0x7bb0b0cb, 0xa85454fc, 0x6dbbbbd6, 0x2c16163a];
var T2 = [0xa5c66363, 0x84f87c7c, 0x99ee7777, 0x8df67b7b, 0x0dfff2f2, 0xbdd66b6b, 0xb1de6f6f, 0x5491c5c5, 0x50603030, 0x03020101, 0xa9ce6767, 0x7d562b2b, 0x19e7fefe, 0x62b5d7d7, 0xe64dabab, 0x9aec7676, 0x458fcaca, 0x9d1f8282, 0x4089c9c9, 0x87fa7d7d, 0x15effafa, 0xebb25959, 0xc98e4747, 0x0bfbf0f0, 0xec41adad, 0x67b3d4d4, 0xfd5fa2a2, 0xea45afaf, 0xbf239c9c, 0xf753a4a4, 0x96e47272, 0x5b9bc0c0, 0xc275b7b7, 0x1ce1fdfd, 0xae3d9393, 0x6a4c2626, 0x5a6c3636, 0x417e3f3f, 0x02f5f7f7, 0x4f83cccc, 0x5c683434, 0xf451a5a5, 0x34d1e5e5, 0x08f9f1f1, 0x93e27171, 0x73abd8d8, 0x53623131, 0x3f2a1515, 0x0c080404, 0x5295c7c7, 0x65462323, 0x5e9dc3c3, 0x28301818, 0xa1379696, 0x0f0a0505, 0xb52f9a9a, 0x090e0707, 0x36241212, 0x9b1b8080, 0x3ddfe2e2, 0x26cdebeb, 0x694e2727, 0xcd7fb2b2, 0x9fea7575, 0x1b120909, 0x9e1d8383, 0x74582c2c, 0x2e341a1a, 0x2d361b1b, 0xb2dc6e6e, 0xeeb45a5a, 0xfb5ba0a0, 0xf6a45252, 0x4d763b3b, 0x61b7d6d6, 0xce7db3b3, 0x7b522929, 0x3edde3e3, 0x715e2f2f, 0x97138484, 0xf5a65353, 0x68b9d1d1, 0x00000000, 0x2cc1eded, 0x60402020, 0x1fe3fcfc, 0xc879b1b1, 0xedb65b5b, 0xbed46a6a, 0x468dcbcb, 0xd967bebe, 0x4b723939, 0xde944a4a, 0xd4984c4c, 0xe8b05858, 0x4a85cfcf, 0x6bbbd0d0, 0x2ac5efef, 0xe54faaaa, 0x16edfbfb, 0xc5864343, 0xd79a4d4d, 0x55663333, 0x94118585, 0xcf8a4545, 0x10e9f9f9, 0x06040202, 0x81fe7f7f, 0xf0a05050, 0x44783c3c, 0xba259f9f, 0xe34ba8a8, 0xf3a25151, 0xfe5da3a3, 0xc0804040, 0x8a058f8f, 0xad3f9292, 0xbc219d9d, 0x48703838, 0x04f1f5f5, 0xdf63bcbc, 0xc177b6b6, 0x75afdada, 0x63422121, 0x30201010, 0x1ae5ffff, 0x0efdf3f3, 0x6dbfd2d2, 0x4c81cdcd, 0x14180c0c, 0x35261313, 0x2fc3ecec, 0xe1be5f5f, 0xa2359797, 0xcc884444, 0x392e1717, 0x5793c4c4, 0xf255a7a7, 0x82fc7e7e, 0x477a3d3d, 0xacc86464, 0xe7ba5d5d, 0x2b321919, 0x95e67373, 0xa0c06060, 0x98198181, 0xd19e4f4f, 0x7fa3dcdc, 0x66442222, 0x7e542a2a, 0xab3b9090, 0x830b8888, 0xca8c4646, 0x29c7eeee, 0xd36bb8b8, 0x3c281414, 0x79a7dede, 0xe2bc5e5e, 0x1d160b0b, 0x76addbdb, 0x3bdbe0e0, 0x56643232, 0x4e743a3a, 0x1e140a0a, 0xdb924949, 0x0a0c0606, 0x6c482424, 0xe4b85c5c, 0x5d9fc2c2, 0x6ebdd3d3, 0xef43acac, 0xa6c46262, 0xa8399191, 0xa4319595, 0x37d3e4e4, 0x8bf27979, 0x32d5e7e7, 0x438bc8c8, 0x596e3737, 0xb7da6d6d, 0x8c018d8d, 0x64b1d5d5, 0xd29c4e4e, 0xe049a9a9, 0xb4d86c6c, 0xfaac5656, 0x07f3f4f4, 0x25cfeaea, 0xafca6565, 0x8ef47a7a, 0xe947aeae, 0x18100808, 0xd56fbaba, 0x88f07878, 0x6f4a2525, 0x725c2e2e, 0x24381c1c, 0xf157a6a6, 0xc773b4b4, 0x5197c6c6, 0x23cbe8e8, 0x7ca1dddd, 0x9ce87474, 0x213e1f1f, 0xdd964b4b, 0xdc61bdbd, 0x860d8b8b, 0x850f8a8a, 0x90e07070, 0x427c3e3e, 0xc471b5b5, 0xaacc6666, 0xd8904848, 0x05060303, 0x01f7f6f6, 0x121c0e0e, 0xa3c26161, 0x5f6a3535, 0xf9ae5757, 0xd069b9b9, 0x91178686, 0x5899c1c1, 0x273a1d1d, 0xb9279e9e, 0x38d9e1e1, 0x13ebf8f8, 0xb32b9898, 0x33221111, 0xbbd26969, 0x70a9d9d9, 0x89078e8e, 0xa7339494, 0xb62d9b9b, 0x223c1e1e, 0x92158787, 0x20c9e9e9, 0x4987cece, 0xffaa5555, 0x78502828, 0x7aa5dfdf, 0x8f038c8c, 0xf859a1a1, 0x80098989, 0x171a0d0d, 0xda65bfbf, 0x31d7e6e6, 0xc6844242, 0xb8d06868, 0xc3824141, 0xb0299999, 0x775a2d2d, 0x111e0f0f, 0xcb7bb0b0, 0xfca85454, 0xd66dbbbb, 0x3a2c1616];
var T3 = [0x63a5c663, 0x7c84f87c, 0x7799ee77, 0x7b8df67b, 0xf20dfff2, 0x6bbdd66b, 0x6fb1de6f, 0xc55491c5, 0x30506030, 0x01030201, 0x67a9ce67, 0x2b7d562b, 0xfe19e7fe, 0xd762b5d7, 0xabe64dab, 0x769aec76, 0xca458fca, 0x829d1f82, 0xc94089c9, 0x7d87fa7d, 0xfa15effa, 0x59ebb259, 0x47c98e47, 0xf00bfbf0, 0xadec41ad, 0xd467b3d4, 0xa2fd5fa2, 0xafea45af, 0x9cbf239c, 0xa4f753a4, 0x7296e472, 0xc05b9bc0, 0xb7c275b7, 0xfd1ce1fd, 0x93ae3d93, 0x266a4c26, 0x365a6c36, 0x3f417e3f, 0xf702f5f7, 0xcc4f83cc, 0x345c6834, 0xa5f451a5, 0xe534d1e5, 0xf108f9f1, 0x7193e271, 0xd873abd8, 0x31536231, 0x153f2a15, 0x040c0804, 0xc75295c7, 0x23654623, 0xc35e9dc3, 0x18283018, 0x96a13796, 0x050f0a05, 0x9ab52f9a, 0x07090e07, 0x12362412, 0x809b1b80, 0xe23ddfe2, 0xeb26cdeb, 0x27694e27, 0xb2cd7fb2, 0x759fea75, 0x091b1209, 0x839e1d83, 0x2c74582c, 0x1a2e341a, 0x1b2d361b, 0x6eb2dc6e, 0x5aeeb45a, 0xa0fb5ba0, 0x52f6a452, 0x3b4d763b, 0xd661b7d6, 0xb3ce7db3, 0x297b5229, 0xe33edde3, 0x2f715e2f, 0x84971384, 0x53f5a653, 0xd168b9d1, 0x00000000, 0xed2cc1ed, 0x20604020, 0xfc1fe3fc, 0xb1c879b1, 0x5bedb65b, 0x6abed46a, 0xcb468dcb, 0xbed967be, 0x394b7239, 0x4ade944a, 0x4cd4984c, 0x58e8b058, 0xcf4a85cf, 0xd06bbbd0, 0xef2ac5ef, 0xaae54faa, 0xfb16edfb, 0x43c58643, 0x4dd79a4d, 0x33556633, 0x85941185, 0x45cf8a45, 0xf910e9f9, 0x02060402, 0x7f81fe7f, 0x50f0a050, 0x3c44783c, 0x9fba259f, 0xa8e34ba8, 0x51f3a251, 0xa3fe5da3, 0x40c08040, 0x8f8a058f, 0x92ad3f92, 0x9dbc219d, 0x38487038, 0xf504f1f5, 0xbcdf63bc, 0xb6c177b6, 0xda75afda, 0x21634221, 0x10302010, 0xff1ae5ff, 0xf30efdf3, 0xd26dbfd2, 0xcd4c81cd, 0x0c14180c, 0x13352613, 0xec2fc3ec, 0x5fe1be5f, 0x97a23597, 0x44cc8844, 0x17392e17, 0xc45793c4, 0xa7f255a7, 0x7e82fc7e, 0x3d477a3d, 0x64acc864, 0x5de7ba5d, 0x192b3219, 0x7395e673, 0x60a0c060, 0x81981981, 0x4fd19e4f, 0xdc7fa3dc, 0x22664422, 0x2a7e542a, 0x90ab3b90, 0x88830b88, 0x46ca8c46, 0xee29c7ee, 0xb8d36bb8, 0x143c2814, 0xde79a7de, 0x5ee2bc5e, 0x0b1d160b, 0xdb76addb, 0xe03bdbe0, 0x32566432, 0x3a4e743a, 0x0a1e140a, 0x49db9249, 0x060a0c06, 0x246c4824, 0x5ce4b85c, 0xc25d9fc2, 0xd36ebdd3, 0xacef43ac, 0x62a6c462, 0x91a83991, 0x95a43195, 0xe437d3e4, 0x798bf279, 0xe732d5e7, 0xc8438bc8, 0x37596e37, 0x6db7da6d, 0x8d8c018d, 0xd564b1d5, 0x4ed29c4e, 0xa9e049a9, 0x6cb4d86c, 0x56faac56, 0xf407f3f4, 0xea25cfea, 0x65afca65, 0x7a8ef47a, 0xaee947ae, 0x08181008, 0xbad56fba, 0x7888f078, 0x256f4a25, 0x2e725c2e, 0x1c24381c, 0xa6f157a6, 0xb4c773b4, 0xc65197c6, 0xe823cbe8, 0xdd7ca1dd, 0x749ce874, 0x1f213e1f, 0x4bdd964b, 0xbddc61bd, 0x8b860d8b, 0x8a850f8a, 0x7090e070, 0x3e427c3e, 0xb5c471b5, 0x66aacc66, 0x48d89048, 0x03050603, 0xf601f7f6, 0x0e121c0e, 0x61a3c261, 0x355f6a35, 0x57f9ae57, 0xb9d069b9, 0x86911786, 0xc15899c1, 0x1d273a1d, 0x9eb9279e, 0xe138d9e1, 0xf813ebf8, 0x98b32b98, 0x11332211, 0x69bbd269, 0xd970a9d9, 0x8e89078e, 0x94a73394, 0x9bb62d9b, 0x1e223c1e, 0x87921587, 0xe920c9e9, 0xce4987ce, 0x55ffaa55, 0x28785028, 0xdf7aa5df, 0x8c8f038c, 0xa1f859a1, 0x89800989, 0x0d171a0d, 0xbfda65bf, 0xe631d7e6, 0x42c68442, 0x68b8d068, 0x41c38241, 0x99b02999, 0x2d775a2d, 0x0f111e0f, 0xb0cb7bb0, 0x54fca854, 0xbbd66dbb, 0x163a2c16];
var T4 = [0x6363a5c6, 0x7c7c84f8, 0x777799ee, 0x7b7b8df6, 0xf2f20dff, 0x6b6bbdd6, 0x6f6fb1de, 0xc5c55491, 0x30305060, 0x01010302, 0x6767a9ce, 0x2b2b7d56, 0xfefe19e7, 0xd7d762b5, 0xababe64d, 0x76769aec, 0xcaca458f, 0x82829d1f, 0xc9c94089, 0x7d7d87fa, 0xfafa15ef, 0x5959ebb2, 0x4747c98e, 0xf0f00bfb, 0xadadec41, 0xd4d467b3, 0xa2a2fd5f, 0xafafea45, 0x9c9cbf23, 0xa4a4f753, 0x727296e4, 0xc0c05b9b, 0xb7b7c275, 0xfdfd1ce1, 0x9393ae3d, 0x26266a4c, 0x36365a6c, 0x3f3f417e, 0xf7f702f5, 0xcccc4f83, 0x34345c68, 0xa5a5f451, 0xe5e534d1, 0xf1f108f9, 0x717193e2, 0xd8d873ab, 0x31315362, 0x15153f2a, 0x04040c08, 0xc7c75295, 0x23236546, 0xc3c35e9d, 0x18182830, 0x9696a137, 0x05050f0a, 0x9a9ab52f, 0x0707090e, 0x12123624, 0x80809b1b, 0xe2e23ddf, 0xebeb26cd, 0x2727694e, 0xb2b2cd7f, 0x75759fea, 0x09091b12, 0x83839e1d, 0x2c2c7458, 0x1a1a2e34, 0x1b1b2d36, 0x6e6eb2dc, 0x5a5aeeb4, 0xa0a0fb5b, 0x5252f6a4, 0x3b3b4d76, 0xd6d661b7, 0xb3b3ce7d, 0x29297b52, 0xe3e33edd, 0x2f2f715e, 0x84849713, 0x5353f5a6, 0xd1d168b9, 0x00000000, 0xeded2cc1, 0x20206040, 0xfcfc1fe3, 0xb1b1c879, 0x5b5bedb6, 0x6a6abed4, 0xcbcb468d, 0xbebed967, 0x39394b72, 0x4a4ade94, 0x4c4cd498, 0x5858e8b0, 0xcfcf4a85, 0xd0d06bbb, 0xefef2ac5, 0xaaaae54f, 0xfbfb16ed, 0x4343c586, 0x4d4dd79a, 0x33335566, 0x85859411, 0x4545cf8a, 0xf9f910e9, 0x02020604, 0x7f7f81fe, 0x5050f0a0, 0x3c3c4478, 0x9f9fba25, 0xa8a8e34b, 0x5151f3a2, 0xa3a3fe5d, 0x4040c080, 0x8f8f8a05, 0x9292ad3f, 0x9d9dbc21, 0x38384870, 0xf5f504f1, 0xbcbcdf63, 0xb6b6c177, 0xdada75af, 0x21216342, 0x10103020, 0xffff1ae5, 0xf3f30efd, 0xd2d26dbf, 0xcdcd4c81, 0x0c0c1418, 0x13133526, 0xecec2fc3, 0x5f5fe1be, 0x9797a235, 0x4444cc88, 0x1717392e, 0xc4c45793, 0xa7a7f255, 0x7e7e82fc, 0x3d3d477a, 0x6464acc8, 0x5d5de7ba, 0x19192b32, 0x737395e6, 0x6060a0c0, 0x81819819, 0x4f4fd19e, 0xdcdc7fa3, 0x22226644, 0x2a2a7e54, 0x9090ab3b, 0x8888830b, 0x4646ca8c, 0xeeee29c7, 0xb8b8d36b, 0x14143c28, 0xdede79a7, 0x5e5ee2bc, 0x0b0b1d16, 0xdbdb76ad, 0xe0e03bdb, 0x32325664, 0x3a3a4e74, 0x0a0a1e14, 0x4949db92, 0x06060a0c, 0x24246c48, 0x5c5ce4b8, 0xc2c25d9f, 0xd3d36ebd, 0xacacef43, 0x6262a6c4, 0x9191a839, 0x9595a431, 0xe4e437d3, 0x79798bf2, 0xe7e732d5, 0xc8c8438b, 0x3737596e, 0x6d6db7da, 0x8d8d8c01, 0xd5d564b1, 0x4e4ed29c, 0xa9a9e049, 0x6c6cb4d8, 0x5656faac, 0xf4f407f3, 0xeaea25cf, 0x6565afca, 0x7a7a8ef4, 0xaeaee947, 0x08081810, 0xbabad56f, 0x787888f0, 0x25256f4a, 0x2e2e725c, 0x1c1c2438, 0xa6a6f157, 0xb4b4c773, 0xc6c65197, 0xe8e823cb, 0xdddd7ca1, 0x74749ce8, 0x1f1f213e, 0x4b4bdd96, 0xbdbddc61, 0x8b8b860d, 0x8a8a850f, 0x707090e0, 0x3e3e427c, 0xb5b5c471, 0x6666aacc, 0x4848d890, 0x03030506, 0xf6f601f7, 0x0e0e121c, 0x6161a3c2, 0x35355f6a, 0x5757f9ae, 0xb9b9d069, 0x86869117, 0xc1c15899, 0x1d1d273a, 0x9e9eb927, 0xe1e138d9, 0xf8f813eb, 0x9898b32b, 0x11113322, 0x6969bbd2, 0xd9d970a9, 0x8e8e8907, 0x9494a733, 0x9b9bb62d, 0x1e1e223c, 0x87879215, 0xe9e920c9, 0xcece4987, 0x5555ffaa, 0x28287850, 0xdfdf7aa5, 0x8c8c8f03, 0xa1a1f859, 0x89898009, 0x0d0d171a, 0xbfbfda65, 0xe6e631d7, 0x4242c684, 0x6868b8d0, 0x4141c382, 0x9999b029, 0x2d2d775a, 0x0f0f111e, 0xb0b0cb7b, 0x5454fca8, 0xbbbbd66d, 0x16163a2c];
// Transformations for decryption
var T5 = [0x51f4a750, 0x7e416553, 0x1a17a4c3, 0x3a275e96, 0x3bab6bcb, 0x1f9d45f1, 0xacfa58ab, 0x4be30393, 0x2030fa55, 0xad766df6, 0x88cc7691, 0xf5024c25, 0x4fe5d7fc, 0xc52acbd7, 0x26354480, 0xb562a38f, 0xdeb15a49, 0x25ba1b67, 0x45ea0e98, 0x5dfec0e1, 0xc32f7502, 0x814cf012, 0x8d4697a3, 0x6bd3f9c6, 0x038f5fe7, 0x15929c95, 0xbf6d7aeb, 0x955259da, 0xd4be832d, 0x587421d3, 0x49e06929, 0x8ec9c844, 0x75c2896a, 0xf48e7978, 0x99583e6b, 0x27b971dd, 0xbee14fb6, 0xf088ad17, 0xc920ac66, 0x7dce3ab4, 0x63df4a18, 0xe51a3182, 0x97513360, 0x62537f45, 0xb16477e0, 0xbb6bae84, 0xfe81a01c, 0xf9082b94, 0x70486858, 0x8f45fd19, 0x94de6c87, 0x527bf8b7, 0xab73d323, 0x724b02e2, 0xe31f8f57, 0x6655ab2a, 0xb2eb2807, 0x2fb5c203, 0x86c57b9a, 0xd33708a5, 0x302887f2, 0x23bfa5b2, 0x02036aba, 0xed16825c, 0x8acf1c2b, 0xa779b492, 0xf307f2f0, 0x4e69e2a1, 0x65daf4cd, 0x0605bed5, 0xd134621f, 0xc4a6fe8a, 0x342e539d, 0xa2f355a0, 0x058ae132, 0xa4f6eb75, 0x0b83ec39, 0x4060efaa, 0x5e719f06, 0xbd6e1051, 0x3e218af9, 0x96dd063d, 0xdd3e05ae, 0x4de6bd46, 0x91548db5, 0x71c45d05, 0x0406d46f, 0x605015ff, 0x1998fb24, 0xd6bde997, 0x894043cc, 0x67d99e77, 0xb0e842bd, 0x07898b88, 0xe7195b38, 0x79c8eedb, 0xa17c0a47, 0x7c420fe9, 0xf8841ec9, 0x00000000, 0x09808683, 0x322bed48, 0x1e1170ac, 0x6c5a724e, 0xfd0efffb, 0x0f853856, 0x3daed51e, 0x362d3927, 0x0a0fd964, 0x685ca621, 0x9b5b54d1, 0x24362e3a, 0x0c0a67b1, 0x9357e70f, 0xb4ee96d2, 0x1b9b919e, 0x80c0c54f, 0x61dc20a2, 0x5a774b69, 0x1c121a16, 0xe293ba0a, 0xc0a02ae5, 0x3c22e043, 0x121b171d, 0x0e090d0b, 0xf28bc7ad, 0x2db6a8b9, 0x141ea9c8, 0x57f11985, 0xaf75074c, 0xee99ddbb, 0xa37f60fd, 0xf701269f, 0x5c72f5bc, 0x44663bc5, 0x5bfb7e34, 0x8b432976, 0xcb23c6dc, 0xb6edfc68, 0xb8e4f163, 0xd731dcca, 0x42638510, 0x13972240, 0x84c61120, 0x854a247d, 0xd2bb3df8, 0xaef93211, 0xc729a16d, 0x1d9e2f4b, 0xdcb230f3, 0x0d8652ec, 0x77c1e3d0, 0x2bb3166c, 0xa970b999, 0x119448fa, 0x47e96422, 0xa8fc8cc4, 0xa0f03f1a, 0x567d2cd8, 0x223390ef, 0x87494ec7, 0xd938d1c1, 0x8ccaa2fe, 0x98d40b36, 0xa6f581cf, 0xa57ade28, 0xdab78e26, 0x3fadbfa4, 0x2c3a9de4, 0x5078920d, 0x6a5fcc9b, 0x547e4662, 0xf68d13c2, 0x90d8b8e8, 0x2e39f75e, 0x82c3aff5, 0x9f5d80be, 0x69d0937c, 0x6fd52da9, 0xcf2512b3, 0xc8ac993b, 0x10187da7, 0xe89c636e, 0xdb3bbb7b, 0xcd267809, 0x6e5918f4, 0xec9ab701, 0x834f9aa8, 0xe6956e65, 0xaaffe67e, 0x21bccf08, 0xef15e8e6, 0xbae79bd9, 0x4a6f36ce, 0xea9f09d4, 0x29b07cd6, 0x31a4b2af, 0x2a3f2331, 0xc6a59430, 0x35a266c0, 0x744ebc37, 0xfc82caa6, 0xe090d0b0, 0x33a7d815, 0xf104984a, 0x41ecdaf7, 0x7fcd500e, 0x1791f62f, 0x764dd68d, 0x43efb04d, 0xccaa4d54, 0xe49604df, 0x9ed1b5e3, 0x4c6a881b, 0xc12c1fb8, 0x4665517f, 0x9d5eea04, 0x018c355d, 0xfa877473, 0xfb0b412e, 0xb3671d5a, 0x92dbd252, 0xe9105633, 0x6dd64713, 0x9ad7618c, 0x37a10c7a, 0x59f8148e, 0xeb133c89, 0xcea927ee, 0xb761c935, 0xe11ce5ed, 0x7a47b13c, 0x9cd2df59, 0x55f2733f, 0x1814ce79, 0x73c737bf, 0x53f7cdea, 0x5ffdaa5b, 0xdf3d6f14, 0x7844db86, 0xcaaff381, 0xb968c43e, 0x3824342c, 0xc2a3405f, 0x161dc372, 0xbce2250c, 0x283c498b, 0xff0d9541, 0x39a80171, 0x080cb3de, 0xd8b4e49c, 0x6456c190, 0x7bcb8461, 0xd532b670, 0x486c5c74, 0xd0b85742];
var T6 = [0x5051f4a7, 0x537e4165, 0xc31a17a4, 0x963a275e, 0xcb3bab6b, 0xf11f9d45, 0xabacfa58, 0x934be303, 0x552030fa, 0xf6ad766d, 0x9188cc76, 0x25f5024c, 0xfc4fe5d7, 0xd7c52acb, 0x80263544, 0x8fb562a3, 0x49deb15a, 0x6725ba1b, 0x9845ea0e, 0xe15dfec0, 0x02c32f75, 0x12814cf0, 0xa38d4697, 0xc66bd3f9, 0xe7038f5f, 0x9515929c, 0xebbf6d7a, 0xda955259, 0x2dd4be83, 0xd3587421, 0x2949e069, 0x448ec9c8, 0x6a75c289, 0x78f48e79, 0x6b99583e, 0xdd27b971, 0xb6bee14f, 0x17f088ad, 0x66c920ac, 0xb47dce3a, 0x1863df4a, 0x82e51a31, 0x60975133, 0x4562537f, 0xe0b16477, 0x84bb6bae, 0x1cfe81a0, 0x94f9082b, 0x58704868, 0x198f45fd, 0x8794de6c, 0xb7527bf8, 0x23ab73d3, 0xe2724b02, 0x57e31f8f, 0x2a6655ab, 0x07b2eb28, 0x032fb5c2, 0x9a86c57b, 0xa5d33708, 0xf2302887, 0xb223bfa5, 0xba02036a, 0x5ced1682, 0x2b8acf1c, 0x92a779b4, 0xf0f307f2, 0xa14e69e2, 0xcd65daf4, 0xd50605be, 0x1fd13462, 0x8ac4a6fe, 0x9d342e53, 0xa0a2f355, 0x32058ae1, 0x75a4f6eb, 0x390b83ec, 0xaa4060ef, 0x065e719f, 0x51bd6e10, 0xf93e218a, 0x3d96dd06, 0xaedd3e05, 0x464de6bd, 0xb591548d, 0x0571c45d, 0x6f0406d4, 0xff605015, 0x241998fb, 0x97d6bde9, 0xcc894043, 0x7767d99e, 0xbdb0e842, 0x8807898b, 0x38e7195b, 0xdb79c8ee, 0x47a17c0a, 0xe97c420f, 0xc9f8841e, 0x00000000, 0x83098086, 0x48322bed, 0xac1e1170, 0x4e6c5a72, 0xfbfd0eff, 0x560f8538, 0x1e3daed5, 0x27362d39, 0x640a0fd9, 0x21685ca6, 0xd19b5b54, 0x3a24362e, 0xb10c0a67, 0x0f9357e7, 0xd2b4ee96, 0x9e1b9b91, 0x4f80c0c5, 0xa261dc20, 0x695a774b, 0x161c121a, 0x0ae293ba, 0xe5c0a02a, 0x433c22e0, 0x1d121b17, 0x0b0e090d, 0xadf28bc7, 0xb92db6a8, 0xc8141ea9, 0x8557f119, 0x4caf7507, 0xbbee99dd, 0xfda37f60, 0x9ff70126, 0xbc5c72f5, 0xc544663b, 0x345bfb7e, 0x768b4329, 0xdccb23c6, 0x68b6edfc, 0x63b8e4f1, 0xcad731dc, 0x10426385, 0x40139722, 0x2084c611, 0x7d854a24, 0xf8d2bb3d, 0x11aef932, 0x6dc729a1, 0x4b1d9e2f, 0xf3dcb230, 0xec0d8652, 0xd077c1e3, 0x6c2bb316, 0x99a970b9, 0xfa119448, 0x2247e964, 0xc4a8fc8c, 0x1aa0f03f, 0xd8567d2c, 0xef223390, 0xc787494e, 0xc1d938d1, 0xfe8ccaa2, 0x3698d40b, 0xcfa6f581, 0x28a57ade, 0x26dab78e, 0xa43fadbf, 0xe42c3a9d, 0x0d507892, 0x9b6a5fcc, 0x62547e46, 0xc2f68d13, 0xe890d8b8, 0x5e2e39f7, 0xf582c3af, 0xbe9f5d80, 0x7c69d093, 0xa96fd52d, 0xb3cf2512, 0x3bc8ac99, 0xa710187d, 0x6ee89c63, 0x7bdb3bbb, 0x09cd2678, 0xf46e5918, 0x01ec9ab7, 0xa8834f9a, 0x65e6956e, 0x7eaaffe6, 0x0821bccf, 0xe6ef15e8, 0xd9bae79b, 0xce4a6f36, 0xd4ea9f09, 0xd629b07c, 0xaf31a4b2, 0x312a3f23, 0x30c6a594, 0xc035a266, 0x37744ebc, 0xa6fc82ca, 0xb0e090d0, 0x1533a7d8, 0x4af10498, 0xf741ecda, 0x0e7fcd50, 0x2f1791f6, 0x8d764dd6, 0x4d43efb0, 0x54ccaa4d, 0xdfe49604, 0xe39ed1b5, 0x1b4c6a88, 0xb8c12c1f, 0x7f466551, 0x049d5eea, 0x5d018c35, 0x73fa8774, 0x2efb0b41, 0x5ab3671d, 0x5292dbd2, 0x33e91056, 0x136dd647, 0x8c9ad761, 0x7a37a10c, 0x8e59f814, 0x89eb133c, 0xeecea927, 0x35b761c9, 0xede11ce5, 0x3c7a47b1, 0x599cd2df, 0x3f55f273, 0x791814ce, 0xbf73c737, 0xea53f7cd, 0x5b5ffdaa, 0x14df3d6f, 0x867844db, 0x81caaff3, 0x3eb968c4, 0x2c382434, 0x5fc2a340, 0x72161dc3, 0x0cbce225, 0x8b283c49, 0x41ff0d95, 0x7139a801, 0xde080cb3, 0x9cd8b4e4, 0x906456c1, 0x617bcb84, 0x70d532b6, 0x74486c5c, 0x42d0b857];
var T7 = [0xa75051f4, 0x65537e41, 0xa4c31a17, 0x5e963a27, 0x6bcb3bab, 0x45f11f9d, 0x58abacfa, 0x03934be3, 0xfa552030, 0x6df6ad76, 0x769188cc, 0x4c25f502, 0xd7fc4fe5, 0xcbd7c52a, 0x44802635, 0xa38fb562, 0x5a49deb1, 0x1b6725ba, 0x0e9845ea, 0xc0e15dfe, 0x7502c32f, 0xf012814c, 0x97a38d46, 0xf9c66bd3, 0x5fe7038f, 0x9c951592, 0x7aebbf6d, 0x59da9552, 0x832dd4be, 0x21d35874, 0x692949e0, 0xc8448ec9, 0x896a75c2, 0x7978f48e, 0x3e6b9958, 0x71dd27b9, 0x4fb6bee1, 0xad17f088, 0xac66c920, 0x3ab47dce, 0x4a1863df, 0x3182e51a, 0x33609751, 0x7f456253, 0x77e0b164, 0xae84bb6b, 0xa01cfe81, 0x2b94f908, 0x68587048, 0xfd198f45, 0x6c8794de, 0xf8b7527b, 0xd323ab73, 0x02e2724b, 0x8f57e31f, 0xab2a6655, 0x2807b2eb, 0xc2032fb5, 0x7b9a86c5, 0x08a5d337, 0x87f23028, 0xa5b223bf, 0x6aba0203, 0x825ced16, 0x1c2b8acf, 0xb492a779, 0xf2f0f307, 0xe2a14e69, 0xf4cd65da, 0xbed50605, 0x621fd134, 0xfe8ac4a6, 0x539d342e, 0x55a0a2f3, 0xe132058a, 0xeb75a4f6, 0xec390b83, 0xefaa4060, 0x9f065e71, 0x1051bd6e, 0x8af93e21, 0x063d96dd, 0x05aedd3e, 0xbd464de6, 0x8db59154, 0x5d0571c4, 0xd46f0406, 0x15ff6050, 0xfb241998, 0xe997d6bd, 0x43cc8940, 0x9e7767d9, 0x42bdb0e8, 0x8b880789, 0x5b38e719, 0xeedb79c8, 0x0a47a17c, 0x0fe97c42, 0x1ec9f884, 0x00000000, 0x86830980, 0xed48322b, 0x70ac1e11, 0x724e6c5a, 0xfffbfd0e, 0x38560f85, 0xd51e3dae, 0x3927362d, 0xd9640a0f, 0xa621685c, 0x54d19b5b, 0x2e3a2436, 0x67b10c0a, 0xe70f9357, 0x96d2b4ee, 0x919e1b9b, 0xc54f80c0, 0x20a261dc, 0x4b695a77, 0x1a161c12, 0xba0ae293, 0x2ae5c0a0, 0xe0433c22, 0x171d121b, 0x0d0b0e09, 0xc7adf28b, 0xa8b92db6, 0xa9c8141e, 0x198557f1, 0x074caf75, 0xddbbee99, 0x60fda37f, 0x269ff701, 0xf5bc5c72, 0x3bc54466, 0x7e345bfb, 0x29768b43, 0xc6dccb23, 0xfc68b6ed, 0xf163b8e4, 0xdccad731, 0x85104263, 0x22401397, 0x112084c6, 0x247d854a, 0x3df8d2bb, 0x3211aef9, 0xa16dc729, 0x2f4b1d9e, 0x30f3dcb2, 0x52ec0d86, 0xe3d077c1, 0x166c2bb3, 0xb999a970, 0x48fa1194, 0x642247e9, 0x8cc4a8fc, 0x3f1aa0f0, 0x2cd8567d, 0x90ef2233, 0x4ec78749, 0xd1c1d938, 0xa2fe8cca, 0x0b3698d4, 0x81cfa6f5, 0xde28a57a, 0x8e26dab7, 0xbfa43fad, 0x9de42c3a, 0x920d5078, 0xcc9b6a5f, 0x4662547e, 0x13c2f68d, 0xb8e890d8, 0xf75e2e39, 0xaff582c3, 0x80be9f5d, 0x937c69d0, 0x2da96fd5, 0x12b3cf25, 0x993bc8ac, 0x7da71018, 0x636ee89c, 0xbb7bdb3b, 0x7809cd26, 0x18f46e59, 0xb701ec9a, 0x9aa8834f, 0x6e65e695, 0xe67eaaff, 0xcf0821bc, 0xe8e6ef15, 0x9bd9bae7, 0x36ce4a6f, 0x09d4ea9f, 0x7cd629b0, 0xb2af31a4, 0x23312a3f, 0x9430c6a5, 0x66c035a2, 0xbc37744e, 0xcaa6fc82, 0xd0b0e090, 0xd81533a7, 0x984af104, 0xdaf741ec, 0x500e7fcd, 0xf62f1791, 0xd68d764d, 0xb04d43ef, 0x4d54ccaa, 0x04dfe496, 0xb5e39ed1, 0x881b4c6a, 0x1fb8c12c, 0x517f4665, 0xea049d5e, 0x355d018c, 0x7473fa87, 0x412efb0b, 0x1d5ab367, 0xd25292db, 0x5633e910, 0x47136dd6, 0x618c9ad7, 0x0c7a37a1, 0x148e59f8, 0x3c89eb13, 0x27eecea9, 0xc935b761, 0xe5ede11c, 0xb13c7a47, 0xdf599cd2, 0x733f55f2, 0xce791814, 0x37bf73c7, 0xcdea53f7, 0xaa5b5ffd, 0x6f14df3d, 0xdb867844, 0xf381caaf, 0xc43eb968, 0x342c3824, 0x405fc2a3, 0xc372161d, 0x250cbce2, 0x498b283c, 0x9541ff0d, 0x017139a8, 0xb3de080c, 0xe49cd8b4, 0xc1906456, 0x84617bcb, 0xb670d532, 0x5c74486c, 0x5742d0b8];
var T8 = [0xf4a75051, 0x4165537e, 0x17a4c31a, 0x275e963a, 0xab6bcb3b, 0x9d45f11f, 0xfa58abac, 0xe303934b, 0x30fa5520, 0x766df6ad, 0xcc769188, 0x024c25f5, 0xe5d7fc4f, 0x2acbd7c5, 0x35448026, 0x62a38fb5, 0xb15a49de, 0xba1b6725, 0xea0e9845, 0xfec0e15d, 0x2f7502c3, 0x4cf01281, 0x4697a38d, 0xd3f9c66b, 0x8f5fe703, 0x929c9515, 0x6d7aebbf, 0x5259da95, 0xbe832dd4, 0x7421d358, 0xe0692949, 0xc9c8448e, 0xc2896a75, 0x8e7978f4, 0x583e6b99, 0xb971dd27, 0xe14fb6be, 0x88ad17f0, 0x20ac66c9, 0xce3ab47d, 0xdf4a1863, 0x1a3182e5, 0x51336097, 0x537f4562, 0x6477e0b1, 0x6bae84bb, 0x81a01cfe, 0x082b94f9, 0x48685870, 0x45fd198f, 0xde6c8794, 0x7bf8b752, 0x73d323ab, 0x4b02e272, 0x1f8f57e3, 0x55ab2a66, 0xeb2807b2, 0xb5c2032f, 0xc57b9a86, 0x3708a5d3, 0x2887f230, 0xbfa5b223, 0x036aba02, 0x16825ced, 0xcf1c2b8a, 0x79b492a7, 0x07f2f0f3, 0x69e2a14e, 0xdaf4cd65, 0x05bed506, 0x34621fd1, 0xa6fe8ac4, 0x2e539d34, 0xf355a0a2, 0x8ae13205, 0xf6eb75a4, 0x83ec390b, 0x60efaa40, 0x719f065e, 0x6e1051bd, 0x218af93e, 0xdd063d96, 0x3e05aedd, 0xe6bd464d, 0x548db591, 0xc45d0571, 0x06d46f04, 0x5015ff60, 0x98fb2419, 0xbde997d6, 0x4043cc89, 0xd99e7767, 0xe842bdb0, 0x898b8807, 0x195b38e7, 0xc8eedb79, 0x7c0a47a1, 0x420fe97c, 0x841ec9f8, 0x00000000, 0x80868309, 0x2bed4832, 0x1170ac1e, 0x5a724e6c, 0x0efffbfd, 0x8538560f, 0xaed51e3d, 0x2d392736, 0x0fd9640a, 0x5ca62168, 0x5b54d19b, 0x362e3a24, 0x0a67b10c, 0x57e70f93, 0xee96d2b4, 0x9b919e1b, 0xc0c54f80, 0xdc20a261, 0x774b695a, 0x121a161c, 0x93ba0ae2, 0xa02ae5c0, 0x22e0433c, 0x1b171d12, 0x090d0b0e, 0x8bc7adf2, 0xb6a8b92d, 0x1ea9c814, 0xf1198557, 0x75074caf, 0x99ddbbee, 0x7f60fda3, 0x01269ff7, 0x72f5bc5c, 0x663bc544, 0xfb7e345b, 0x4329768b, 0x23c6dccb, 0xedfc68b6, 0xe4f163b8, 0x31dccad7, 0x63851042, 0x97224013, 0xc6112084, 0x4a247d85, 0xbb3df8d2, 0xf93211ae, 0x29a16dc7, 0x9e2f4b1d, 0xb230f3dc, 0x8652ec0d, 0xc1e3d077, 0xb3166c2b, 0x70b999a9, 0x9448fa11, 0xe9642247, 0xfc8cc4a8, 0xf03f1aa0, 0x7d2cd856, 0x3390ef22, 0x494ec787, 0x38d1c1d9, 0xcaa2fe8c, 0xd40b3698, 0xf581cfa6, 0x7ade28a5, 0xb78e26da, 0xadbfa43f, 0x3a9de42c, 0x78920d50, 0x5fcc9b6a, 0x7e466254, 0x8d13c2f6, 0xd8b8e890, 0x39f75e2e, 0xc3aff582, 0x5d80be9f, 0xd0937c69, 0xd52da96f, 0x2512b3cf, 0xac993bc8, 0x187da710, 0x9c636ee8, 0x3bbb7bdb, 0x267809cd, 0x5918f46e, 0x9ab701ec, 0x4f9aa883, 0x956e65e6, 0xffe67eaa, 0xbccf0821, 0x15e8e6ef, 0xe79bd9ba, 0x6f36ce4a, 0x9f09d4ea, 0xb07cd629, 0xa4b2af31, 0x3f23312a, 0xa59430c6, 0xa266c035, 0x4ebc3774, 0x82caa6fc, 0x90d0b0e0, 0xa7d81533, 0x04984af1, 0xecdaf741, 0xcd500e7f, 0x91f62f17, 0x4dd68d76, 0xefb04d43, 0xaa4d54cc, 0x9604dfe4, 0xd1b5e39e, 0x6a881b4c, 0x2c1fb8c1, 0x65517f46, 0x5eea049d, 0x8c355d01, 0x877473fa, 0x0b412efb, 0x671d5ab3, 0xdbd25292, 0x105633e9, 0xd647136d, 0xd7618c9a, 0xa10c7a37, 0xf8148e59, 0x133c89eb, 0xa927eece, 0x61c935b7, 0x1ce5ede1, 0x47b13c7a, 0xd2df599c, 0xf2733f55, 0x14ce7918, 0xc737bf73, 0xf7cdea53, 0xfdaa5b5f, 0x3d6f14df, 0x44db8678, 0xaff381ca, 0x68c43eb9, 0x24342c38, 0xa3405fc2, 0x1dc37216, 0xe2250cbc, 0x3c498b28, 0x0d9541ff, 0xa8017139, 0x0cb3de08, 0xb4e49cd8, 0x56c19064, 0xcb84617b, 0x32b670d5, 0x6c5c7448, 0xb85742d0];
// Transformations for decryption key expansion
var U1 = [0x00000000, 0x0e090d0b, 0x1c121a16, 0x121b171d, 0x3824342c, 0x362d3927, 0x24362e3a, 0x2a3f2331, 0x70486858, 0x7e416553, 0x6c5a724e, 0x62537f45, 0x486c5c74, 0x4665517f, 0x547e4662, 0x5a774b69, 0xe090d0b0, 0xee99ddbb, 0xfc82caa6, 0xf28bc7ad, 0xd8b4e49c, 0xd6bde997, 0xc4a6fe8a, 0xcaaff381, 0x90d8b8e8, 0x9ed1b5e3, 0x8ccaa2fe, 0x82c3aff5, 0xa8fc8cc4, 0xa6f581cf, 0xb4ee96d2, 0xbae79bd9, 0xdb3bbb7b, 0xd532b670, 0xc729a16d, 0xc920ac66, 0xe31f8f57, 0xed16825c, 0xff0d9541, 0xf104984a, 0xab73d323, 0xa57ade28, 0xb761c935, 0xb968c43e, 0x9357e70f, 0x9d5eea04, 0x8f45fd19, 0x814cf012, 0x3bab6bcb, 0x35a266c0, 0x27b971dd, 0x29b07cd6, 0x038f5fe7, 0x0d8652ec, 0x1f9d45f1, 0x119448fa, 0x4be30393, 0x45ea0e98, 0x57f11985, 0x59f8148e, 0x73c737bf, 0x7dce3ab4, 0x6fd52da9, 0x61dc20a2, 0xad766df6, 0xa37f60fd, 0xb16477e0, 0xbf6d7aeb, 0x955259da, 0x9b5b54d1, 0x894043cc, 0x87494ec7, 0xdd3e05ae, 0xd33708a5, 0xc12c1fb8, 0xcf2512b3, 0xe51a3182, 0xeb133c89, 0xf9082b94, 0xf701269f, 0x4de6bd46, 0x43efb04d, 0x51f4a750, 0x5ffdaa5b, 0x75c2896a, 0x7bcb8461, 0x69d0937c, 0x67d99e77, 0x3daed51e, 0x33a7d815, 0x21bccf08, 0x2fb5c203, 0x058ae132, 0x0b83ec39, 0x1998fb24, 0x1791f62f, 0x764dd68d, 0x7844db86, 0x6a5fcc9b, 0x6456c190, 0x4e69e2a1, 0x4060efaa, 0x527bf8b7, 0x5c72f5bc, 0x0605bed5, 0x080cb3de, 0x1a17a4c3, 0x141ea9c8, 0x3e218af9, 0x302887f2, 0x223390ef, 0x2c3a9de4, 0x96dd063d, 0x98d40b36, 0x8acf1c2b, 0x84c61120, 0xaef93211, 0xa0f03f1a, 0xb2eb2807, 0xbce2250c, 0xe6956e65, 0xe89c636e, 0xfa877473, 0xf48e7978, 0xdeb15a49, 0xd0b85742, 0xc2a3405f, 0xccaa4d54, 0x41ecdaf7, 0x4fe5d7fc, 0x5dfec0e1, 0x53f7cdea, 0x79c8eedb, 0x77c1e3d0, 0x65daf4cd, 0x6bd3f9c6, 0x31a4b2af, 0x3fadbfa4, 0x2db6a8b9, 0x23bfa5b2, 0x09808683, 0x07898b88, 0x15929c95, 0x1b9b919e, 0xa17c0a47, 0xaf75074c, 0xbd6e1051, 0xb3671d5a, 0x99583e6b, 0x97513360, 0x854a247d, 0x8b432976, 0xd134621f, 0xdf3d6f14, 0xcd267809, 0xc32f7502, 0xe9105633, 0xe7195b38, 0xf5024c25, 0xfb0b412e, 0x9ad7618c, 0x94de6c87, 0x86c57b9a, 0x88cc7691, 0xa2f355a0, 0xacfa58ab, 0xbee14fb6, 0xb0e842bd, 0xea9f09d4, 0xe49604df, 0xf68d13c2, 0xf8841ec9, 0xd2bb3df8, 0xdcb230f3, 0xcea927ee, 0xc0a02ae5, 0x7a47b13c, 0x744ebc37, 0x6655ab2a, 0x685ca621, 0x42638510, 0x4c6a881b, 0x5e719f06, 0x5078920d, 0x0a0fd964, 0x0406d46f, 0x161dc372, 0x1814ce79, 0x322bed48, 0x3c22e043, 0x2e39f75e, 0x2030fa55, 0xec9ab701, 0xe293ba0a, 0xf088ad17, 0xfe81a01c, 0xd4be832d, 0xdab78e26, 0xc8ac993b, 0xc6a59430, 0x9cd2df59, 0x92dbd252, 0x80c0c54f, 0x8ec9c844, 0xa4f6eb75, 0xaaffe67e, 0xb8e4f163, 0xb6edfc68, 0x0c0a67b1, 0x02036aba, 0x10187da7, 0x1e1170ac, 0x342e539d, 0x3a275e96, 0x283c498b, 0x26354480, 0x7c420fe9, 0x724b02e2, 0x605015ff, 0x6e5918f4, 0x44663bc5, 0x4a6f36ce, 0x587421d3, 0x567d2cd8, 0x37a10c7a, 0x39a80171, 0x2bb3166c, 0x25ba1b67, 0x0f853856, 0x018c355d, 0x13972240, 0x1d9e2f4b, 0x47e96422, 0x49e06929, 0x5bfb7e34, 0x55f2733f, 0x7fcd500e, 0x71c45d05, 0x63df4a18, 0x6dd64713, 0xd731dcca, 0xd938d1c1, 0xcb23c6dc, 0xc52acbd7, 0xef15e8e6, 0xe11ce5ed, 0xf307f2f0, 0xfd0efffb, 0xa779b492, 0xa970b999, 0xbb6bae84, 0xb562a38f, 0x9f5d80be, 0x91548db5, 0x834f9aa8, 0x8d4697a3];
var U2 = [0x00000000, 0x0b0e090d, 0x161c121a, 0x1d121b17, 0x2c382434, 0x27362d39, 0x3a24362e, 0x312a3f23, 0x58704868, 0x537e4165, 0x4e6c5a72, 0x4562537f, 0x74486c5c, 0x7f466551, 0x62547e46, 0x695a774b, 0xb0e090d0, 0xbbee99dd, 0xa6fc82ca, 0xadf28bc7, 0x9cd8b4e4, 0x97d6bde9, 0x8ac4a6fe, 0x81caaff3, 0xe890d8b8, 0xe39ed1b5, 0xfe8ccaa2, 0xf582c3af, 0xc4a8fc8c, 0xcfa6f581, 0xd2b4ee96, 0xd9bae79b, 0x7bdb3bbb, 0x70d532b6, 0x6dc729a1, 0x66c920ac, 0x57e31f8f, 0x5ced1682, 0x41ff0d95, 0x4af10498, 0x23ab73d3, 0x28a57ade, 0x35b761c9, 0x3eb968c4, 0x0f9357e7, 0x049d5eea, 0x198f45fd, 0x12814cf0, 0xcb3bab6b, 0xc035a266, 0xdd27b971, 0xd629b07c, 0xe7038f5f, 0xec0d8652, 0xf11f9d45, 0xfa119448, 0x934be303, 0x9845ea0e, 0x8557f119, 0x8e59f814, 0xbf73c737, 0xb47dce3a, 0xa96fd52d, 0xa261dc20, 0xf6ad766d, 0xfda37f60, 0xe0b16477, 0xebbf6d7a, 0xda955259, 0xd19b5b54, 0xcc894043, 0xc787494e, 0xaedd3e05, 0xa5d33708, 0xb8c12c1f, 0xb3cf2512, 0x82e51a31, 0x89eb133c, 0x94f9082b, 0x9ff70126, 0x464de6bd, 0x4d43efb0, 0x5051f4a7, 0x5b5ffdaa, 0x6a75c289, 0x617bcb84, 0x7c69d093, 0x7767d99e, 0x1e3daed5, 0x1533a7d8, 0x0821bccf, 0x032fb5c2, 0x32058ae1, 0x390b83ec, 0x241998fb, 0x2f1791f6, 0x8d764dd6, 0x867844db, 0x9b6a5fcc, 0x906456c1, 0xa14e69e2, 0xaa4060ef, 0xb7527bf8, 0xbc5c72f5, 0xd50605be, 0xde080cb3, 0xc31a17a4, 0xc8141ea9, 0xf93e218a, 0xf2302887, 0xef223390, 0xe42c3a9d, 0x3d96dd06, 0x3698d40b, 0x2b8acf1c, 0x2084c611, 0x11aef932, 0x1aa0f03f, 0x07b2eb28, 0x0cbce225, 0x65e6956e, 0x6ee89c63, 0x73fa8774, 0x78f48e79, 0x49deb15a, 0x42d0b857, 0x5fc2a340, 0x54ccaa4d, 0xf741ecda, 0xfc4fe5d7, 0xe15dfec0, 0xea53f7cd, 0xdb79c8ee, 0xd077c1e3, 0xcd65daf4, 0xc66bd3f9, 0xaf31a4b2, 0xa43fadbf, 0xb92db6a8, 0xb223bfa5, 0x83098086, 0x8807898b, 0x9515929c, 0x9e1b9b91, 0x47a17c0a, 0x4caf7507, 0x51bd6e10, 0x5ab3671d, 0x6b99583e, 0x60975133, 0x7d854a24, 0x768b4329, 0x1fd13462, 0x14df3d6f, 0x09cd2678, 0x02c32f75, 0x33e91056, 0x38e7195b, 0x25f5024c, 0x2efb0b41, 0x8c9ad761, 0x8794de6c, 0x9a86c57b, 0x9188cc76, 0xa0a2f355, 0xabacfa58, 0xb6bee14f, 0xbdb0e842, 0xd4ea9f09, 0xdfe49604, 0xc2f68d13, 0xc9f8841e, 0xf8d2bb3d, 0xf3dcb230, 0xeecea927, 0xe5c0a02a, 0x3c7a47b1, 0x37744ebc, 0x2a6655ab, 0x21685ca6, 0x10426385, 0x1b4c6a88, 0x065e719f, 0x0d507892, 0x640a0fd9, 0x6f0406d4, 0x72161dc3, 0x791814ce, 0x48322bed, 0x433c22e0, 0x5e2e39f7, 0x552030fa, 0x01ec9ab7, 0x0ae293ba, 0x17f088ad, 0x1cfe81a0, 0x2dd4be83, 0x26dab78e, 0x3bc8ac99, 0x30c6a594, 0x599cd2df, 0x5292dbd2, 0x4f80c0c5, 0x448ec9c8, 0x75a4f6eb, 0x7eaaffe6, 0x63b8e4f1, 0x68b6edfc, 0xb10c0a67, 0xba02036a, 0xa710187d, 0xac1e1170, 0x9d342e53, 0x963a275e, 0x8b283c49, 0x80263544, 0xe97c420f, 0xe2724b02, 0xff605015, 0xf46e5918, 0xc544663b, 0xce4a6f36, 0xd3587421, 0xd8567d2c, 0x7a37a10c, 0x7139a801, 0x6c2bb316, 0x6725ba1b, 0x560f8538, 0x5d018c35, 0x40139722, 0x4b1d9e2f, 0x2247e964, 0x2949e069, 0x345bfb7e, 0x3f55f273, 0x0e7fcd50, 0x0571c45d, 0x1863df4a, 0x136dd647, 0xcad731dc, 0xc1d938d1, 0xdccb23c6, 0xd7c52acb, 0xe6ef15e8, 0xede11ce5, 0xf0f307f2, 0xfbfd0eff, 0x92a779b4, 0x99a970b9, 0x84bb6bae, 0x8fb562a3, 0xbe9f5d80, 0xb591548d, 0xa8834f9a, 0xa38d4697];
var U3 = [0x00000000, 0x0d0b0e09, 0x1a161c12, 0x171d121b, 0x342c3824, 0x3927362d, 0x2e3a2436, 0x23312a3f, 0x68587048, 0x65537e41, 0x724e6c5a, 0x7f456253, 0x5c74486c, 0x517f4665, 0x4662547e, 0x4b695a77, 0xd0b0e090, 0xddbbee99, 0xcaa6fc82, 0xc7adf28b, 0xe49cd8b4, 0xe997d6bd, 0xfe8ac4a6, 0xf381caaf, 0xb8e890d8, 0xb5e39ed1, 0xa2fe8cca, 0xaff582c3, 0x8cc4a8fc, 0x81cfa6f5, 0x96d2b4ee, 0x9bd9bae7, 0xbb7bdb3b, 0xb670d532, 0xa16dc729, 0xac66c920, 0x8f57e31f, 0x825ced16, 0x9541ff0d, 0x984af104, 0xd323ab73, 0xde28a57a, 0xc935b761, 0xc43eb968, 0xe70f9357, 0xea049d5e, 0xfd198f45, 0xf012814c, 0x6bcb3bab, 0x66c035a2, 0x71dd27b9, 0x7cd629b0, 0x5fe7038f, 0x52ec0d86, 0x45f11f9d, 0x48fa1194, 0x03934be3, 0x0e9845ea, 0x198557f1, 0x148e59f8, 0x37bf73c7, 0x3ab47dce, 0x2da96fd5, 0x20a261dc, 0x6df6ad76, 0x60fda37f, 0x77e0b164, 0x7aebbf6d, 0x59da9552, 0x54d19b5b, 0x43cc8940, 0x4ec78749, 0x05aedd3e, 0x08a5d337, 0x1fb8c12c, 0x12b3cf25, 0x3182e51a, 0x3c89eb13, 0x2b94f908, 0x269ff701, 0xbd464de6, 0xb04d43ef, 0xa75051f4, 0xaa5b5ffd, 0x896a75c2, 0x84617bcb, 0x937c69d0, 0x9e7767d9, 0xd51e3dae, 0xd81533a7, 0xcf0821bc, 0xc2032fb5, 0xe132058a, 0xec390b83, 0xfb241998, 0xf62f1791, 0xd68d764d, 0xdb867844, 0xcc9b6a5f, 0xc1906456, 0xe2a14e69, 0xefaa4060, 0xf8b7527b, 0xf5bc5c72, 0xbed50605, 0xb3de080c, 0xa4c31a17, 0xa9c8141e, 0x8af93e21, 0x87f23028, 0x90ef2233, 0x9de42c3a, 0x063d96dd, 0x0b3698d4, 0x1c2b8acf, 0x112084c6, 0x3211aef9, 0x3f1aa0f0, 0x2807b2eb, 0x250cbce2, 0x6e65e695, 0x636ee89c, 0x7473fa87, 0x7978f48e, 0x5a49deb1, 0x5742d0b8, 0x405fc2a3, 0x4d54ccaa, 0xdaf741ec, 0xd7fc4fe5, 0xc0e15dfe, 0xcdea53f7, 0xeedb79c8, 0xe3d077c1, 0xf4cd65da, 0xf9c66bd3, 0xb2af31a4, 0xbfa43fad, 0xa8b92db6, 0xa5b223bf, 0x86830980, 0x8b880789, 0x9c951592, 0x919e1b9b, 0x0a47a17c, 0x074caf75, 0x1051bd6e, 0x1d5ab367, 0x3e6b9958, 0x33609751, 0x247d854a, 0x29768b43, 0x621fd134, 0x6f14df3d, 0x7809cd26, 0x7502c32f, 0x5633e910, 0x5b38e719, 0x4c25f502, 0x412efb0b, 0x618c9ad7, 0x6c8794de, 0x7b9a86c5, 0x769188cc, 0x55a0a2f3, 0x58abacfa, 0x4fb6bee1, 0x42bdb0e8, 0x09d4ea9f, 0x04dfe496, 0x13c2f68d, 0x1ec9f884, 0x3df8d2bb, 0x30f3dcb2, 0x27eecea9, 0x2ae5c0a0, 0xb13c7a47, 0xbc37744e, 0xab2a6655, 0xa621685c, 0x85104263, 0x881b4c6a, 0x9f065e71, 0x920d5078, 0xd9640a0f, 0xd46f0406, 0xc372161d, 0xce791814, 0xed48322b, 0xe0433c22, 0xf75e2e39, 0xfa552030, 0xb701ec9a, 0xba0ae293, 0xad17f088, 0xa01cfe81, 0x832dd4be, 0x8e26dab7, 0x993bc8ac, 0x9430c6a5, 0xdf599cd2, 0xd25292db, 0xc54f80c0, 0xc8448ec9, 0xeb75a4f6, 0xe67eaaff, 0xf163b8e4, 0xfc68b6ed, 0x67b10c0a, 0x6aba0203, 0x7da71018, 0x70ac1e11, 0x539d342e, 0x5e963a27, 0x498b283c, 0x44802635, 0x0fe97c42, 0x02e2724b, 0x15ff6050, 0x18f46e59, 0x3bc54466, 0x36ce4a6f, 0x21d35874, 0x2cd8567d, 0x0c7a37a1, 0x017139a8, 0x166c2bb3, 0x1b6725ba, 0x38560f85, 0x355d018c, 0x22401397, 0x2f4b1d9e, 0x642247e9, 0x692949e0, 0x7e345bfb, 0x733f55f2, 0x500e7fcd, 0x5d0571c4, 0x4a1863df, 0x47136dd6, 0xdccad731, 0xd1c1d938, 0xc6dccb23, 0xcbd7c52a, 0xe8e6ef15, 0xe5ede11c, 0xf2f0f307, 0xfffbfd0e, 0xb492a779, 0xb999a970, 0xae84bb6b, 0xa38fb562, 0x80be9f5d, 0x8db59154, 0x9aa8834f, 0x97a38d46];
var U4 = [0x00000000, 0x090d0b0e, 0x121a161c, 0x1b171d12, 0x24342c38, 0x2d392736, 0x362e3a24, 0x3f23312a, 0x48685870, 0x4165537e, 0x5a724e6c, 0x537f4562, 0x6c5c7448, 0x65517f46, 0x7e466254, 0x774b695a, 0x90d0b0e0, 0x99ddbbee, 0x82caa6fc, 0x8bc7adf2, 0xb4e49cd8, 0xbde997d6, 0xa6fe8ac4, 0xaff381ca, 0xd8b8e890, 0xd1b5e39e, 0xcaa2fe8c, 0xc3aff582, 0xfc8cc4a8, 0xf581cfa6, 0xee96d2b4, 0xe79bd9ba, 0x3bbb7bdb, 0x32b670d5, 0x29a16dc7, 0x20ac66c9, 0x1f8f57e3, 0x16825ced, 0x0d9541ff, 0x04984af1, 0x73d323ab, 0x7ade28a5, 0x61c935b7, 0x68c43eb9, 0x57e70f93, 0x5eea049d, 0x45fd198f, 0x4cf01281, 0xab6bcb3b, 0xa266c035, 0xb971dd27, 0xb07cd629, 0x8f5fe703, 0x8652ec0d, 0x9d45f11f, 0x9448fa11, 0xe303934b, 0xea0e9845, 0xf1198557, 0xf8148e59, 0xc737bf73, 0xce3ab47d, 0xd52da96f, 0xdc20a261, 0x766df6ad, 0x7f60fda3, 0x6477e0b1, 0x6d7aebbf, 0x5259da95, 0x5b54d19b, 0x4043cc89, 0x494ec787, 0x3e05aedd, 0x3708a5d3, 0x2c1fb8c1, 0x2512b3cf, 0x1a3182e5, 0x133c89eb, 0x082b94f9, 0x01269ff7, 0xe6bd464d, 0xefb04d43, 0xf4a75051, 0xfdaa5b5f, 0xc2896a75, 0xcb84617b, 0xd0937c69, 0xd99e7767, 0xaed51e3d, 0xa7d81533, 0xbccf0821, 0xb5c2032f, 0x8ae13205, 0x83ec390b, 0x98fb2419, 0x91f62f17, 0x4dd68d76, 0x44db8678, 0x5fcc9b6a, 0x56c19064, 0x69e2a14e, 0x60efaa40, 0x7bf8b752, 0x72f5bc5c, 0x05bed506, 0x0cb3de08, 0x17a4c31a, 0x1ea9c814, 0x218af93e, 0x2887f230, 0x3390ef22, 0x3a9de42c, 0xdd063d96, 0xd40b3698, 0xcf1c2b8a, 0xc6112084, 0xf93211ae, 0xf03f1aa0, 0xeb2807b2, 0xe2250cbc, 0x956e65e6, 0x9c636ee8, 0x877473fa, 0x8e7978f4, 0xb15a49de, 0xb85742d0, 0xa3405fc2, 0xaa4d54cc, 0xecdaf741, 0xe5d7fc4f, 0xfec0e15d, 0xf7cdea53, 0xc8eedb79, 0xc1e3d077, 0xdaf4cd65, 0xd3f9c66b, 0xa4b2af31, 0xadbfa43f, 0xb6a8b92d, 0xbfa5b223, 0x80868309, 0x898b8807, 0x929c9515, 0x9b919e1b, 0x7c0a47a1, 0x75074caf, 0x6e1051bd, 0x671d5ab3, 0x583e6b99, 0x51336097, 0x4a247d85, 0x4329768b, 0x34621fd1, 0x3d6f14df, 0x267809cd, 0x2f7502c3, 0x105633e9, 0x195b38e7, 0x024c25f5, 0x0b412efb, 0xd7618c9a, 0xde6c8794, 0xc57b9a86, 0xcc769188, 0xf355a0a2, 0xfa58abac, 0xe14fb6be, 0xe842bdb0, 0x9f09d4ea, 0x9604dfe4, 0x8d13c2f6, 0x841ec9f8, 0xbb3df8d2, 0xb230f3dc, 0xa927eece, 0xa02ae5c0, 0x47b13c7a, 0x4ebc3774, 0x55ab2a66, 0x5ca62168, 0x63851042, 0x6a881b4c, 0x719f065e, 0x78920d50, 0x0fd9640a, 0x06d46f04, 0x1dc37216, 0x14ce7918, 0x2bed4832, 0x22e0433c, 0x39f75e2e, 0x30fa5520, 0x9ab701ec, 0x93ba0ae2, 0x88ad17f0, 0x81a01cfe, 0xbe832dd4, 0xb78e26da, 0xac993bc8, 0xa59430c6, 0xd2df599c, 0xdbd25292, 0xc0c54f80, 0xc9c8448e, 0xf6eb75a4, 0xffe67eaa, 0xe4f163b8, 0xedfc68b6, 0x0a67b10c, 0x036aba02, 0x187da710, 0x1170ac1e, 0x2e539d34, 0x275e963a, 0x3c498b28, 0x35448026, 0x420fe97c, 0x4b02e272, 0x5015ff60, 0x5918f46e, 0x663bc544, 0x6f36ce4a, 0x7421d358, 0x7d2cd856, 0xa10c7a37, 0xa8017139, 0xb3166c2b, 0xba1b6725, 0x8538560f, 0x8c355d01, 0x97224013, 0x9e2f4b1d, 0xe9642247, 0xe0692949, 0xfb7e345b, 0xf2733f55, 0xcd500e7f, 0xc45d0571, 0xdf4a1863, 0xd647136d, 0x31dccad7, 0x38d1c1d9, 0x23c6dccb, 0x2acbd7c5, 0x15e8e6ef, 0x1ce5ede1, 0x07f2f0f3, 0x0efffbfd, 0x79b492a7, 0x70b999a9, 0x6bae84bb, 0x62a38fb5, 0x5d80be9f, 0x548db591, 0x4f9aa883, 0x4697a38d];
function convertToInt32(bytes) {
  var result = [];
  for (var i = 0; i < bytes.length; i += 4) {
    result.push(bytes[i] << 24 | bytes[i + 1] << 16 | bytes[i + 2] << 8 | bytes[i + 3]);
  }
  return result;
}
var AES = /*#__PURE__*/function () {
  function AES(key) {
    _classCallCheck(this, AES);
    _AES_key.set(this, void 0);
    _AES_Kd.set(this, void 0);
    _AES_Ke.set(this, void 0);
    if (!(this instanceof AES)) {
      throw Error('AES must be instanitated with `new`');
    }
    __classPrivateFieldSet(this, _AES_key, new Uint8Array(key), "f");
    var rounds = numberOfRounds[this.key.length];
    if (rounds == null) {
      throw new TypeError('invalid key size (must be 16, 24 or 32 bytes)');
    }
    // encryption round keys
    __classPrivateFieldSet(this, _AES_Ke, [], "f");
    // decryption round keys
    __classPrivateFieldSet(this, _AES_Kd, [], "f");
    for (var i = 0; i <= rounds; i++) {
      __classPrivateFieldGet(this, _AES_Ke, "f").push([0, 0, 0, 0]);
      __classPrivateFieldGet(this, _AES_Kd, "f").push([0, 0, 0, 0]);
    }
    var roundKeyCount = (rounds + 1) * 4;
    var KC = this.key.length / 4;
    // convert the key into ints
    var tk = convertToInt32(this.key);
    // copy values into round key arrays
    var index;
    for (var _i = 0; _i < KC; _i++) {
      index = _i >> 2;
      __classPrivateFieldGet(this, _AES_Ke, "f")[index][_i % 4] = tk[_i];
      __classPrivateFieldGet(this, _AES_Kd, "f")[rounds - index][_i % 4] = tk[_i];
    }
    // key expansion (fips-197 section 5.2)
    var rconpointer = 0;
    var t = KC,
      tt;
    while (t < roundKeyCount) {
      tt = tk[KC - 1];
      tk[0] ^= S[tt >> 16 & 0xFF] << 24 ^ S[tt >> 8 & 0xFF] << 16 ^ S[tt & 0xFF] << 8 ^ S[tt >> 24 & 0xFF] ^ rcon[rconpointer] << 24;
      rconpointer += 1;
      // key expansion (for non-256 bit)
      if (KC != 8) {
        for (var _i2 = 1; _i2 < KC; _i2++) {
          tk[_i2] ^= tk[_i2 - 1];
        }
        // key expansion for 256-bit keys is "slightly different" (fips-197)
      } else {
        for (var _i3 = 1; _i3 < KC / 2; _i3++) {
          tk[_i3] ^= tk[_i3 - 1];
        }
        tt = tk[KC / 2 - 1];
        tk[KC / 2] ^= S[tt & 0xFF] ^ S[tt >> 8 & 0xFF] << 8 ^ S[tt >> 16 & 0xFF] << 16 ^ S[tt >> 24 & 0xFF] << 24;
        for (var _i4 = KC / 2 + 1; _i4 < KC; _i4++) {
          tk[_i4] ^= tk[_i4 - 1];
        }
      }
      // copy values into round key arrays
      var _i5 = 0,
        r = void 0,
        c = void 0;
      while (_i5 < KC && t < roundKeyCount) {
        r = t >> 2;
        c = t % 4;
        __classPrivateFieldGet(this, _AES_Ke, "f")[r][c] = tk[_i5];
        __classPrivateFieldGet(this, _AES_Kd, "f")[rounds - r][c] = tk[_i5++];
        t++;
      }
    }
    // inverse-cipher-ify the decryption round key (fips-197 section 5.3)
    for (var _r = 1; _r < rounds; _r++) {
      for (var _c = 0; _c < 4; _c++) {
        tt = __classPrivateFieldGet(this, _AES_Kd, "f")[_r][_c];
        __classPrivateFieldGet(this, _AES_Kd, "f")[_r][_c] = U1[tt >> 24 & 0xFF] ^ U2[tt >> 16 & 0xFF] ^ U3[tt >> 8 & 0xFF] ^ U4[tt & 0xFF];
      }
    }
  }
  return _createClass(AES, [{
    key: "key",
    get: function get() {
      return __classPrivateFieldGet(this, _AES_key, "f").slice();
    }
  }, {
    key: "encrypt",
    value: function encrypt(plaintext) {
      if (plaintext.length != 16) {
        throw new TypeError('invalid plaintext size (must be 16 bytes)');
      }
      var rounds = __classPrivateFieldGet(this, _AES_Ke, "f").length - 1;
      var a = [0, 0, 0, 0];
      // convert plaintext to (ints ^ key)
      var t = convertToInt32(plaintext);
      for (var i = 0; i < 4; i++) {
        t[i] ^= __classPrivateFieldGet(this, _AES_Ke, "f")[0][i];
      }
      // apply round transforms
      for (var r = 1; r < rounds; r++) {
        for (var _i6 = 0; _i6 < 4; _i6++) {
          a[_i6] = T1[t[_i6] >> 24 & 0xff] ^ T2[t[(_i6 + 1) % 4] >> 16 & 0xff] ^ T3[t[(_i6 + 2) % 4] >> 8 & 0xff] ^ T4[t[(_i6 + 3) % 4] & 0xff] ^ __classPrivateFieldGet(this, _AES_Ke, "f")[r][_i6];
        }
        t = a.slice();
      }
      // the last round is special
      var result = new Uint8Array(16);
      var tt = 0;
      for (var _i7 = 0; _i7 < 4; _i7++) {
        tt = __classPrivateFieldGet(this, _AES_Ke, "f")[rounds][_i7];
        result[4 * _i7] = (S[t[_i7] >> 24 & 0xff] ^ tt >> 24) & 0xff;
        result[4 * _i7 + 1] = (S[t[(_i7 + 1) % 4] >> 16 & 0xff] ^ tt >> 16) & 0xff;
        result[4 * _i7 + 2] = (S[t[(_i7 + 2) % 4] >> 8 & 0xff] ^ tt >> 8) & 0xff;
        result[4 * _i7 + 3] = (S[t[(_i7 + 3) % 4] & 0xff] ^ tt) & 0xff;
      }
      return result;
    }
  }, {
    key: "decrypt",
    value: function decrypt(ciphertext) {
      if (ciphertext.length != 16) {
        throw new TypeError('invalid ciphertext size (must be 16 bytes)');
      }
      var rounds = __classPrivateFieldGet(this, _AES_Kd, "f").length - 1;
      var a = [0, 0, 0, 0];
      // convert plaintext to (ints ^ key)
      var t = convertToInt32(ciphertext);
      for (var i = 0; i < 4; i++) {
        t[i] ^= __classPrivateFieldGet(this, _AES_Kd, "f")[0][i];
      }
      // apply round transforms
      for (var r = 1; r < rounds; r++) {
        for (var _i8 = 0; _i8 < 4; _i8++) {
          a[_i8] = T5[t[_i8] >> 24 & 0xff] ^ T6[t[(_i8 + 3) % 4] >> 16 & 0xff] ^ T7[t[(_i8 + 2) % 4] >> 8 & 0xff] ^ T8[t[(_i8 + 1) % 4] & 0xff] ^ __classPrivateFieldGet(this, _AES_Kd, "f")[r][_i8];
        }
        t = a.slice();
      }
      // the last round is special
      var result = new Uint8Array(16);
      var tt = 0;
      for (var _i9 = 0; _i9 < 4; _i9++) {
        tt = __classPrivateFieldGet(this, _AES_Kd, "f")[rounds][_i9];
        result[4 * _i9] = (Si[t[_i9] >> 24 & 0xff] ^ tt >> 24) & 0xff;
        result[4 * _i9 + 1] = (Si[t[(_i9 + 3) % 4] >> 16 & 0xff] ^ tt >> 16) & 0xff;
        result[4 * _i9 + 2] = (Si[t[(_i9 + 2) % 4] >> 8 & 0xff] ^ tt >> 8) & 0xff;
        result[4 * _i9 + 3] = (Si[t[(_i9 + 1) % 4] & 0xff] ^ tt) & 0xff;
      }
      return result;
    }
  }]);
}();
exports.AES = AES;
_AES_key = new WeakMap(), _AES_Kd = new WeakMap(), _AES_Ke = new WeakMap();

},{}],75:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pkcs7Strip = exports.pkcs7Pad = exports.OFB = exports.ECB = exports.CTR = exports.CFB = exports.CBC = exports.ModeOfOperation = exports.AES = void 0;
var aes_js_1 = require("./aes.js");
Object.defineProperty(exports, "AES", {
  enumerable: true,
  get: function get() {
    return aes_js_1.AES;
  }
});
var mode_js_1 = require("./mode.js");
Object.defineProperty(exports, "ModeOfOperation", {
  enumerable: true,
  get: function get() {
    return mode_js_1.ModeOfOperation;
  }
});
var mode_cbc_js_1 = require("./mode-cbc.js");
Object.defineProperty(exports, "CBC", {
  enumerable: true,
  get: function get() {
    return mode_cbc_js_1.CBC;
  }
});
var mode_cfb_js_1 = require("./mode-cfb.js");
Object.defineProperty(exports, "CFB", {
  enumerable: true,
  get: function get() {
    return mode_cfb_js_1.CFB;
  }
});
var mode_ctr_js_1 = require("./mode-ctr.js");
Object.defineProperty(exports, "CTR", {
  enumerable: true,
  get: function get() {
    return mode_ctr_js_1.CTR;
  }
});
var mode_ecb_js_1 = require("./mode-ecb.js");
Object.defineProperty(exports, "ECB", {
  enumerable: true,
  get: function get() {
    return mode_ecb_js_1.ECB;
  }
});
var mode_ofb_js_1 = require("./mode-ofb.js");
Object.defineProperty(exports, "OFB", {
  enumerable: true,
  get: function get() {
    return mode_ofb_js_1.OFB;
  }
});
var padding_js_1 = require("./padding.js");
Object.defineProperty(exports, "pkcs7Pad", {
  enumerable: true,
  get: function get() {
    return padding_js_1.pkcs7Pad;
  }
});
Object.defineProperty(exports, "pkcs7Strip", {
  enumerable: true,
  get: function get() {
    return padding_js_1.pkcs7Strip;
  }
});

},{"./aes.js":74,"./mode-cbc.js":76,"./mode-cfb.js":77,"./mode-ctr.js":78,"./mode-ecb.js":79,"./mode-ofb.js":80,"./mode.js":81,"./padding.js":82}],76:[function(require,module,exports){
"use strict";

// Cipher Block Chaining
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
var __classPrivateFieldSet = void 0 && (void 0).__classPrivateFieldSet || function (receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = void 0 && (void 0).__classPrivateFieldGet || function (receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _CBC_iv, _CBC_lastBlock;
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CBC = void 0;
var mode_js_1 = require("./mode.js");
var CBC = /*#__PURE__*/function (_mode_js_1$ModeOfOper) {
  function CBC(key, iv) {
    var _this;
    _classCallCheck(this, CBC);
    _this = _callSuper(this, CBC, ["ECC", key, CBC]);
    _CBC_iv.set(_this, void 0);
    _CBC_lastBlock.set(_this, void 0);
    if (iv) {
      if (iv.length % 16) {
        throw new TypeError("invalid iv size (must be 16 bytes)");
      }
      __classPrivateFieldSet(_this, _CBC_iv, new Uint8Array(iv), "f");
    } else {
      __classPrivateFieldSet(_this, _CBC_iv, new Uint8Array(16), "f");
    }
    __classPrivateFieldSet(_this, _CBC_lastBlock, _this.iv, "f");
    return _this;
  }
  _inherits(CBC, _mode_js_1$ModeOfOper);
  return _createClass(CBC, [{
    key: "iv",
    get: function get() {
      return new Uint8Array(__classPrivateFieldGet(this, _CBC_iv, "f"));
    }
  }, {
    key: "encrypt",
    value: function encrypt(plaintext) {
      if (plaintext.length % 16) {
        throw new TypeError("invalid plaintext size (must be multiple of 16 bytes)");
      }
      var ciphertext = new Uint8Array(plaintext.length);
      for (var i = 0; i < plaintext.length; i += 16) {
        for (var j = 0; j < 16; j++) {
          __classPrivateFieldGet(this, _CBC_lastBlock, "f")[j] ^= plaintext[i + j];
        }
        __classPrivateFieldSet(this, _CBC_lastBlock, this.aes.encrypt(__classPrivateFieldGet(this, _CBC_lastBlock, "f")), "f");
        ciphertext.set(__classPrivateFieldGet(this, _CBC_lastBlock, "f"), i);
      }
      return ciphertext;
    }
  }, {
    key: "decrypt",
    value: function decrypt(ciphertext) {
      if (ciphertext.length % 16) {
        throw new TypeError("invalid ciphertext size (must be multiple of 16 bytes)");
      }
      var plaintext = new Uint8Array(ciphertext.length);
      for (var i = 0; i < ciphertext.length; i += 16) {
        var block = this.aes.decrypt(ciphertext.subarray(i, i + 16));
        for (var j = 0; j < 16; j++) {
          plaintext[i + j] = block[j] ^ __classPrivateFieldGet(this, _CBC_lastBlock, "f")[j];
          __classPrivateFieldGet(this, _CBC_lastBlock, "f")[j] = ciphertext[i + j];
        }
      }
      return plaintext;
    }
  }]);
}(mode_js_1.ModeOfOperation);
exports.CBC = CBC;
_CBC_iv = new WeakMap(), _CBC_lastBlock = new WeakMap();

},{"./mode.js":81}],77:[function(require,module,exports){
"use strict";

// Cipher Feedback
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
var __classPrivateFieldSet = void 0 && (void 0).__classPrivateFieldSet || function (receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = void 0 && (void 0).__classPrivateFieldGet || function (receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _CFB_instances, _CFB_iv, _CFB_shiftRegister, _CFB_shift;
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CFB = void 0;
var mode_js_1 = require("./mode.js");
var CFB = /*#__PURE__*/function (_mode_js_1$ModeOfOper) {
  function CFB(key, iv) {
    var _this;
    var segmentSize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 8;
    _classCallCheck(this, CFB);
    _this = _callSuper(this, CFB, ["CFB", key, CFB]);
    _CFB_instances.add(_this);
    _CFB_iv.set(_this, void 0);
    _CFB_shiftRegister.set(_this, void 0);
    // This library currently only handles byte-aligned segmentSize
    if (!Number.isInteger(segmentSize) || segmentSize % 8) {
      throw new TypeError("invalid segmentSize");
    }
    Object.defineProperties(_this, {
      segmentSize: {
        enumerable: true,
        value: segmentSize
      }
    });
    if (iv) {
      if (iv.length % 16) {
        throw new TypeError("invalid iv size (must be 16 bytes)");
      }
      __classPrivateFieldSet(_this, _CFB_iv, new Uint8Array(iv), "f");
    } else {
      __classPrivateFieldSet(_this, _CFB_iv, new Uint8Array(16), "f");
    }
    __classPrivateFieldSet(_this, _CFB_shiftRegister, _this.iv, "f");
    return _this;
  }
  _inherits(CFB, _mode_js_1$ModeOfOper);
  return _createClass(CFB, [{
    key: "iv",
    get: function get() {
      return new Uint8Array(__classPrivateFieldGet(this, _CFB_iv, "f"));
    }
  }, {
    key: "encrypt",
    value: function encrypt(plaintext) {
      if (8 * plaintext.length % this.segmentSize) {
        throw new TypeError("invalid plaintext size (must be multiple of segmentSize bytes)");
      }
      var segmentSize = this.segmentSize / 8;
      var ciphertext = new Uint8Array(plaintext);
      for (var i = 0; i < ciphertext.length; i += segmentSize) {
        var xorSegment = this.aes.encrypt(__classPrivateFieldGet(this, _CFB_shiftRegister, "f"));
        for (var j = 0; j < segmentSize; j++) {
          ciphertext[i + j] ^= xorSegment[j];
        }
        __classPrivateFieldGet(this, _CFB_instances, "m", _CFB_shift).call(this, ciphertext.subarray(i));
      }
      return ciphertext;
    }
  }, {
    key: "decrypt",
    value: function decrypt(ciphertext) {
      if (8 * ciphertext.length % this.segmentSize) {
        throw new TypeError("invalid ciphertext size (must be multiple of segmentSize bytes)");
      }
      var segmentSize = this.segmentSize / 8;
      var plaintext = new Uint8Array(ciphertext);
      for (var i = 0; i < plaintext.length; i += segmentSize) {
        var xorSegment = this.aes.encrypt(__classPrivateFieldGet(this, _CFB_shiftRegister, "f"));
        for (var j = 0; j < segmentSize; j++) {
          plaintext[i + j] ^= xorSegment[j];
        }
        __classPrivateFieldGet(this, _CFB_instances, "m", _CFB_shift).call(this, ciphertext.subarray(i));
      }
      return plaintext;
    }
  }]);
}(mode_js_1.ModeOfOperation);
exports.CFB = CFB;
_CFB_iv = new WeakMap(), _CFB_shiftRegister = new WeakMap(), _CFB_instances = new WeakSet(), _CFB_shift = function _CFB_shift(data) {
  var segmentSize = this.segmentSize / 8;
  // Shift the register
  __classPrivateFieldGet(this, _CFB_shiftRegister, "f").set(__classPrivateFieldGet(this, _CFB_shiftRegister, "f").subarray(segmentSize));
  __classPrivateFieldGet(this, _CFB_shiftRegister, "f").set(data.subarray(0, segmentSize), 16 - segmentSize);
};

},{"./mode.js":81}],78:[function(require,module,exports){
"use strict";

// Counter Mode
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
var __classPrivateFieldSet = void 0 && (void 0).__classPrivateFieldSet || function (receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = void 0 && (void 0).__classPrivateFieldGet || function (receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _CTR_remaining, _CTR_remainingIndex, _CTR_counter;
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CTR = void 0;
var mode_js_1 = require("./mode.js");
var CTR = /*#__PURE__*/function (_mode_js_1$ModeOfOper) {
  function CTR(key, initialValue) {
    var _this;
    _classCallCheck(this, CTR);
    _this = _callSuper(this, CTR, ["CTR", key, CTR]);
    // Remaining bytes for the one-time pad
    _CTR_remaining.set(_this, void 0);
    _CTR_remainingIndex.set(_this, void 0);
    // The current counter
    _CTR_counter.set(_this, void 0);
    __classPrivateFieldSet(_this, _CTR_counter, new Uint8Array(16), "f");
    __classPrivateFieldGet(_this, _CTR_counter, "f").fill(0);
    __classPrivateFieldSet(_this, _CTR_remaining, __classPrivateFieldGet(_this, _CTR_counter, "f"), "f"); // This will be discarded immediately
    __classPrivateFieldSet(_this, _CTR_remainingIndex, 16, "f");
    if (initialValue == null) {
      initialValue = 1;
    }
    if (typeof initialValue === "number") {
      _this.setCounterValue(initialValue);
    } else {
      _this.setCounterBytes(initialValue);
    }
    return _this;
  }
  _inherits(CTR, _mode_js_1$ModeOfOper);
  return _createClass(CTR, [{
    key: "counter",
    get: function get() {
      return new Uint8Array(__classPrivateFieldGet(this, _CTR_counter, "f"));
    }
  }, {
    key: "setCounterValue",
    value: function setCounterValue(value) {
      if (!Number.isInteger(value) || value < 0 || value > Number.MAX_SAFE_INTEGER) {
        throw new TypeError("invalid counter initial integer value");
      }
      for (var index = 15; index >= 0; --index) {
        __classPrivateFieldGet(this, _CTR_counter, "f")[index] = value % 256;
        value = Math.floor(value / 256);
      }
    }
  }, {
    key: "setCounterBytes",
    value: function setCounterBytes(value) {
      if (value.length !== 16) {
        throw new TypeError("invalid counter initial Uint8Array value length");
      }
      __classPrivateFieldGet(this, _CTR_counter, "f").set(value);
    }
  }, {
    key: "increment",
    value: function increment() {
      for (var i = 15; i >= 0; i--) {
        if (__classPrivateFieldGet(this, _CTR_counter, "f")[i] === 255) {
          __classPrivateFieldGet(this, _CTR_counter, "f")[i] = 0;
        } else {
          __classPrivateFieldGet(this, _CTR_counter, "f")[i]++;
          break;
        }
      }
    }
  }, {
    key: "encrypt",
    value: function encrypt(plaintext) {
      var _a, _b;
      var crypttext = new Uint8Array(plaintext);
      for (var i = 0; i < crypttext.length; i++) {
        if (__classPrivateFieldGet(this, _CTR_remainingIndex, "f") === 16) {
          __classPrivateFieldSet(this, _CTR_remaining, this.aes.encrypt(__classPrivateFieldGet(this, _CTR_counter, "f")), "f");
          __classPrivateFieldSet(this, _CTR_remainingIndex, 0, "f");
          this.increment();
        }
        crypttext[i] ^= __classPrivateFieldGet(this, _CTR_remaining, "f")[(__classPrivateFieldSet(this, _CTR_remainingIndex, (_b = __classPrivateFieldGet(this, _CTR_remainingIndex, "f"), _a = _b++, _b), "f"), _a)];
      }
      return crypttext;
    }
  }, {
    key: "decrypt",
    value: function decrypt(ciphertext) {
      return this.encrypt(ciphertext);
    }
  }]);
}(mode_js_1.ModeOfOperation);
exports.CTR = CTR;
_CTR_remaining = new WeakMap(), _CTR_remainingIndex = new WeakMap(), _CTR_counter = new WeakMap();

},{"./mode.js":81}],79:[function(require,module,exports){
"use strict";

// Electronic Code Book
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ECB = void 0;
var mode_js_1 = require("./mode.js");
var ECB = /*#__PURE__*/function (_mode_js_1$ModeOfOper) {
  function ECB(key) {
    _classCallCheck(this, ECB);
    return _callSuper(this, ECB, ["ECB", key, ECB]);
  }
  _inherits(ECB, _mode_js_1$ModeOfOper);
  return _createClass(ECB, [{
    key: "encrypt",
    value: function encrypt(plaintext) {
      if (plaintext.length % 16) {
        throw new TypeError("invalid plaintext size (must be multiple of 16 bytes)");
      }
      var crypttext = new Uint8Array(plaintext.length);
      for (var i = 0; i < plaintext.length; i += 16) {
        crypttext.set(this.aes.encrypt(plaintext.subarray(i, i + 16)), i);
      }
      return crypttext;
    }
  }, {
    key: "decrypt",
    value: function decrypt(crypttext) {
      if (crypttext.length % 16) {
        throw new TypeError("invalid ciphertext size (must be multiple of 16 bytes)");
      }
      var plaintext = new Uint8Array(crypttext.length);
      for (var i = 0; i < crypttext.length; i += 16) {
        plaintext.set(this.aes.decrypt(crypttext.subarray(i, i + 16)), i);
      }
      return plaintext;
    }
  }]);
}(mode_js_1.ModeOfOperation);
exports.ECB = ECB;

},{"./mode.js":81}],80:[function(require,module,exports){
"use strict";

// Output Feedback
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
var __classPrivateFieldSet = void 0 && (void 0).__classPrivateFieldSet || function (receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = void 0 && (void 0).__classPrivateFieldGet || function (receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _OFB_iv, _OFB_lastPrecipher, _OFB_lastPrecipherIndex;
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OFB = void 0;
var mode_js_1 = require("./mode.js");
var OFB = /*#__PURE__*/function (_mode_js_1$ModeOfOper) {
  function OFB(key, iv) {
    var _this;
    _classCallCheck(this, OFB);
    _this = _callSuper(this, OFB, ["OFB", key, OFB]);
    _OFB_iv.set(_this, void 0);
    _OFB_lastPrecipher.set(_this, void 0);
    _OFB_lastPrecipherIndex.set(_this, void 0);
    if (iv) {
      if (iv.length % 16) {
        throw new TypeError("invalid iv size (must be 16 bytes)");
      }
      __classPrivateFieldSet(_this, _OFB_iv, new Uint8Array(iv), "f");
    } else {
      __classPrivateFieldSet(_this, _OFB_iv, new Uint8Array(16), "f");
    }
    __classPrivateFieldSet(_this, _OFB_lastPrecipher, _this.iv, "f");
    __classPrivateFieldSet(_this, _OFB_lastPrecipherIndex, 16, "f");
    return _this;
  }
  _inherits(OFB, _mode_js_1$ModeOfOper);
  return _createClass(OFB, [{
    key: "iv",
    get: function get() {
      return new Uint8Array(__classPrivateFieldGet(this, _OFB_iv, "f"));
    }
  }, {
    key: "encrypt",
    value: function encrypt(plaintext) {
      var _a, _b;
      if (plaintext.length % 16) {
        throw new TypeError("invalid plaintext size (must be multiple of 16 bytes)");
      }
      var ciphertext = new Uint8Array(plaintext);
      for (var i = 0; i < ciphertext.length; i++) {
        if (__classPrivateFieldGet(this, _OFB_lastPrecipherIndex, "f") === 16) {
          __classPrivateFieldSet(this, _OFB_lastPrecipher, this.aes.encrypt(__classPrivateFieldGet(this, _OFB_lastPrecipher, "f")), "f");
          __classPrivateFieldSet(this, _OFB_lastPrecipherIndex, 0, "f");
        }
        ciphertext[i] ^= __classPrivateFieldGet(this, _OFB_lastPrecipher, "f")[(__classPrivateFieldSet(this, _OFB_lastPrecipherIndex, (_b = __classPrivateFieldGet(this, _OFB_lastPrecipherIndex, "f"), _a = _b++, _b), "f"), _a)];
      }
      return ciphertext;
    }
  }, {
    key: "decrypt",
    value: function decrypt(ciphertext) {
      if (ciphertext.length % 16) {
        throw new TypeError("invalid ciphertext size (must be multiple of 16 bytes)");
      }
      return this.encrypt(ciphertext);
    }
  }]);
}(mode_js_1.ModeOfOperation);
exports.OFB = OFB;
_OFB_iv = new WeakMap(), _OFB_lastPrecipher = new WeakMap(), _OFB_lastPrecipherIndex = new WeakMap();

},{"./mode.js":81}],81:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ModeOfOperation = void 0;
var aes_js_1 = require("./aes.js");
var ModeOfOperation = /*#__PURE__*/_createClass(function ModeOfOperation(name, key, cls) {
  _classCallCheck(this, ModeOfOperation);
  if (cls && !(this instanceof cls)) {
    throw new Error("".concat(name, " must be instantiated with \"new\""));
  }
  Object.defineProperties(this, {
    aes: {
      enumerable: true,
      value: new aes_js_1.AES(key)
    },
    name: {
      enumerable: true,
      value: name
    }
  });
});
exports.ModeOfOperation = ModeOfOperation;

},{"./aes.js":74}],82:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pkcs7Strip = exports.pkcs7Pad = void 0;
function pkcs7Pad(data) {
  var padder = 16 - data.length % 16;
  var result = new Uint8Array(data.length + padder);
  result.set(data);
  for (var i = data.length; i < result.length; i++) {
    result[i] = padder;
  }
  return result;
}
exports.pkcs7Pad = pkcs7Pad;
function pkcs7Strip(data) {
  if (data.length < 16) {
    throw new TypeError('PKCS#7 invalid length');
  }
  var padder = data[data.length - 1];
  if (padder > 16) {
    throw new TypeError('PKCS#7 padding byte out of range');
  }
  var length = data.length - padder;
  for (var i = 0; i < padder; i++) {
    if (data[length + i] !== padder) {
      throw new TypeError('PKCS#7 invalid padding byte');
    }
  }
  return new Uint8Array(data.subarray(0, length));
}
exports.pkcs7Strip = pkcs7Strip;

},{}],83:[function(require,module,exports){
"use strict";

var asn1 = exports;
asn1.bignum = require('bn.js');
asn1.define = require('./asn1/api').define;
asn1.base = require('./asn1/base');
asn1.constants = require('./asn1/constants');
asn1.decoders = require('./asn1/decoders');
asn1.encoders = require('./asn1/encoders');

},{"./asn1/api":84,"./asn1/base":86,"./asn1/constants":90,"./asn1/decoders":92,"./asn1/encoders":95,"bn.js":103}],84:[function(require,module,exports){
"use strict";

var asn1 = require('../asn1');
var inherits = require('inherits');
var api = exports;
api.define = function define(name, body) {
  return new Entity(name, body);
};
function Entity(name, body) {
  this.name = name;
  this.body = body;
  this.decoders = {};
  this.encoders = {};
}
;
Entity.prototype._createNamed = function createNamed(base) {
  var named;
  try {
    named = require('vm').runInThisContext('(function ' + this.name + '(entity) {\n' + '  this._initNamed(entity);\n' + '})');
  } catch (e) {
    named = function named(entity) {
      this._initNamed(entity);
    };
  }
  inherits(named, base);
  named.prototype._initNamed = function initnamed(entity) {
    base.call(this, entity);
  };
  return new named(this);
};
Entity.prototype._getDecoder = function _getDecoder(enc) {
  enc = enc || 'der';
  // Lazily create decoder
  if (!this.decoders.hasOwnProperty(enc)) this.decoders[enc] = this._createNamed(asn1.decoders[enc]);
  return this.decoders[enc];
};
Entity.prototype.decode = function decode(data, enc, options) {
  return this._getDecoder(enc).decode(data, options);
};
Entity.prototype._getEncoder = function _getEncoder(enc) {
  enc = enc || 'der';
  // Lazily create encoder
  if (!this.encoders.hasOwnProperty(enc)) this.encoders[enc] = this._createNamed(asn1.encoders[enc]);
  return this.encoders[enc];
};
Entity.prototype.encode = function encode(data, enc, /* internal */reporter) {
  return this._getEncoder(enc).encode(data, reporter);
};

},{"../asn1":83,"inherits":327,"vm":530}],85:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var inherits = require('inherits');
var Reporter = require('../base').Reporter;
var Buffer = require('buffer').Buffer;
function DecoderBuffer(base, options) {
  Reporter.call(this, options);
  if (!Buffer.isBuffer(base)) {
    this.error('Input not Buffer');
    return;
  }
  this.base = base;
  this.offset = 0;
  this.length = base.length;
}
inherits(DecoderBuffer, Reporter);
exports.DecoderBuffer = DecoderBuffer;
DecoderBuffer.prototype.save = function save() {
  return {
    offset: this.offset,
    reporter: Reporter.prototype.save.call(this)
  };
};
DecoderBuffer.prototype.restore = function restore(save) {
  // Return skipped data
  var res = new DecoderBuffer(this.base);
  res.offset = save.offset;
  res.length = this.offset;
  this.offset = save.offset;
  Reporter.prototype.restore.call(this, save.reporter);
  return res;
};
DecoderBuffer.prototype.isEmpty = function isEmpty() {
  return this.offset === this.length;
};
DecoderBuffer.prototype.readUInt8 = function readUInt8(fail) {
  if (this.offset + 1 <= this.length) return this.base.readUInt8(this.offset++, true);else return this.error(fail || 'DecoderBuffer overrun');
};
DecoderBuffer.prototype.skip = function skip(bytes, fail) {
  if (!(this.offset + bytes <= this.length)) return this.error(fail || 'DecoderBuffer overrun');
  var res = new DecoderBuffer(this.base);

  // Share reporter state
  res._reporterState = this._reporterState;
  res.offset = this.offset;
  res.length = this.offset + bytes;
  this.offset += bytes;
  return res;
};
DecoderBuffer.prototype.raw = function raw(save) {
  return this.base.slice(save ? save.offset : this.offset, this.length);
};
function EncoderBuffer(value, reporter) {
  if (Array.isArray(value)) {
    this.length = 0;
    this.value = value.map(function (item) {
      if (!(item instanceof EncoderBuffer)) item = new EncoderBuffer(item, reporter);
      this.length += item.length;
      return item;
    }, this);
  } else if (typeof value === 'number') {
    if (!(0 <= value && value <= 0xff)) return reporter.error('non-byte EncoderBuffer value');
    this.value = value;
    this.length = 1;
  } else if (typeof value === 'string') {
    this.value = value;
    this.length = Buffer.byteLength(value);
  } else if (Buffer.isBuffer(value)) {
    this.value = value;
    this.length = value.length;
  } else {
    return reporter.error('Unsupported type: ' + _typeof(value));
  }
}
exports.EncoderBuffer = EncoderBuffer;
EncoderBuffer.prototype.join = function join(out, offset) {
  if (!out) out = new Buffer(this.length);
  if (!offset) offset = 0;
  if (this.length === 0) return out;
  if (Array.isArray(this.value)) {
    this.value.forEach(function (item) {
      item.join(out, offset);
      offset += item.length;
    });
  } else {
    if (typeof this.value === 'number') out[offset] = this.value;else if (typeof this.value === 'string') out.write(this.value, offset);else if (Buffer.isBuffer(this.value)) this.value.copy(out, offset);
    offset += this.length;
  }
  return out;
};

},{"../base":86,"buffer":139,"inherits":327}],86:[function(require,module,exports){
"use strict";

var base = exports;
base.Reporter = require('./reporter').Reporter;
base.DecoderBuffer = require('./buffer').DecoderBuffer;
base.EncoderBuffer = require('./buffer').EncoderBuffer;
base.Node = require('./node');

},{"./buffer":85,"./node":87,"./reporter":88}],87:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var Reporter = require('../base').Reporter;
var EncoderBuffer = require('../base').EncoderBuffer;
var DecoderBuffer = require('../base').DecoderBuffer;
var assert = require('minimalistic-assert');

// Supported tags
var tags = ['seq', 'seqof', 'set', 'setof', 'objid', 'bool', 'gentime', 'utctime', 'null_', 'enum', 'int', 'objDesc', 'bitstr', 'bmpstr', 'charstr', 'genstr', 'graphstr', 'ia5str', 'iso646str', 'numstr', 'octstr', 'printstr', 't61str', 'unistr', 'utf8str', 'videostr'];

// Public methods list
var methods = ['key', 'obj', 'use', 'optional', 'explicit', 'implicit', 'def', 'choice', 'any', 'contains'].concat(tags);

// Overrided methods list
var overrided = ['_peekTag', '_decodeTag', '_use', '_decodeStr', '_decodeObjid', '_decodeTime', '_decodeNull', '_decodeInt', '_decodeBool', '_decodeList', '_encodeComposite', '_encodeStr', '_encodeObjid', '_encodeTime', '_encodeNull', '_encodeInt', '_encodeBool'];
function Node(enc, parent) {
  var state = {};
  this._baseState = state;
  state.enc = enc;
  state.parent = parent || null;
  state.children = null;

  // State
  state.tag = null;
  state.args = null;
  state.reverseArgs = null;
  state.choice = null;
  state.optional = false;
  state.any = false;
  state.obj = false;
  state.use = null;
  state.useDecoder = null;
  state.key = null;
  state['default'] = null;
  state.explicit = null;
  state.implicit = null;
  state.contains = null;

  // Should create new instance on each method
  if (!state.parent) {
    state.children = [];
    this._wrap();
  }
}
module.exports = Node;
var stateProps = ['enc', 'parent', 'children', 'tag', 'args', 'reverseArgs', 'choice', 'optional', 'any', 'obj', 'use', 'alteredUse', 'key', 'default', 'explicit', 'implicit', 'contains'];
Node.prototype.clone = function clone() {
  var state = this._baseState;
  var cstate = {};
  stateProps.forEach(function (prop) {
    cstate[prop] = state[prop];
  });
  var res = new this.constructor(cstate.parent);
  res._baseState = cstate;
  return res;
};
Node.prototype._wrap = function wrap() {
  var state = this._baseState;
  methods.forEach(function (method) {
    this[method] = function _wrappedMethod() {
      var clone = new this.constructor(this);
      state.children.push(clone);
      return clone[method].apply(clone, arguments);
    };
  }, this);
};
Node.prototype._init = function init(body) {
  var state = this._baseState;
  assert(state.parent === null);
  body.call(this);

  // Filter children
  state.children = state.children.filter(function (child) {
    return child._baseState.parent === this;
  }, this);
  assert.equal(state.children.length, 1, 'Root node can have only one child');
};
Node.prototype._useArgs = function useArgs(args) {
  var state = this._baseState;

  // Filter children and args
  var children = args.filter(function (arg) {
    return arg instanceof this.constructor;
  }, this);
  args = args.filter(function (arg) {
    return !(arg instanceof this.constructor);
  }, this);
  if (children.length !== 0) {
    assert(state.children === null);
    state.children = children;

    // Replace parent to maintain backward link
    children.forEach(function (child) {
      child._baseState.parent = this;
    }, this);
  }
  if (args.length !== 0) {
    assert(state.args === null);
    state.args = args;
    state.reverseArgs = args.map(function (arg) {
      if (_typeof(arg) !== 'object' || arg.constructor !== Object) return arg;
      var res = {};
      Object.keys(arg).forEach(function (key) {
        if (key == (key | 0)) key |= 0;
        var value = arg[key];
        res[value] = key;
      });
      return res;
    });
  }
};

//
// Overrided methods
//

overrided.forEach(function (method) {
  Node.prototype[method] = function _overrided() {
    var state = this._baseState;
    throw new Error(method + ' not implemented for encoding: ' + state.enc);
  };
});

//
// Public methods
//

tags.forEach(function (tag) {
  Node.prototype[tag] = function _tagMethod() {
    var state = this._baseState;
    var args = Array.prototype.slice.call(arguments);
    assert(state.tag === null);
    state.tag = tag;
    this._useArgs(args);
    return this;
  };
});
Node.prototype.use = function use(item) {
  assert(item);
  var state = this._baseState;
  assert(state.use === null);
  state.use = item;
  return this;
};
Node.prototype.optional = function optional() {
  var state = this._baseState;
  state.optional = true;
  return this;
};
Node.prototype.def = function def(val) {
  var state = this._baseState;
  assert(state['default'] === null);
  state['default'] = val;
  state.optional = true;
  return this;
};
Node.prototype.explicit = function explicit(num) {
  var state = this._baseState;
  assert(state.explicit === null && state.implicit === null);
  state.explicit = num;
  return this;
};
Node.prototype.implicit = function implicit(num) {
  var state = this._baseState;
  assert(state.explicit === null && state.implicit === null);
  state.implicit = num;
  return this;
};
Node.prototype.obj = function obj() {
  var state = this._baseState;
  var args = Array.prototype.slice.call(arguments);
  state.obj = true;
  if (args.length !== 0) this._useArgs(args);
  return this;
};
Node.prototype.key = function key(newKey) {
  var state = this._baseState;
  assert(state.key === null);
  state.key = newKey;
  return this;
};
Node.prototype.any = function any() {
  var state = this._baseState;
  state.any = true;
  return this;
};
Node.prototype.choice = function choice(obj) {
  var state = this._baseState;
  assert(state.choice === null);
  state.choice = obj;
  this._useArgs(Object.keys(obj).map(function (key) {
    return obj[key];
  }));
  return this;
};
Node.prototype.contains = function contains(item) {
  var state = this._baseState;
  assert(state.use === null);
  state.contains = item;
  return this;
};

//
// Decoding
//

Node.prototype._decode = function decode(input, options) {
  var state = this._baseState;

  // Decode root node
  if (state.parent === null) return input.wrapResult(state.children[0]._decode(input, options));
  var result = state['default'];
  var present = true;
  var prevKey = null;
  if (state.key !== null) prevKey = input.enterKey(state.key);

  // Check if tag is there
  if (state.optional) {
    var tag = null;
    if (state.explicit !== null) tag = state.explicit;else if (state.implicit !== null) tag = state.implicit;else if (state.tag !== null) tag = state.tag;
    if (tag === null && !state.any) {
      // Trial and Error
      var save = input.save();
      try {
        if (state.choice === null) this._decodeGeneric(state.tag, input, options);else this._decodeChoice(input, options);
        present = true;
      } catch (e) {
        present = false;
      }
      input.restore(save);
    } else {
      present = this._peekTag(input, tag, state.any);
      if (input.isError(present)) return present;
    }
  }

  // Push object on stack
  var prevObj;
  if (state.obj && present) prevObj = input.enterObject();
  if (present) {
    // Unwrap explicit values
    if (state.explicit !== null) {
      var explicit = this._decodeTag(input, state.explicit);
      if (input.isError(explicit)) return explicit;
      input = explicit;
    }
    var start = input.offset;

    // Unwrap implicit and normal values
    if (state.use === null && state.choice === null) {
      if (state.any) var save = input.save();
      var body = this._decodeTag(input, state.implicit !== null ? state.implicit : state.tag, state.any);
      if (input.isError(body)) return body;
      if (state.any) result = input.raw(save);else input = body;
    }
    if (options && options.track && state.tag !== null) options.track(input.path(), start, input.length, 'tagged');
    if (options && options.track && state.tag !== null) options.track(input.path(), input.offset, input.length, 'content');

    // Select proper method for tag
    if (state.any) result = result;else if (state.choice === null) result = this._decodeGeneric(state.tag, input, options);else result = this._decodeChoice(input, options);
    if (input.isError(result)) return result;

    // Decode children
    if (!state.any && state.choice === null && state.children !== null) {
      state.children.forEach(function decodeChildren(child) {
        // NOTE: We are ignoring errors here, to let parser continue with other
        // parts of encoded data
        child._decode(input, options);
      });
    }

    // Decode contained/encoded by schema, only in bit or octet strings
    if (state.contains && (state.tag === 'octstr' || state.tag === 'bitstr')) {
      var data = new DecoderBuffer(result);
      result = this._getUse(state.contains, input._reporterState.obj)._decode(data, options);
    }
  }

  // Pop object
  if (state.obj && present) result = input.leaveObject(prevObj);

  // Set key
  if (state.key !== null && (result !== null || present === true)) input.leaveKey(prevKey, state.key, result);else if (prevKey !== null) input.exitKey(prevKey);
  return result;
};
Node.prototype._decodeGeneric = function decodeGeneric(tag, input, options) {
  var state = this._baseState;
  if (tag === 'seq' || tag === 'set') return null;
  if (tag === 'seqof' || tag === 'setof') return this._decodeList(input, tag, state.args[0], options);else if (/str$/.test(tag)) return this._decodeStr(input, tag, options);else if (tag === 'objid' && state.args) return this._decodeObjid(input, state.args[0], state.args[1], options);else if (tag === 'objid') return this._decodeObjid(input, null, null, options);else if (tag === 'gentime' || tag === 'utctime') return this._decodeTime(input, tag, options);else if (tag === 'null_') return this._decodeNull(input, options);else if (tag === 'bool') return this._decodeBool(input, options);else if (tag === 'objDesc') return this._decodeStr(input, tag, options);else if (tag === 'int' || tag === 'enum') return this._decodeInt(input, state.args && state.args[0], options);
  if (state.use !== null) {
    return this._getUse(state.use, input._reporterState.obj)._decode(input, options);
  } else {
    return input.error('unknown tag: ' + tag);
  }
};
Node.prototype._getUse = function _getUse(entity, obj) {
  var state = this._baseState;
  // Create altered use decoder if implicit is set
  state.useDecoder = this._use(entity, obj);
  assert(state.useDecoder._baseState.parent === null);
  state.useDecoder = state.useDecoder._baseState.children[0];
  if (state.implicit !== state.useDecoder._baseState.implicit) {
    state.useDecoder = state.useDecoder.clone();
    state.useDecoder._baseState.implicit = state.implicit;
  }
  return state.useDecoder;
};
Node.prototype._decodeChoice = function decodeChoice(input, options) {
  var state = this._baseState;
  var result = null;
  var match = false;
  Object.keys(state.choice).some(function (key) {
    var save = input.save();
    var node = state.choice[key];
    try {
      var value = node._decode(input, options);
      if (input.isError(value)) return false;
      result = {
        type: key,
        value: value
      };
      match = true;
    } catch (e) {
      input.restore(save);
      return false;
    }
    return true;
  }, this);
  if (!match) return input.error('Choice not matched');
  return result;
};

//
// Encoding
//

Node.prototype._createEncoderBuffer = function createEncoderBuffer(data) {
  return new EncoderBuffer(data, this.reporter);
};
Node.prototype._encode = function encode(data, reporter, parent) {
  var state = this._baseState;
  if (state['default'] !== null && state['default'] === data) return;
  var result = this._encodeValue(data, reporter, parent);
  if (result === undefined) return;
  if (this._skipDefault(result, reporter, parent)) return;
  return result;
};
Node.prototype._encodeValue = function encode(data, reporter, parent) {
  var state = this._baseState;

  // Decode root node
  if (state.parent === null) return state.children[0]._encode(data, reporter || new Reporter());
  var result = null;

  // Set reporter to share it with a child class
  this.reporter = reporter;

  // Check if data is there
  if (state.optional && data === undefined) {
    if (state['default'] !== null) data = state['default'];else return;
  }

  // Encode children first
  var content = null;
  var primitive = false;
  if (state.any) {
    // Anything that was given is translated to buffer
    result = this._createEncoderBuffer(data);
  } else if (state.choice) {
    result = this._encodeChoice(data, reporter);
  } else if (state.contains) {
    content = this._getUse(state.contains, parent)._encode(data, reporter);
    primitive = true;
  } else if (state.children) {
    content = state.children.map(function (child) {
      if (child._baseState.tag === 'null_') return child._encode(null, reporter, data);
      if (child._baseState.key === null) return reporter.error('Child should have a key');
      var prevKey = reporter.enterKey(child._baseState.key);
      if (_typeof(data) !== 'object') return reporter.error('Child expected, but input is not object');
      var res = child._encode(data[child._baseState.key], reporter, data);
      reporter.leaveKey(prevKey);
      return res;
    }, this).filter(function (child) {
      return child;
    });
    content = this._createEncoderBuffer(content);
  } else {
    if (state.tag === 'seqof' || state.tag === 'setof') {
      // TODO(indutny): this should be thrown on DSL level
      if (!(state.args && state.args.length === 1)) return reporter.error('Too many args for : ' + state.tag);
      if (!Array.isArray(data)) return reporter.error('seqof/setof, but data is not Array');
      var child = this.clone();
      child._baseState.implicit = null;
      content = this._createEncoderBuffer(data.map(function (item) {
        var state = this._baseState;
        return this._getUse(state.args[0], data)._encode(item, reporter);
      }, child));
    } else if (state.use !== null) {
      result = this._getUse(state.use, parent)._encode(data, reporter);
    } else {
      content = this._encodePrimitive(state.tag, data);
      primitive = true;
    }
  }

  // Encode data itself
  var result;
  if (!state.any && state.choice === null) {
    var tag = state.implicit !== null ? state.implicit : state.tag;
    var cls = state.implicit === null ? 'universal' : 'context';
    if (tag === null) {
      if (state.use === null) reporter.error('Tag could be omitted only for .use()');
    } else {
      if (state.use === null) result = this._encodeComposite(tag, primitive, cls, content);
    }
  }

  // Wrap in explicit
  if (state.explicit !== null) result = this._encodeComposite(state.explicit, false, 'context', result);
  return result;
};
Node.prototype._encodeChoice = function encodeChoice(data, reporter) {
  var state = this._baseState;
  var node = state.choice[data.type];
  if (!node) {
    assert(false, data.type + ' not found in ' + JSON.stringify(Object.keys(state.choice)));
  }
  return node._encode(data.value, reporter);
};
Node.prototype._encodePrimitive = function encodePrimitive(tag, data) {
  var state = this._baseState;
  if (/str$/.test(tag)) return this._encodeStr(data, tag);else if (tag === 'objid' && state.args) return this._encodeObjid(data, state.reverseArgs[0], state.args[1]);else if (tag === 'objid') return this._encodeObjid(data, null, null);else if (tag === 'gentime' || tag === 'utctime') return this._encodeTime(data, tag);else if (tag === 'null_') return this._encodeNull();else if (tag === 'int' || tag === 'enum') return this._encodeInt(data, state.args && state.reverseArgs[0]);else if (tag === 'bool') return this._encodeBool(data);else if (tag === 'objDesc') return this._encodeStr(data, tag);else throw new Error('Unsupported tag: ' + tag);
};
Node.prototype._isNumstr = function isNumstr(str) {
  return /^[0-9 ]*$/.test(str);
};
Node.prototype._isPrintstr = function isPrintstr(str) {
  return /^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(str);
};

},{"../base":86,"minimalistic-assert":342}],88:[function(require,module,exports){
"use strict";

var inherits = require('inherits');
function Reporter(options) {
  this._reporterState = {
    obj: null,
    path: [],
    options: options || {},
    errors: []
  };
}
exports.Reporter = Reporter;
Reporter.prototype.isError = function isError(obj) {
  return obj instanceof ReporterError;
};
Reporter.prototype.save = function save() {
  var state = this._reporterState;
  return {
    obj: state.obj,
    pathLen: state.path.length
  };
};
Reporter.prototype.restore = function restore(data) {
  var state = this._reporterState;
  state.obj = data.obj;
  state.path = state.path.slice(0, data.pathLen);
};
Reporter.prototype.enterKey = function enterKey(key) {
  return this._reporterState.path.push(key);
};
Reporter.prototype.exitKey = function exitKey(index) {
  var state = this._reporterState;
  state.path = state.path.slice(0, index - 1);
};
Reporter.prototype.leaveKey = function leaveKey(index, key, value) {
  var state = this._reporterState;
  this.exitKey(index);
  if (state.obj !== null) state.obj[key] = value;
};
Reporter.prototype.path = function path() {
  return this._reporterState.path.join('/');
};
Reporter.prototype.enterObject = function enterObject() {
  var state = this._reporterState;
  var prev = state.obj;
  state.obj = {};
  return prev;
};
Reporter.prototype.leaveObject = function leaveObject(prev) {
  var state = this._reporterState;
  var now = state.obj;
  state.obj = prev;
  return now;
};
Reporter.prototype.error = function error(msg) {
  var err;
  var state = this._reporterState;
  var inherited = msg instanceof ReporterError;
  if (inherited) {
    err = msg;
  } else {
    err = new ReporterError(state.path.map(function (elem) {
      return '[' + JSON.stringify(elem) + ']';
    }).join(''), msg.message || msg, msg.stack);
  }
  if (!state.options.partial) throw err;
  if (!inherited) state.errors.push(err);
  return err;
};
Reporter.prototype.wrapResult = function wrapResult(result) {
  var state = this._reporterState;
  if (!state.options.partial) return result;
  return {
    result: this.isError(result) ? null : result,
    errors: state.errors
  };
};
function ReporterError(path, msg) {
  this.path = path;
  this.rethrow(msg);
}
;
inherits(ReporterError, Error);
ReporterError.prototype.rethrow = function rethrow(msg) {
  this.message = msg + ' at: ' + (this.path || '(shallow)');
  if (Error.captureStackTrace) Error.captureStackTrace(this, ReporterError);
  if (!this.stack) {
    try {
      // IE only adds stack when thrown
      throw new Error(this.message);
    } catch (e) {
      this.stack = e.stack;
    }
  }
  return this;
};

},{"inherits":327}],89:[function(require,module,exports){
"use strict";

var constants = require('../constants');
exports.tagClass = {
  0: 'universal',
  1: 'application',
  2: 'context',
  3: 'private'
};
exports.tagClassByName = constants._reverse(exports.tagClass);
exports.tag = {
  0x00: 'end',
  0x01: 'bool',
  0x02: 'int',
  0x03: 'bitstr',
  0x04: 'octstr',
  0x05: 'null_',
  0x06: 'objid',
  0x07: 'objDesc',
  0x08: 'external',
  0x09: 'real',
  0x0a: 'enum',
  0x0b: 'embed',
  0x0c: 'utf8str',
  0x0d: 'relativeOid',
  0x10: 'seq',
  0x11: 'set',
  0x12: 'numstr',
  0x13: 'printstr',
  0x14: 't61str',
  0x15: 'videostr',
  0x16: 'ia5str',
  0x17: 'utctime',
  0x18: 'gentime',
  0x19: 'graphstr',
  0x1a: 'iso646str',
  0x1b: 'genstr',
  0x1c: 'unistr',
  0x1d: 'charstr',
  0x1e: 'bmpstr'
};
exports.tagByName = constants._reverse(exports.tag);

},{"../constants":90}],90:[function(require,module,exports){
"use strict";

var constants = exports;

// Helper
constants._reverse = function reverse(map) {
  var res = {};
  Object.keys(map).forEach(function (key) {
    // Convert key to integer if it is stringified
    if ((key | 0) == key) key = key | 0;
    var value = map[key];
    res[value] = key;
  });
  return res;
};
constants.der = require('./der');

},{"./der":89}],91:[function(require,module,exports){
"use strict";

var inherits = require('inherits');
var asn1 = require('../../asn1');
var base = asn1.base;
var bignum = asn1.bignum;

// Import DER constants
var der = asn1.constants.der;
function DERDecoder(entity) {
  this.enc = 'der';
  this.name = entity.name;
  this.entity = entity;

  // Construct base tree
  this.tree = new DERNode();
  this.tree._init(entity.body);
}
;
module.exports = DERDecoder;
DERDecoder.prototype.decode = function decode(data, options) {
  if (!(data instanceof base.DecoderBuffer)) data = new base.DecoderBuffer(data, options);
  return this.tree._decode(data, options);
};

// Tree methods

function DERNode(parent) {
  base.Node.call(this, 'der', parent);
}
inherits(DERNode, base.Node);
DERNode.prototype._peekTag = function peekTag(buffer, tag, any) {
  if (buffer.isEmpty()) return false;
  var state = buffer.save();
  var decodedTag = derDecodeTag(buffer, 'Failed to peek tag: "' + tag + '"');
  if (buffer.isError(decodedTag)) return decodedTag;
  buffer.restore(state);
  return decodedTag.tag === tag || decodedTag.tagStr === tag || decodedTag.tagStr + 'of' === tag || any;
};
DERNode.prototype._decodeTag = function decodeTag(buffer, tag, any) {
  var decodedTag = derDecodeTag(buffer, 'Failed to decode tag of "' + tag + '"');
  if (buffer.isError(decodedTag)) return decodedTag;
  var len = derDecodeLen(buffer, decodedTag.primitive, 'Failed to get length of "' + tag + '"');

  // Failure
  if (buffer.isError(len)) return len;
  if (!any && decodedTag.tag !== tag && decodedTag.tagStr !== tag && decodedTag.tagStr + 'of' !== tag) {
    return buffer.error('Failed to match tag: "' + tag + '"');
  }
  if (decodedTag.primitive || len !== null) return buffer.skip(len, 'Failed to match body of: "' + tag + '"');

  // Indefinite length... find END tag
  var state = buffer.save();
  var res = this._skipUntilEnd(buffer, 'Failed to skip indefinite length body: "' + this.tag + '"');
  if (buffer.isError(res)) return res;
  len = buffer.offset - state.offset;
  buffer.restore(state);
  return buffer.skip(len, 'Failed to match body of: "' + tag + '"');
};
DERNode.prototype._skipUntilEnd = function skipUntilEnd(buffer, fail) {
  while (true) {
    var tag = derDecodeTag(buffer, fail);
    if (buffer.isError(tag)) return tag;
    var len = derDecodeLen(buffer, tag.primitive, fail);
    if (buffer.isError(len)) return len;
    var res;
    if (tag.primitive || len !== null) res = buffer.skip(len);else res = this._skipUntilEnd(buffer, fail);

    // Failure
    if (buffer.isError(res)) return res;
    if (tag.tagStr === 'end') break;
  }
};
DERNode.prototype._decodeList = function decodeList(buffer, tag, decoder, options) {
  var result = [];
  while (!buffer.isEmpty()) {
    var possibleEnd = this._peekTag(buffer, 'end');
    if (buffer.isError(possibleEnd)) return possibleEnd;
    var res = decoder.decode(buffer, 'der', options);
    if (buffer.isError(res) && possibleEnd) break;
    result.push(res);
  }
  return result;
};
DERNode.prototype._decodeStr = function decodeStr(buffer, tag) {
  if (tag === 'bitstr') {
    var unused = buffer.readUInt8();
    if (buffer.isError(unused)) return unused;
    return {
      unused: unused,
      data: buffer.raw()
    };
  } else if (tag === 'bmpstr') {
    var raw = buffer.raw();
    if (raw.length % 2 === 1) return buffer.error('Decoding of string type: bmpstr length mismatch');
    var str = '';
    for (var i = 0; i < raw.length / 2; i++) {
      str += String.fromCharCode(raw.readUInt16BE(i * 2));
    }
    return str;
  } else if (tag === 'numstr') {
    var numstr = buffer.raw().toString('ascii');
    if (!this._isNumstr(numstr)) {
      return buffer.error('Decoding of string type: ' + 'numstr unsupported characters');
    }
    return numstr;
  } else if (tag === 'octstr') {
    return buffer.raw();
  } else if (tag === 'objDesc') {
    return buffer.raw();
  } else if (tag === 'printstr') {
    var printstr = buffer.raw().toString('ascii');
    if (!this._isPrintstr(printstr)) {
      return buffer.error('Decoding of string type: ' + 'printstr unsupported characters');
    }
    return printstr;
  } else if (/str$/.test(tag)) {
    return buffer.raw().toString();
  } else {
    return buffer.error('Decoding of string type: ' + tag + ' unsupported');
  }
};
DERNode.prototype._decodeObjid = function decodeObjid(buffer, values, relative) {
  var result;
  var identifiers = [];
  var ident = 0;
  while (!buffer.isEmpty()) {
    var subident = buffer.readUInt8();
    ident <<= 7;
    ident |= subident & 0x7f;
    if ((subident & 0x80) === 0) {
      identifiers.push(ident);
      ident = 0;
    }
  }
  if (subident & 0x80) identifiers.push(ident);
  var first = identifiers[0] / 40 | 0;
  var second = identifiers[0] % 40;
  if (relative) result = identifiers;else result = [first, second].concat(identifiers.slice(1));
  if (values) {
    var tmp = values[result.join(' ')];
    if (tmp === undefined) tmp = values[result.join('.')];
    if (tmp !== undefined) result = tmp;
  }
  return result;
};
DERNode.prototype._decodeTime = function decodeTime(buffer, tag) {
  var str = buffer.raw().toString();
  if (tag === 'gentime') {
    var year = str.slice(0, 4) | 0;
    var mon = str.slice(4, 6) | 0;
    var day = str.slice(6, 8) | 0;
    var hour = str.slice(8, 10) | 0;
    var min = str.slice(10, 12) | 0;
    var sec = str.slice(12, 14) | 0;
  } else if (tag === 'utctime') {
    var year = str.slice(0, 2) | 0;
    var mon = str.slice(2, 4) | 0;
    var day = str.slice(4, 6) | 0;
    var hour = str.slice(6, 8) | 0;
    var min = str.slice(8, 10) | 0;
    var sec = str.slice(10, 12) | 0;
    if (year < 70) year = 2000 + year;else year = 1900 + year;
  } else {
    return buffer.error('Decoding ' + tag + ' time is not supported yet');
  }
  return Date.UTC(year, mon - 1, day, hour, min, sec, 0);
};
DERNode.prototype._decodeNull = function decodeNull(buffer) {
  return null;
};
DERNode.prototype._decodeBool = function decodeBool(buffer) {
  var res = buffer.readUInt8();
  if (buffer.isError(res)) return res;else return res !== 0;
};
DERNode.prototype._decodeInt = function decodeInt(buffer, values) {
  // Bigint, return as it is (assume big endian)
  var raw = buffer.raw();
  var res = new bignum(raw);
  if (values) res = values[res.toString(10)] || res;
  return res;
};
DERNode.prototype._use = function use(entity, obj) {
  if (typeof entity === 'function') entity = entity(obj);
  return entity._getDecoder('der').tree;
};

// Utility methods

function derDecodeTag(buf, fail) {
  var tag = buf.readUInt8(fail);
  if (buf.isError(tag)) return tag;
  var cls = der.tagClass[tag >> 6];
  var primitive = (tag & 0x20) === 0;

  // Multi-octet tag - load
  if ((tag & 0x1f) === 0x1f) {
    var oct = tag;
    tag = 0;
    while ((oct & 0x80) === 0x80) {
      oct = buf.readUInt8(fail);
      if (buf.isError(oct)) return oct;
      tag <<= 7;
      tag |= oct & 0x7f;
    }
  } else {
    tag &= 0x1f;
  }
  var tagStr = der.tag[tag];
  return {
    cls: cls,
    primitive: primitive,
    tag: tag,
    tagStr: tagStr
  };
}
function derDecodeLen(buf, primitive, fail) {
  var len = buf.readUInt8(fail);
  if (buf.isError(len)) return len;

  // Indefinite form
  if (!primitive && len === 0x80) return null;

  // Definite form
  if ((len & 0x80) === 0) {
    // Short form
    return len;
  }

  // Long form
  var num = len & 0x7f;
  if (num > 4) return buf.error('length octect is too long');
  len = 0;
  for (var i = 0; i < num; i++) {
    len <<= 8;
    var j = buf.readUInt8(fail);
    if (buf.isError(j)) return j;
    len |= j;
  }
  return len;
}

},{"../../asn1":83,"inherits":327}],92:[function(require,module,exports){
"use strict";

var decoders = exports;
decoders.der = require('./der');
decoders.pem = require('./pem');

},{"./der":91,"./pem":93}],93:[function(require,module,exports){
"use strict";

var inherits = require('inherits');
var Buffer = require('buffer').Buffer;
var DERDecoder = require('./der');
function PEMDecoder(entity) {
  DERDecoder.call(this, entity);
  this.enc = 'pem';
}
;
inherits(PEMDecoder, DERDecoder);
module.exports = PEMDecoder;
PEMDecoder.prototype.decode = function decode(data, options) {
  var lines = data.toString().split(/[\r\n]+/g);
  var label = options.label.toUpperCase();
  var re = /^-----(BEGIN|END) ([^-]+)-----$/;
  var start = -1;
  var end = -1;
  for (var i = 0; i < lines.length; i++) {
    var match = lines[i].match(re);
    if (match === null) continue;
    if (match[2] !== label) continue;
    if (start === -1) {
      if (match[1] !== 'BEGIN') break;
      start = i;
    } else {
      if (match[1] !== 'END') break;
      end = i;
      break;
    }
  }
  if (start === -1 || end === -1) throw new Error('PEM section not found for: ' + label);
  var base64 = lines.slice(start + 1, end).join('');
  // Remove excessive symbols
  base64.replace(/[^a-z0-9\+\/=]+/gi, '');
  var input = new Buffer(base64, 'base64');
  return DERDecoder.prototype.decode.call(this, input, options);
};

},{"./der":91,"buffer":139,"inherits":327}],94:[function(require,module,exports){
"use strict";

var inherits = require('inherits');
var Buffer = require('buffer').Buffer;
var asn1 = require('../../asn1');
var base = asn1.base;

// Import DER constants
var der = asn1.constants.der;
function DEREncoder(entity) {
  this.enc = 'der';
  this.name = entity.name;
  this.entity = entity;

  // Construct base tree
  this.tree = new DERNode();
  this.tree._init(entity.body);
}
;
module.exports = DEREncoder;
DEREncoder.prototype.encode = function encode(data, reporter) {
  return this.tree._encode(data, reporter).join();
};

// Tree methods

function DERNode(parent) {
  base.Node.call(this, 'der', parent);
}
inherits(DERNode, base.Node);
DERNode.prototype._encodeComposite = function encodeComposite(tag, primitive, cls, content) {
  var encodedTag = encodeTag(tag, primitive, cls, this.reporter);

  // Short form
  if (content.length < 0x80) {
    var header = new Buffer(2);
    header[0] = encodedTag;
    header[1] = content.length;
    return this._createEncoderBuffer([header, content]);
  }

  // Long form
  // Count octets required to store length
  var lenOctets = 1;
  for (var i = content.length; i >= 0x100; i >>= 8) lenOctets++;
  var header = new Buffer(1 + 1 + lenOctets);
  header[0] = encodedTag;
  header[1] = 0x80 | lenOctets;
  for (var i = 1 + lenOctets, j = content.length; j > 0; i--, j >>= 8) header[i] = j & 0xff;
  return this._createEncoderBuffer([header, content]);
};
DERNode.prototype._encodeStr = function encodeStr(str, tag) {
  if (tag === 'bitstr') {
    return this._createEncoderBuffer([str.unused | 0, str.data]);
  } else if (tag === 'bmpstr') {
    var buf = new Buffer(str.length * 2);
    for (var i = 0; i < str.length; i++) {
      buf.writeUInt16BE(str.charCodeAt(i), i * 2);
    }
    return this._createEncoderBuffer(buf);
  } else if (tag === 'numstr') {
    if (!this._isNumstr(str)) {
      return this.reporter.error('Encoding of string type: numstr supports ' + 'only digits and space');
    }
    return this._createEncoderBuffer(str);
  } else if (tag === 'printstr') {
    if (!this._isPrintstr(str)) {
      return this.reporter.error('Encoding of string type: printstr supports ' + 'only latin upper and lower case letters, ' + 'digits, space, apostrophe, left and rigth ' + 'parenthesis, plus sign, comma, hyphen, ' + 'dot, slash, colon, equal sign, ' + 'question mark');
    }
    return this._createEncoderBuffer(str);
  } else if (/str$/.test(tag)) {
    return this._createEncoderBuffer(str);
  } else if (tag === 'objDesc') {
    return this._createEncoderBuffer(str);
  } else {
    return this.reporter.error('Encoding of string type: ' + tag + ' unsupported');
  }
};
DERNode.prototype._encodeObjid = function encodeObjid(id, values, relative) {
  if (typeof id === 'string') {
    if (!values) return this.reporter.error('string objid given, but no values map found');
    if (!values.hasOwnProperty(id)) return this.reporter.error('objid not found in values map');
    id = values[id].split(/[\s\.]+/g);
    for (var i = 0; i < id.length; i++) id[i] |= 0;
  } else if (Array.isArray(id)) {
    id = id.slice();
    for (var i = 0; i < id.length; i++) id[i] |= 0;
  }
  if (!Array.isArray(id)) {
    return this.reporter.error('objid() should be either array or string, ' + 'got: ' + JSON.stringify(id));
  }
  if (!relative) {
    if (id[1] >= 40) return this.reporter.error('Second objid identifier OOB');
    id.splice(0, 2, id[0] * 40 + id[1]);
  }

  // Count number of octets
  var size = 0;
  for (var i = 0; i < id.length; i++) {
    var ident = id[i];
    for (size++; ident >= 0x80; ident >>= 7) size++;
  }
  var objid = new Buffer(size);
  var offset = objid.length - 1;
  for (var i = id.length - 1; i >= 0; i--) {
    var ident = id[i];
    objid[offset--] = ident & 0x7f;
    while ((ident >>= 7) > 0) objid[offset--] = 0x80 | ident & 0x7f;
  }
  return this._createEncoderBuffer(objid);
};
function two(num) {
  if (num < 10) return '0' + num;else return num;
}
DERNode.prototype._encodeTime = function encodeTime(time, tag) {
  var str;
  var date = new Date(time);
  if (tag === 'gentime') {
    str = [two(date.getFullYear()), two(date.getUTCMonth() + 1), two(date.getUTCDate()), two(date.getUTCHours()), two(date.getUTCMinutes()), two(date.getUTCSeconds()), 'Z'].join('');
  } else if (tag === 'utctime') {
    str = [two(date.getFullYear() % 100), two(date.getUTCMonth() + 1), two(date.getUTCDate()), two(date.getUTCHours()), two(date.getUTCMinutes()), two(date.getUTCSeconds()), 'Z'].join('');
  } else {
    this.reporter.error('Encoding ' + tag + ' time is not supported yet');
  }
  return this._encodeStr(str, 'octstr');
};
DERNode.prototype._encodeNull = function encodeNull() {
  return this._createEncoderBuffer('');
};
DERNode.prototype._encodeInt = function encodeInt(num, values) {
  if (typeof num === 'string') {
    if (!values) return this.reporter.error('String int or enum given, but no values map');
    if (!values.hasOwnProperty(num)) {
      return this.reporter.error('Values map doesn\'t contain: ' + JSON.stringify(num));
    }
    num = values[num];
  }

  // Bignum, assume big endian
  if (typeof num !== 'number' && !Buffer.isBuffer(num)) {
    var numArray = num.toArray();
    if (!num.sign && numArray[0] & 0x80) {
      numArray.unshift(0);
    }
    num = new Buffer(numArray);
  }
  if (Buffer.isBuffer(num)) {
    var size = num.length;
    if (num.length === 0) size++;
    var out = new Buffer(size);
    num.copy(out);
    if (num.length === 0) out[0] = 0;
    return this._createEncoderBuffer(out);
  }
  if (num < 0x80) return this._createEncoderBuffer(num);
  if (num < 0x100) return this._createEncoderBuffer([0, num]);
  var size = 1;
  for (var i = num; i >= 0x100; i >>= 8) size++;
  var out = new Array(size);
  for (var i = out.length - 1; i >= 0; i--) {
    out[i] = num & 0xff;
    num >>= 8;
  }
  if (out[0] & 0x80) {
    out.unshift(0);
  }
  return this._createEncoderBuffer(new Buffer(out));
};
DERNode.prototype._encodeBool = function encodeBool(value) {
  return this._createEncoderBuffer(value ? 0xff : 0);
};
DERNode.prototype._use = function use(entity, obj) {
  if (typeof entity === 'function') entity = entity(obj);
  return entity._getEncoder('der').tree;
};
DERNode.prototype._skipDefault = function skipDefault(dataBuffer, reporter, parent) {
  var state = this._baseState;
  var i;
  if (state['default'] === null) return false;
  var data = dataBuffer.join();
  if (state.defaultBuffer === undefined) state.defaultBuffer = this._encodeValue(state['default'], reporter, parent).join();
  if (data.length !== state.defaultBuffer.length) return false;
  for (i = 0; i < data.length; i++) if (data[i] !== state.defaultBuffer[i]) return false;
  return true;
};

// Utility methods

function encodeTag(tag, primitive, cls, reporter) {
  var res;
  if (tag === 'seqof') tag = 'seq';else if (tag === 'setof') tag = 'set';
  if (der.tagByName.hasOwnProperty(tag)) res = der.tagByName[tag];else if (typeof tag === 'number' && (tag | 0) === tag) res = tag;else return reporter.error('Unknown tag: ' + tag);
  if (res >= 0x1f) return reporter.error('Multi-octet tag encoding unsupported');
  if (!primitive) res |= 0x20;
  res |= der.tagClassByName[cls || 'universal'] << 6;
  return res;
}

},{"../../asn1":83,"buffer":139,"inherits":327}],95:[function(require,module,exports){
"use strict";

var encoders = exports;
encoders.der = require('./der');
encoders.pem = require('./pem');

},{"./der":94,"./pem":96}],96:[function(require,module,exports){
"use strict";

var inherits = require('inherits');
var DEREncoder = require('./der');
function PEMEncoder(entity) {
  DEREncoder.call(this, entity);
  this.enc = 'pem';
}
;
inherits(PEMEncoder, DEREncoder);
module.exports = PEMEncoder;
PEMEncoder.prototype.encode = function encode(data, options) {
  var buf = DEREncoder.prototype.encode.call(this, data);
  var p = buf.toString('base64');
  var out = ['-----BEGIN ' + options.label + '-----'];
  for (var i = 0; i < p.length; i += 64) out.push(p.slice(i, i + 64));
  out.push('-----END ' + options.label + '-----');
  return out.join('\n');
};

},{"./der":94,"inherits":327}],97:[function(require,module,exports){
(function (global){(function (){
'use strict';

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var objectAssign = require('object.assign/polyfill')();

// compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
// original notice:

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
function compare(a, b) {
  if (a === b) {
    return 0;
  }
  var x = a.length;
  var y = b.length;
  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }
  if (x < y) {
    return -1;
  }
  if (y < x) {
    return 1;
  }
  return 0;
}
function isBuffer(b) {
  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {
    return global.Buffer.isBuffer(b);
  }
  return !!(b != null && b._isBuffer);
}

// based on node assert, original notice:
// NB: The URL to the CommonJS spec is kept just for tradition.
//     node-assert has evolved a lot since then, both in API and behavior.

// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
//
// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
//
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

var util = require('util/');
var hasOwn = Object.prototype.hasOwnProperty;
var pSlice = Array.prototype.slice;
var functionsHaveNames = function () {
  return function foo() {}.name === 'foo';
}();
function pToString(obj) {
  return Object.prototype.toString.call(obj);
}
function isView(arrbuf) {
  if (isBuffer(arrbuf)) {
    return false;
  }
  if (typeof global.ArrayBuffer !== 'function') {
    return false;
  }
  if (typeof ArrayBuffer.isView === 'function') {
    return ArrayBuffer.isView(arrbuf);
  }
  if (!arrbuf) {
    return false;
  }
  if (arrbuf instanceof DataView) {
    return true;
  }
  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
    return true;
  }
  return false;
}
// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

var regex = /\s*function\s+([^\(\s]*)\s*/;
// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js
function getName(func) {
  if (!util.isFunction(func)) {
    return;
  }
  if (functionsHaveNames) {
    return func.name;
  }
  var str = func.toString();
  var match = str.match(regex);
  return match && match[1];
}
assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  } else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();
    if (err.stack) {
      var out = err.stack;

      // try to strip useless frames
      var fn_name = getName(stackStartFunction);
      var idx = out.indexOf('\n' + fn_name);
      if (idx >= 0) {
        // once we have located the function frame
        // we need to strip out everything before it (and its line)
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }
      this.stack = out;
    }
  }
};

// assert.AssertionError instanceof Error
util.inherits(assert.AssertionError, Error);
function truncate(s, n) {
  if (typeof s === 'string') {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}
function inspect(something) {
  if (functionsHaveNames || !util.isFunction(something)) {
    return util.inspect(something);
  }
  var rawname = getName(something);
  var name = rawname ? ': ' + rawname : '';
  return '[Function' + name + ']';
}
function getMessage(self) {
  return truncate(inspect(self.actual), 128) + ' ' + self.operator + ' ' + truncate(inspect(self.expected), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};
assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);
  }
};
function _deepEqual(actual, expected, strict, memos) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;
  } else if (isBuffer(actual) && isBuffer(expected)) {
    return compare(actual, expected) === 0;

    // 7.2. If the expected value is a Date object, the actual value is
    // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();

    // 7.3 If the expected value is a RegExp object, the actual value is
    // equivalent if it is also a RegExp object with the same source and
    // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase;

    // 7.4. Other pairs that do not both pass typeof value == 'object',
    // equivalence is determined by ==.
  } else if ((actual === null || _typeof(actual) !== 'object') && (expected === null || _typeof(expected) !== 'object')) {
    return strict ? actual === expected : actual == expected;

    // If both values are instances of typed arrays, wrap their underlying
    // ArrayBuffers in a Buffer each to increase performance
    // This optimization requires the arrays to have the same type as checked by
    // Object.prototype.toString (aka pToString). Never perform binary
    // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their
    // bit patterns are not identical.
  } else if (isView(actual) && isView(expected) && pToString(actual) === pToString(expected) && !(actual instanceof Float32Array || actual instanceof Float64Array)) {
    return compare(new Uint8Array(actual.buffer), new Uint8Array(expected.buffer)) === 0;

    // 7.5 For all other Object pairs, including Array objects, equivalence is
    // determined by having the same number of owned properties (as verified
    // with Object.prototype.hasOwnProperty.call), the same set of keys
    // (although not necessarily the same order), equivalent values for every
    // corresponding key, and an identical 'prototype' property. Note: this
    // accounts for both named and indexed properties on Arrays.
  } else if (isBuffer(actual) !== isBuffer(expected)) {
    return false;
  } else {
    memos = memos || {
      actual: [],
      expected: []
    };
    var actualIndex = memos.actual.indexOf(actual);
    if (actualIndex !== -1) {
      if (actualIndex === memos.expected.indexOf(expected)) {
        return true;
      }
    }
    memos.actual.push(actual);
    memos.expected.push(expected);
    return objEquiv(actual, expected, strict, memos);
  }
}
function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}
function objEquiv(a, b, strict, actualVisitedObjects) {
  if (a === null || a === undefined || b === null || b === undefined) return false;
  // if one is a primitive, the other must be same
  if (util.isPrimitive(a) || util.isPrimitive(b)) return a === b;
  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b)) return false;
  var aIsArgs = isArguments(a);
  var bIsArgs = isArguments(b);
  if (aIsArgs && !bIsArgs || !aIsArgs && bIsArgs) return false;
  if (aIsArgs) {
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b, strict);
  }
  var ka = objectKeys(a);
  var kb = objectKeys(b);
  var key, i;
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length !== kb.length) return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] !== kb[i]) return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects)) return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};
assert.notDeepStrictEqual = notDeepStrictEqual;
function notDeepStrictEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
  }
}

// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};
function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }
  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  }
  try {
    if (actual instanceof expected) {
      return true;
    }
  } catch (e) {
    // Ignore.  The instanceof check doesn't work for arrow functions.
  }
  if (Error.isPrototypeOf(expected)) {
    return false;
  }
  return expected.call({}, actual) === true;
}
function _tryBlock(block) {
  var error;
  try {
    block();
  } catch (e) {
    error = e;
  }
  return error;
}
function _throws(shouldThrow, block, expected, message) {
  var actual;
  if (typeof block !== 'function') {
    throw new TypeError('"block" argument must be a function');
  }
  if (typeof expected === 'string') {
    message = expected;
    expected = null;
  }
  actual = _tryBlock(block);
  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') + (message ? ' ' + message : '.');
  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }
  var userProvidedMessage = typeof message === 'string';
  var isUnwantedException = !shouldThrow && util.isError(actual);
  var isUnexpectedException = !shouldThrow && actual && !expected;
  if (isUnwantedException && userProvidedMessage && expectedException(actual, expected) || isUnexpectedException) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }
  if (shouldThrow && actual && expected && !expectedException(actual, expected) || !shouldThrow && actual) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert["throws"] = function (block, /*optional*/error, /*optional*/message) {
  _throws(true, block, error, message);
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function (block, /*optional*/error, /*optional*/message) {
  _throws(false, block, error, message);
};
assert.ifError = function (err) {
  if (err) throw err;
};

// Expose a strict only variant of assert
function strict(value, message) {
  if (!value) fail(value, true, message, '==', strict);
}
assert.strict = objectAssign(strict, assert, {
  equal: assert.strictEqual,
  deepEqual: assert.deepStrictEqual,
  notEqual: assert.notStrictEqual,
  notDeepEqual: assert.notDeepStrictEqual
});
assert.strict.strict = assert.strict;
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }
  return keys;
};

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"object.assign/polyfill":348,"util/":99}],98:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
module.exports = function isBuffer(arg) {
  return arg && _typeof(arg) === 'object' && typeof arg.copy === 'function' && typeof arg.fill === 'function' && typeof arg.readUInt8 === 'function';
};

},{}],99:[function(require,module,exports){
(function (process,global){(function (){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function (f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }
  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function (x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s':
        return String(args[i++]);
      case '%d':
        return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};

// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function (fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function () {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }
  if (process.noDeprecation === true) {
    return fn;
  }
  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }
  return deprecated;
};
var debugs = {};
var debugEnviron;
exports.debuglog = function (set) {
  if (isUndefined(debugEnviron)) debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function () {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function () {};
    }
  }
  return debugs[set];
};

/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;

// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold': [1, 22],
  'italic': [3, 23],
  'underline': [4, 24],
  'inverse': [7, 27],
  'white': [37, 39],
  'grey': [90, 39],
  'black': [30, 39],
  'blue': [34, 39],
  'cyan': [36, 39],
  'green': [32, 39],
  'magenta': [35, 39],
  'red': [31, 39],
  'yellow': [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};
function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];
  if (style) {
    return "\x1B[" + inspect.colors[style][0] + 'm' + str + "\x1B[" + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}
function stylizeNoColor(str, styleType) {
  return str;
}
function arrayToHash(array) {
  var hash = {};
  array.forEach(function (val, idx) {
    hash[val] = true;
  });
  return hash;
}
function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect && value && isFunction(value.inspect) &&
  // Filter out the util module, it's inspect function is special
  value.inspect !== exports.inspect &&
  // Also filter out any prototype objects using the circular check.
  !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);
  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }
  var base = '',
    array = false,
    braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }
  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }
  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }
  ctx.seen.push(value);
  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function (key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }
  ctx.seen.pop();
  return reduceToSingleString(output, base, braces);
}
function formatPrimitive(ctx, value) {
  if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value)) return ctx.stylize('' + value, 'number');
  if (isBoolean(value)) return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value)) return ctx.stylize('null', 'null');
}
function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}
function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function (key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
    }
  });
  return output;
}
function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || {
    value: value[key]
  };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function (line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function (line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }
  return name + ': ' + str;
}
function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function (prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);
  if (length > 60) {
    return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
  }
  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;
function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;
function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;
function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;
function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;
function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;
function isSymbol(arg) {
  return _typeof(arg) === 'symbol';
}
exports.isSymbol = isSymbol;
function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;
function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;
function isObject(arg) {
  return _typeof(arg) === 'object' && arg !== null;
}
exports.isObject = isObject;
function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;
function isError(e) {
  return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;
function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;
function isPrimitive(arg) {
  return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || _typeof(arg) === 'symbol' ||
  // ES6 symbol
  typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;
exports.isBuffer = require('./support/isBuffer');
function objectToString(o) {
  return Object.prototype.toString.call(o);
}
function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}
var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}

// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function () {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};

/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');
exports._extend = function (origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;
  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./support/isBuffer":98,"_process":363,"inherits":327}],100:[function(require,module,exports){
'use strict';

exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62;
revLookup['_'.charCodeAt(0)] = 63;
function getLens(b64) {
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4');
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=');
  if (validLen === -1) validLen = len;
  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
}

// base64 is 4/3 + up to two characters of the original data
function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0;

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i;
  for (i = 0; i < len; i += 4) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[curByte++] = tmp >> 16 & 0xFF;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }
  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[curByte++] = tmp & 0xFF;
  }
  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }
  return arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}
function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
    output.push(tripletToBase64(tmp));
  }
  return output.join('');
}
function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');
  }
  return parts.join('');
}

},{}],101:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
;
(function (globalObject) {
  'use strict';

  /*
   *      bignumber.js v8.0.1
   *      A JavaScript library for arbitrary-precision arithmetic.
   *      https://github.com/MikeMcl/bignumber.js
   *      Copyright (c) 2018 Michael Mclaughlin <M8ch88l@gmail.com>
   *      MIT Licensed.
   *
   *      BigNumber.prototype methods     |  BigNumber methods
   *                                      |
   *      absoluteValue            abs    |  clone
   *      comparedTo                      |  config               set
   *      decimalPlaces            dp     |      DECIMAL_PLACES
   *      dividedBy                div    |      ROUNDING_MODE
   *      dividedToIntegerBy       idiv   |      EXPONENTIAL_AT
   *      exponentiatedBy          pow    |      RANGE
   *      integerValue                    |      CRYPTO
   *      isEqualTo                eq     |      MODULO_MODE
   *      isFinite                        |      POW_PRECISION
   *      isGreaterThan            gt     |      FORMAT
   *      isGreaterThanOrEqualTo   gte    |      ALPHABET
   *      isInteger                       |  isBigNumber
   *      isLessThan               lt     |  maximum              max
   *      isLessThanOrEqualTo      lte    |  minimum              min
   *      isNaN                           |  random
   *      isNegative                      |  sum
   *      isPositive                      |
   *      isZero                          |
   *      minus                           |
   *      modulo                   mod    |
   *      multipliedBy             times  |
   *      negated                         |
   *      plus                            |
   *      precision                sd     |
   *      shiftedBy                       |
   *      squareRoot               sqrt   |
   *      toExponential                   |
   *      toFixed                         |
   *      toFormat                        |
   *      toFraction                      |
   *      toJSON                          |
   *      toNumber                        |
   *      toPrecision                     |
   *      toString                        |
   *      valueOf                         |
   *
   */
  var BigNumber,
    isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i,
    mathceil = Math.ceil,
    mathfloor = Math.floor,
    bignumberError = '[BigNumber Error] ',
    tooManyDigits = bignumberError + 'Number primitive has more than 15 significant digits: ',
    BASE = 1e14,
    LOG_BASE = 14,
    MAX_SAFE_INTEGER = 0x1fffffffffffff,
    // 2^53 - 1
    // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1
    POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],
    SQRT_BASE = 1e7,
    // EDITABLE
    // The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and
    // the arguments to toExponential, toFixed, toFormat, and toPrecision.
    MAX = 1E9; // 0 to MAX_INT32

  /*
   * Create and return a BigNumber constructor.
   */
  function clone(configObject) {
    var div,
      convertBase,
      parseNumeric,
      P = BigNumber.prototype = {
        constructor: BigNumber,
        toString: null,
        valueOf: null
      },
      ONE = new BigNumber(1),
      //----------------------------- EDITABLE CONFIG DEFAULTS -------------------------------

      // The default values below must be integers within the inclusive ranges stated.
      // The values can also be changed at run-time using BigNumber.set.

      // The maximum number of decimal places for operations involving division.
      DECIMAL_PLACES = 20,
      // 0 to MAX

      // The rounding mode used when rounding to the above decimal places, and when using
      // toExponential, toFixed, toFormat and toPrecision, and round (default value).
      // UP         0 Away from zero.
      // DOWN       1 Towards zero.
      // CEIL       2 Towards +Infinity.
      // FLOOR      3 Towards -Infinity.
      // HALF_UP    4 Towards nearest neighbour. If equidistant, up.
      // HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
      // HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
      // HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
      // HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
      ROUNDING_MODE = 4,
      // 0 to 8

      // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]

      // The exponent value at and beneath which toString returns exponential notation.
      // Number type: -7
      TO_EXP_NEG = -7,
      // 0 to -MAX

      // The exponent value at and above which toString returns exponential notation.
      // Number type: 21
      TO_EXP_POS = 21,
      // 0 to MAX

      // RANGE : [MIN_EXP, MAX_EXP]

      // The minimum exponent value, beneath which underflow to zero occurs.
      // Number type: -324  (5e-324)
      MIN_EXP = -1e7,
      // -1 to -MAX

      // The maximum exponent value, above which overflow to Infinity occurs.
      // Number type:  308  (1.7976931348623157e+308)
      // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.
      MAX_EXP = 1e7,
      // 1 to MAX

      // Whether to use cryptographically-secure random number generation, if available.
      CRYPTO = false,
      // true or false

      // The modulo mode used when calculating the modulus: a mod n.
      // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
      // The remainder (r) is calculated as: r = a - n * q.
      //
      // UP        0 The remainder is positive if the dividend is negative, else is negative.
      // DOWN      1 The remainder has the same sign as the dividend.
      //             This modulo mode is commonly known as 'truncated division' and is
      //             equivalent to (a % n) in JavaScript.
      // FLOOR     3 The remainder has the same sign as the divisor (Python %).
      // HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.
      // EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).
      //             The remainder is always positive.
      //
      // The truncated division, floored division, Euclidian division and IEEE 754 remainder
      // modes are commonly used for the modulus operation.
      // Although the other rounding modes can also be used, they may not give useful results.
      MODULO_MODE = 1,
      // 0 to 9

      // The maximum number of significant digits of the result of the exponentiatedBy operation.
      // If POW_PRECISION is 0, there will be unlimited significant digits.
      POW_PRECISION = 0,
      // 0 to MAX

      // The format specification used by the BigNumber.prototype.toFormat method.
      FORMAT = {
        prefix: '',
        groupSize: 3,
        secondaryGroupSize: 0,
        groupSeparator: ',',
        decimalSeparator: '.',
        fractionGroupSize: 0,
        fractionGroupSeparator: '\xA0',
        // non-breaking space
        suffix: ''
      },
      // The alphabet used for base conversion. It must be at least 2 characters long, with no '+',
      // '-', '.', whitespace, or repeated character.
      // '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'
      ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyz';

    //------------------------------------------------------------------------------------------

    // CONSTRUCTOR

    /*
     * The BigNumber constructor and exported function.
     * Create and return a new instance of a BigNumber object.
     *
     * n {number|string|BigNumber} A numeric value.
     * [b] {number} The base of n. Integer, 2 to ALPHABET.length inclusive.
     */
    function BigNumber(n, b) {
      var alphabet,
        c,
        caseChanged,
        e,
        i,
        isNum,
        len,
        str,
        x = this;

      // Enable constructor usage without new.
      if (!(x instanceof BigNumber)) {
        // Don't throw on constructor call without new (#81).
        // '[BigNumber Error] Constructor call without new: {n}'
        //throw Error(bignumberError + ' Constructor call without new: ' + n);
        return new BigNumber(n, b);
      }
      if (b == null) {
        // Duplicate.
        if (n instanceof BigNumber) {
          x.s = n.s;
          x.e = n.e;
          x.c = (n = n.c) ? n.slice() : n;
          return;
        }
        isNum = typeof n == 'number';
        if (isNum && n * 0 == 0) {
          // Use `1 / n` to handle minus zero also.
          x.s = 1 / n < 0 ? (n = -n, -1) : 1;

          // Faster path for integers.
          if (n === ~~n) {
            for (e = 0, i = n; i >= 10; i /= 10, e++);
            x.e = e;
            x.c = [n];
            return;
          }
          str = String(n);
        } else {
          str = String(n);
          if (!isNumeric.test(str)) return parseNumeric(x, str, isNum);
          x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
        }

        // Decimal point?
        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');

        // Exponential form?
        if ((i = str.search(/e/i)) > 0) {
          // Determine exponent.
          if (e < 0) e = i;
          e += +str.slice(i + 1);
          str = str.substring(0, i);
        } else if (e < 0) {
          // Integer.
          e = str.length;
        }
      } else {
        // '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
        intCheck(b, 2, ALPHABET.length, 'Base');
        str = String(n);

        // Allow exponential notation to be used with base 10 argument, while
        // also rounding to DECIMAL_PLACES as with other bases.
        if (b == 10) {
          x = new BigNumber(n instanceof BigNumber ? n : str);
          return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
        }
        isNum = typeof n == 'number';
        if (isNum) {
          // Avoid potential interpretation of Infinity and NaN as base 44+ values.
          if (n * 0 != 0) return parseNumeric(x, str, isNum, b);
          x.s = 1 / n < 0 ? (str = str.slice(1), -1) : 1;

          // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
          if (BigNumber.DEBUG && str.replace(/^0\.0*|\./, '').length > 15) {
            throw Error(tooManyDigits + n);
          }

          // Prevent later check for length on converted number.
          isNum = false;
        } else {
          x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
        }
        alphabet = ALPHABET.slice(0, b);
        e = i = 0;

        // Check that str is a valid base b number.
        // Don't use RegExp so alphabet can contain special characters.
        for (len = str.length; i < len; i++) {
          if (alphabet.indexOf(c = str.charAt(i)) < 0) {
            if (c == '.') {
              // If '.' is not the first character and it has not be found before.
              if (i > e) {
                e = len;
                continue;
              }
            } else if (!caseChanged) {
              // Allow e.g. hexadecimal 'FF' as well as 'ff'.
              if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
                caseChanged = true;
                i = -1;
                e = 0;
                continue;
              }
            }
            return parseNumeric(x, String(n), isNum, b);
          }
        }
        str = convertBase(str, b, 10, x.s);

        // Decimal point?
        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');else e = str.length;
      }

      // Determine leading zeros.
      for (i = 0; str.charCodeAt(i) === 48; i++);

      // Determine trailing zeros.
      for (len = str.length; str.charCodeAt(--len) === 48;);
      str = str.slice(i, ++len);
      if (str) {
        len -= i;

        // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
        if (isNum && BigNumber.DEBUG && len > 15 && (n > MAX_SAFE_INTEGER || n !== mathfloor(n))) {
          throw Error(tooManyDigits + x.s * n);
        }
        e = e - i - 1;

        // Overflow?
        if (e > MAX_EXP) {
          // Infinity.
          x.c = x.e = null;

          // Underflow?
        } else if (e < MIN_EXP) {
          // Zero.
          x.c = [x.e = 0];
        } else {
          x.e = e;
          x.c = [];

          // Transform base

          // e is the base 10 exponent.
          // i is where to slice str to get the first element of the coefficient array.
          i = (e + 1) % LOG_BASE;
          if (e < 0) i += LOG_BASE;
          if (i < len) {
            if (i) x.c.push(+str.slice(0, i));
            for (len -= LOG_BASE; i < len;) {
              x.c.push(+str.slice(i, i += LOG_BASE));
            }
            str = str.slice(i);
            i = LOG_BASE - str.length;
          } else {
            i -= len;
          }
          for (; i--; str += '0');
          x.c.push(+str);
        }
      } else {
        // Zero.
        x.c = [x.e = 0];
      }
    }

    // CONSTRUCTOR PROPERTIES

    BigNumber.clone = clone;
    BigNumber.ROUND_UP = 0;
    BigNumber.ROUND_DOWN = 1;
    BigNumber.ROUND_CEIL = 2;
    BigNumber.ROUND_FLOOR = 3;
    BigNumber.ROUND_HALF_UP = 4;
    BigNumber.ROUND_HALF_DOWN = 5;
    BigNumber.ROUND_HALF_EVEN = 6;
    BigNumber.ROUND_HALF_CEIL = 7;
    BigNumber.ROUND_HALF_FLOOR = 8;
    BigNumber.EUCLID = 9;

    /*
     * Configure infrequently-changing library-wide settings.
     *
     * Accept an object with the following optional properties (if the value of a property is
     * a number, it must be an integer within the inclusive range stated):
     *
     *   DECIMAL_PLACES   {number}           0 to MAX
     *   ROUNDING_MODE    {number}           0 to 8
     *   EXPONENTIAL_AT   {number|number[]}  -MAX to MAX  or  [-MAX to 0, 0 to MAX]
     *   RANGE            {number|number[]}  -MAX to MAX (not zero)  or  [-MAX to -1, 1 to MAX]
     *   CRYPTO           {boolean}          true or false
     *   MODULO_MODE      {number}           0 to 9
     *   POW_PRECISION       {number}           0 to MAX
     *   ALPHABET         {string}           A string of two or more unique characters which does
     *                                       not contain '.'.
     *   FORMAT           {object}           An object with some of the following properties:
     *     prefix                 {string}
     *     groupSize              {number}
     *     secondaryGroupSize     {number}
     *     groupSeparator         {string}
     *     decimalSeparator       {string}
     *     fractionGroupSize      {number}
     *     fractionGroupSeparator {string}
     *     suffix                 {string}
     *
     * (The values assigned to the above FORMAT object properties are not checked for validity.)
     *
     * E.g.
     * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })
     *
     * Ignore properties/parameters set to null or undefined, except for ALPHABET.
     *
     * Return an object with the properties current values.
     */
    BigNumber.config = BigNumber.set = function (obj) {
      var p, v;
      if (obj != null) {
        if (_typeof(obj) == 'object') {
          // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.
          // '[BigNumber Error] DECIMAL_PLACES {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'DECIMAL_PLACES')) {
            v = obj[p];
            intCheck(v, 0, MAX, p);
            DECIMAL_PLACES = v;
          }

          // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.
          // '[BigNumber Error] ROUNDING_MODE {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'ROUNDING_MODE')) {
            v = obj[p];
            intCheck(v, 0, 8, p);
            ROUNDING_MODE = v;
          }

          // EXPONENTIAL_AT {number|number[]}
          // Integer, -MAX to MAX inclusive or
          // [integer -MAX to 0 inclusive, 0 to MAX inclusive].
          // '[BigNumber Error] EXPONENTIAL_AT {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'EXPONENTIAL_AT')) {
            v = obj[p];
            if (v && v.pop) {
              intCheck(v[0], -MAX, 0, p);
              intCheck(v[1], 0, MAX, p);
              TO_EXP_NEG = v[0];
              TO_EXP_POS = v[1];
            } else {
              intCheck(v, -MAX, MAX, p);
              TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
            }
          }

          // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or
          // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].
          // '[BigNumber Error] RANGE {not a primitive number|not an integer|out of range|cannot be zero}: {v}'
          if (obj.hasOwnProperty(p = 'RANGE')) {
            v = obj[p];
            if (v && v.pop) {
              intCheck(v[0], -MAX, -1, p);
              intCheck(v[1], 1, MAX, p);
              MIN_EXP = v[0];
              MAX_EXP = v[1];
            } else {
              intCheck(v, -MAX, MAX, p);
              if (v) {
                MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
              } else {
                throw Error(bignumberError + p + ' cannot be zero: ' + v);
              }
            }
          }

          // CRYPTO {boolean} true or false.
          // '[BigNumber Error] CRYPTO not true or false: {v}'
          // '[BigNumber Error] crypto unavailable'
          if (obj.hasOwnProperty(p = 'CRYPTO')) {
            v = obj[p];
            if (v === !!v) {
              if (v) {
                if (typeof crypto != 'undefined' && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                  CRYPTO = v;
                } else {
                  CRYPTO = !v;
                  throw Error(bignumberError + 'crypto unavailable');
                }
              } else {
                CRYPTO = v;
              }
            } else {
              throw Error(bignumberError + p + ' not true or false: ' + v);
            }
          }

          // MODULO_MODE {number} Integer, 0 to 9 inclusive.
          // '[BigNumber Error] MODULO_MODE {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'MODULO_MODE')) {
            v = obj[p];
            intCheck(v, 0, 9, p);
            MODULO_MODE = v;
          }

          // POW_PRECISION {number} Integer, 0 to MAX inclusive.
          // '[BigNumber Error] POW_PRECISION {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'POW_PRECISION')) {
            v = obj[p];
            intCheck(v, 0, MAX, p);
            POW_PRECISION = v;
          }

          // FORMAT {object}
          // '[BigNumber Error] FORMAT not an object: {v}'
          if (obj.hasOwnProperty(p = 'FORMAT')) {
            v = obj[p];
            if (_typeof(v) == 'object') FORMAT = v;else throw Error(bignumberError + p + ' not an object: ' + v);
          }

          // ALPHABET {string}
          // '[BigNumber Error] ALPHABET invalid: {v}'
          if (obj.hasOwnProperty(p = 'ALPHABET')) {
            v = obj[p];

            // Disallow if only one character,
            // or if it contains '+', '-', '.', whitespace, or a repeated character.
            if (typeof v == 'string' && !/^.$|[+-.\s]|(.).*\1/.test(v)) {
              ALPHABET = v;
            } else {
              throw Error(bignumberError + p + ' invalid: ' + v);
            }
          }
        } else {
          // '[BigNumber Error] Object expected: {v}'
          throw Error(bignumberError + 'Object expected: ' + obj);
        }
      }
      return {
        DECIMAL_PLACES: DECIMAL_PLACES,
        ROUNDING_MODE: ROUNDING_MODE,
        EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
        RANGE: [MIN_EXP, MAX_EXP],
        CRYPTO: CRYPTO,
        MODULO_MODE: MODULO_MODE,
        POW_PRECISION: POW_PRECISION,
        FORMAT: FORMAT,
        ALPHABET: ALPHABET
      };
    };

    /*
     * Return true if v is a BigNumber instance, otherwise return false.
     *
     * v {any}
     */
    BigNumber.isBigNumber = function (v) {
      return v instanceof BigNumber || v && v._isBigNumber === true || false;
    };

    /*
     * Return a new BigNumber whose value is the maximum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */
    BigNumber.maximum = BigNumber.max = function () {
      return maxOrMin(arguments, P.lt);
    };

    /*
     * Return a new BigNumber whose value is the minimum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */
    BigNumber.minimum = BigNumber.min = function () {
      return maxOrMin(arguments, P.gt);
    };

    /*
     * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,
     * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing
     * zeros are produced).
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp}'
     * '[BigNumber Error] crypto unavailable'
     */
    BigNumber.random = function () {
      var pow2_53 = 0x20000000000000;

      // Return a 53 bit integer n, where 0 <= n < 9007199254740992.
      // Check if Math.random() produces more than 32 bits of randomness.
      // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.
      // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.
      var random53bitInt = Math.random() * pow2_53 & 0x1fffff ? function () {
        return mathfloor(Math.random() * pow2_53);
      } : function () {
        return (Math.random() * 0x40000000 | 0) * 0x800000 + (Math.random() * 0x800000 | 0);
      };
      return function (dp) {
        var a,
          b,
          e,
          k,
          v,
          i = 0,
          c = [],
          rand = new BigNumber(ONE);
        if (dp == null) dp = DECIMAL_PLACES;else intCheck(dp, 0, MAX);
        k = mathceil(dp / LOG_BASE);
        if (CRYPTO) {
          // Browsers supporting crypto.getRandomValues.
          if (crypto.getRandomValues) {
            a = crypto.getRandomValues(new Uint32Array(k *= 2));
            for (; i < k;) {
              // 53 bits:
              // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)
              // 11111 11111111 11111111 11111111 11100000 00000000 00000000
              // ((Math.pow(2, 32) - 1) >>> 11).toString(2)
              //                                     11111 11111111 11111111
              // 0x20000 is 2^21.
              v = a[i] * 0x20000 + (a[i + 1] >>> 11);

              // Rejection sampling:
              // 0 <= v < 9007199254740992
              // Probability that v >= 9e15, is
              // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251
              if (v >= 9e15) {
                b = crypto.getRandomValues(new Uint32Array(2));
                a[i] = b[0];
                a[i + 1] = b[1];
              } else {
                // 0 <= v <= 8999999999999999
                // 0 <= (v % 1e14) <= 99999999999999
                c.push(v % 1e14);
                i += 2;
              }
            }
            i = k / 2;

            // Node.js supporting crypto.randomBytes.
          } else if (crypto.randomBytes) {
            // buffer
            a = crypto.randomBytes(k *= 7);
            for (; i < k;) {
              // 0x1000000000000 is 2^48, 0x10000000000 is 2^40
              // 0x100000000 is 2^32, 0x1000000 is 2^24
              // 11111 11111111 11111111 11111111 11111111 11111111 11111111
              // 0 <= v < 9007199254740992
              v = (a[i] & 31) * 0x1000000000000 + a[i + 1] * 0x10000000000 + a[i + 2] * 0x100000000 + a[i + 3] * 0x1000000 + (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];
              if (v >= 9e15) {
                crypto.randomBytes(7).copy(a, i);
              } else {
                // 0 <= (v % 1e14) <= 99999999999999
                c.push(v % 1e14);
                i += 7;
              }
            }
            i = k / 7;
          } else {
            CRYPTO = false;
            throw Error(bignumberError + 'crypto unavailable');
          }
        }

        // Use Math.random.
        if (!CRYPTO) {
          for (; i < k;) {
            v = random53bitInt();
            if (v < 9e15) c[i++] = v % 1e14;
          }
        }
        k = c[--i];
        dp %= LOG_BASE;

        // Convert trailing digits to zeros according to dp.
        if (k && dp) {
          v = POWS_TEN[LOG_BASE - dp];
          c[i] = mathfloor(k / v) * v;
        }

        // Remove trailing elements which are zero.
        for (; c[i] === 0; c.pop(), i--);

        // Zero?
        if (i < 0) {
          c = [e = 0];
        } else {
          // Remove leading elements which are zero and adjust exponent accordingly.
          for (e = -1; c[0] === 0; c.splice(0, 1), e -= LOG_BASE);

          // Count the digits of the first element of c to determine leading zeros, and...
          for (i = 1, v = c[0]; v >= 10; v /= 10, i++);

          // adjust the exponent accordingly.
          if (i < LOG_BASE) e -= LOG_BASE - i;
        }
        rand.e = e;
        rand.c = c;
        return rand;
      };
    }();

    /*
     * Return a BigNumber whose value is the sum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */
    BigNumber.sum = function () {
      var i = 1,
        args = arguments,
        sum = new BigNumber(args[0]);
      for (; i < args.length;) sum = sum.plus(args[i++]);
      return sum;
    };

    // PRIVATE FUNCTIONS

    // Called by BigNumber and BigNumber.prototype.toString.
    convertBase = function () {
      var decimal = '0123456789';

      /*
       * Convert string of baseIn to an array of numbers of baseOut.
       * Eg. toBaseOut('255', 10, 16) returns [15, 15].
       * Eg. toBaseOut('ff', 16, 10) returns [2, 5, 5].
       */
      function toBaseOut(str, baseIn, baseOut, alphabet) {
        var j,
          arr = [0],
          arrL,
          i = 0,
          len = str.length;
        for (; i < len;) {
          for (arrL = arr.length; arrL--; arr[arrL] *= baseIn);
          arr[0] += alphabet.indexOf(str.charAt(i++));
          for (j = 0; j < arr.length; j++) {
            if (arr[j] > baseOut - 1) {
              if (arr[j + 1] == null) arr[j + 1] = 0;
              arr[j + 1] += arr[j] / baseOut | 0;
              arr[j] %= baseOut;
            }
          }
        }
        return arr.reverse();
      }

      // Convert a numeric string of baseIn to a numeric string of baseOut.
      // If the caller is toString, we are converting from base 10 to baseOut.
      // If the caller is BigNumber, we are converting from baseIn to base 10.
      return function (str, baseIn, baseOut, sign, callerIsToString) {
        var alphabet,
          d,
          e,
          k,
          r,
          x,
          xc,
          y,
          i = str.indexOf('.'),
          dp = DECIMAL_PLACES,
          rm = ROUNDING_MODE;

        // Non-integer.
        if (i >= 0) {
          k = POW_PRECISION;

          // Unlimited precision.
          POW_PRECISION = 0;
          str = str.replace('.', '');
          y = new BigNumber(baseIn);
          x = y.pow(str.length - i);
          POW_PRECISION = k;

          // Convert str as if an integer, then restore the fraction part by dividing the
          // result by its base raised to a power.

          y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, '0'), 10, baseOut, decimal);
          y.e = y.c.length;
        }

        // Convert the number as integer.

        xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET));

        // xc now represents str as an integer and converted to baseOut. e is the exponent.
        e = k = xc.length;

        // Remove trailing zeros.
        for (; xc[--k] == 0; xc.pop());

        // Zero?
        if (!xc[0]) return alphabet.charAt(0);

        // Does str represent an integer? If so, no need for the division.
        if (i < 0) {
          --e;
        } else {
          x.c = xc;
          x.e = e;

          // The sign is needed for correct rounding.
          x.s = sign;
          x = div(x, y, dp, rm, baseOut);
          xc = x.c;
          r = x.r;
          e = x.e;
        }

        // xc now represents str converted to baseOut.

        // THe index of the rounding digit.
        d = e + dp + 1;

        // The rounding digit: the digit to the right of the digit that may be rounded up.
        i = xc[d];

        // Look at the rounding digits and mode to determine whether to round up.

        k = baseOut / 2;
        r = r || d < 0 || xc[d + 1] != null;
        r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : i > k || i == k && (rm == 4 || r || rm == 6 && xc[d - 1] & 1 || rm == (x.s < 0 ? 8 : 7));

        // If the index of the rounding digit is not greater than zero, or xc represents
        // zero, then the result of the base conversion is zero or, if rounding up, a value
        // such as 0.00001.
        if (d < 1 || !xc[0]) {
          // 1^-dp or 0
          str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
        } else {
          // Truncate xc to the required number of decimal places.
          xc.length = d;

          // Round up?
          if (r) {
            // Rounding up may mean the previous digit has to be rounded up and so on.
            for (--baseOut; ++xc[--d] > baseOut;) {
              xc[d] = 0;
              if (!d) {
                ++e;
                xc = [1].concat(xc);
              }
            }
          }

          // Determine trailing zeros.
          for (k = xc.length; !xc[--k];);

          // E.g. [4, 11, 15] becomes 4bf.
          for (i = 0, str = ''; i <= k; str += alphabet.charAt(xc[i++]));

          // Add leading zeros, decimal point and trailing zeros as required.
          str = toFixedPoint(str, e, alphabet.charAt(0));
        }

        // The caller will add the sign.
        return str;
      };
    }();

    // Perform division in the specified base. Called by div and convertBase.
    div = function () {
      // Assume non-zero x and k.
      function multiply(x, k, base) {
        var m,
          temp,
          xlo,
          xhi,
          carry = 0,
          i = x.length,
          klo = k % SQRT_BASE,
          khi = k / SQRT_BASE | 0;
        for (x = x.slice(); i--;) {
          xlo = x[i] % SQRT_BASE;
          xhi = x[i] / SQRT_BASE | 0;
          m = khi * xlo + xhi * klo;
          temp = klo * xlo + m % SQRT_BASE * SQRT_BASE + carry;
          carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
          x[i] = temp % base;
        }
        if (carry) x = [carry].concat(x);
        return x;
      }
      function compare(a, b, aL, bL) {
        var i, cmp;
        if (aL != bL) {
          cmp = aL > bL ? 1 : -1;
        } else {
          for (i = cmp = 0; i < aL; i++) {
            if (a[i] != b[i]) {
              cmp = a[i] > b[i] ? 1 : -1;
              break;
            }
          }
        }
        return cmp;
      }
      function subtract(a, b, aL, base) {
        var i = 0;

        // Subtract b from a.
        for (; aL--;) {
          a[aL] -= i;
          i = a[aL] < b[aL] ? 1 : 0;
          a[aL] = i * base + a[aL] - b[aL];
        }

        // Remove leading zeros.
        for (; !a[0] && a.length > 1; a.splice(0, 1));
      }

      // x: dividend, y: divisor.
      return function (x, y, dp, rm, base) {
        var cmp,
          e,
          i,
          more,
          n,
          prod,
          prodL,
          q,
          qc,
          rem,
          remL,
          rem0,
          xi,
          xL,
          yc0,
          yL,
          yz,
          s = x.s == y.s ? 1 : -1,
          xc = x.c,
          yc = y.c;

        // Either NaN, Infinity or 0?
        if (!xc || !xc[0] || !yc || !yc[0]) {
          return new BigNumber(
          // Return NaN if either NaN, or both Infinity or 0.
          !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN :
          // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
          xc && xc[0] == 0 || !yc ? s * 0 : s / 0);
        }
        q = new BigNumber(s);
        qc = q.c = [];
        e = x.e - y.e;
        s = dp + e + 1;
        if (!base) {
          base = BASE;
          e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
          s = s / LOG_BASE | 0;
        }

        // Result exponent may be one less then the current value of e.
        // The coefficients of the BigNumbers from convertBase may have trailing zeros.
        for (i = 0; yc[i] == (xc[i] || 0); i++);
        if (yc[i] > (xc[i] || 0)) e--;
        if (s < 0) {
          qc.push(1);
          more = true;
        } else {
          xL = xc.length;
          yL = yc.length;
          i = 0;
          s += 2;

          // Normalise xc and yc so highest order digit of yc is >= base / 2.

          n = mathfloor(base / (yc[0] + 1));

          // Not necessary, but to handle odd bases where yc[0] == (base / 2) - 1.
          // if (n > 1 || n++ == 1 && yc[0] < base / 2) {
          if (n > 1) {
            yc = multiply(yc, n, base);
            xc = multiply(xc, n, base);
            yL = yc.length;
            xL = xc.length;
          }
          xi = yL;
          rem = xc.slice(0, yL);
          remL = rem.length;

          // Add zeros to make remainder as long as divisor.
          for (; remL < yL; rem[remL++] = 0);
          yz = yc.slice();
          yz = [0].concat(yz);
          yc0 = yc[0];
          if (yc[1] >= base / 2) yc0++;
          // Not necessary, but to prevent trial digit n > base, when using base 3.
          // else if (base == 3 && yc0 == 1) yc0 = 1 + 1e-15;

          do {
            n = 0;

            // Compare divisor and remainder.
            cmp = compare(yc, rem, yL, remL);

            // If divisor < remainder.
            if (cmp < 0) {
              // Calculate trial digit, n.

              rem0 = rem[0];
              if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);

              // n is how many times the divisor goes into the current remainder.
              n = mathfloor(rem0 / yc0);

              //  Algorithm:
              //  product = divisor multiplied by trial digit (n).
              //  Compare product and remainder.
              //  If product is greater than remainder:
              //    Subtract divisor from product, decrement trial digit.
              //  Subtract product from remainder.
              //  If product was less than remainder at the last compare:
              //    Compare new remainder and divisor.
              //    If remainder is greater than divisor:
              //      Subtract divisor from remainder, increment trial digit.

              if (n > 1) {
                // n may be > base only when base is 3.
                if (n >= base) n = base - 1;

                // product = divisor * trial digit.
                prod = multiply(yc, n, base);
                prodL = prod.length;
                remL = rem.length;

                // Compare product and remainder.
                // If product > remainder then trial digit n too high.
                // n is 1 too high about 5% of the time, and is not known to have
                // ever been more than 1 too high.
                while (compare(prod, rem, prodL, remL) == 1) {
                  n--;

                  // Subtract divisor from product.
                  subtract(prod, yL < prodL ? yz : yc, prodL, base);
                  prodL = prod.length;
                  cmp = 1;
                }
              } else {
                // n is 0 or 1, cmp is -1.
                // If n is 0, there is no need to compare yc and rem again below,
                // so change cmp to 1 to avoid it.
                // If n is 1, leave cmp as -1, so yc and rem are compared again.
                if (n == 0) {
                  // divisor < remainder, so n must be at least 1.
                  cmp = n = 1;
                }

                // product = divisor
                prod = yc.slice();
                prodL = prod.length;
              }
              if (prodL < remL) prod = [0].concat(prod);

              // Subtract product from remainder.
              subtract(rem, prod, remL, base);
              remL = rem.length;

              // If product was < remainder.
              if (cmp == -1) {
                // Compare divisor and new remainder.
                // If divisor < new remainder, subtract divisor from remainder.
                // Trial digit n too low.
                // n is 1 too low about 5% of the time, and very rarely 2 too low.
                while (compare(yc, rem, yL, remL) < 1) {
                  n++;

                  // Subtract divisor from remainder.
                  subtract(rem, yL < remL ? yz : yc, remL, base);
                  remL = rem.length;
                }
              }
            } else if (cmp === 0) {
              n++;
              rem = [0];
            } // else cmp === 1 and n will be 0

            // Add the next digit, n, to the result array.
            qc[i++] = n;

            // Update the remainder.
            if (rem[0]) {
              rem[remL++] = xc[xi] || 0;
            } else {
              rem = [xc[xi]];
              remL = 1;
            }
          } while ((xi++ < xL || rem[0] != null) && s--);
          more = rem[0] != null;

          // Leading zero?
          if (!qc[0]) qc.splice(0, 1);
        }
        if (base == BASE) {
          // To calculate q.e, first get the number of digits of qc[0].
          for (i = 1, s = qc[0]; s >= 10; s /= 10, i++);
          round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);

          // Caller is convertBase.
        } else {
          q.e = e;
          q.r = +more;
        }
        return q;
      };
    }();

    /*
     * Return a string representing the value of BigNumber n in fixed-point or exponential
     * notation rounded to the specified decimal places or significant digits.
     *
     * n: a BigNumber.
     * i: the index of the last digit required (i.e. the digit that may be rounded up).
     * rm: the rounding mode.
     * id: 1 (toExponential) or 2 (toPrecision).
     */
    function format(n, i, rm, id) {
      var c0, e, ne, len, str;
      if (rm == null) rm = ROUNDING_MODE;else intCheck(rm, 0, 8);
      if (!n.c) return n.toString();
      c0 = n.c[0];
      ne = n.e;
      if (i == null) {
        str = coeffToString(n.c);
        str = id == 1 || id == 2 && ne <= TO_EXP_NEG ? toExponential(str, ne) : toFixedPoint(str, ne, '0');
      } else {
        n = round(new BigNumber(n), i, rm);

        // n.e may have changed if the value was rounded up.
        e = n.e;
        str = coeffToString(n.c);
        len = str.length;

        // toPrecision returns exponential notation if the number of significant digits
        // specified is less than the number of digits necessary to represent the integer
        // part of the value in fixed-point notation.

        // Exponential notation.
        if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {
          // Append zeros?
          for (; len < i; str += '0', len++);
          str = toExponential(str, e);

          // Fixed-point notation.
        } else {
          i -= ne;
          str = toFixedPoint(str, e, '0');

          // Append zeros?
          if (e + 1 > len) {
            if (--i > 0) for (str += '.'; i--; str += '0');
          } else {
            i += e - len;
            if (i > 0) {
              if (e + 1 == len) str += '.';
              for (; i--; str += '0');
            }
          }
        }
      }
      return n.s < 0 && c0 ? '-' + str : str;
    }

    // Handle BigNumber.max and BigNumber.min.
    function maxOrMin(args, method) {
      var n,
        i = 1,
        m = new BigNumber(args[0]);
      for (; i < args.length; i++) {
        n = new BigNumber(args[i]);

        // If any number is NaN, return NaN.
        if (!n.s) {
          m = n;
          break;
        } else if (method.call(m, n)) {
          m = n;
        }
      }
      return m;
    }

    /*
     * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.
     * Called by minus, plus and times.
     */
    function normalise(n, c, e) {
      var i = 1,
        j = c.length;

      // Remove trailing zeros.
      for (; !c[--j]; c.pop());

      // Calculate the base 10 exponent. First get the number of digits of c[0].
      for (j = c[0]; j >= 10; j /= 10, i++);

      // Overflow?
      if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {
        // Infinity.
        n.c = n.e = null;

        // Underflow?
      } else if (e < MIN_EXP) {
        // Zero.
        n.c = [n.e = 0];
      } else {
        n.e = e;
        n.c = c;
      }
      return n;
    }

    // Handle values that fail the validity test in BigNumber.
    parseNumeric = function () {
      var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i,
        dotAfter = /^([^.]+)\.$/,
        dotBefore = /^\.([^.]+)$/,
        isInfinityOrNaN = /^-?(Infinity|NaN)$/,
        whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
      return function (x, str, isNum, b) {
        var base,
          s = isNum ? str : str.replace(whitespaceOrPlus, '');

        // No exception on Infinity or NaN.
        if (isInfinityOrNaN.test(s)) {
          x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
          x.c = x.e = null;
        } else {
          if (!isNum) {
            // basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i
            s = s.replace(basePrefix, function (m, p1, p2) {
              base = (p2 = p2.toLowerCase()) == 'x' ? 16 : p2 == 'b' ? 2 : 8;
              return !b || b == base ? p1 : m;
            });
            if (b) {
              base = b;

              // E.g. '1.' to '1', '.1' to '0.1'
              s = s.replace(dotAfter, '$1').replace(dotBefore, '0.$1');
            }
            if (str != s) return new BigNumber(s, base);
          }

          // '[BigNumber Error] Not a number: {n}'
          // '[BigNumber Error] Not a base {b} number: {n}'
          if (BigNumber.DEBUG) {
            throw Error(bignumberError + 'Not a' + (b ? ' base ' + b : '') + ' number: ' + str);
          }

          // NaN
          x.c = x.e = x.s = null;
        }
      };
    }();

    /*
     * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.
     * If r is truthy, it is known that there are more digits after the rounding digit.
     */
    function round(x, sd, rm, r) {
      var d,
        i,
        j,
        k,
        n,
        ni,
        rd,
        xc = x.c,
        pows10 = POWS_TEN;

      // if x is not Infinity or NaN...
      if (xc) {
        // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.
        // n is a base 1e14 number, the value of the element of array x.c containing rd.
        // ni is the index of n within x.c.
        // d is the number of digits of n.
        // i is the index of rd within n including leading zeros.
        // j is the actual index of rd within n (if < 0, rd is a leading zero).
        out: {
          // Get the number of digits of the first element of xc.
          for (d = 1, k = xc[0]; k >= 10; k /= 10, d++);
          i = sd - d;

          // If the rounding digit is in the first element of xc...
          if (i < 0) {
            i += LOG_BASE;
            j = sd;
            n = xc[ni = 0];

            // Get the rounding digit at index j of n.
            rd = n / pows10[d - j - 1] % 10 | 0;
          } else {
            ni = mathceil((i + 1) / LOG_BASE);
            if (ni >= xc.length) {
              if (r) {
                // Needed by sqrt.
                for (; xc.length <= ni; xc.push(0));
                n = rd = 0;
                d = 1;
                i %= LOG_BASE;
                j = i - LOG_BASE + 1;
              } else {
                break out;
              }
            } else {
              n = k = xc[ni];

              // Get the number of digits of n.
              for (d = 1; k >= 10; k /= 10, d++);

              // Get the index of rd within n.
              i %= LOG_BASE;

              // Get the index of rd within n, adjusted for leading zeros.
              // The number of leading zeros of n is given by LOG_BASE - d.
              j = i - LOG_BASE + d;

              // Get the rounding digit at index j of n.
              rd = j < 0 ? 0 : n / pows10[d - j - 1] % 10 | 0;
            }
          }
          r = r || sd < 0 ||
          // Are there any non-zero digits after the rounding digit?
          // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
          // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
          xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);
          r = rm < 4 ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 &&
          // Check whether the digit to the left of the rounding digit is odd.
          (i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
          if (sd < 1 || !xc[0]) {
            xc.length = 0;
            if (r) {
              // Convert sd to decimal places.
              sd -= x.e + 1;

              // 1, 0.1, 0.01, 0.001, 0.0001 etc.
              xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
              x.e = -sd || 0;
            } else {
              // Zero.
              xc[0] = x.e = 0;
            }
            return x;
          }

          // Remove excess digits.
          if (i == 0) {
            xc.length = ni;
            k = 1;
            ni--;
          } else {
            xc.length = ni + 1;
            k = pows10[LOG_BASE - i];

            // E.g. 56700 becomes 56000 if 7 is the rounding digit.
            // j > 0 means i > number of leading zeros of n.
            xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
          }

          // Round up?
          if (r) {
            for (;;) {
              // If the digit to be rounded up is in the first element of xc...
              if (ni == 0) {
                // i will be the length of xc[0] before k is added.
                for (i = 1, j = xc[0]; j >= 10; j /= 10, i++);
                j = xc[0] += k;
                for (k = 1; j >= 10; j /= 10, k++);

                // if i != k the length has increased.
                if (i != k) {
                  x.e++;
                  if (xc[0] == BASE) xc[0] = 1;
                }
                break;
              } else {
                xc[ni] += k;
                if (xc[ni] != BASE) break;
                xc[ni--] = 0;
                k = 1;
              }
            }
          }

          // Remove trailing zeros.
          for (i = xc.length; xc[--i] === 0; xc.pop());
        }

        // Overflow? Infinity.
        if (x.e > MAX_EXP) {
          x.c = x.e = null;

          // Underflow? Zero.
        } else if (x.e < MIN_EXP) {
          x.c = [x.e = 0];
        }
      }
      return x;
    }
    function valueOf(n) {
      var str,
        e = n.e;
      if (e === null) return n.toString();
      str = coeffToString(n.c);
      str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e, '0');
      return n.s < 0 ? '-' + str : str;
    }

    // PROTOTYPE/INSTANCE METHODS

    /*
     * Return a new BigNumber whose value is the absolute value of this BigNumber.
     */
    P.absoluteValue = P.abs = function () {
      var x = new BigNumber(this);
      if (x.s < 0) x.s = 1;
      return x;
    };

    /*
     * Return
     *   1 if the value of this BigNumber is greater than the value of BigNumber(y, b),
     *   -1 if the value of this BigNumber is less than the value of BigNumber(y, b),
     *   0 if they have the same value,
     *   or null if the value of either is NaN.
     */
    P.comparedTo = function (y, b) {
      return compare(this, new BigNumber(y, b));
    };

    /*
     * If dp is undefined or null or true or false, return the number of decimal places of the
     * value of this BigNumber, or null if the value of this BigNumber is Infinity or NaN.
     *
     * Otherwise, if dp is a number, return a new BigNumber whose value is the value of this
     * BigNumber rounded to a maximum of dp decimal places using rounding mode rm, or
     * ROUNDING_MODE if rm is omitted.
     *
     * [dp] {number} Decimal places: integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */
    P.decimalPlaces = P.dp = function (dp, rm) {
      var c,
        n,
        v,
        x = this;
      if (dp != null) {
        intCheck(dp, 0, MAX);
        if (rm == null) rm = ROUNDING_MODE;else intCheck(rm, 0, 8);
        return round(new BigNumber(x), dp + x.e + 1, rm);
      }
      if (!(c = x.c)) return null;
      n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;

      // Subtract the number of trailing zeros of the last number.
      if (v = c[v]) for (; v % 10 == 0; v /= 10, n--);
      if (n < 0) n = 0;
      return n;
    };

    /*
     *  n / 0 = I
     *  n / N = N
     *  n / I = 0
     *  0 / n = 0
     *  0 / 0 = N
     *  0 / N = N
     *  0 / I = 0
     *  N / n = N
     *  N / 0 = N
     *  N / N = N
     *  N / I = N
     *  I / n = I
     *  I / 0 = I
     *  I / N = N
     *  I / I = N
     *
     * Return a new BigNumber whose value is the value of this BigNumber divided by the value of
     * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.
     */
    P.dividedBy = P.div = function (y, b) {
      return div(this, new BigNumber(y, b), DECIMAL_PLACES, ROUNDING_MODE);
    };

    /*
     * Return a new BigNumber whose value is the integer part of dividing the value of this
     * BigNumber by the value of BigNumber(y, b).
     */
    P.dividedToIntegerBy = P.idiv = function (y, b) {
      return div(this, new BigNumber(y, b), 0, 1);
    };

    /*
     * Return a BigNumber whose value is the value of this BigNumber exponentiated by n.
     *
     * If m is present, return the result modulo m.
     * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.
     * If POW_PRECISION is non-zero and m is not present, round to POW_PRECISION using ROUNDING_MODE.
     *
     * The modular power operation works efficiently when x, n, and m are integers, otherwise it
     * is equivalent to calculating x.exponentiatedBy(n).modulo(m) with a POW_PRECISION of 0.
     *
     * n {number|string|BigNumber} The exponent. An integer.
     * [m] {number|string|BigNumber} The modulus.
     *
     * '[BigNumber Error] Exponent not an integer: {n}'
     */
    P.exponentiatedBy = P.pow = function (n, m) {
      var half,
        isModExp,
        i,
        k,
        more,
        nIsBig,
        nIsNeg,
        nIsOdd,
        y,
        x = this;
      n = new BigNumber(n);

      // Allow NaN and Infinity, but not other non-integers.
      if (n.c && !n.isInteger()) {
        throw Error(bignumberError + 'Exponent not an integer: ' + valueOf(n));
      }
      if (m != null) m = new BigNumber(m);

      // Exponent of MAX_SAFE_INTEGER is 15.
      nIsBig = n.e > 14;

      // If x is NaN, Infinity, 0 or 1, or n is Infinity, NaN or 0.
      if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {
        // The sign of the result of pow when x is negative depends on the evenness of n.
        // If +n overflows to Infinity, the evenness of n would be not be known.
        y = new BigNumber(Math.pow(+valueOf(x), nIsBig ? 2 - isOdd(n) : +valueOf(n)));
        return m ? y.mod(m) : y;
      }
      nIsNeg = n.s < 0;
      if (m) {
        // x % m returns NaN if abs(m) is zero, or m is NaN.
        if (m.c ? !m.c[0] : !m.s) return new BigNumber(NaN);
        isModExp = !nIsNeg && x.isInteger() && m.isInteger();
        if (isModExp) x = x.mod(m);

        // Overflow to Infinity: >=2**1e10 or >=1.0000024**1e15.
        // Underflow to 0: <=0.79**1e10 or <=0.9999975**1e15.
      } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0
      // [1, 240000000]
      ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7
      // [80000000000000]  [99999750000000]
      : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {
        // If x is negative and n is odd, k = -0, else k = 0.
        k = x.s < 0 && isOdd(n) ? -0 : 0;

        // If x >= 1, k = Infinity.
        if (x.e > -1) k = 1 / k;

        // If n is negative return 0, else return Infinity.
        return new BigNumber(nIsNeg ? 1 / k : k);
      } else if (POW_PRECISION) {
        // Truncating each coefficient array to a length of k after each multiplication
        // equates to truncating significant digits to POW_PRECISION + [28, 41],
        // i.e. there will be a minimum of 28 guard digits retained.
        k = mathceil(POW_PRECISION / LOG_BASE + 2);
      }
      if (nIsBig) {
        half = new BigNumber(0.5);
        if (nIsNeg) n.s = 1;
        nIsOdd = isOdd(n);
      } else {
        i = Math.abs(+valueOf(n));
        nIsOdd = i % 2;
      }
      y = new BigNumber(ONE);

      // Performs 54 loop iterations for n of 9007199254740991.
      for (;;) {
        if (nIsOdd) {
          y = y.times(x);
          if (!y.c) break;
          if (k) {
            if (y.c.length > k) y.c.length = k;
          } else if (isModExp) {
            y = y.mod(m); //y = y.minus(div(y, m, 0, MODULO_MODE).times(m));
          }
        }
        if (i) {
          i = mathfloor(i / 2);
          if (i === 0) break;
          nIsOdd = i % 2;
        } else {
          n = n.times(half);
          round(n, n.e + 1, 1);
          if (n.e > 14) {
            nIsOdd = isOdd(n);
          } else {
            i = +valueOf(n);
            if (i === 0) break;
            nIsOdd = i % 2;
          }
        }
        x = x.times(x);
        if (k) {
          if (x.c && x.c.length > k) x.c.length = k;
        } else if (isModExp) {
          x = x.mod(m); //x = x.minus(div(x, m, 0, MODULO_MODE).times(m));
        }
      }
      if (isModExp) return y;
      if (nIsNeg) y = ONE.div(y);
      return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
    };

    /*
     * Return a new BigNumber whose value is the value of this BigNumber rounded to an integer
     * using rounding mode rm, or ROUNDING_MODE if rm is omitted.
     *
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {rm}'
     */
    P.integerValue = function (rm) {
      var n = new BigNumber(this);
      if (rm == null) rm = ROUNDING_MODE;else intCheck(rm, 0, 8);
      return round(n, n.e + 1, rm);
    };

    /*
     * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),
     * otherwise return false.
     */
    P.isEqualTo = P.eq = function (y, b) {
      return compare(this, new BigNumber(y, b)) === 0;
    };

    /*
     * Return true if the value of this BigNumber is a finite number, otherwise return false.
     */
    P.isFinite = function () {
      return !!this.c;
    };

    /*
     * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),
     * otherwise return false.
     */
    P.isGreaterThan = P.gt = function (y, b) {
      return compare(this, new BigNumber(y, b)) > 0;
    };

    /*
     * Return true if the value of this BigNumber is greater than or equal to the value of
     * BigNumber(y, b), otherwise return false.
     */
    P.isGreaterThanOrEqualTo = P.gte = function (y, b) {
      return (b = compare(this, new BigNumber(y, b))) === 1 || b === 0;
    };

    /*
     * Return true if the value of this BigNumber is an integer, otherwise return false.
     */
    P.isInteger = function () {
      return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
    };

    /*
     * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),
     * otherwise return false.
     */
    P.isLessThan = P.lt = function (y, b) {
      return compare(this, new BigNumber(y, b)) < 0;
    };

    /*
     * Return true if the value of this BigNumber is less than or equal to the value of
     * BigNumber(y, b), otherwise return false.
     */
    P.isLessThanOrEqualTo = P.lte = function (y, b) {
      return (b = compare(this, new BigNumber(y, b))) === -1 || b === 0;
    };

    /*
     * Return true if the value of this BigNumber is NaN, otherwise return false.
     */
    P.isNaN = function () {
      return !this.s;
    };

    /*
     * Return true if the value of this BigNumber is negative, otherwise return false.
     */
    P.isNegative = function () {
      return this.s < 0;
    };

    /*
     * Return true if the value of this BigNumber is positive, otherwise return false.
     */
    P.isPositive = function () {
      return this.s > 0;
    };

    /*
     * Return true if the value of this BigNumber is 0 or -0, otherwise return false.
     */
    P.isZero = function () {
      return !!this.c && this.c[0] == 0;
    };

    /*
     *  n - 0 = n
     *  n - N = N
     *  n - I = -I
     *  0 - n = -n
     *  0 - 0 = 0
     *  0 - N = N
     *  0 - I = -I
     *  N - n = N
     *  N - 0 = N
     *  N - N = N
     *  N - I = N
     *  I - n = I
     *  I - 0 = I
     *  I - N = N
     *  I - I = N
     *
     * Return a new BigNumber whose value is the value of this BigNumber minus the value of
     * BigNumber(y, b).
     */
    P.minus = function (y, b) {
      var i,
        j,
        t,
        xLTy,
        x = this,
        a = x.s;
      y = new BigNumber(y, b);
      b = y.s;

      // Either NaN?
      if (!a || !b) return new BigNumber(NaN);

      // Signs differ?
      if (a != b) {
        y.s = -b;
        return x.plus(y);
      }
      var xe = x.e / LOG_BASE,
        ye = y.e / LOG_BASE,
        xc = x.c,
        yc = y.c;
      if (!xe || !ye) {
        // Either Infinity?
        if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber(yc ? x : NaN);

        // Either zero?
        if (!xc[0] || !yc[0]) {
          // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
          return yc[0] ? (y.s = -b, y) : new BigNumber(xc[0] ? x :
          // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
          ROUNDING_MODE == 3 ? -0 : 0);
        }
      }
      xe = bitFloor(xe);
      ye = bitFloor(ye);
      xc = xc.slice();

      // Determine which is the bigger number.
      if (a = xe - ye) {
        if (xLTy = a < 0) {
          a = -a;
          t = xc;
        } else {
          ye = xe;
          t = yc;
        }
        t.reverse();

        // Prepend zeros to equalise exponents.
        for (b = a; b--; t.push(0));
        t.reverse();
      } else {
        // Exponents equal. Check digit by digit.
        j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;
        for (a = b = 0; b < j; b++) {
          if (xc[b] != yc[b]) {
            xLTy = xc[b] < yc[b];
            break;
          }
        }
      }

      // x < y? Point xc to the array of the bigger number.
      if (xLTy) t = xc, xc = yc, yc = t, y.s = -y.s;
      b = (j = yc.length) - (i = xc.length);

      // Append zeros to xc if shorter.
      // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.
      if (b > 0) for (; b--; xc[i++] = 0);
      b = BASE - 1;

      // Subtract yc from xc.
      for (; j > a;) {
        if (xc[--j] < yc[j]) {
          for (i = j; i && !xc[--i]; xc[i] = b);
          --xc[i];
          xc[j] += BASE;
        }
        xc[j] -= yc[j];
      }

      // Remove leading zeros and adjust exponent accordingly.
      for (; xc[0] == 0; xc.splice(0, 1), --ye);

      // Zero?
      if (!xc[0]) {
        // Following IEEE 754 (2008) 6.3,
        // n - n = +0  but  n - n = -0  when rounding towards -Infinity.
        y.s = ROUNDING_MODE == 3 ? -1 : 1;
        y.c = [y.e = 0];
        return y;
      }

      // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity
      // for finite x and y.
      return normalise(y, xc, ye);
    };

    /*
     *   n % 0 =  N
     *   n % N =  N
     *   n % I =  n
     *   0 % n =  0
     *  -0 % n = -0
     *   0 % 0 =  N
     *   0 % N =  N
     *   0 % I =  0
     *   N % n =  N
     *   N % 0 =  N
     *   N % N =  N
     *   N % I =  N
     *   I % n =  N
     *   I % 0 =  N
     *   I % N =  N
     *   I % I =  N
     *
     * Return a new BigNumber whose value is the value of this BigNumber modulo the value of
     * BigNumber(y, b). The result depends on the value of MODULO_MODE.
     */
    P.modulo = P.mod = function (y, b) {
      var q,
        s,
        x = this;
      y = new BigNumber(y, b);

      // Return NaN if x is Infinity or NaN, or y is NaN or zero.
      if (!x.c || !y.s || y.c && !y.c[0]) {
        return new BigNumber(NaN);

        // Return x if y is Infinity or x is zero.
      } else if (!y.c || x.c && !x.c[0]) {
        return new BigNumber(x);
      }
      if (MODULO_MODE == 9) {
        // Euclidian division: q = sign(y) * floor(x / abs(y))
        // r = x - qy    where  0 <= r < abs(y)
        s = y.s;
        y.s = 1;
        q = div(x, y, 0, 3);
        y.s = s;
        q.s *= s;
      } else {
        q = div(x, y, 0, MODULO_MODE);
      }
      y = x.minus(q.times(y));

      // To match JavaScript %, ensure sign of zero is sign of dividend.
      if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;
      return y;
    };

    /*
     *  n * 0 = 0
     *  n * N = N
     *  n * I = I
     *  0 * n = 0
     *  0 * 0 = 0
     *  0 * N = N
     *  0 * I = N
     *  N * n = N
     *  N * 0 = N
     *  N * N = N
     *  N * I = N
     *  I * n = I
     *  I * 0 = N
     *  I * N = N
     *  I * I = I
     *
     * Return a new BigNumber whose value is the value of this BigNumber multiplied by the value
     * of BigNumber(y, b).
     */
    P.multipliedBy = P.times = function (y, b) {
      var c,
        e,
        i,
        j,
        k,
        m,
        xcL,
        xlo,
        xhi,
        ycL,
        ylo,
        yhi,
        zc,
        base,
        sqrtBase,
        x = this,
        xc = x.c,
        yc = (y = new BigNumber(y, b)).c;

      // Either NaN, Infinity or 0?
      if (!xc || !yc || !xc[0] || !yc[0]) {
        // Return NaN if either is NaN, or one is 0 and the other is Infinity.
        if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
          y.c = y.e = y.s = null;
        } else {
          y.s *= x.s;

          // Return Infinity if either is Infinity.
          if (!xc || !yc) {
            y.c = y.e = null;

            // Return 0 if either is 0.
          } else {
            y.c = [0];
            y.e = 0;
          }
        }
        return y;
      }
      e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
      y.s *= x.s;
      xcL = xc.length;
      ycL = yc.length;

      // Ensure xc points to longer array and xcL to its length.
      if (xcL < ycL) zc = xc, xc = yc, yc = zc, i = xcL, xcL = ycL, ycL = i;

      // Initialise the result array with zeros.
      for (i = xcL + ycL, zc = []; i--; zc.push(0));
      base = BASE;
      sqrtBase = SQRT_BASE;
      for (i = ycL; --i >= 0;) {
        c = 0;
        ylo = yc[i] % sqrtBase;
        yhi = yc[i] / sqrtBase | 0;
        for (k = xcL, j = i + k; j > i;) {
          xlo = xc[--k] % sqrtBase;
          xhi = xc[k] / sqrtBase | 0;
          m = yhi * xlo + xhi * ylo;
          xlo = ylo * xlo + m % sqrtBase * sqrtBase + zc[j] + c;
          c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
          zc[j--] = xlo % base;
        }
        zc[j] = c;
      }
      if (c) {
        ++e;
      } else {
        zc.splice(0, 1);
      }
      return normalise(y, zc, e);
    };

    /*
     * Return a new BigNumber whose value is the value of this BigNumber negated,
     * i.e. multiplied by -1.
     */
    P.negated = function () {
      var x = new BigNumber(this);
      x.s = -x.s || null;
      return x;
    };

    /*
     *  n + 0 = n
     *  n + N = N
     *  n + I = I
     *  0 + n = n
     *  0 + 0 = 0
     *  0 + N = N
     *  0 + I = I
     *  N + n = N
     *  N + 0 = N
     *  N + N = N
     *  N + I = N
     *  I + n = I
     *  I + 0 = I
     *  I + N = N
     *  I + I = I
     *
     * Return a new BigNumber whose value is the value of this BigNumber plus the value of
     * BigNumber(y, b).
     */
    P.plus = function (y, b) {
      var t,
        x = this,
        a = x.s;
      y = new BigNumber(y, b);
      b = y.s;

      // Either NaN?
      if (!a || !b) return new BigNumber(NaN);

      // Signs differ?
      if (a != b) {
        y.s = -b;
        return x.minus(y);
      }
      var xe = x.e / LOG_BASE,
        ye = y.e / LOG_BASE,
        xc = x.c,
        yc = y.c;
      if (!xe || !ye) {
        // Return Infinity if either Infinity.
        if (!xc || !yc) return new BigNumber(a / 0);

        // Either zero?
        // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
        if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber(xc[0] ? x : a * 0);
      }
      xe = bitFloor(xe);
      ye = bitFloor(ye);
      xc = xc.slice();

      // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.
      if (a = xe - ye) {
        if (a > 0) {
          ye = xe;
          t = yc;
        } else {
          a = -a;
          t = xc;
        }
        t.reverse();
        for (; a--; t.push(0));
        t.reverse();
      }
      a = xc.length;
      b = yc.length;

      // Point xc to the longer array, and b to the shorter length.
      if (a - b < 0) t = yc, yc = xc, xc = t, b = a;

      // Only start adding at yc.length - 1 as the further digits of xc can be ignored.
      for (a = 0; b;) {
        a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
        xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
      }
      if (a) {
        xc = [a].concat(xc);
        ++ye;
      }

      // No need to check for zero, as +x + +y != 0 && -x + -y != 0
      // ye = MAX_EXP + 1 possible
      return normalise(y, xc, ye);
    };

    /*
     * If sd is undefined or null or true or false, return the number of significant digits of
     * the value of this BigNumber, or null if the value of this BigNumber is Infinity or NaN.
     * If sd is true include integer-part trailing zeros in the count.
     *
     * Otherwise, if sd is a number, return a new BigNumber whose value is the value of this
     * BigNumber rounded to a maximum of sd significant digits using rounding mode rm, or
     * ROUNDING_MODE if rm is omitted.
     *
     * sd {number|boolean} number: significant digits: integer, 1 to MAX inclusive.
     *                     boolean: whether to count integer-part trailing zeros: true or false.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
     */
    P.precision = P.sd = function (sd, rm) {
      var c,
        n,
        v,
        x = this;
      if (sd != null && sd !== !!sd) {
        intCheck(sd, 1, MAX);
        if (rm == null) rm = ROUNDING_MODE;else intCheck(rm, 0, 8);
        return round(new BigNumber(x), sd, rm);
      }
      if (!(c = x.c)) return null;
      v = c.length - 1;
      n = v * LOG_BASE + 1;
      if (v = c[v]) {
        // Subtract the number of trailing zeros of the last element.
        for (; v % 10 == 0; v /= 10, n--);

        // Add the number of digits of the first element.
        for (v = c[0]; v >= 10; v /= 10, n++);
      }
      if (sd && x.e + 1 > n) n = x.e + 1;
      return n;
    };

    /*
     * Return a new BigNumber whose value is the value of this BigNumber shifted by k places
     * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.
     *
     * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {k}'
     */
    P.shiftedBy = function (k) {
      intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
      return this.times('1e' + k);
    };

    /*
     *  sqrt(-n) =  N
     *  sqrt(N) =  N
     *  sqrt(-I) =  N
     *  sqrt(I) =  I
     *  sqrt(0) =  0
     *  sqrt(-0) = -0
     *
     * Return a new BigNumber whose value is the square root of the value of this BigNumber,
     * rounded according to DECIMAL_PLACES and ROUNDING_MODE.
     */
    P.squareRoot = P.sqrt = function () {
      var m,
        n,
        r,
        rep,
        t,
        x = this,
        c = x.c,
        s = x.s,
        e = x.e,
        dp = DECIMAL_PLACES + 4,
        half = new BigNumber('0.5');

      // Negative/NaN/Infinity/zero?
      if (s !== 1 || !c || !c[0]) {
        return new BigNumber(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
      }

      // Initial estimate.
      s = Math.sqrt(+valueOf(x));

      // Math.sqrt underflow/overflow?
      // Pass x to Math.sqrt as integer, then adjust the exponent of the result.
      if (s == 0 || s == 1 / 0) {
        n = coeffToString(c);
        if ((n.length + e) % 2 == 0) n += '0';
        s = Math.sqrt(+n);
        e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);
        if (s == 1 / 0) {
          n = '1e' + e;
        } else {
          n = s.toExponential();
          n = n.slice(0, n.indexOf('e') + 1) + e;
        }
        r = new BigNumber(n);
      } else {
        r = new BigNumber(s + '');
      }

      // Check for zero.
      // r could be zero if MIN_EXP is changed after the this value was created.
      // This would cause a division by zero (x/t) and hence Infinity below, which would cause
      // coeffToString to throw.
      if (r.c[0]) {
        e = r.e;
        s = e + dp;
        if (s < 3) s = 0;

        // Newton-Raphson iteration.
        for (;;) {
          t = r;
          r = half.times(t.plus(div(x, t, dp, 1)));
          if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {
            // The exponent of r may here be one less than the final result exponent,
            // e.g 0.0009999 (e-4) --> 0.001 (e-3), so adjust s so the rounding digits
            // are indexed correctly.
            if (r.e < e) --s;
            n = n.slice(s - 3, s + 1);

            // The 4th rounding digit may be in error by -1 so if the 4 rounding digits
            // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the
            // iteration.
            if (n == '9999' || !rep && n == '4999') {
              // On the first iteration only, check to see if rounding up gives the
              // exact result as the nines may infinitely repeat.
              if (!rep) {
                round(t, t.e + DECIMAL_PLACES + 2, 0);
                if (t.times(t).eq(x)) {
                  r = t;
                  break;
                }
              }
              dp += 4;
              s += 4;
              rep = 1;
            } else {
              // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact
              // result. If not, then there are further digits and m will be truthy.
              if (!+n || !+n.slice(1) && n.charAt(0) == '5') {
                // Truncate to the first rounding digit.
                round(r, r.e + DECIMAL_PLACES + 2, 1);
                m = !r.times(r).eq(x);
              }
              break;
            }
          }
        }
      }
      return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
    };

    /*
     * Return a string representing the value of this BigNumber in exponential notation and
     * rounded using ROUNDING_MODE to dp fixed decimal places.
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */
    P.toExponential = function (dp, rm) {
      if (dp != null) {
        intCheck(dp, 0, MAX);
        dp++;
      }
      return format(this, dp, rm, 1);
    };

    /*
     * Return a string representing the value of this BigNumber in fixed-point notation rounding
     * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.
     *
     * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',
     * but e.g. (-0.00001).toFixed(0) is '-0'.
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */
    P.toFixed = function (dp, rm) {
      if (dp != null) {
        intCheck(dp, 0, MAX);
        dp = dp + this.e + 1;
      }
      return format(this, dp, rm);
    };

    /*
     * Return a string representing the value of this BigNumber in fixed-point notation rounded
     * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties
     * of the format or FORMAT object (see BigNumber.set).
     *
     * The formatting object may contain some or all of the properties shown below.
     *
     * FORMAT = {
     *   prefix: '',
     *   groupSize: 3,
     *   secondaryGroupSize: 0,
     *   groupSeparator: ',',
     *   decimalSeparator: '.',
     *   fractionGroupSize: 0,
     *   fractionGroupSeparator: '\xA0',      // non-breaking space
     *   suffix: ''
     * };
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     * [format] {object} Formatting options. See FORMAT pbject above.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     * '[BigNumber Error] Argument not an object: {format}'
     */
    P.toFormat = function (dp, rm, format) {
      var str,
        x = this;
      if (format == null) {
        if (dp != null && rm && _typeof(rm) == 'object') {
          format = rm;
          rm = null;
        } else if (dp && _typeof(dp) == 'object') {
          format = dp;
          dp = rm = null;
        } else {
          format = FORMAT;
        }
      } else if (_typeof(format) != 'object') {
        throw Error(bignumberError + 'Argument not an object: ' + format);
      }
      str = x.toFixed(dp, rm);
      if (x.c) {
        var i,
          arr = str.split('.'),
          g1 = +format.groupSize,
          g2 = +format.secondaryGroupSize,
          groupSeparator = format.groupSeparator || '',
          intPart = arr[0],
          fractionPart = arr[1],
          isNeg = x.s < 0,
          intDigits = isNeg ? intPart.slice(1) : intPart,
          len = intDigits.length;
        if (g2) i = g1, g1 = g2, g2 = i, len -= i;
        if (g1 > 0 && len > 0) {
          i = len % g1 || g1;
          intPart = intDigits.substr(0, i);
          for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);
          if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);
          if (isNeg) intPart = '-' + intPart;
        }
        str = fractionPart ? intPart + (format.decimalSeparator || '') + ((g2 = +format.fractionGroupSize) ? fractionPart.replace(new RegExp('\\d{' + g2 + '}\\B', 'g'), '$&' + (format.fractionGroupSeparator || '')) : fractionPart) : intPart;
      }
      return (format.prefix || '') + str + (format.suffix || '');
    };

    /*
     * Return an array of two BigNumbers representing the value of this BigNumber as a simple
     * fraction with an integer numerator and an integer denominator.
     * The denominator will be a positive non-zero value less than or equal to the specified
     * maximum denominator. If a maximum denominator is not specified, the denominator will be
     * the lowest value necessary to represent the number exactly.
     *
     * [md] {number|string|BigNumber} Integer >= 1, or Infinity. The maximum denominator.
     *
     * '[BigNumber Error] Argument {not an integer|out of range} : {md}'
     */
    P.toFraction = function (md) {
      var d,
        d0,
        d1,
        d2,
        e,
        exp,
        n,
        n0,
        n1,
        q,
        r,
        s,
        x = this,
        xc = x.c;
      if (md != null) {
        n = new BigNumber(md);

        // Throw if md is less than one or is not an integer, unless it is Infinity.
        if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
          throw Error(bignumberError + 'Argument ' + (n.isInteger() ? 'out of range: ' : 'not an integer: ') + valueOf(n));
        }
      }
      if (!xc) return new BigNumber(x);
      d = new BigNumber(ONE);
      n1 = d0 = new BigNumber(ONE);
      d1 = n0 = new BigNumber(ONE);
      s = coeffToString(xc);

      // Determine initial denominator.
      // d is a power of 10 and the minimum max denominator that specifies the value exactly.
      e = d.e = s.length - x.e - 1;
      d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
      md = !md || n.comparedTo(d) > 0 ? e > 0 ? d : n1 : n;
      exp = MAX_EXP;
      MAX_EXP = 1 / 0;
      n = new BigNumber(s);

      // n0 = d1 = 0
      n0.c[0] = 0;
      for (;;) {
        q = div(n, d, 0, 1);
        d2 = d0.plus(q.times(d1));
        if (d2.comparedTo(md) == 1) break;
        d0 = d1;
        d1 = d2;
        n1 = n0.plus(q.times(d2 = n1));
        n0 = d2;
        d = n.minus(q.times(d2 = d));
        n = d2;
      }
      d2 = div(md.minus(d0), d1, 0, 1);
      n0 = n0.plus(d2.times(n1));
      d0 = d0.plus(d2.times(d1));
      n0.s = n1.s = x.s;
      e = e * 2;

      // Determine which fraction is closer to x, n0/d0 or n1/d1
      r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];
      MAX_EXP = exp;
      return r;
    };

    /*
     * Return the value of this BigNumber converted to a number primitive.
     */
    P.toNumber = function () {
      return +valueOf(this);
    };

    /*
     * Return a string representing the value of this BigNumber rounded to sd significant digits
     * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits
     * necessary to represent the integer part of the value in fixed-point notation, then use
     * exponential notation.
     *
     * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
     */
    P.toPrecision = function (sd, rm) {
      if (sd != null) intCheck(sd, 1, MAX);
      return format(this, sd, rm, 2);
    };

    /*
     * Return a string representing the value of this BigNumber in base b, or base 10 if b is
     * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and
     * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent
     * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than
     * TO_EXP_NEG, return exponential notation.
     *
     * [b] {number} Integer, 2 to ALPHABET.length inclusive.
     *
     * '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
     */
    P.toString = function (b) {
      var str,
        n = this,
        s = n.s,
        e = n.e;

      // Infinity or NaN?
      if (e === null) {
        if (s) {
          str = 'Infinity';
          if (s < 0) str = '-' + str;
        } else {
          str = 'NaN';
        }
      } else {
        str = coeffToString(n.c);
        if (b == null) {
          str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e, '0');
        } else {
          intCheck(b, 2, ALPHABET.length, 'Base');
          str = convertBase(toFixedPoint(str, e, '0'), 10, b, s, true);
        }
        if (s < 0 && n.c[0]) str = '-' + str;
      }
      return str;
    };

    /*
     * Return as toString, but do not accept a base argument, and include the minus sign for
     * negative zero.
     */
    P.valueOf = P.toJSON = function () {
      return valueOf(this);
    };
    P._isBigNumber = true;
    if (typeof Symbol == 'function' && _typeof(Symbol.iterator) == 'symbol') {
      P[Symbol.toStringTag] = 'BigNumber';
      // Node.js v10.12.0+
      P[Symbol["for"]('nodejs.util.inspect.custom')] = P.valueOf;
    }
    if (configObject != null) BigNumber.set(configObject);
    return BigNumber;
  }

  // PRIVATE HELPER FUNCTIONS

  function bitFloor(n) {
    var i = n | 0;
    return n > 0 || n === i ? i : i - 1;
  }

  // Return a coefficient array as a string of base 10 digits.
  function coeffToString(a) {
    var s,
      z,
      i = 1,
      j = a.length,
      r = a[0] + '';
    for (; i < j;) {
      s = a[i++] + '';
      z = LOG_BASE - s.length;
      for (; z--; s = '0' + s);
      r += s;
    }

    // Determine trailing zeros.
    for (j = r.length; r.charCodeAt(--j) === 48;);
    return r.slice(0, j + 1 || 1);
  }

  // Compare the value of BigNumbers x and y.
  function compare(x, y) {
    var a,
      b,
      xc = x.c,
      yc = y.c,
      i = x.s,
      j = y.s,
      k = x.e,
      l = y.e;

    // Either NaN?
    if (!i || !j) return null;
    a = xc && !xc[0];
    b = yc && !yc[0];

    // Either zero?
    if (a || b) return a ? b ? 0 : -j : i;

    // Signs differ?
    if (i != j) return i;
    a = i < 0;
    b = k == l;

    // Either Infinity?
    if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;

    // Compare exponents.
    if (!b) return k > l ^ a ? 1 : -1;
    j = (k = xc.length) < (l = yc.length) ? k : l;

    // Compare digit by digit.
    for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;

    // Compare lengths.
    return k == l ? 0 : k > l ^ a ? 1 : -1;
  }

  /*
   * Check that n is a primitive number, an integer, and in range, otherwise throw.
   */
  function intCheck(n, min, max, name) {
    if (n < min || n > max || n !== (n < 0 ? mathceil(n) : mathfloor(n))) {
      throw Error(bignumberError + (name || 'Argument') + (typeof n == 'number' ? n < min || n > max ? ' out of range: ' : ' not an integer: ' : ' not a primitive number: ') + String(n));
    }
  }

  // Assumes finite n.
  function isOdd(n) {
    var k = n.c.length - 1;
    return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
  }
  function toExponential(str, e) {
    return (str.length > 1 ? str.charAt(0) + '.' + str.slice(1) : str) + (e < 0 ? 'e' : 'e+') + e;
  }
  function toFixedPoint(str, e, z) {
    var len, zs;

    // Negative exponent?
    if (e < 0) {
      // Prepend zeros.
      for (zs = z + '.'; ++e; zs += z);
      str = zs + str;

      // Positive exponent
    } else {
      len = str.length;

      // Append zeros.
      if (++e > len) {
        for (zs = z, e -= len; --e; zs += z);
        str += zs;
      } else if (e < len) {
        str = str.slice(0, e) + '.' + str.slice(e);
      }
    }
    return str;
  }

  // EXPORT

  BigNumber = clone();
  BigNumber['default'] = BigNumber.BigNumber = BigNumber;

  // AMD.
  if (typeof define == 'function' && define.amd) {
    define(function () {
      return BigNumber;
    });

    // Node.js and other environments that support module.exports.
  } else if (typeof module != 'undefined' && module.exports) {
    module.exports = BigNumber;

    // Browser.
  } else {
    if (!globalObject) {
      globalObject = typeof self != 'undefined' && self ? self : window;
    }
    globalObject.BigNumber = BigNumber;
  }
})(void 0);

},{}],102:[function(require,module,exports){
"use strict";

// Reference https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki
// Format: 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S]
// NOTE: SIGHASH byte ignored AND restricted, truncate before use

var Buffer = require('safe-buffer').Buffer;
function check(buffer) {
  if (buffer.length < 8) return false;
  if (buffer.length > 72) return false;
  if (buffer[0] !== 0x30) return false;
  if (buffer[1] !== buffer.length - 2) return false;
  if (buffer[2] !== 0x02) return false;
  var lenR = buffer[3];
  if (lenR === 0) return false;
  if (5 + lenR >= buffer.length) return false;
  if (buffer[4 + lenR] !== 0x02) return false;
  var lenS = buffer[5 + lenR];
  if (lenS === 0) return false;
  if (6 + lenR + lenS !== buffer.length) return false;
  if (buffer[4] & 0x80) return false;
  if (lenR > 1 && buffer[4] === 0x00 && !(buffer[5] & 0x80)) return false;
  if (buffer[lenR + 6] & 0x80) return false;
  if (lenS > 1 && buffer[lenR + 6] === 0x00 && !(buffer[lenR + 7] & 0x80)) return false;
  return true;
}
function decode(buffer) {
  if (buffer.length < 8) throw new Error('DER sequence length is too short');
  if (buffer.length > 72) throw new Error('DER sequence length is too long');
  if (buffer[0] !== 0x30) throw new Error('Expected DER sequence');
  if (buffer[1] !== buffer.length - 2) throw new Error('DER sequence length is invalid');
  if (buffer[2] !== 0x02) throw new Error('Expected DER integer');
  var lenR = buffer[3];
  if (lenR === 0) throw new Error('R length is zero');
  if (5 + lenR >= buffer.length) throw new Error('R length is too long');
  if (buffer[4 + lenR] !== 0x02) throw new Error('Expected DER integer (2)');
  var lenS = buffer[5 + lenR];
  if (lenS === 0) throw new Error('S length is zero');
  if (6 + lenR + lenS !== buffer.length) throw new Error('S length is invalid');
  if (buffer[4] & 0x80) throw new Error('R value is negative');
  if (lenR > 1 && buffer[4] === 0x00 && !(buffer[5] & 0x80)) throw new Error('R value excessively padded');
  if (buffer[lenR + 6] & 0x80) throw new Error('S value is negative');
  if (lenS > 1 && buffer[lenR + 6] === 0x00 && !(buffer[lenR + 7] & 0x80)) throw new Error('S value excessively padded');

  // non-BIP66 - extract R, S values
  return {
    r: buffer.slice(4, 4 + lenR),
    s: buffer.slice(6 + lenR)
  };
}

/*
 * Expects r and s to be positive DER integers.
 *
 * The DER format uses the most significant bit as a sign bit (& 0x80).
 * If the significant bit is set AND the integer is positive, a 0x00 is prepended.
 *
 * Examples:
 *
 *      0 =>     0x00
 *      1 =>     0x01
 *     -1 =>     0xff
 *    127 =>     0x7f
 *   -127 =>     0x81
 *    128 =>   0x0080
 *   -128 =>     0x80
 *    255 =>   0x00ff
 *   -255 =>   0xff01
 *  16300 =>   0x3fac
 * -16300 =>   0xc054
 *  62300 => 0x00f35c
 * -62300 => 0xff0ca4
*/
function encode(r, s) {
  var lenR = r.length;
  var lenS = s.length;
  if (lenR === 0) throw new Error('R length is zero');
  if (lenS === 0) throw new Error('S length is zero');
  if (lenR > 33) throw new Error('R length is too long');
  if (lenS > 33) throw new Error('S length is too long');
  if (r[0] & 0x80) throw new Error('R value is negative');
  if (s[0] & 0x80) throw new Error('S value is negative');
  if (lenR > 1 && r[0] === 0x00 && !(r[1] & 0x80)) throw new Error('R value excessively padded');
  if (lenS > 1 && s[0] === 0x00 && !(s[1] & 0x80)) throw new Error('S value excessively padded');
  var signature = Buffer.allocUnsafe(6 + lenR + lenS);

  // 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S]
  signature[0] = 0x30;
  signature[1] = signature.length - 2;
  signature[2] = 0x02;
  signature[3] = r.length;
  r.copy(signature, 4);
  signature[4 + lenR] = 0x02;
  signature[5 + lenR] = s.length;
  s.copy(signature, 6 + lenR);
  return signature;
}
module.exports = {
  check: check,
  decode: decode,
  encode: encode
};

},{"safe-buffer":384}],103:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
(function (module, exports) {
  'use strict';

  // Utils
  function assert(val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
  }

  // Could use `inherits` module, but don't want to move from single file
  // architecture yet.
  function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function TempCtor() {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  }

  // BN

  function BN(number, base, endian) {
    if (BN.isBN(number)) {
      return number;
    }
    this.negative = 0;
    this.words = null;
    this.length = 0;

    // Reduction context
    this.red = null;
    if (number !== null) {
      if (base === 'le' || base === 'be') {
        endian = base;
        base = 10;
      }
      this._init(number || 0, base || 10, endian || 'be');
    }
  }
  if (_typeof(module) === 'object') {
    module.exports = BN;
  } else {
    exports.BN = BN;
  }
  BN.BN = BN;
  BN.wordSize = 26;
  var Buffer;
  try {
    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
      Buffer = window.Buffer;
    } else {
      Buffer = require('buffer').Buffer;
    }
  } catch (e) {}
  BN.isBN = function isBN(num) {
    if (num instanceof BN) {
      return true;
    }
    return num !== null && _typeof(num) === 'object' && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
  };
  BN.max = function max(left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
  };
  BN.min = function min(left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
  };
  BN.prototype._init = function init(number, base, endian) {
    if (typeof number === 'number') {
      return this._initNumber(number, base, endian);
    }
    if (_typeof(number) === 'object') {
      return this._initArray(number, base, endian);
    }
    if (base === 'hex') {
      base = 16;
    }
    assert(base === (base | 0) && base >= 2 && base <= 36);
    number = number.toString().replace(/\s+/g, '');
    var start = 0;
    if (number[0] === '-') {
      start++;
      this.negative = 1;
    }
    if (start < number.length) {
      if (base === 16) {
        this._parseHex(number, start, endian);
      } else {
        this._parseBase(number, base, start);
        if (endian === 'le') {
          this._initArray(this.toArray(), base, endian);
        }
      }
    }
  };
  BN.prototype._initNumber = function _initNumber(number, base, endian) {
    if (number < 0) {
      this.negative = 1;
      number = -number;
    }
    if (number < 0x4000000) {
      this.words = [number & 0x3ffffff];
      this.length = 1;
    } else if (number < 0x10000000000000) {
      this.words = [number & 0x3ffffff, number / 0x4000000 & 0x3ffffff];
      this.length = 2;
    } else {
      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
      this.words = [number & 0x3ffffff, number / 0x4000000 & 0x3ffffff, 1];
      this.length = 3;
    }
    if (endian !== 'le') return;

    // Reverse the bytes
    this._initArray(this.toArray(), base, endian);
  };
  BN.prototype._initArray = function _initArray(number, base, endian) {
    // Perhaps a Uint8Array
    assert(typeof number.length === 'number');
    if (number.length <= 0) {
      this.words = [0];
      this.length = 1;
      return this;
    }
    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }
    var j, w;
    var off = 0;
    if (endian === 'be') {
      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
        w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
        this.words[j] |= w << off & 0x3ffffff;
        this.words[j + 1] = w >>> 26 - off & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    } else if (endian === 'le') {
      for (i = 0, j = 0; i < number.length; i += 3) {
        w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
        this.words[j] |= w << off & 0x3ffffff;
        this.words[j + 1] = w >>> 26 - off & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    }
    return this.strip();
  };
  function parseHex4Bits(string, index) {
    var c = string.charCodeAt(index);
    // 'A' - 'F'
    if (c >= 65 && c <= 70) {
      return c - 55;
      // 'a' - 'f'
    } else if (c >= 97 && c <= 102) {
      return c - 87;
      // '0' - '9'
    } else {
      return c - 48 & 0xf;
    }
  }
  function parseHexByte(string, lowerBound, index) {
    var r = parseHex4Bits(string, index);
    if (index - 1 >= lowerBound) {
      r |= parseHex4Bits(string, index - 1) << 4;
    }
    return r;
  }
  BN.prototype._parseHex = function _parseHex(number, start, endian) {
    // Create possibly bigger array to ensure that it fits the number
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    // 24-bits chunks
    var off = 0;
    var j = 0;
    var w;
    if (endian === 'be') {
      for (i = number.length - 1; i >= start; i -= 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    } else {
      var parseLength = number.length - start;
      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    }
    this.strip();
  };
  function parseBase(str, start, end, mul) {
    var r = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;
      r *= mul;

      // 'a'
      if (c >= 49) {
        r += c - 49 + 0xa;

        // 'A'
      } else if (c >= 17) {
        r += c - 17 + 0xa;

        // '0' - '9'
      } else {
        r += c;
      }
    }
    return r;
  }
  BN.prototype._parseBase = function _parseBase(number, base, start) {
    // Initialize as zero
    this.words = [0];
    this.length = 1;

    // Find length of limb in base
    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
      limbLen++;
    }
    limbLen--;
    limbPow = limbPow / base | 0;
    var total = number.length - start;
    var mod = total % limbLen;
    var end = Math.min(total, total - mod) + start;
    var word = 0;
    for (var i = start; i < end; i += limbLen) {
      word = parseBase(number, i, i + limbLen, base);
      this.imuln(limbPow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }
    if (mod !== 0) {
      var pow = 1;
      word = parseBase(number, i, number.length, base);
      for (i = 0; i < mod; i++) {
        pow *= base;
      }
      this.imuln(pow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }
    this.strip();
  };
  BN.prototype.copy = function copy(dest) {
    dest.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      dest.words[i] = this.words[i];
    }
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
  };
  BN.prototype.clone = function clone() {
    var r = new BN(null);
    this.copy(r);
    return r;
  };
  BN.prototype._expand = function _expand(size) {
    while (this.length < size) {
      this.words[this.length++] = 0;
    }
    return this;
  };

  // Remove leading `0` from `this`
  BN.prototype.strip = function strip() {
    while (this.length > 1 && this.words[this.length - 1] === 0) {
      this.length--;
    }
    return this._normSign();
  };
  BN.prototype._normSign = function _normSign() {
    // -0 = 0
    if (this.length === 1 && this.words[0] === 0) {
      this.negative = 0;
    }
    return this;
  };
  BN.prototype.inspect = function inspect() {
    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
  };

  /*
   var zeros = [];
  var groupSizes = [];
  var groupBases = [];
   var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }
   */

  var zeros = ['', '0', '00', '000', '0000', '00000', '000000', '0000000', '00000000', '000000000', '0000000000', '00000000000', '000000000000', '0000000000000', '00000000000000', '000000000000000', '0000000000000000', '00000000000000000', '000000000000000000', '0000000000000000000', '00000000000000000000', '000000000000000000000', '0000000000000000000000', '00000000000000000000000', '000000000000000000000000', '0000000000000000000000000'];
  var groupSizes = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5];
  var groupBases = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
  BN.prototype.toString = function toString(base, padding) {
    base = base || 10;
    padding = padding | 0 || 1;
    var out;
    if (base === 16 || base === 'hex') {
      out = '';
      var off = 0;
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = this.words[i];
        var word = ((w << off | carry) & 0xffffff).toString(16);
        carry = w >>> 24 - off & 0xffffff;
        if (carry !== 0 || i !== this.length - 1) {
          out = zeros[6 - word.length] + word + out;
        } else {
          out = word + out;
        }
        off += 2;
        if (off >= 26) {
          off -= 26;
          i--;
        }
      }
      if (carry !== 0) {
        out = carry.toString(16) + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }
    if (base === (base | 0) && base >= 2 && base <= 36) {
      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
      var groupSize = groupSizes[base];
      // var groupBase = Math.pow(base, groupSize);
      var groupBase = groupBases[base];
      out = '';
      var c = this.clone();
      c.negative = 0;
      while (!c.isZero()) {
        var r = c.modn(groupBase).toString(base);
        c = c.idivn(groupBase);
        if (!c.isZero()) {
          out = zeros[groupSize - r.length] + r + out;
        } else {
          out = r + out;
        }
      }
      if (this.isZero()) {
        out = '0' + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }
    assert(false, 'Base should be between 2 and 36');
  };
  BN.prototype.toNumber = function toNumber() {
    var ret = this.words[0];
    if (this.length === 2) {
      ret += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
      // NOTE: at this stage it is known that the top bit is set
      ret += 0x10000000000000 + this.words[1] * 0x4000000;
    } else if (this.length > 2) {
      assert(false, 'Number can only safely store up to 53 bits');
    }
    return this.negative !== 0 ? -ret : ret;
  };
  BN.prototype.toJSON = function toJSON() {
    return this.toString(16);
  };
  BN.prototype.toBuffer = function toBuffer(endian, length) {
    assert(typeof Buffer !== 'undefined');
    return this.toArrayLike(Buffer, endian, length);
  };
  BN.prototype.toArray = function toArray(endian, length) {
    return this.toArrayLike(Array, endian, length);
  };
  BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert(byteLength <= reqLength, 'byte array longer than desired length');
    assert(reqLength > 0, 'Requested array length <= 0');
    this.strip();
    var littleEndian = endian === 'le';
    var res = new ArrayType(reqLength);
    var b, i;
    var q = this.clone();
    if (!littleEndian) {
      // Assume big-endian
      for (i = 0; i < reqLength - byteLength; i++) {
        res[i] = 0;
      }
      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);
        res[reqLength - i - 1] = b;
      }
    } else {
      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);
        res[i] = b;
      }
      for (; i < reqLength; i++) {
        res[i] = 0;
      }
    }
    return res;
  };
  if (Math.clz32) {
    BN.prototype._countBits = function _countBits(w) {
      return 32 - Math.clz32(w);
    };
  } else {
    BN.prototype._countBits = function _countBits(w) {
      var t = w;
      var r = 0;
      if (t >= 0x1000) {
        r += 13;
        t >>>= 13;
      }
      if (t >= 0x40) {
        r += 7;
        t >>>= 7;
      }
      if (t >= 0x8) {
        r += 4;
        t >>>= 4;
      }
      if (t >= 0x02) {
        r += 2;
        t >>>= 2;
      }
      return r + t;
    };
  }
  BN.prototype._zeroBits = function _zeroBits(w) {
    // Short-cut
    if (w === 0) return 26;
    var t = w;
    var r = 0;
    if ((t & 0x1fff) === 0) {
      r += 13;
      t >>>= 13;
    }
    if ((t & 0x7f) === 0) {
      r += 7;
      t >>>= 7;
    }
    if ((t & 0xf) === 0) {
      r += 4;
      t >>>= 4;
    }
    if ((t & 0x3) === 0) {
      r += 2;
      t >>>= 2;
    }
    if ((t & 0x1) === 0) {
      r++;
    }
    return r;
  };

  // Return number of used bits in a BN
  BN.prototype.bitLength = function bitLength() {
    var w = this.words[this.length - 1];
    var hi = this._countBits(w);
    return (this.length - 1) * 26 + hi;
  };
  function toBitArray(num) {
    var w = new Array(num.bitLength());
    for (var bit = 0; bit < w.length; bit++) {
      var off = bit / 26 | 0;
      var wbit = bit % 26;
      w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
    }
    return w;
  }

  // Number of trailing zero bits
  BN.prototype.zeroBits = function zeroBits() {
    if (this.isZero()) return 0;
    var r = 0;
    for (var i = 0; i < this.length; i++) {
      var b = this._zeroBits(this.words[i]);
      r += b;
      if (b !== 26) break;
    }
    return r;
  };
  BN.prototype.byteLength = function byteLength() {
    return Math.ceil(this.bitLength() / 8);
  };
  BN.prototype.toTwos = function toTwos(width) {
    if (this.negative !== 0) {
      return this.abs().inotn(width).iaddn(1);
    }
    return this.clone();
  };
  BN.prototype.fromTwos = function fromTwos(width) {
    if (this.testn(width - 1)) {
      return this.notn(width).iaddn(1).ineg();
    }
    return this.clone();
  };
  BN.prototype.isNeg = function isNeg() {
    return this.negative !== 0;
  };

  // Return negative clone of `this`
  BN.prototype.neg = function neg() {
    return this.clone().ineg();
  };
  BN.prototype.ineg = function ineg() {
    if (!this.isZero()) {
      this.negative ^= 1;
    }
    return this;
  };

  // Or `num` with `this` in-place
  BN.prototype.iuor = function iuor(num) {
    while (this.length < num.length) {
      this.words[this.length++] = 0;
    }
    for (var i = 0; i < num.length; i++) {
      this.words[i] = this.words[i] | num.words[i];
    }
    return this.strip();
  };
  BN.prototype.ior = function ior(num) {
    assert((this.negative | num.negative) === 0);
    return this.iuor(num);
  };

  // Or `num` with `this`
  BN.prototype.or = function or(num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
  };
  BN.prototype.uor = function uor(num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
  };

  // And `num` with `this` in-place
  BN.prototype.iuand = function iuand(num) {
    // b = min-length(num, this)
    var b;
    if (this.length > num.length) {
      b = num;
    } else {
      b = this;
    }
    for (var i = 0; i < b.length; i++) {
      this.words[i] = this.words[i] & num.words[i];
    }
    this.length = b.length;
    return this.strip();
  };
  BN.prototype.iand = function iand(num) {
    assert((this.negative | num.negative) === 0);
    return this.iuand(num);
  };

  // And `num` with `this`
  BN.prototype.and = function and(num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
  };
  BN.prototype.uand = function uand(num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
  };

  // Xor `num` with `this` in-place
  BN.prototype.iuxor = function iuxor(num) {
    // a.length > b.length
    var a;
    var b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }
    for (var i = 0; i < b.length; i++) {
      this.words[i] = a.words[i] ^ b.words[i];
    }
    if (this !== a) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }
    this.length = a.length;
    return this.strip();
  };
  BN.prototype.ixor = function ixor(num) {
    assert((this.negative | num.negative) === 0);
    return this.iuxor(num);
  };

  // Xor `num` with `this`
  BN.prototype.xor = function xor(num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
  };
  BN.prototype.uxor = function uxor(num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
  };

  // Not ``this`` with ``width`` bitwidth
  BN.prototype.inotn = function inotn(width) {
    assert(typeof width === 'number' && width >= 0);
    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26;

    // Extend the buffer with leading zeroes
    this._expand(bytesNeeded);
    if (bitsLeft > 0) {
      bytesNeeded--;
    }

    // Handle complete words
    for (var i = 0; i < bytesNeeded; i++) {
      this.words[i] = ~this.words[i] & 0x3ffffff;
    }

    // Handle the residue
    if (bitsLeft > 0) {
      this.words[i] = ~this.words[i] & 0x3ffffff >> 26 - bitsLeft;
    }

    // And remove leading zeroes
    return this.strip();
  };
  BN.prototype.notn = function notn(width) {
    return this.clone().inotn(width);
  };

  // Set `bit` of `this`
  BN.prototype.setn = function setn(bit, val) {
    assert(typeof bit === 'number' && bit >= 0);
    var off = bit / 26 | 0;
    var wbit = bit % 26;
    this._expand(off + 1);
    if (val) {
      this.words[off] = this.words[off] | 1 << wbit;
    } else {
      this.words[off] = this.words[off] & ~(1 << wbit);
    }
    return this.strip();
  };

  // Add `num` to `this` in-place
  BN.prototype.iadd = function iadd(num) {
    var r;

    // negative + positive
    if (this.negative !== 0 && num.negative === 0) {
      this.negative = 0;
      r = this.isub(num);
      this.negative ^= 1;
      return this._normSign();

      // positive + negative
    } else if (this.negative === 0 && num.negative !== 0) {
      num.negative = 0;
      r = this.isub(num);
      num.negative = 1;
      return r._normSign();
    }

    // a.length > b.length
    var a, b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }
    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }
    this.length = a.length;
    if (carry !== 0) {
      this.words[this.length] = carry;
      this.length++;
      // Copy the rest of the words
    } else if (a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }
    return this;
  };

  // Add `num` to `this`
  BN.prototype.add = function add(num) {
    var res;
    if (num.negative !== 0 && this.negative === 0) {
      num.negative = 0;
      res = this.sub(num);
      num.negative ^= 1;
      return res;
    } else if (num.negative === 0 && this.negative !== 0) {
      this.negative = 0;
      res = num.sub(this);
      this.negative = 1;
      return res;
    }
    if (this.length > num.length) return this.clone().iadd(num);
    return num.clone().iadd(this);
  };

  // Subtract `num` from `this` in-place
  BN.prototype.isub = function isub(num) {
    // this - (-num) = this + num
    if (num.negative !== 0) {
      num.negative = 0;
      var r = this.iadd(num);
      num.negative = 1;
      return r._normSign();

      // -this - num = -(this + num)
    } else if (this.negative !== 0) {
      this.negative = 0;
      this.iadd(num);
      this.negative = 1;
      return this._normSign();
    }

    // At this point both numbers are positive
    var cmp = this.cmp(num);

    // Optimization - zeroify
    if (cmp === 0) {
      this.negative = 0;
      this.length = 1;
      this.words[0] = 0;
      return this;
    }

    // a > b
    var a, b;
    if (cmp > 0) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }
    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }

    // Copy rest of the words
    if (carry === 0 && i < a.length && a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }
    this.length = Math.max(this.length, i);
    if (a !== this) {
      this.negative = 1;
    }
    return this.strip();
  };

  // Subtract `num` from `this`
  BN.prototype.sub = function sub(num) {
    return this.clone().isub(num);
  };
  function smallMulTo(self, num, out) {
    out.negative = num.negative ^ self.negative;
    var len = self.length + num.length | 0;
    out.length = len;
    len = len - 1 | 0;

    // Peel one iteration (compiler can't do it, because of code complexity)
    var a = self.words[0] | 0;
    var b = num.words[0] | 0;
    var r = a * b;
    var lo = r & 0x3ffffff;
    var carry = r / 0x4000000 | 0;
    out.words[0] = lo;
    for (var k = 1; k < len; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = carry >>> 26;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j | 0;
        a = self.words[i] | 0;
        b = num.words[j] | 0;
        r = a * b + rword;
        ncarry += r / 0x4000000 | 0;
        rword = r & 0x3ffffff;
      }
      out.words[k] = rword | 0;
      carry = ncarry | 0;
    }
    if (carry !== 0) {
      out.words[k] = carry | 0;
    } else {
      out.length--;
    }
    return out.strip();
  }

  // TODO(indutny): it may be reasonable to omit it for users who don't need
  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
  // multiplication (like elliptic secp256k1).
  var comb10MulTo = function comb10MulTo(self, num, out) {
    var a = self.words;
    var b = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;
    out.negative = self.negative ^ num.negative;
    out.length = 19;
    /* k = 0 */
    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = mid + Math.imul(ah0, bl0) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
    w0 &= 0x3ffffff;
    /* k = 1 */
    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = mid + Math.imul(ah1, bl0) | 0;
    hi = Math.imul(ah1, bh0);
    lo = lo + Math.imul(al0, bl1) | 0;
    mid = mid + Math.imul(al0, bh1) | 0;
    mid = mid + Math.imul(ah0, bl1) | 0;
    hi = hi + Math.imul(ah0, bh1) | 0;
    var w1 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
    w1 &= 0x3ffffff;
    /* k = 2 */
    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = mid + Math.imul(ah2, bl0) | 0;
    hi = Math.imul(ah2, bh0);
    lo = lo + Math.imul(al1, bl1) | 0;
    mid = mid + Math.imul(al1, bh1) | 0;
    mid = mid + Math.imul(ah1, bl1) | 0;
    hi = hi + Math.imul(ah1, bh1) | 0;
    lo = lo + Math.imul(al0, bl2) | 0;
    mid = mid + Math.imul(al0, bh2) | 0;
    mid = mid + Math.imul(ah0, bl2) | 0;
    hi = hi + Math.imul(ah0, bh2) | 0;
    var w2 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
    w2 &= 0x3ffffff;
    /* k = 3 */
    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = mid + Math.imul(ah3, bl0) | 0;
    hi = Math.imul(ah3, bh0);
    lo = lo + Math.imul(al2, bl1) | 0;
    mid = mid + Math.imul(al2, bh1) | 0;
    mid = mid + Math.imul(ah2, bl1) | 0;
    hi = hi + Math.imul(ah2, bh1) | 0;
    lo = lo + Math.imul(al1, bl2) | 0;
    mid = mid + Math.imul(al1, bh2) | 0;
    mid = mid + Math.imul(ah1, bl2) | 0;
    hi = hi + Math.imul(ah1, bh2) | 0;
    lo = lo + Math.imul(al0, bl3) | 0;
    mid = mid + Math.imul(al0, bh3) | 0;
    mid = mid + Math.imul(ah0, bl3) | 0;
    hi = hi + Math.imul(ah0, bh3) | 0;
    var w3 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
    w3 &= 0x3ffffff;
    /* k = 4 */
    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = mid + Math.imul(ah4, bl0) | 0;
    hi = Math.imul(ah4, bh0);
    lo = lo + Math.imul(al3, bl1) | 0;
    mid = mid + Math.imul(al3, bh1) | 0;
    mid = mid + Math.imul(ah3, bl1) | 0;
    hi = hi + Math.imul(ah3, bh1) | 0;
    lo = lo + Math.imul(al2, bl2) | 0;
    mid = mid + Math.imul(al2, bh2) | 0;
    mid = mid + Math.imul(ah2, bl2) | 0;
    hi = hi + Math.imul(ah2, bh2) | 0;
    lo = lo + Math.imul(al1, bl3) | 0;
    mid = mid + Math.imul(al1, bh3) | 0;
    mid = mid + Math.imul(ah1, bl3) | 0;
    hi = hi + Math.imul(ah1, bh3) | 0;
    lo = lo + Math.imul(al0, bl4) | 0;
    mid = mid + Math.imul(al0, bh4) | 0;
    mid = mid + Math.imul(ah0, bl4) | 0;
    hi = hi + Math.imul(ah0, bh4) | 0;
    var w4 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
    w4 &= 0x3ffffff;
    /* k = 5 */
    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = mid + Math.imul(ah5, bl0) | 0;
    hi = Math.imul(ah5, bh0);
    lo = lo + Math.imul(al4, bl1) | 0;
    mid = mid + Math.imul(al4, bh1) | 0;
    mid = mid + Math.imul(ah4, bl1) | 0;
    hi = hi + Math.imul(ah4, bh1) | 0;
    lo = lo + Math.imul(al3, bl2) | 0;
    mid = mid + Math.imul(al3, bh2) | 0;
    mid = mid + Math.imul(ah3, bl2) | 0;
    hi = hi + Math.imul(ah3, bh2) | 0;
    lo = lo + Math.imul(al2, bl3) | 0;
    mid = mid + Math.imul(al2, bh3) | 0;
    mid = mid + Math.imul(ah2, bl3) | 0;
    hi = hi + Math.imul(ah2, bh3) | 0;
    lo = lo + Math.imul(al1, bl4) | 0;
    mid = mid + Math.imul(al1, bh4) | 0;
    mid = mid + Math.imul(ah1, bl4) | 0;
    hi = hi + Math.imul(ah1, bh4) | 0;
    lo = lo + Math.imul(al0, bl5) | 0;
    mid = mid + Math.imul(al0, bh5) | 0;
    mid = mid + Math.imul(ah0, bl5) | 0;
    hi = hi + Math.imul(ah0, bh5) | 0;
    var w5 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
    w5 &= 0x3ffffff;
    /* k = 6 */
    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = mid + Math.imul(ah6, bl0) | 0;
    hi = Math.imul(ah6, bh0);
    lo = lo + Math.imul(al5, bl1) | 0;
    mid = mid + Math.imul(al5, bh1) | 0;
    mid = mid + Math.imul(ah5, bl1) | 0;
    hi = hi + Math.imul(ah5, bh1) | 0;
    lo = lo + Math.imul(al4, bl2) | 0;
    mid = mid + Math.imul(al4, bh2) | 0;
    mid = mid + Math.imul(ah4, bl2) | 0;
    hi = hi + Math.imul(ah4, bh2) | 0;
    lo = lo + Math.imul(al3, bl3) | 0;
    mid = mid + Math.imul(al3, bh3) | 0;
    mid = mid + Math.imul(ah3, bl3) | 0;
    hi = hi + Math.imul(ah3, bh3) | 0;
    lo = lo + Math.imul(al2, bl4) | 0;
    mid = mid + Math.imul(al2, bh4) | 0;
    mid = mid + Math.imul(ah2, bl4) | 0;
    hi = hi + Math.imul(ah2, bh4) | 0;
    lo = lo + Math.imul(al1, bl5) | 0;
    mid = mid + Math.imul(al1, bh5) | 0;
    mid = mid + Math.imul(ah1, bl5) | 0;
    hi = hi + Math.imul(ah1, bh5) | 0;
    lo = lo + Math.imul(al0, bl6) | 0;
    mid = mid + Math.imul(al0, bh6) | 0;
    mid = mid + Math.imul(ah0, bl6) | 0;
    hi = hi + Math.imul(ah0, bh6) | 0;
    var w6 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
    w6 &= 0x3ffffff;
    /* k = 7 */
    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = mid + Math.imul(ah7, bl0) | 0;
    hi = Math.imul(ah7, bh0);
    lo = lo + Math.imul(al6, bl1) | 0;
    mid = mid + Math.imul(al6, bh1) | 0;
    mid = mid + Math.imul(ah6, bl1) | 0;
    hi = hi + Math.imul(ah6, bh1) | 0;
    lo = lo + Math.imul(al5, bl2) | 0;
    mid = mid + Math.imul(al5, bh2) | 0;
    mid = mid + Math.imul(ah5, bl2) | 0;
    hi = hi + Math.imul(ah5, bh2) | 0;
    lo = lo + Math.imul(al4, bl3) | 0;
    mid = mid + Math.imul(al4, bh3) | 0;
    mid = mid + Math.imul(ah4, bl3) | 0;
    hi = hi + Math.imul(ah4, bh3) | 0;
    lo = lo + Math.imul(al3, bl4) | 0;
    mid = mid + Math.imul(al3, bh4) | 0;
    mid = mid + Math.imul(ah3, bl4) | 0;
    hi = hi + Math.imul(ah3, bh4) | 0;
    lo = lo + Math.imul(al2, bl5) | 0;
    mid = mid + Math.imul(al2, bh5) | 0;
    mid = mid + Math.imul(ah2, bl5) | 0;
    hi = hi + Math.imul(ah2, bh5) | 0;
    lo = lo + Math.imul(al1, bl6) | 0;
    mid = mid + Math.imul(al1, bh6) | 0;
    mid = mid + Math.imul(ah1, bl6) | 0;
    hi = hi + Math.imul(ah1, bh6) | 0;
    lo = lo + Math.imul(al0, bl7) | 0;
    mid = mid + Math.imul(al0, bh7) | 0;
    mid = mid + Math.imul(ah0, bl7) | 0;
    hi = hi + Math.imul(ah0, bh7) | 0;
    var w7 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
    w7 &= 0x3ffffff;
    /* k = 8 */
    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = mid + Math.imul(ah8, bl0) | 0;
    hi = Math.imul(ah8, bh0);
    lo = lo + Math.imul(al7, bl1) | 0;
    mid = mid + Math.imul(al7, bh1) | 0;
    mid = mid + Math.imul(ah7, bl1) | 0;
    hi = hi + Math.imul(ah7, bh1) | 0;
    lo = lo + Math.imul(al6, bl2) | 0;
    mid = mid + Math.imul(al6, bh2) | 0;
    mid = mid + Math.imul(ah6, bl2) | 0;
    hi = hi + Math.imul(ah6, bh2) | 0;
    lo = lo + Math.imul(al5, bl3) | 0;
    mid = mid + Math.imul(al5, bh3) | 0;
    mid = mid + Math.imul(ah5, bl3) | 0;
    hi = hi + Math.imul(ah5, bh3) | 0;
    lo = lo + Math.imul(al4, bl4) | 0;
    mid = mid + Math.imul(al4, bh4) | 0;
    mid = mid + Math.imul(ah4, bl4) | 0;
    hi = hi + Math.imul(ah4, bh4) | 0;
    lo = lo + Math.imul(al3, bl5) | 0;
    mid = mid + Math.imul(al3, bh5) | 0;
    mid = mid + Math.imul(ah3, bl5) | 0;
    hi = hi + Math.imul(ah3, bh5) | 0;
    lo = lo + Math.imul(al2, bl6) | 0;
    mid = mid + Math.imul(al2, bh6) | 0;
    mid = mid + Math.imul(ah2, bl6) | 0;
    hi = hi + Math.imul(ah2, bh6) | 0;
    lo = lo + Math.imul(al1, bl7) | 0;
    mid = mid + Math.imul(al1, bh7) | 0;
    mid = mid + Math.imul(ah1, bl7) | 0;
    hi = hi + Math.imul(ah1, bh7) | 0;
    lo = lo + Math.imul(al0, bl8) | 0;
    mid = mid + Math.imul(al0, bh8) | 0;
    mid = mid + Math.imul(ah0, bl8) | 0;
    hi = hi + Math.imul(ah0, bh8) | 0;
    var w8 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
    w8 &= 0x3ffffff;
    /* k = 9 */
    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = mid + Math.imul(ah9, bl0) | 0;
    hi = Math.imul(ah9, bh0);
    lo = lo + Math.imul(al8, bl1) | 0;
    mid = mid + Math.imul(al8, bh1) | 0;
    mid = mid + Math.imul(ah8, bl1) | 0;
    hi = hi + Math.imul(ah8, bh1) | 0;
    lo = lo + Math.imul(al7, bl2) | 0;
    mid = mid + Math.imul(al7, bh2) | 0;
    mid = mid + Math.imul(ah7, bl2) | 0;
    hi = hi + Math.imul(ah7, bh2) | 0;
    lo = lo + Math.imul(al6, bl3) | 0;
    mid = mid + Math.imul(al6, bh3) | 0;
    mid = mid + Math.imul(ah6, bl3) | 0;
    hi = hi + Math.imul(ah6, bh3) | 0;
    lo = lo + Math.imul(al5, bl4) | 0;
    mid = mid + Math.imul(al5, bh4) | 0;
    mid = mid + Math.imul(ah5, bl4) | 0;
    hi = hi + Math.imul(ah5, bh4) | 0;
    lo = lo + Math.imul(al4, bl5) | 0;
    mid = mid + Math.imul(al4, bh5) | 0;
    mid = mid + Math.imul(ah4, bl5) | 0;
    hi = hi + Math.imul(ah4, bh5) | 0;
    lo = lo + Math.imul(al3, bl6) | 0;
    mid = mid + Math.imul(al3, bh6) | 0;
    mid = mid + Math.imul(ah3, bl6) | 0;
    hi = hi + Math.imul(ah3, bh6) | 0;
    lo = lo + Math.imul(al2, bl7) | 0;
    mid = mid + Math.imul(al2, bh7) | 0;
    mid = mid + Math.imul(ah2, bl7) | 0;
    hi = hi + Math.imul(ah2, bh7) | 0;
    lo = lo + Math.imul(al1, bl8) | 0;
    mid = mid + Math.imul(al1, bh8) | 0;
    mid = mid + Math.imul(ah1, bl8) | 0;
    hi = hi + Math.imul(ah1, bh8) | 0;
    lo = lo + Math.imul(al0, bl9) | 0;
    mid = mid + Math.imul(al0, bh9) | 0;
    mid = mid + Math.imul(ah0, bl9) | 0;
    hi = hi + Math.imul(ah0, bh9) | 0;
    var w9 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
    w9 &= 0x3ffffff;
    /* k = 10 */
    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = mid + Math.imul(ah9, bl1) | 0;
    hi = Math.imul(ah9, bh1);
    lo = lo + Math.imul(al8, bl2) | 0;
    mid = mid + Math.imul(al8, bh2) | 0;
    mid = mid + Math.imul(ah8, bl2) | 0;
    hi = hi + Math.imul(ah8, bh2) | 0;
    lo = lo + Math.imul(al7, bl3) | 0;
    mid = mid + Math.imul(al7, bh3) | 0;
    mid = mid + Math.imul(ah7, bl3) | 0;
    hi = hi + Math.imul(ah7, bh3) | 0;
    lo = lo + Math.imul(al6, bl4) | 0;
    mid = mid + Math.imul(al6, bh4) | 0;
    mid = mid + Math.imul(ah6, bl4) | 0;
    hi = hi + Math.imul(ah6, bh4) | 0;
    lo = lo + Math.imul(al5, bl5) | 0;
    mid = mid + Math.imul(al5, bh5) | 0;
    mid = mid + Math.imul(ah5, bl5) | 0;
    hi = hi + Math.imul(ah5, bh5) | 0;
    lo = lo + Math.imul(al4, bl6) | 0;
    mid = mid + Math.imul(al4, bh6) | 0;
    mid = mid + Math.imul(ah4, bl6) | 0;
    hi = hi + Math.imul(ah4, bh6) | 0;
    lo = lo + Math.imul(al3, bl7) | 0;
    mid = mid + Math.imul(al3, bh7) | 0;
    mid = mid + Math.imul(ah3, bl7) | 0;
    hi = hi + Math.imul(ah3, bh7) | 0;
    lo = lo + Math.imul(al2, bl8) | 0;
    mid = mid + Math.imul(al2, bh8) | 0;
    mid = mid + Math.imul(ah2, bl8) | 0;
    hi = hi + Math.imul(ah2, bh8) | 0;
    lo = lo + Math.imul(al1, bl9) | 0;
    mid = mid + Math.imul(al1, bh9) | 0;
    mid = mid + Math.imul(ah1, bl9) | 0;
    hi = hi + Math.imul(ah1, bh9) | 0;
    var w10 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
    w10 &= 0x3ffffff;
    /* k = 11 */
    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = mid + Math.imul(ah9, bl2) | 0;
    hi = Math.imul(ah9, bh2);
    lo = lo + Math.imul(al8, bl3) | 0;
    mid = mid + Math.imul(al8, bh3) | 0;
    mid = mid + Math.imul(ah8, bl3) | 0;
    hi = hi + Math.imul(ah8, bh3) | 0;
    lo = lo + Math.imul(al7, bl4) | 0;
    mid = mid + Math.imul(al7, bh4) | 0;
    mid = mid + Math.imul(ah7, bl4) | 0;
    hi = hi + Math.imul(ah7, bh4) | 0;
    lo = lo + Math.imul(al6, bl5) | 0;
    mid = mid + Math.imul(al6, bh5) | 0;
    mid = mid + Math.imul(ah6, bl5) | 0;
    hi = hi + Math.imul(ah6, bh5) | 0;
    lo = lo + Math.imul(al5, bl6) | 0;
    mid = mid + Math.imul(al5, bh6) | 0;
    mid = mid + Math.imul(ah5, bl6) | 0;
    hi = hi + Math.imul(ah5, bh6) | 0;
    lo = lo + Math.imul(al4, bl7) | 0;
    mid = mid + Math.imul(al4, bh7) | 0;
    mid = mid + Math.imul(ah4, bl7) | 0;
    hi = hi + Math.imul(ah4, bh7) | 0;
    lo = lo + Math.imul(al3, bl8) | 0;
    mid = mid + Math.imul(al3, bh8) | 0;
    mid = mid + Math.imul(ah3, bl8) | 0;
    hi = hi + Math.imul(ah3, bh8) | 0;
    lo = lo + Math.imul(al2, bl9) | 0;
    mid = mid + Math.imul(al2, bh9) | 0;
    mid = mid + Math.imul(ah2, bl9) | 0;
    hi = hi + Math.imul(ah2, bh9) | 0;
    var w11 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
    w11 &= 0x3ffffff;
    /* k = 12 */
    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = mid + Math.imul(ah9, bl3) | 0;
    hi = Math.imul(ah9, bh3);
    lo = lo + Math.imul(al8, bl4) | 0;
    mid = mid + Math.imul(al8, bh4) | 0;
    mid = mid + Math.imul(ah8, bl4) | 0;
    hi = hi + Math.imul(ah8, bh4) | 0;
    lo = lo + Math.imul(al7, bl5) | 0;
    mid = mid + Math.imul(al7, bh5) | 0;
    mid = mid + Math.imul(ah7, bl5) | 0;
    hi = hi + Math.imul(ah7, bh5) | 0;
    lo = lo + Math.imul(al6, bl6) | 0;
    mid = mid + Math.imul(al6, bh6) | 0;
    mid = mid + Math.imul(ah6, bl6) | 0;
    hi = hi + Math.imul(ah6, bh6) | 0;
    lo = lo + Math.imul(al5, bl7) | 0;
    mid = mid + Math.imul(al5, bh7) | 0;
    mid = mid + Math.imul(ah5, bl7) | 0;
    hi = hi + Math.imul(ah5, bh7) | 0;
    lo = lo + Math.imul(al4, bl8) | 0;
    mid = mid + Math.imul(al4, bh8) | 0;
    mid = mid + Math.imul(ah4, bl8) | 0;
    hi = hi + Math.imul(ah4, bh8) | 0;
    lo = lo + Math.imul(al3, bl9) | 0;
    mid = mid + Math.imul(al3, bh9) | 0;
    mid = mid + Math.imul(ah3, bl9) | 0;
    hi = hi + Math.imul(ah3, bh9) | 0;
    var w12 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
    w12 &= 0x3ffffff;
    /* k = 13 */
    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = mid + Math.imul(ah9, bl4) | 0;
    hi = Math.imul(ah9, bh4);
    lo = lo + Math.imul(al8, bl5) | 0;
    mid = mid + Math.imul(al8, bh5) | 0;
    mid = mid + Math.imul(ah8, bl5) | 0;
    hi = hi + Math.imul(ah8, bh5) | 0;
    lo = lo + Math.imul(al7, bl6) | 0;
    mid = mid + Math.imul(al7, bh6) | 0;
    mid = mid + Math.imul(ah7, bl6) | 0;
    hi = hi + Math.imul(ah7, bh6) | 0;
    lo = lo + Math.imul(al6, bl7) | 0;
    mid = mid + Math.imul(al6, bh7) | 0;
    mid = mid + Math.imul(ah6, bl7) | 0;
    hi = hi + Math.imul(ah6, bh7) | 0;
    lo = lo + Math.imul(al5, bl8) | 0;
    mid = mid + Math.imul(al5, bh8) | 0;
    mid = mid + Math.imul(ah5, bl8) | 0;
    hi = hi + Math.imul(ah5, bh8) | 0;
    lo = lo + Math.imul(al4, bl9) | 0;
    mid = mid + Math.imul(al4, bh9) | 0;
    mid = mid + Math.imul(ah4, bl9) | 0;
    hi = hi + Math.imul(ah4, bh9) | 0;
    var w13 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
    w13 &= 0x3ffffff;
    /* k = 14 */
    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = mid + Math.imul(ah9, bl5) | 0;
    hi = Math.imul(ah9, bh5);
    lo = lo + Math.imul(al8, bl6) | 0;
    mid = mid + Math.imul(al8, bh6) | 0;
    mid = mid + Math.imul(ah8, bl6) | 0;
    hi = hi + Math.imul(ah8, bh6) | 0;
    lo = lo + Math.imul(al7, bl7) | 0;
    mid = mid + Math.imul(al7, bh7) | 0;
    mid = mid + Math.imul(ah7, bl7) | 0;
    hi = hi + Math.imul(ah7, bh7) | 0;
    lo = lo + Math.imul(al6, bl8) | 0;
    mid = mid + Math.imul(al6, bh8) | 0;
    mid = mid + Math.imul(ah6, bl8) | 0;
    hi = hi + Math.imul(ah6, bh8) | 0;
    lo = lo + Math.imul(al5, bl9) | 0;
    mid = mid + Math.imul(al5, bh9) | 0;
    mid = mid + Math.imul(ah5, bl9) | 0;
    hi = hi + Math.imul(ah5, bh9) | 0;
    var w14 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
    w14 &= 0x3ffffff;
    /* k = 15 */
    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = mid + Math.imul(ah9, bl6) | 0;
    hi = Math.imul(ah9, bh6);
    lo = lo + Math.imul(al8, bl7) | 0;
    mid = mid + Math.imul(al8, bh7) | 0;
    mid = mid + Math.imul(ah8, bl7) | 0;
    hi = hi + Math.imul(ah8, bh7) | 0;
    lo = lo + Math.imul(al7, bl8) | 0;
    mid = mid + Math.imul(al7, bh8) | 0;
    mid = mid + Math.imul(ah7, bl8) | 0;
    hi = hi + Math.imul(ah7, bh8) | 0;
    lo = lo + Math.imul(al6, bl9) | 0;
    mid = mid + Math.imul(al6, bh9) | 0;
    mid = mid + Math.imul(ah6, bl9) | 0;
    hi = hi + Math.imul(ah6, bh9) | 0;
    var w15 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
    w15 &= 0x3ffffff;
    /* k = 16 */
    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = mid + Math.imul(ah9, bl7) | 0;
    hi = Math.imul(ah9, bh7);
    lo = lo + Math.imul(al8, bl8) | 0;
    mid = mid + Math.imul(al8, bh8) | 0;
    mid = mid + Math.imul(ah8, bl8) | 0;
    hi = hi + Math.imul(ah8, bh8) | 0;
    lo = lo + Math.imul(al7, bl9) | 0;
    mid = mid + Math.imul(al7, bh9) | 0;
    mid = mid + Math.imul(ah7, bl9) | 0;
    hi = hi + Math.imul(ah7, bh9) | 0;
    var w16 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
    w16 &= 0x3ffffff;
    /* k = 17 */
    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = mid + Math.imul(ah9, bl8) | 0;
    hi = Math.imul(ah9, bh8);
    lo = lo + Math.imul(al8, bl9) | 0;
    mid = mid + Math.imul(al8, bh9) | 0;
    mid = mid + Math.imul(ah8, bl9) | 0;
    hi = hi + Math.imul(ah8, bh9) | 0;
    var w17 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
    w17 &= 0x3ffffff;
    /* k = 18 */
    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = mid + Math.imul(ah9, bl9) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;
    if (c !== 0) {
      o[19] = c;
      out.length++;
    }
    return out;
  };

  // Polyfill comb
  if (!Math.imul) {
    comb10MulTo = smallMulTo;
  }
  function bigMulTo(self, num, out) {
    out.negative = num.negative ^ self.negative;
    out.length = self.length + num.length;
    var carry = 0;
    var hncarry = 0;
    for (var k = 0; k < out.length - 1; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = hncarry;
      hncarry = 0;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j;
        var a = self.words[i] | 0;
        var b = num.words[j] | 0;
        var r = a * b;
        var lo = r & 0x3ffffff;
        ncarry = ncarry + (r / 0x4000000 | 0) | 0;
        lo = lo + rword | 0;
        rword = lo & 0x3ffffff;
        ncarry = ncarry + (lo >>> 26) | 0;
        hncarry += ncarry >>> 26;
        ncarry &= 0x3ffffff;
      }
      out.words[k] = rword;
      carry = ncarry;
      ncarry = hncarry;
    }
    if (carry !== 0) {
      out.words[k] = carry;
    } else {
      out.length--;
    }
    return out.strip();
  }
  function jumboMulTo(self, num, out) {
    var fftm = new FFTM();
    return fftm.mulp(self, num, out);
  }
  BN.prototype.mulTo = function mulTo(num, out) {
    var res;
    var len = this.length + num.length;
    if (this.length === 10 && num.length === 10) {
      res = comb10MulTo(this, num, out);
    } else if (len < 63) {
      res = smallMulTo(this, num, out);
    } else if (len < 1024) {
      res = bigMulTo(this, num, out);
    } else {
      res = jumboMulTo(this, num, out);
    }
    return res;
  };

  // Cooley-Tukey algorithm for FFT
  // slightly revisited to rely on looping instead of recursion

  function FFTM(x, y) {
    this.x = x;
    this.y = y;
  }
  FFTM.prototype.makeRBT = function makeRBT(N) {
    var t = new Array(N);
    var l = BN.prototype._countBits(N) - 1;
    for (var i = 0; i < N; i++) {
      t[i] = this.revBin(i, l, N);
    }
    return t;
  };

  // Returns binary-reversed representation of `x`
  FFTM.prototype.revBin = function revBin(x, l, N) {
    if (x === 0 || x === N - 1) return x;
    var rb = 0;
    for (var i = 0; i < l; i++) {
      rb |= (x & 1) << l - i - 1;
      x >>= 1;
    }
    return rb;
  };

  // Performs "tweedling" phase, therefore 'emulating'
  // behaviour of the recursive algorithm
  FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
    for (var i = 0; i < N; i++) {
      rtws[i] = rws[rbt[i]];
      itws[i] = iws[rbt[i]];
    }
  };
  FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);
    for (var s = 1; s < N; s <<= 1) {
      var l = s << 1;
      var rtwdf = Math.cos(2 * Math.PI / l);
      var itwdf = Math.sin(2 * Math.PI / l);
      for (var p = 0; p < N; p += l) {
        var rtwdf_ = rtwdf;
        var itwdf_ = itwdf;
        for (var j = 0; j < s; j++) {
          var re = rtws[p + j];
          var ie = itws[p + j];
          var ro = rtws[p + j + s];
          var io = itws[p + j + s];
          var rx = rtwdf_ * ro - itwdf_ * io;
          io = rtwdf_ * io + itwdf_ * ro;
          ro = rx;
          rtws[p + j] = re + ro;
          itws[p + j] = ie + io;
          rtws[p + j + s] = re - ro;
          itws[p + j + s] = ie - io;

          /* jshint maxdepth : false */
          if (j !== l) {
            rx = rtwdf * rtwdf_ - itwdf * itwdf_;
            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
            rtwdf_ = rx;
          }
        }
      }
    }
  };
  FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
    var N = Math.max(m, n) | 1;
    var odd = N & 1;
    var i = 0;
    for (N = N / 2 | 0; N; N = N >>> 1) {
      i++;
    }
    return 1 << i + 1 + odd;
  };
  FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
    if (N <= 1) return;
    for (var i = 0; i < N / 2; i++) {
      var t = rws[i];
      rws[i] = rws[N - i - 1];
      rws[N - i - 1] = t;
      t = iws[i];
      iws[i] = -iws[N - i - 1];
      iws[N - i - 1] = -t;
    }
  };
  FFTM.prototype.normalize13b = function normalize13b(ws, N) {
    var carry = 0;
    for (var i = 0; i < N / 2; i++) {
      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 + Math.round(ws[2 * i] / N) + carry;
      ws[i] = w & 0x3ffffff;
      if (w < 0x4000000) {
        carry = 0;
      } else {
        carry = w / 0x4000000 | 0;
      }
    }
    return ws;
  };
  FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
    var carry = 0;
    for (var i = 0; i < len; i++) {
      carry = carry + (ws[i] | 0);
      rws[2 * i] = carry & 0x1fff;
      carry = carry >>> 13;
      rws[2 * i + 1] = carry & 0x1fff;
      carry = carry >>> 13;
    }

    // Pad with zeroes
    for (i = 2 * len; i < N; ++i) {
      rws[i] = 0;
    }
    assert(carry === 0);
    assert((carry & ~0x1fff) === 0);
  };
  FFTM.prototype.stub = function stub(N) {
    var ph = new Array(N);
    for (var i = 0; i < N; i++) {
      ph[i] = 0;
    }
    return ph;
  };
  FFTM.prototype.mulp = function mulp(x, y, out) {
    var N = 2 * this.guessLen13b(x.length, y.length);
    var rbt = this.makeRBT(N);
    var _ = this.stub(N);
    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);
    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);
    var rmws = out.words;
    rmws.length = N;
    this.convert13b(x.words, x.length, rws, N);
    this.convert13b(y.words, y.length, nrws, N);
    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);
    for (var i = 0; i < N; i++) {
      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
      rwst[i] = rx;
    }
    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);
    out.negative = x.negative ^ y.negative;
    out.length = x.length + y.length;
    return out.strip();
  };

  // Multiply `this` by `num`
  BN.prototype.mul = function mul(num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
  };

  // Multiply employing FFT
  BN.prototype.mulf = function mulf(num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
  };

  // In-place Multiplication
  BN.prototype.imul = function imul(num) {
    return this.clone().mulTo(num, this);
  };
  BN.prototype.imuln = function imuln(num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);

    // Carry
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = (this.words[i] | 0) * num;
      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
      carry >>= 26;
      carry += w / 0x4000000 | 0;
      // NOTE: lo is 27bit maximum
      carry += lo >>> 26;
      this.words[i] = lo & 0x3ffffff;
    }
    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    return this;
  };
  BN.prototype.muln = function muln(num) {
    return this.clone().imuln(num);
  };

  // `this` * `this`
  BN.prototype.sqr = function sqr() {
    return this.mul(this);
  };

  // `this` * `this` in-place
  BN.prototype.isqr = function isqr() {
    return this.imul(this.clone());
  };

  // Math.pow(`this`, `num`)
  BN.prototype.pow = function pow(num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1);

    // Skip leading zeroes
    var res = this;
    for (var i = 0; i < w.length; i++, res = res.sqr()) {
      if (w[i] !== 0) break;
    }
    if (++i < w.length) {
      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
        if (w[i] === 0) continue;
        res = res.mul(q);
      }
    }
    return res;
  };

  // Shift-left in-place
  BN.prototype.iushln = function iushln(bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = 0x3ffffff >>> 26 - r << 26 - r;
    var i;
    if (r !== 0) {
      var carry = 0;
      for (i = 0; i < this.length; i++) {
        var newCarry = this.words[i] & carryMask;
        var c = (this.words[i] | 0) - newCarry << r;
        this.words[i] = c | carry;
        carry = newCarry >>> 26 - r;
      }
      if (carry) {
        this.words[i] = carry;
        this.length++;
      }
    }
    if (s !== 0) {
      for (i = this.length - 1; i >= 0; i--) {
        this.words[i + s] = this.words[i];
      }
      for (i = 0; i < s; i++) {
        this.words[i] = 0;
      }
      this.length += s;
    }
    return this.strip();
  };
  BN.prototype.ishln = function ishln(bits) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushln(bits);
  };

  // Shift-right in-place
  // NOTE: `hint` is a lowest bit before trailing zeroes
  // NOTE: if `extended` is present - it will be filled with destroyed bits
  BN.prototype.iushrn = function iushrn(bits, hint, extended) {
    assert(typeof bits === 'number' && bits >= 0);
    var h;
    if (hint) {
      h = (hint - hint % 26) / 26;
    } else {
      h = 0;
    }
    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ 0x3ffffff >>> r << r;
    var maskedWords = extended;
    h -= s;
    h = Math.max(0, h);

    // Extended mode, copy masked part
    if (maskedWords) {
      for (var i = 0; i < s; i++) {
        maskedWords.words[i] = this.words[i];
      }
      maskedWords.length = s;
    }
    if (s === 0) {
      // No-op, we should not move anything at all
    } else if (this.length > s) {
      this.length -= s;
      for (i = 0; i < this.length; i++) {
        this.words[i] = this.words[i + s];
      }
    } else {
      this.words[0] = 0;
      this.length = 1;
    }
    var carry = 0;
    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
      var word = this.words[i] | 0;
      this.words[i] = carry << 26 - r | word >>> r;
      carry = word & mask;
    }

    // Push carried bits as a mask
    if (maskedWords && carry !== 0) {
      maskedWords.words[maskedWords.length++] = carry;
    }
    if (this.length === 0) {
      this.words[0] = 0;
      this.length = 1;
    }
    return this.strip();
  };
  BN.prototype.ishrn = function ishrn(bits, hint, extended) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushrn(bits, hint, extended);
  };

  // Shift-left
  BN.prototype.shln = function shln(bits) {
    return this.clone().ishln(bits);
  };
  BN.prototype.ushln = function ushln(bits) {
    return this.clone().iushln(bits);
  };

  // Shift-right
  BN.prototype.shrn = function shrn(bits) {
    return this.clone().ishrn(bits);
  };
  BN.prototype.ushrn = function ushrn(bits) {
    return this.clone().iushrn(bits);
  };

  // Test if n bit is set
  BN.prototype.testn = function testn(bit) {
    assert(typeof bit === 'number' && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) return false;

    // Check bit and return
    var w = this.words[s];
    return !!(w & q);
  };

  // Return only lowers bits of number (in-place)
  BN.prototype.imaskn = function imaskn(bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    assert(this.negative === 0, 'imaskn works only with positive numbers');
    if (this.length <= s) {
      return this;
    }
    if (r !== 0) {
      s++;
    }
    this.length = Math.min(s, this.length);
    if (r !== 0) {
      var mask = 0x3ffffff ^ 0x3ffffff >>> r << r;
      this.words[this.length - 1] &= mask;
    }
    return this.strip();
  };

  // Return only lowers bits of number
  BN.prototype.maskn = function maskn(bits) {
    return this.clone().imaskn(bits);
  };

  // Add plain number `num` to `this`
  BN.prototype.iaddn = function iaddn(num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.isubn(-num);

    // Possible sign change
    if (this.negative !== 0) {
      if (this.length === 1 && (this.words[0] | 0) < num) {
        this.words[0] = num - (this.words[0] | 0);
        this.negative = 0;
        return this;
      }
      this.negative = 0;
      this.isubn(num);
      this.negative = 1;
      return this;
    }

    // Add without checks
    return this._iaddn(num);
  };
  BN.prototype._iaddn = function _iaddn(num) {
    this.words[0] += num;

    // Carry
    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
      this.words[i] -= 0x4000000;
      if (i === this.length - 1) {
        this.words[i + 1] = 1;
      } else {
        this.words[i + 1]++;
      }
    }
    this.length = Math.max(this.length, i + 1);
    return this;
  };

  // Subtract plain number `num` from `this`
  BN.prototype.isubn = function isubn(num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);
    if (this.negative !== 0) {
      this.negative = 0;
      this.iaddn(num);
      this.negative = 1;
      return this;
    }
    this.words[0] -= num;
    if (this.length === 1 && this.words[0] < 0) {
      this.words[0] = -this.words[0];
      this.negative = 1;
    } else {
      // Carry
      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
        this.words[i] += 0x4000000;
        this.words[i + 1] -= 1;
      }
    }
    return this.strip();
  };
  BN.prototype.addn = function addn(num) {
    return this.clone().iaddn(num);
  };
  BN.prototype.subn = function subn(num) {
    return this.clone().isubn(num);
  };
  BN.prototype.iabs = function iabs() {
    this.negative = 0;
    return this;
  };
  BN.prototype.abs = function abs() {
    return this.clone().iabs();
  };
  BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
    var len = num.length + shift;
    var i;
    this._expand(len);
    var w;
    var carry = 0;
    for (i = 0; i < num.length; i++) {
      w = (this.words[i + shift] | 0) + carry;
      var right = (num.words[i] | 0) * mul;
      w -= right & 0x3ffffff;
      carry = (w >> 26) - (right / 0x4000000 | 0);
      this.words[i + shift] = w & 0x3ffffff;
    }
    for (; i < this.length - shift; i++) {
      w = (this.words[i + shift] | 0) + carry;
      carry = w >> 26;
      this.words[i + shift] = w & 0x3ffffff;
    }
    if (carry === 0) return this.strip();

    // Subtraction overflow
    assert(carry === -1);
    carry = 0;
    for (i = 0; i < this.length; i++) {
      w = -(this.words[i] | 0) + carry;
      carry = w >> 26;
      this.words[i] = w & 0x3ffffff;
    }
    this.negative = 1;
    return this.strip();
  };
  BN.prototype._wordDiv = function _wordDiv(num, mode) {
    var shift = this.length - num.length;
    var a = this.clone();
    var b = num;

    // Normalize
    var bhi = b.words[b.length - 1] | 0;
    var bhiBits = this._countBits(bhi);
    shift = 26 - bhiBits;
    if (shift !== 0) {
      b = b.ushln(shift);
      a.iushln(shift);
      bhi = b.words[b.length - 1] | 0;
    }

    // Initialize quotient
    var m = a.length - b.length;
    var q;
    if (mode !== 'mod') {
      q = new BN(null);
      q.length = m + 1;
      q.words = new Array(q.length);
      for (var i = 0; i < q.length; i++) {
        q.words[i] = 0;
      }
    }
    var diff = a.clone()._ishlnsubmul(b, 1, m);
    if (diff.negative === 0) {
      a = diff;
      if (q) {
        q.words[m] = 1;
      }
    }
    for (var j = m - 1; j >= 0; j--) {
      var qj = (a.words[b.length + j] | 0) * 0x4000000 + (a.words[b.length + j - 1] | 0);

      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
      // (0x7ffffff)
      qj = Math.min(qj / bhi | 0, 0x3ffffff);
      a._ishlnsubmul(b, qj, j);
      while (a.negative !== 0) {
        qj--;
        a.negative = 0;
        a._ishlnsubmul(b, 1, j);
        if (!a.isZero()) {
          a.negative ^= 1;
        }
      }
      if (q) {
        q.words[j] = qj;
      }
    }
    if (q) {
      q.strip();
    }
    a.strip();

    // Denormalize
    if (mode !== 'div' && shift !== 0) {
      a.iushrn(shift);
    }
    return {
      div: q || null,
      mod: a
    };
  };

  // NOTE: 1) `mode` can be set to `mod` to request mod only,
  //       to `div` to request div only, or be absent to
  //       request both div & mod
  //       2) `positive` is true if unsigned mod is requested
  BN.prototype.divmod = function divmod(num, mode, positive) {
    assert(!num.isZero());
    if (this.isZero()) {
      return {
        div: new BN(0),
        mod: new BN(0)
      };
    }
    var div, mod, res;
    if (this.negative !== 0 && num.negative === 0) {
      res = this.neg().divmod(num, mode);
      if (mode !== 'mod') {
        div = res.div.neg();
      }
      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.iadd(num);
        }
      }
      return {
        div: div,
        mod: mod
      };
    }
    if (this.negative === 0 && num.negative !== 0) {
      res = this.divmod(num.neg(), mode);
      if (mode !== 'mod') {
        div = res.div.neg();
      }
      return {
        div: div,
        mod: res.mod
      };
    }
    if ((this.negative & num.negative) !== 0) {
      res = this.neg().divmod(num.neg(), mode);
      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.isub(num);
        }
      }
      return {
        div: res.div,
        mod: mod
      };
    }

    // Both numbers are positive at this point

    // Strip both numbers to approximate shift value
    if (num.length > this.length || this.cmp(num) < 0) {
      return {
        div: new BN(0),
        mod: this
      };
    }

    // Very short reduction
    if (num.length === 1) {
      if (mode === 'div') {
        return {
          div: this.divn(num.words[0]),
          mod: null
        };
      }
      if (mode === 'mod') {
        return {
          div: null,
          mod: new BN(this.modn(num.words[0]))
        };
      }
      return {
        div: this.divn(num.words[0]),
        mod: new BN(this.modn(num.words[0]))
      };
    }
    return this._wordDiv(num, mode);
  };

  // Find `this` / `num`
  BN.prototype.div = function div(num) {
    return this.divmod(num, 'div', false).div;
  };

  // Find `this` % `num`
  BN.prototype.mod = function mod(num) {
    return this.divmod(num, 'mod', false).mod;
  };
  BN.prototype.umod = function umod(num) {
    return this.divmod(num, 'mod', true).mod;
  };

  // Find Round(`this` / `num`)
  BN.prototype.divRound = function divRound(num) {
    var dm = this.divmod(num);

    // Fast case - exact division
    if (dm.mod.isZero()) return dm.div;
    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod.cmp(half);

    // Round down
    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;

    // Round up
    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
  };
  BN.prototype.modn = function modn(num) {
    assert(num <= 0x3ffffff);
    var p = (1 << 26) % num;
    var acc = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      acc = (p * acc + (this.words[i] | 0)) % num;
    }
    return acc;
  };

  // In-place division by number
  BN.prototype.idivn = function idivn(num) {
    assert(num <= 0x3ffffff);
    var carry = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var w = (this.words[i] | 0) + carry * 0x4000000;
      this.words[i] = w / num | 0;
      carry = w % num;
    }
    return this.strip();
  };
  BN.prototype.divn = function divn(num) {
    return this.clone().idivn(num);
  };
  BN.prototype.egcd = function egcd(p) {
    assert(p.negative === 0);
    assert(!p.isZero());
    var x = this;
    var y = p.clone();
    if (x.negative !== 0) {
      x = x.umod(p);
    } else {
      x = x.clone();
    }

    // A * x + B * y = x
    var A = new BN(1);
    var B = new BN(0);

    // C * x + D * y = y
    var C = new BN(0);
    var D = new BN(1);
    var g = 0;
    while (x.isEven() && y.isEven()) {
      x.iushrn(1);
      y.iushrn(1);
      ++g;
    }
    var yp = y.clone();
    var xp = x.clone();
    while (!x.isZero()) {
      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        x.iushrn(i);
        while (i-- > 0) {
          if (A.isOdd() || B.isOdd()) {
            A.iadd(yp);
            B.isub(xp);
          }
          A.iushrn(1);
          B.iushrn(1);
        }
      }
      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        y.iushrn(j);
        while (j-- > 0) {
          if (C.isOdd() || D.isOdd()) {
            C.iadd(yp);
            D.isub(xp);
          }
          C.iushrn(1);
          D.iushrn(1);
        }
      }
      if (x.cmp(y) >= 0) {
        x.isub(y);
        A.isub(C);
        B.isub(D);
      } else {
        y.isub(x);
        C.isub(A);
        D.isub(B);
      }
    }
    return {
      a: C,
      b: D,
      gcd: y.iushln(g)
    };
  };

  // This is reduced incarnation of the binary EEA
  // above, designated to invert members of the
  // _prime_ fields F(p) at a maximal speed
  BN.prototype._invmp = function _invmp(p) {
    assert(p.negative === 0);
    assert(!p.isZero());
    var a = this;
    var b = p.clone();
    if (a.negative !== 0) {
      a = a.umod(p);
    } else {
      a = a.clone();
    }
    var x1 = new BN(1);
    var x2 = new BN(0);
    var delta = b.clone();
    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        a.iushrn(i);
        while (i-- > 0) {
          if (x1.isOdd()) {
            x1.iadd(delta);
          }
          x1.iushrn(1);
        }
      }
      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        b.iushrn(j);
        while (j-- > 0) {
          if (x2.isOdd()) {
            x2.iadd(delta);
          }
          x2.iushrn(1);
        }
      }
      if (a.cmp(b) >= 0) {
        a.isub(b);
        x1.isub(x2);
      } else {
        b.isub(a);
        x2.isub(x1);
      }
    }
    var res;
    if (a.cmpn(1) === 0) {
      res = x1;
    } else {
      res = x2;
    }
    if (res.cmpn(0) < 0) {
      res.iadd(p);
    }
    return res;
  };
  BN.prototype.gcd = function gcd(num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();
    var a = this.clone();
    var b = num.clone();
    a.negative = 0;
    b.negative = 0;

    // Remove common factor of two
    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
      a.iushrn(1);
      b.iushrn(1);
    }
    do {
      while (a.isEven()) {
        a.iushrn(1);
      }
      while (b.isEven()) {
        b.iushrn(1);
      }
      var r = a.cmp(b);
      if (r < 0) {
        // Swap `a` and `b` to make `a` always bigger than `b`
        var t = a;
        a = b;
        b = t;
      } else if (r === 0 || b.cmpn(1) === 0) {
        break;
      }
      a.isub(b);
    } while (true);
    return b.iushln(shift);
  };

  // Invert number in the field F(num)
  BN.prototype.invm = function invm(num) {
    return this.egcd(num).a.umod(num);
  };
  BN.prototype.isEven = function isEven() {
    return (this.words[0] & 1) === 0;
  };
  BN.prototype.isOdd = function isOdd() {
    return (this.words[0] & 1) === 1;
  };

  // And first word and num
  BN.prototype.andln = function andln(num) {
    return this.words[0] & num;
  };

  // Increment at the bit position in-line
  BN.prototype.bincn = function bincn(bit) {
    assert(typeof bit === 'number');
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) {
      this._expand(s + 1);
      this.words[s] |= q;
      return this;
    }

    // Add bit and propagate, if needed
    var carry = q;
    for (var i = s; carry !== 0 && i < this.length; i++) {
      var w = this.words[i] | 0;
      w += carry;
      carry = w >>> 26;
      w &= 0x3ffffff;
      this.words[i] = w;
    }
    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    return this;
  };
  BN.prototype.isZero = function isZero() {
    return this.length === 1 && this.words[0] === 0;
  };
  BN.prototype.cmpn = function cmpn(num) {
    var negative = num < 0;
    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;
    this.strip();
    var res;
    if (this.length > 1) {
      res = 1;
    } else {
      if (negative) {
        num = -num;
      }
      assert(num <= 0x3ffffff, 'Number is too big');
      var w = this.words[0] | 0;
      res = w === num ? 0 : w < num ? -1 : 1;
    }
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Compare two numbers and return:
  // 1 - if `this` > `num`
  // 0 - if `this` == `num`
  // -1 - if `this` < `num`
  BN.prototype.cmp = function cmp(num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;
    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Unsigned comparison
  BN.prototype.ucmp = function ucmp(num) {
    // At this point both numbers have the same sign
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;
    var res = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var a = this.words[i] | 0;
      var b = num.words[i] | 0;
      if (a === b) continue;
      if (a < b) {
        res = -1;
      } else if (a > b) {
        res = 1;
      }
      break;
    }
    return res;
  };
  BN.prototype.gtn = function gtn(num) {
    return this.cmpn(num) === 1;
  };
  BN.prototype.gt = function gt(num) {
    return this.cmp(num) === 1;
  };
  BN.prototype.gten = function gten(num) {
    return this.cmpn(num) >= 0;
  };
  BN.prototype.gte = function gte(num) {
    return this.cmp(num) >= 0;
  };
  BN.prototype.ltn = function ltn(num) {
    return this.cmpn(num) === -1;
  };
  BN.prototype.lt = function lt(num) {
    return this.cmp(num) === -1;
  };
  BN.prototype.lten = function lten(num) {
    return this.cmpn(num) <= 0;
  };
  BN.prototype.lte = function lte(num) {
    return this.cmp(num) <= 0;
  };
  BN.prototype.eqn = function eqn(num) {
    return this.cmpn(num) === 0;
  };
  BN.prototype.eq = function eq(num) {
    return this.cmp(num) === 0;
  };

  //
  // A reduce context, could be using montgomery or something better, depending
  // on the `m` itself.
  //
  BN.red = function red(num) {
    return new Red(num);
  };
  BN.prototype.toRed = function toRed(ctx) {
    assert(!this.red, 'Already a number in reduction context');
    assert(this.negative === 0, 'red works only with positives');
    return ctx.convertTo(this)._forceRed(ctx);
  };
  BN.prototype.fromRed = function fromRed() {
    assert(this.red, 'fromRed works only with numbers in reduction context');
    return this.red.convertFrom(this);
  };
  BN.prototype._forceRed = function _forceRed(ctx) {
    this.red = ctx;
    return this;
  };
  BN.prototype.forceRed = function forceRed(ctx) {
    assert(!this.red, 'Already a number in reduction context');
    return this._forceRed(ctx);
  };
  BN.prototype.redAdd = function redAdd(num) {
    assert(this.red, 'redAdd works only with red numbers');
    return this.red.add(this, num);
  };
  BN.prototype.redIAdd = function redIAdd(num) {
    assert(this.red, 'redIAdd works only with red numbers');
    return this.red.iadd(this, num);
  };
  BN.prototype.redSub = function redSub(num) {
    assert(this.red, 'redSub works only with red numbers');
    return this.red.sub(this, num);
  };
  BN.prototype.redISub = function redISub(num) {
    assert(this.red, 'redISub works only with red numbers');
    return this.red.isub(this, num);
  };
  BN.prototype.redShl = function redShl(num) {
    assert(this.red, 'redShl works only with red numbers');
    return this.red.shl(this, num);
  };
  BN.prototype.redMul = function redMul(num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.mul(this, num);
  };
  BN.prototype.redIMul = function redIMul(num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.imul(this, num);
  };
  BN.prototype.redSqr = function redSqr() {
    assert(this.red, 'redSqr works only with red numbers');
    this.red._verify1(this);
    return this.red.sqr(this);
  };
  BN.prototype.redISqr = function redISqr() {
    assert(this.red, 'redISqr works only with red numbers');
    this.red._verify1(this);
    return this.red.isqr(this);
  };

  // Square root over p
  BN.prototype.redSqrt = function redSqrt() {
    assert(this.red, 'redSqrt works only with red numbers');
    this.red._verify1(this);
    return this.red.sqrt(this);
  };
  BN.prototype.redInvm = function redInvm() {
    assert(this.red, 'redInvm works only with red numbers');
    this.red._verify1(this);
    return this.red.invm(this);
  };

  // Return negative clone of `this` % `red modulo`
  BN.prototype.redNeg = function redNeg() {
    assert(this.red, 'redNeg works only with red numbers');
    this.red._verify1(this);
    return this.red.neg(this);
  };
  BN.prototype.redPow = function redPow(num) {
    assert(this.red && !num.red, 'redPow(normalNum)');
    this.red._verify1(this);
    return this.red.pow(this, num);
  };

  // Prime numbers with efficient reduction
  var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
  };

  // Pseudo-Mersenne prime
  function MPrime(name, p) {
    // P = 2 ^ N - K
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);
    this.tmp = this._tmp();
  }
  MPrime.prototype._tmp = function _tmp() {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
  };
  MPrime.prototype.ireduce = function ireduce(num) {
    // Assumes that `num` is less than `P^2`
    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
    var r = num;
    var rlen;
    do {
      this.split(r, this.tmp);
      r = this.imulK(r);
      r = r.iadd(this.tmp);
      rlen = r.bitLength();
    } while (rlen > this.n);
    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
    if (cmp === 0) {
      r.words[0] = 0;
      r.length = 1;
    } else if (cmp > 0) {
      r.isub(this.p);
    } else {
      if (r.strip !== undefined) {
        // r is BN v4 instance
        r.strip();
      } else {
        // r is BN v5 instance
        r._strip();
      }
    }
    return r;
  };
  MPrime.prototype.split = function split(input, out) {
    input.iushrn(this.n, 0, out);
  };
  MPrime.prototype.imulK = function imulK(num) {
    return num.imul(this.k);
  };
  function K256() {
    MPrime.call(this, 'k256', 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
  }
  inherits(K256, MPrime);
  K256.prototype.split = function split(input, output) {
    // 256 = 9 * 26 + 22
    var mask = 0x3fffff;
    var outLen = Math.min(input.length, 9);
    for (var i = 0; i < outLen; i++) {
      output.words[i] = input.words[i];
    }
    output.length = outLen;
    if (input.length <= 9) {
      input.words[0] = 0;
      input.length = 1;
      return;
    }

    // Shift by 9 limbs
    var prev = input.words[9];
    output.words[output.length++] = prev & mask;
    for (i = 10; i < input.length; i++) {
      var next = input.words[i] | 0;
      input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
      prev = next;
    }
    prev >>>= 22;
    input.words[i - 10] = prev;
    if (prev === 0 && input.length > 10) {
      input.length -= 10;
    } else {
      input.length -= 9;
    }
  };
  K256.prototype.imulK = function imulK(num) {
    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2;

    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
    var lo = 0;
    for (var i = 0; i < num.length; i++) {
      var w = num.words[i] | 0;
      lo += w * 0x3d1;
      num.words[i] = lo & 0x3ffffff;
      lo = w * 0x40 + (lo / 0x4000000 | 0);
    }

    // Fast length reduction
    if (num.words[num.length - 1] === 0) {
      num.length--;
      if (num.words[num.length - 1] === 0) {
        num.length--;
      }
    }
    return num;
  };
  function P224() {
    MPrime.call(this, 'p224', 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
  }
  inherits(P224, MPrime);
  function P192() {
    MPrime.call(this, 'p192', 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
  }
  inherits(P192, MPrime);
  function P25519() {
    // 2 ^ 255 - 19
    MPrime.call(this, '25519', '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
  }
  inherits(P25519, MPrime);
  P25519.prototype.imulK = function imulK(num) {
    // K = 0x13
    var carry = 0;
    for (var i = 0; i < num.length; i++) {
      var hi = (num.words[i] | 0) * 0x13 + carry;
      var lo = hi & 0x3ffffff;
      hi >>>= 26;
      num.words[i] = lo;
      carry = hi;
    }
    if (carry !== 0) {
      num.words[num.length++] = carry;
    }
    return num;
  };

  // Exported mostly for testing purposes, use plain name instead
  BN._prime = function prime(name) {
    // Cached version of prime
    if (primes[name]) return primes[name];
    var prime;
    if (name === 'k256') {
      prime = new K256();
    } else if (name === 'p224') {
      prime = new P224();
    } else if (name === 'p192') {
      prime = new P192();
    } else if (name === 'p25519') {
      prime = new P25519();
    } else {
      throw new Error('Unknown prime ' + name);
    }
    primes[name] = prime;
    return prime;
  };

  //
  // Base reduction engine
  //
  function Red(m) {
    if (typeof m === 'string') {
      var prime = BN._prime(m);
      this.m = prime.p;
      this.prime = prime;
    } else {
      assert(m.gtn(1), 'modulus must be greater than 1');
      this.m = m;
      this.prime = null;
    }
  }
  Red.prototype._verify1 = function _verify1(a) {
    assert(a.negative === 0, 'red works only with positives');
    assert(a.red, 'red works only with red numbers');
  };
  Red.prototype._verify2 = function _verify2(a, b) {
    assert((a.negative | b.negative) === 0, 'red works only with positives');
    assert(a.red && a.red === b.red, 'red works only with red numbers');
  };
  Red.prototype.imod = function imod(a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
    return a.umod(this.m)._forceRed(this);
  };
  Red.prototype.neg = function neg(a) {
    if (a.isZero()) {
      return a.clone();
    }
    return this.m.sub(a)._forceRed(this);
  };
  Red.prototype.add = function add(a, b) {
    this._verify2(a, b);
    var res = a.add(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res._forceRed(this);
  };
  Red.prototype.iadd = function iadd(a, b) {
    this._verify2(a, b);
    var res = a.iadd(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res;
  };
  Red.prototype.sub = function sub(a, b) {
    this._verify2(a, b);
    var res = a.sub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res._forceRed(this);
  };
  Red.prototype.isub = function isub(a, b) {
    this._verify2(a, b);
    var res = a.isub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res;
  };
  Red.prototype.shl = function shl(a, num) {
    this._verify1(a);
    return this.imod(a.ushln(num));
  };
  Red.prototype.imul = function imul(a, b) {
    this._verify2(a, b);
    return this.imod(a.imul(b));
  };
  Red.prototype.mul = function mul(a, b) {
    this._verify2(a, b);
    return this.imod(a.mul(b));
  };
  Red.prototype.isqr = function isqr(a) {
    return this.imul(a, a.clone());
  };
  Red.prototype.sqr = function sqr(a) {
    return this.mul(a, a);
  };
  Red.prototype.sqrt = function sqrt(a) {
    if (a.isZero()) return a.clone();
    var mod3 = this.m.andln(3);
    assert(mod3 % 2 === 1);

    // Fast case
    if (mod3 === 3) {
      var pow = this.m.add(new BN(1)).iushrn(2);
      return this.pow(a, pow);
    }

    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
    //
    // Find Q and S, that Q * 2 ^ S = (P - 1)
    var q = this.m.subn(1);
    var s = 0;
    while (!q.isZero() && q.andln(1) === 0) {
      s++;
      q.iushrn(1);
    }
    assert(!q.isZero());
    var one = new BN(1).toRed(this);
    var nOne = one.redNeg();

    // Find quadratic non-residue
    // NOTE: Max is such because of generalized Riemann hypothesis.
    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);
    while (this.pow(z, lpow).cmp(nOne) !== 0) {
      z.redIAdd(nOne);
    }
    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;
    while (t.cmp(one) !== 0) {
      var tmp = t;
      for (var i = 0; tmp.cmp(one) !== 0; i++) {
        tmp = tmp.redSqr();
      }
      assert(i < m);
      var b = this.pow(c, new BN(1).iushln(m - i - 1));
      r = r.redMul(b);
      c = b.redSqr();
      t = t.redMul(c);
      m = i;
    }
    return r;
  };
  Red.prototype.invm = function invm(a) {
    var inv = a._invmp(this.m);
    if (inv.negative !== 0) {
      inv.negative = 0;
      return this.imod(inv).redNeg();
    } else {
      return this.imod(inv);
    }
  };
  Red.prototype.pow = function pow(a, num) {
    if (num.isZero()) return new BN(1).toRed(this);
    if (num.cmpn(1) === 0) return a.clone();
    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;
    for (var i = 2; i < wnd.length; i++) {
      wnd[i] = this.mul(wnd[i - 1], a);
    }
    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;
    if (start === 0) {
      start = 26;
    }
    for (i = num.length - 1; i >= 0; i--) {
      var word = num.words[i];
      for (var j = start - 1; j >= 0; j--) {
        var bit = word >> j & 1;
        if (res !== wnd[0]) {
          res = this.sqr(res);
        }
        if (bit === 0 && current === 0) {
          currentLen = 0;
          continue;
        }
        current <<= 1;
        current |= bit;
        currentLen++;
        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;
        res = this.mul(res, wnd[current]);
        currentLen = 0;
        current = 0;
      }
      start = 26;
    }
    return res;
  };
  Red.prototype.convertTo = function convertTo(num) {
    var r = num.umod(this.m);
    return r === num ? r.clone() : r;
  };
  Red.prototype.convertFrom = function convertFrom(num) {
    var res = num.clone();
    res.red = null;
    return res;
  };

  //
  // Montgomery method engine
  //

  BN.mont = function mont(num) {
    return new Mont(num);
  };
  function Mont(m) {
    Red.call(this, m);
    this.shift = this.m.bitLength();
    if (this.shift % 26 !== 0) {
      this.shift += 26 - this.shift % 26;
    }
    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);
    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
  }
  inherits(Mont, Red);
  Mont.prototype.convertTo = function convertTo(num) {
    return this.imod(num.ushln(this.shift));
  };
  Mont.prototype.convertFrom = function convertFrom(num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
  };
  Mont.prototype.imul = function imul(a, b) {
    if (a.isZero() || b.isZero()) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }
    var t = a.imul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }
    return res._forceRed(this);
  };
  Mont.prototype.mul = function mul(a, b) {
    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);
    var t = a.mul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }
    return res._forceRed(this);
  };
  Mont.prototype.invm = function invm(a) {
    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
  };
})(typeof module === 'undefined' || module, void 0);

},{"buffer":105}],104:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var r;
module.exports = function rand(len) {
  if (!r) r = new Rand(null);
  return r.generate(len);
};
function Rand(rand) {
  this.rand = rand;
}
module.exports.Rand = Rand;
Rand.prototype.generate = function generate(len) {
  return this._rand(len);
};

// Emulate crypto API using randy
Rand.prototype._rand = function _rand(n) {
  if (this.rand.getBytes) return this.rand.getBytes(n);
  var res = new Uint8Array(n);
  for (var i = 0; i < res.length; i++) res[i] = this.rand.getByte();
  return res;
};
if ((typeof self === "undefined" ? "undefined" : _typeof(self)) === 'object') {
  if (self.crypto && self.crypto.getRandomValues) {
    // Modern browsers
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      self.crypto.getRandomValues(arr);
      return arr;
    };
  } else if (self.msCrypto && self.msCrypto.getRandomValues) {
    // IE
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      self.msCrypto.getRandomValues(arr);
      return arr;
    };

    // Safari's WebWorkers do not have `crypto`
  } else if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === 'object') {
    // Old junk
    Rand.prototype._rand = function () {
      throw new Error('Not implemented yet');
    };
  }
} else {
  // Node.js or Web worker with no crypto support
  try {
    var crypto = require('crypto');
    if (typeof crypto.randomBytes !== 'function') throw new Error('Not supported');
    Rand.prototype._rand = function _rand(n) {
      return crypto.randomBytes(n);
    };
  } catch (e) {}
}

},{"crypto":105}],105:[function(require,module,exports){
"use strict";

},{}],106:[function(require,module,exports){
"use strict";

// based on the aes implimentation in triple sec
// https://github.com/keybase/triplesec
// which is in turn based on the one from crypto-js
// https://code.google.com/p/crypto-js/

var Buffer = require('safe-buffer').Buffer;
function asUInt32Array(buf) {
  if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);
  var len = buf.length / 4 | 0;
  var out = new Array(len);
  for (var i = 0; i < len; i++) {
    out[i] = buf.readUInt32BE(i * 4);
  }
  return out;
}
function scrubVec(v) {
  for (var i = 0; i < v.length; v++) {
    v[i] = 0;
  }
}
function cryptBlock(M, keySchedule, SUB_MIX, SBOX, nRounds) {
  var SUB_MIX0 = SUB_MIX[0];
  var SUB_MIX1 = SUB_MIX[1];
  var SUB_MIX2 = SUB_MIX[2];
  var SUB_MIX3 = SUB_MIX[3];
  var s0 = M[0] ^ keySchedule[0];
  var s1 = M[1] ^ keySchedule[1];
  var s2 = M[2] ^ keySchedule[2];
  var s3 = M[3] ^ keySchedule[3];
  var t0, t1, t2, t3;
  var ksRow = 4;
  for (var round = 1; round < nRounds; round++) {
    t0 = SUB_MIX0[s0 >>> 24] ^ SUB_MIX1[s1 >>> 16 & 0xff] ^ SUB_MIX2[s2 >>> 8 & 0xff] ^ SUB_MIX3[s3 & 0xff] ^ keySchedule[ksRow++];
    t1 = SUB_MIX0[s1 >>> 24] ^ SUB_MIX1[s2 >>> 16 & 0xff] ^ SUB_MIX2[s3 >>> 8 & 0xff] ^ SUB_MIX3[s0 & 0xff] ^ keySchedule[ksRow++];
    t2 = SUB_MIX0[s2 >>> 24] ^ SUB_MIX1[s3 >>> 16 & 0xff] ^ SUB_MIX2[s0 >>> 8 & 0xff] ^ SUB_MIX3[s1 & 0xff] ^ keySchedule[ksRow++];
    t3 = SUB_MIX0[s3 >>> 24] ^ SUB_MIX1[s0 >>> 16 & 0xff] ^ SUB_MIX2[s1 >>> 8 & 0xff] ^ SUB_MIX3[s2 & 0xff] ^ keySchedule[ksRow++];
    s0 = t0;
    s1 = t1;
    s2 = t2;
    s3 = t3;
  }
  t0 = (SBOX[s0 >>> 24] << 24 | SBOX[s1 >>> 16 & 0xff] << 16 | SBOX[s2 >>> 8 & 0xff] << 8 | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];
  t1 = (SBOX[s1 >>> 24] << 24 | SBOX[s2 >>> 16 & 0xff] << 16 | SBOX[s3 >>> 8 & 0xff] << 8 | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];
  t2 = (SBOX[s2 >>> 24] << 24 | SBOX[s3 >>> 16 & 0xff] << 16 | SBOX[s0 >>> 8 & 0xff] << 8 | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];
  t3 = (SBOX[s3 >>> 24] << 24 | SBOX[s0 >>> 16 & 0xff] << 16 | SBOX[s1 >>> 8 & 0xff] << 8 | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++];
  t0 = t0 >>> 0;
  t1 = t1 >>> 0;
  t2 = t2 >>> 0;
  t3 = t3 >>> 0;
  return [t0, t1, t2, t3];
}

// AES constants
var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];
var G = function () {
  // Compute double table
  var d = new Array(256);
  for (var j = 0; j < 256; j++) {
    if (j < 128) {
      d[j] = j << 1;
    } else {
      d[j] = j << 1 ^ 0x11b;
    }
  }
  var SBOX = [];
  var INV_SBOX = [];
  var SUB_MIX = [[], [], [], []];
  var INV_SUB_MIX = [[], [], [], []];

  // Walk GF(2^8)
  var x = 0;
  var xi = 0;
  for (var i = 0; i < 256; ++i) {
    // Compute sbox
    var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
    sx = sx >>> 8 ^ sx & 0xff ^ 0x63;
    SBOX[x] = sx;
    INV_SBOX[sx] = x;

    // Compute multiplication
    var x2 = d[x];
    var x4 = d[x2];
    var x8 = d[x4];

    // Compute sub bytes, mix columns tables
    var t = d[sx] * 0x101 ^ sx * 0x1010100;
    SUB_MIX[0][x] = t << 24 | t >>> 8;
    SUB_MIX[1][x] = t << 16 | t >>> 16;
    SUB_MIX[2][x] = t << 8 | t >>> 24;
    SUB_MIX[3][x] = t;

    // Compute inv sub bytes, inv mix columns tables
    t = x8 * 0x1010101 ^ x4 * 0x10001 ^ x2 * 0x101 ^ x * 0x1010100;
    INV_SUB_MIX[0][sx] = t << 24 | t >>> 8;
    INV_SUB_MIX[1][sx] = t << 16 | t >>> 16;
    INV_SUB_MIX[2][sx] = t << 8 | t >>> 24;
    INV_SUB_MIX[3][sx] = t;
    if (x === 0) {
      x = xi = 1;
    } else {
      x = x2 ^ d[d[d[x8 ^ x2]]];
      xi ^= d[d[xi]];
    }
  }
  return {
    SBOX: SBOX,
    INV_SBOX: INV_SBOX,
    SUB_MIX: SUB_MIX,
    INV_SUB_MIX: INV_SUB_MIX
  };
}();
function AES(key) {
  this._key = asUInt32Array(key);
  this._reset();
}
AES.blockSize = 4 * 4;
AES.keySize = 256 / 8;
AES.prototype.blockSize = AES.blockSize;
AES.prototype.keySize = AES.keySize;
AES.prototype._reset = function () {
  var keyWords = this._key;
  var keySize = keyWords.length;
  var nRounds = keySize + 6;
  var ksRows = (nRounds + 1) * 4;
  var keySchedule = [];
  for (var k = 0; k < keySize; k++) {
    keySchedule[k] = keyWords[k];
  }
  for (k = keySize; k < ksRows; k++) {
    var t = keySchedule[k - 1];
    if (k % keySize === 0) {
      t = t << 8 | t >>> 24;
      t = G.SBOX[t >>> 24] << 24 | G.SBOX[t >>> 16 & 0xff] << 16 | G.SBOX[t >>> 8 & 0xff] << 8 | G.SBOX[t & 0xff];
      t ^= RCON[k / keySize | 0] << 24;
    } else if (keySize > 6 && k % keySize === 4) {
      t = G.SBOX[t >>> 24] << 24 | G.SBOX[t >>> 16 & 0xff] << 16 | G.SBOX[t >>> 8 & 0xff] << 8 | G.SBOX[t & 0xff];
    }
    keySchedule[k] = keySchedule[k - keySize] ^ t;
  }
  var invKeySchedule = [];
  for (var ik = 0; ik < ksRows; ik++) {
    var ksR = ksRows - ik;
    var tt = keySchedule[ksR - (ik % 4 ? 0 : 4)];
    if (ik < 4 || ksR <= 4) {
      invKeySchedule[ik] = tt;
    } else {
      invKeySchedule[ik] = G.INV_SUB_MIX[0][G.SBOX[tt >>> 24]] ^ G.INV_SUB_MIX[1][G.SBOX[tt >>> 16 & 0xff]] ^ G.INV_SUB_MIX[2][G.SBOX[tt >>> 8 & 0xff]] ^ G.INV_SUB_MIX[3][G.SBOX[tt & 0xff]];
    }
  }
  this._nRounds = nRounds;
  this._keySchedule = keySchedule;
  this._invKeySchedule = invKeySchedule;
};
AES.prototype.encryptBlockRaw = function (M) {
  M = asUInt32Array(M);
  return cryptBlock(M, this._keySchedule, G.SUB_MIX, G.SBOX, this._nRounds);
};
AES.prototype.encryptBlock = function (M) {
  var out = this.encryptBlockRaw(M);
  var buf = Buffer.allocUnsafe(16);
  buf.writeUInt32BE(out[0], 0);
  buf.writeUInt32BE(out[1], 4);
  buf.writeUInt32BE(out[2], 8);
  buf.writeUInt32BE(out[3], 12);
  return buf;
};
AES.prototype.decryptBlock = function (M) {
  M = asUInt32Array(M);

  // swap
  var m1 = M[1];
  M[1] = M[3];
  M[3] = m1;
  var out = cryptBlock(M, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX, this._nRounds);
  var buf = Buffer.allocUnsafe(16);
  buf.writeUInt32BE(out[0], 0);
  buf.writeUInt32BE(out[3], 4);
  buf.writeUInt32BE(out[2], 8);
  buf.writeUInt32BE(out[1], 12);
  return buf;
};
AES.prototype.scrub = function () {
  scrubVec(this._keySchedule);
  scrubVec(this._invKeySchedule);
  scrubVec(this._key);
};
module.exports.AES = AES;

},{"safe-buffer":384}],107:[function(require,module,exports){
"use strict";

var aes = require('./aes');
var Buffer = require('safe-buffer').Buffer;
var Transform = require('cipher-base');
var inherits = require('inherits');
var GHASH = require('./ghash');
var xor = require('buffer-xor');
var incr32 = require('./incr32');
function xorTest(a, b) {
  var out = 0;
  if (a.length !== b.length) out++;
  var len = Math.min(a.length, b.length);
  for (var i = 0; i < len; ++i) {
    out += a[i] ^ b[i];
  }
  return out;
}
function calcIv(self, iv, ck) {
  if (iv.length === 12) {
    self._finID = Buffer.concat([iv, Buffer.from([0, 0, 0, 1])]);
    return Buffer.concat([iv, Buffer.from([0, 0, 0, 2])]);
  }
  var ghash = new GHASH(ck);
  var len = iv.length;
  var toPad = len % 16;
  ghash.update(iv);
  if (toPad) {
    toPad = 16 - toPad;
    ghash.update(Buffer.alloc(toPad, 0));
  }
  ghash.update(Buffer.alloc(8, 0));
  var ivBits = len * 8;
  var tail = Buffer.alloc(8);
  tail.writeUIntBE(ivBits, 0, 8);
  ghash.update(tail);
  self._finID = ghash.state;
  var out = Buffer.from(self._finID);
  incr32(out);
  return out;
}
function StreamCipher(mode, key, iv, decrypt) {
  Transform.call(this);
  var h = Buffer.alloc(4, 0);
  this._cipher = new aes.AES(key);
  var ck = this._cipher.encryptBlock(h);
  this._ghash = new GHASH(ck);
  iv = calcIv(this, iv, ck);
  this._prev = Buffer.from(iv);
  this._cache = Buffer.allocUnsafe(0);
  this._secCache = Buffer.allocUnsafe(0);
  this._decrypt = decrypt;
  this._alen = 0;
  this._len = 0;
  this._mode = mode;
  this._authTag = null;
  this._called = false;
}
inherits(StreamCipher, Transform);
StreamCipher.prototype._update = function (chunk) {
  if (!this._called && this._alen) {
    var rump = 16 - this._alen % 16;
    if (rump < 16) {
      rump = Buffer.alloc(rump, 0);
      this._ghash.update(rump);
    }
  }
  this._called = true;
  var out = this._mode.encrypt(this, chunk);
  if (this._decrypt) {
    this._ghash.update(chunk);
  } else {
    this._ghash.update(out);
  }
  this._len += chunk.length;
  return out;
};
StreamCipher.prototype._final = function () {
  if (this._decrypt && !this._authTag) throw new Error('Unsupported state or unable to authenticate data');
  var tag = xor(this._ghash["final"](this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
  if (this._decrypt && xorTest(tag, this._authTag)) throw new Error('Unsupported state or unable to authenticate data');
  this._authTag = tag;
  this._cipher.scrub();
};
StreamCipher.prototype.getAuthTag = function getAuthTag() {
  if (this._decrypt || !Buffer.isBuffer(this._authTag)) throw new Error('Attempting to get auth tag in unsupported state');
  return this._authTag;
};
StreamCipher.prototype.setAuthTag = function setAuthTag(tag) {
  if (!this._decrypt) throw new Error('Attempting to set auth tag in unsupported state');
  this._authTag = tag;
};
StreamCipher.prototype.setAAD = function setAAD(buf) {
  if (this._called) throw new Error('Attempting to set AAD in unsupported state');
  this._ghash.update(buf);
  this._alen += buf.length;
};
module.exports = StreamCipher;

},{"./aes":106,"./ghash":111,"./incr32":112,"buffer-xor":138,"cipher-base":142,"inherits":327,"safe-buffer":384}],108:[function(require,module,exports){
"use strict";

var ciphers = require('./encrypter');
var deciphers = require('./decrypter');
var modes = require('./modes/list.json');
function getCiphers() {
  return Object.keys(modes);
}
exports.createCipher = exports.Cipher = ciphers.createCipher;
exports.createCipheriv = exports.Cipheriv = ciphers.createCipheriv;
exports.createDecipher = exports.Decipher = deciphers.createDecipher;
exports.createDecipheriv = exports.Decipheriv = deciphers.createDecipheriv;
exports.listCiphers = exports.getCiphers = getCiphers;

},{"./decrypter":109,"./encrypter":110,"./modes/list.json":120}],109:[function(require,module,exports){
"use strict";

var AuthCipher = require('./authCipher');
var Buffer = require('safe-buffer').Buffer;
var MODES = require('./modes');
var StreamCipher = require('./streamCipher');
var Transform = require('cipher-base');
var aes = require('./aes');
var ebtk = require('evp_bytestokey');
var inherits = require('inherits');
function Decipher(mode, key, iv) {
  Transform.call(this);
  this._cache = new Splitter();
  this._last = void 0;
  this._cipher = new aes.AES(key);
  this._prev = Buffer.from(iv);
  this._mode = mode;
  this._autopadding = true;
}
inherits(Decipher, Transform);
Decipher.prototype._update = function (data) {
  this._cache.add(data);
  var chunk;
  var thing;
  var out = [];
  while (chunk = this._cache.get(this._autopadding)) {
    thing = this._mode.decrypt(this, chunk);
    out.push(thing);
  }
  return Buffer.concat(out);
};
Decipher.prototype._final = function () {
  var chunk = this._cache.flush();
  if (this._autopadding) {
    return unpad(this._mode.decrypt(this, chunk));
  } else if (chunk) {
    throw new Error('data not multiple of block length');
  }
};
Decipher.prototype.setAutoPadding = function (setTo) {
  this._autopadding = !!setTo;
  return this;
};
function Splitter() {
  this.cache = Buffer.allocUnsafe(0);
}
Splitter.prototype.add = function (data) {
  this.cache = Buffer.concat([this.cache, data]);
};
Splitter.prototype.get = function (autoPadding) {
  var out;
  if (autoPadding) {
    if (this.cache.length > 16) {
      out = this.cache.slice(0, 16);
      this.cache = this.cache.slice(16);
      return out;
    }
  } else {
    if (this.cache.length >= 16) {
      out = this.cache.slice(0, 16);
      this.cache = this.cache.slice(16);
      return out;
    }
  }
  return null;
};
Splitter.prototype.flush = function () {
  if (this.cache.length) return this.cache;
};
function unpad(last) {
  var padded = last[15];
  if (padded < 1 || padded > 16) {
    throw new Error('unable to decrypt data');
  }
  var i = -1;
  while (++i < padded) {
    if (last[i + (16 - padded)] !== padded) {
      throw new Error('unable to decrypt data');
    }
  }
  if (padded === 16) return;
  return last.slice(0, 16 - padded);
}
function createDecipheriv(suite, password, iv) {
  var config = MODES[suite.toLowerCase()];
  if (!config) throw new TypeError('invalid suite type');
  if (typeof iv === 'string') iv = Buffer.from(iv);
  if (config.mode !== 'GCM' && iv.length !== config.iv) throw new TypeError('invalid iv length ' + iv.length);
  if (typeof password === 'string') password = Buffer.from(password);
  if (password.length !== config.key / 8) throw new TypeError('invalid key length ' + password.length);
  if (config.type === 'stream') {
    return new StreamCipher(config.module, password, iv, true);
  } else if (config.type === 'auth') {
    return new AuthCipher(config.module, password, iv, true);
  }
  return new Decipher(config.module, password, iv);
}
function createDecipher(suite, password) {
  var config = MODES[suite.toLowerCase()];
  if (!config) throw new TypeError('invalid suite type');
  var keys = ebtk(password, false, config.key, config.iv);
  return createDecipheriv(suite, keys.key, keys.iv);
}
exports.createDecipher = createDecipher;
exports.createDecipheriv = createDecipheriv;

},{"./aes":106,"./authCipher":107,"./modes":119,"./streamCipher":122,"cipher-base":142,"evp_bytestokey":302,"inherits":327,"safe-buffer":384}],110:[function(require,module,exports){
"use strict";

var MODES = require('./modes');
var AuthCipher = require('./authCipher');
var Buffer = require('safe-buffer').Buffer;
var StreamCipher = require('./streamCipher');
var Transform = require('cipher-base');
var aes = require('./aes');
var ebtk = require('evp_bytestokey');
var inherits = require('inherits');
function Cipher(mode, key, iv) {
  Transform.call(this);
  this._cache = new Splitter();
  this._cipher = new aes.AES(key);
  this._prev = Buffer.from(iv);
  this._mode = mode;
  this._autopadding = true;
}
inherits(Cipher, Transform);
Cipher.prototype._update = function (data) {
  this._cache.add(data);
  var chunk;
  var thing;
  var out = [];
  while (chunk = this._cache.get()) {
    thing = this._mode.encrypt(this, chunk);
    out.push(thing);
  }
  return Buffer.concat(out);
};
var PADDING = Buffer.alloc(16, 0x10);
Cipher.prototype._final = function () {
  var chunk = this._cache.flush();
  if (this._autopadding) {
    chunk = this._mode.encrypt(this, chunk);
    this._cipher.scrub();
    return chunk;
  }
  if (!chunk.equals(PADDING)) {
    this._cipher.scrub();
    throw new Error('data not multiple of block length');
  }
};
Cipher.prototype.setAutoPadding = function (setTo) {
  this._autopadding = !!setTo;
  return this;
};
function Splitter() {
  this.cache = Buffer.allocUnsafe(0);
}
Splitter.prototype.add = function (data) {
  this.cache = Buffer.concat([this.cache, data]);
};
Splitter.prototype.get = function () {
  if (this.cache.length > 15) {
    var out = this.cache.slice(0, 16);
    this.cache = this.cache.slice(16);
    return out;
  }
  return null;
};
Splitter.prototype.flush = function () {
  var len = 16 - this.cache.length;
  var padBuff = Buffer.allocUnsafe(len);
  var i = -1;
  while (++i < len) {
    padBuff.writeUInt8(len, i);
  }
  return Buffer.concat([this.cache, padBuff]);
};
function createCipheriv(suite, password, iv) {
  var config = MODES[suite.toLowerCase()];
  if (!config) throw new TypeError('invalid suite type');
  if (typeof password === 'string') password = Buffer.from(password);
  if (password.length !== config.key / 8) throw new TypeError('invalid key length ' + password.length);
  if (typeof iv === 'string') iv = Buffer.from(iv);
  if (config.mode !== 'GCM' && iv.length !== config.iv) throw new TypeError('invalid iv length ' + iv.length);
  if (config.type === 'stream') {
    return new StreamCipher(config.module, password, iv);
  } else if (config.type === 'auth') {
    return new AuthCipher(config.module, password, iv);
  }
  return new Cipher(config.module, password, iv);
}
function createCipher(suite, password) {
  var config = MODES[suite.toLowerCase()];
  if (!config) throw new TypeError('invalid suite type');
  var keys = ebtk(password, false, config.key, config.iv);
  return createCipheriv(suite, keys.key, keys.iv);
}
exports.createCipheriv = createCipheriv;
exports.createCipher = createCipher;

},{"./aes":106,"./authCipher":107,"./modes":119,"./streamCipher":122,"cipher-base":142,"evp_bytestokey":302,"inherits":327,"safe-buffer":384}],111:[function(require,module,exports){
"use strict";

var Buffer = require('safe-buffer').Buffer;
var ZEROES = Buffer.alloc(16, 0);
function toArray(buf) {
  return [buf.readUInt32BE(0), buf.readUInt32BE(4), buf.readUInt32BE(8), buf.readUInt32BE(12)];
}
function fromArray(out) {
  var buf = Buffer.allocUnsafe(16);
  buf.writeUInt32BE(out[0] >>> 0, 0);
  buf.writeUInt32BE(out[1] >>> 0, 4);
  buf.writeUInt32BE(out[2] >>> 0, 8);
  buf.writeUInt32BE(out[3] >>> 0, 12);
  return buf;
}
function GHASH(key) {
  this.h = key;
  this.state = Buffer.alloc(16, 0);
  this.cache = Buffer.allocUnsafe(0);
}

// from http://bitwiseshiftleft.github.io/sjcl/doc/symbols/src/core_gcm.js.html
// by Juho Vh-Herttua
GHASH.prototype.ghash = function (block) {
  var i = -1;
  while (++i < block.length) {
    this.state[i] ^= block[i];
  }
  this._multiply();
};
GHASH.prototype._multiply = function () {
  var Vi = toArray(this.h);
  var Zi = [0, 0, 0, 0];
  var j, xi, lsbVi;
  var i = -1;
  while (++i < 128) {
    xi = (this.state[~~(i / 8)] & 1 << 7 - i % 8) !== 0;
    if (xi) {
      // Z_i+1 = Z_i ^ V_i
      Zi[0] ^= Vi[0];
      Zi[1] ^= Vi[1];
      Zi[2] ^= Vi[2];
      Zi[3] ^= Vi[3];
    }

    // Store the value of LSB(V_i)
    lsbVi = (Vi[3] & 1) !== 0;

    // V_i+1 = V_i >> 1
    for (j = 3; j > 0; j--) {
      Vi[j] = Vi[j] >>> 1 | (Vi[j - 1] & 1) << 31;
    }
    Vi[0] = Vi[0] >>> 1;

    // If LSB(V_i) is 1, V_i+1 = (V_i >> 1) ^ R
    if (lsbVi) {
      Vi[0] = Vi[0] ^ 0xe1 << 24;
    }
  }
  this.state = fromArray(Zi);
};
GHASH.prototype.update = function (buf) {
  this.cache = Buffer.concat([this.cache, buf]);
  var chunk;
  while (this.cache.length >= 16) {
    chunk = this.cache.slice(0, 16);
    this.cache = this.cache.slice(16);
    this.ghash(chunk);
  }
};
GHASH.prototype["final"] = function (abl, bl) {
  if (this.cache.length) {
    this.ghash(Buffer.concat([this.cache, ZEROES], 16));
  }
  this.ghash(fromArray([0, abl, 0, bl]));
  return this.state;
};
module.exports = GHASH;

},{"safe-buffer":384}],112:[function(require,module,exports){
"use strict";

function incr32(iv) {
  var len = iv.length;
  var item;
  while (len--) {
    item = iv.readUInt8(len);
    if (item === 255) {
      iv.writeUInt8(0, len);
    } else {
      item++;
      iv.writeUInt8(item, len);
      break;
    }
  }
}
module.exports = incr32;

},{}],113:[function(require,module,exports){
"use strict";

var xor = require('buffer-xor');
exports.encrypt = function (self, block) {
  var data = xor(block, self._prev);
  self._prev = self._cipher.encryptBlock(data);
  return self._prev;
};
exports.decrypt = function (self, block) {
  var pad = self._prev;
  self._prev = block;
  var out = self._cipher.decryptBlock(block);
  return xor(out, pad);
};

},{"buffer-xor":138}],114:[function(require,module,exports){
"use strict";

var Buffer = require('safe-buffer').Buffer;
var xor = require('buffer-xor');
function encryptStart(self, data, decrypt) {
  var len = data.length;
  var out = xor(data, self._cache);
  self._cache = self._cache.slice(len);
  self._prev = Buffer.concat([self._prev, decrypt ? data : out]);
  return out;
}
exports.encrypt = function (self, data, decrypt) {
  var out = Buffer.allocUnsafe(0);
  var len;
  while (data.length) {
    if (self._cache.length === 0) {
      self._cache = self._cipher.encryptBlock(self._prev);
      self._prev = Buffer.allocUnsafe(0);
    }
    if (self._cache.length <= data.length) {
      len = self._cache.length;
      out = Buffer.concat([out, encryptStart(self, data.slice(0, len), decrypt)]);
      data = data.slice(len);
    } else {
      out = Buffer.concat([out, encryptStart(self, data, decrypt)]);
      break;
    }
  }
  return out;
};

},{"buffer-xor":138,"safe-buffer":384}],115:[function(require,module,exports){
"use strict";

var Buffer = require('safe-buffer').Buffer;
function encryptByte(self, byteParam, decrypt) {
  var pad;
  var i = -1;
  var len = 8;
  var out = 0;
  var bit, value;
  while (++i < len) {
    pad = self._cipher.encryptBlock(self._prev);
    bit = byteParam & 1 << 7 - i ? 0x80 : 0;
    value = pad[0] ^ bit;
    out += (value & 0x80) >> i % 8;
    self._prev = shiftIn(self._prev, decrypt ? bit : value);
  }
  return out;
}
function shiftIn(buffer, value) {
  var len = buffer.length;
  var i = -1;
  var out = Buffer.allocUnsafe(buffer.length);
  buffer = Buffer.concat([buffer, Buffer.from([value])]);
  while (++i < len) {
    out[i] = buffer[i] << 1 | buffer[i + 1] >> 7;
  }
  return out;
}
exports.encrypt = function (self, chunk, decrypt) {
  var len = chunk.length;
  var out = Buffer.allocUnsafe(len);
  var i = -1;
  while (++i < len) {
    out[i] = encryptByte(self, chunk[i], decrypt);
  }
  return out;
};

},{"safe-buffer":384}],116:[function(require,module,exports){
"use strict";

var Buffer = require('safe-buffer').Buffer;
function encryptByte(self, byteParam, decrypt) {
  var pad = self._cipher.encryptBlock(self._prev);
  var out = pad[0] ^ byteParam;
  self._prev = Buffer.concat([self._prev.slice(1), Buffer.from([decrypt ? byteParam : out])]);
  return out;
}
exports.encrypt = function (self, chunk, decrypt) {
  var len = chunk.length;
  var out = Buffer.allocUnsafe(len);
  var i = -1;
  while (++i < len) {
    out[i] = encryptByte(self, chunk[i], decrypt);
  }
  return out;
};

},{"safe-buffer":384}],117:[function(require,module,exports){
"use strict";

var xor = require('buffer-xor');
var Buffer = require('safe-buffer').Buffer;
var incr32 = require('../incr32');
function getBlock(self) {
  var out = self._cipher.encryptBlockRaw(self._prev);
  incr32(self._prev);
  return out;
}
var blockSize = 16;
exports.encrypt = function (self, chunk) {
  var chunkNum = Math.ceil(chunk.length / blockSize);
  var start = self._cache.length;
  self._cache = Buffer.concat([self._cache, Buffer.allocUnsafe(chunkNum * blockSize)]);
  for (var i = 0; i < chunkNum; i++) {
    var out = getBlock(self);
    var offset = start + i * blockSize;
    self._cache.writeUInt32BE(out[0], offset + 0);
    self._cache.writeUInt32BE(out[1], offset + 4);
    self._cache.writeUInt32BE(out[2], offset + 8);
    self._cache.writeUInt32BE(out[3], offset + 12);
  }
  var pad = self._cache.slice(0, chunk.length);
  self._cache = self._cache.slice(chunk.length);
  return xor(chunk, pad);
};

},{"../incr32":112,"buffer-xor":138,"safe-buffer":384}],118:[function(require,module,exports){
"use strict";

exports.encrypt = function (self, block) {
  return self._cipher.encryptBlock(block);
};
exports.decrypt = function (self, block) {
  return self._cipher.decryptBlock(block);
};

},{}],119:[function(require,module,exports){
"use strict";

var modeModules = {
  ECB: require('./ecb'),
  CBC: require('./cbc'),
  CFB: require('./cfb'),
  CFB8: require('./cfb8'),
  CFB1: require('./cfb1'),
  OFB: require('./ofb'),
  CTR: require('./ctr'),
  GCM: require('./ctr')
};
var modes = require('./list.json');
for (var key in modes) {
  modes[key].module = modeModules[modes[key].mode];
}
module.exports = modes;

},{"./cbc":113,"./cfb":114,"./cfb1":115,"./cfb8":116,"./ctr":117,"./ecb":118,"./list.json":120,"./ofb":121}],120:[function(require,module,exports){
module.exports={
  "aes-128-ecb": {
    "cipher": "AES",
    "key": 128,
    "iv": 0,
    "mode": "ECB",
    "type": "block"
  },
  "aes-192-ecb": {
    "cipher": "AES",
    "key": 192,
    "iv": 0,
    "mode": "ECB",
    "type": "block"
  },
  "aes-256-ecb": {
    "cipher": "AES",
    "key": 256,
    "iv": 0,
    "mode": "ECB",
    "type": "block"
  },
  "aes-128-cbc": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes-192-cbc": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes-256-cbc": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes128": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes192": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes256": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes-128-cfb": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CFB",
    "type": "stream"
  },
  "aes-192-cfb": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CFB",
    "type": "stream"
  },
  "aes-256-cfb": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CFB",
    "type": "stream"
  },
  "aes-128-cfb8": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CFB8",
    "type": "stream"
  },
  "aes-192-cfb8": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CFB8",
    "type": "stream"
  },
  "aes-256-cfb8": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CFB8",
    "type": "stream"
  },
  "aes-128-cfb1": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CFB1",
    "type": "stream"
  },
  "aes-192-cfb1": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CFB1",
    "type": "stream"
  },
  "aes-256-cfb1": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CFB1",
    "type": "stream"
  },
  "aes-128-ofb": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "OFB",
    "type": "stream"
  },
  "aes-192-ofb": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "OFB",
    "type": "stream"
  },
  "aes-256-ofb": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "OFB",
    "type": "stream"
  },
  "aes-128-ctr": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CTR",
    "type": "stream"
  },
  "aes-192-ctr": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CTR",
    "type": "stream"
  },
  "aes-256-ctr": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CTR",
    "type": "stream"
  },
  "aes-128-gcm": {
    "cipher": "AES",
    "key": 128,
    "iv": 12,
    "mode": "GCM",
    "type": "auth"
  },
  "aes-192-gcm": {
    "cipher": "AES",
    "key": 192,
    "iv": 12,
    "mode": "GCM",
    "type": "auth"
  },
  "aes-256-gcm": {
    "cipher": "AES",
    "key": 256,
    "iv": 12,
    "mode": "GCM",
    "type": "auth"
  }
}

},{}],121:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";

var xor = require('buffer-xor');
function getBlock(self) {
  self._prev = self._cipher.encryptBlock(self._prev);
  return self._prev;
}
exports.encrypt = function (self, chunk) {
  while (self._cache.length < chunk.length) {
    self._cache = Buffer.concat([self._cache, getBlock(self)]);
  }
  var pad = self._cache.slice(0, chunk.length);
  self._cache = self._cache.slice(chunk.length);
  return xor(chunk, pad);
};

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":139,"buffer-xor":138}],122:[function(require,module,exports){
"use strict";

var aes = require('./aes');
var Buffer = require('safe-buffer').Buffer;
var Transform = require('cipher-base');
var inherits = require('inherits');
function StreamCipher(mode, key, iv, decrypt) {
  Transform.call(this);
  this._cipher = new aes.AES(key);
  this._prev = Buffer.from(iv);
  this._cache = Buffer.allocUnsafe(0);
  this._secCache = Buffer.allocUnsafe(0);
  this._decrypt = decrypt;
  this._mode = mode;
}
inherits(StreamCipher, Transform);
StreamCipher.prototype._update = function (chunk) {
  return this._mode.encrypt(this, chunk, this._decrypt);
};
StreamCipher.prototype._final = function () {
  this._cipher.scrub();
};
module.exports = StreamCipher;

},{"./aes":106,"cipher-base":142,"inherits":327,"safe-buffer":384}],123:[function(require,module,exports){
"use strict";

var DES = require('browserify-des');
var aes = require('browserify-aes/browser');
var aesModes = require('browserify-aes/modes');
var desModes = require('browserify-des/modes');
var ebtk = require('evp_bytestokey');
function createCipher(suite, password) {
  suite = suite.toLowerCase();
  var keyLen, ivLen;
  if (aesModes[suite]) {
    keyLen = aesModes[suite].key;
    ivLen = aesModes[suite].iv;
  } else if (desModes[suite]) {
    keyLen = desModes[suite].key * 8;
    ivLen = desModes[suite].iv;
  } else {
    throw new TypeError('invalid suite type');
  }
  var keys = ebtk(password, false, keyLen, ivLen);
  return createCipheriv(suite, keys.key, keys.iv);
}
function createDecipher(suite, password) {
  suite = suite.toLowerCase();
  var keyLen, ivLen;
  if (aesModes[suite]) {
    keyLen = aesModes[suite].key;
    ivLen = aesModes[suite].iv;
  } else if (desModes[suite]) {
    keyLen = desModes[suite].key * 8;
    ivLen = desModes[suite].iv;
  } else {
    throw new TypeError('invalid suite type');
  }
  var keys = ebtk(password, false, keyLen, ivLen);
  return createDecipheriv(suite, keys.key, keys.iv);
}
function createCipheriv(suite, key, iv) {
  suite = suite.toLowerCase();
  if (aesModes[suite]) return aes.createCipheriv(suite, key, iv);
  if (desModes[suite]) return new DES({
    key: key,
    iv: iv,
    mode: suite
  });
  throw new TypeError('invalid suite type');
}
function createDecipheriv(suite, key, iv) {
  suite = suite.toLowerCase();
  if (aesModes[suite]) return aes.createDecipheriv(suite, key, iv);
  if (desModes[suite]) return new DES({
    key: key,
    iv: iv,
    mode: suite,
    decrypt: true
  });
  throw new TypeError('invalid suite type');
}
function getCiphers() {
  return Object.keys(desModes).concat(aes.getCiphers());
}
exports.createCipher = exports.Cipher = createCipher;
exports.createCipheriv = exports.Cipheriv = createCipheriv;
exports.createDecipher = exports.Decipher = createDecipher;
exports.createDecipheriv = exports.Decipheriv = createDecipheriv;
exports.listCiphers = exports.getCiphers = getCiphers;

},{"browserify-aes/browser":108,"browserify-aes/modes":119,"browserify-des":124,"browserify-des/modes":125,"evp_bytestokey":302}],124:[function(require,module,exports){
"use strict";

var CipherBase = require('cipher-base');
var des = require('des.js');
var inherits = require('inherits');
var Buffer = require('safe-buffer').Buffer;
var modes = {
  'des-ede3-cbc': des.CBC.instantiate(des.EDE),
  'des-ede3': des.EDE,
  'des-ede-cbc': des.CBC.instantiate(des.EDE),
  'des-ede': des.EDE,
  'des-cbc': des.CBC.instantiate(des.DES),
  'des-ecb': des.DES
};
modes.des = modes['des-cbc'];
modes.des3 = modes['des-ede3-cbc'];
module.exports = DES;
inherits(DES, CipherBase);
function DES(opts) {
  CipherBase.call(this);
  var modeName = opts.mode.toLowerCase();
  var mode = modes[modeName];
  var type;
  if (opts.decrypt) {
    type = 'decrypt';
  } else {
    type = 'encrypt';
  }
  var key = opts.key;
  if (!Buffer.isBuffer(key)) {
    key = Buffer.from(key);
  }
  if (modeName === 'des-ede' || modeName === 'des-ede-cbc') {
    key = Buffer.concat([key, key.slice(0, 8)]);
  }
  var iv = opts.iv;
  if (!Buffer.isBuffer(iv)) {
    iv = Buffer.from(iv);
  }
  this._des = mode.create({
    key: key,
    iv: iv,
    type: type
  });
}
DES.prototype._update = function (data) {
  return Buffer.from(this._des.update(data));
};
DES.prototype._final = function () {
  return Buffer.from(this._des["final"]());
};

},{"cipher-base":142,"des.js":151,"inherits":327,"safe-buffer":384}],125:[function(require,module,exports){
"use strict";

exports['des-ecb'] = {
  key: 8,
  iv: 0
};
exports['des-cbc'] = exports.des = {
  key: 8,
  iv: 8
};
exports['des-ede3-cbc'] = exports.des3 = {
  key: 24,
  iv: 8
};
exports['des-ede3'] = {
  key: 24,
  iv: 0
};
exports['des-ede-cbc'] = {
  key: 16,
  iv: 8
};
exports['des-ede'] = {
  key: 16,
  iv: 0
};

},{}],126:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";

var BN = require('bn.js');
var randomBytes = require('randombytes');
function blind(priv) {
  var r = getr(priv);
  var blinder = r.toRed(BN.mont(priv.modulus)).redPow(new BN(priv.publicExponent)).fromRed();
  return {
    blinder: blinder,
    unblinder: r.invm(priv.modulus)
  };
}
function getr(priv) {
  var len = priv.modulus.byteLength();
  var r;
  do {
    r = new BN(randomBytes(len));
  } while (r.cmp(priv.modulus) >= 0 || !r.umod(priv.prime1) || !r.umod(priv.prime2));
  return r;
}
function crt(msg, priv) {
  var blinds = blind(priv);
  var len = priv.modulus.byteLength();
  var blinded = new BN(msg).mul(blinds.blinder).umod(priv.modulus);
  var c1 = blinded.toRed(BN.mont(priv.prime1));
  var c2 = blinded.toRed(BN.mont(priv.prime2));
  var qinv = priv.coefficient;
  var p = priv.prime1;
  var q = priv.prime2;
  var m1 = c1.redPow(priv.exponent1).fromRed();
  var m2 = c2.redPow(priv.exponent2).fromRed();
  var h = m1.isub(m2).imul(qinv).umod(p).imul(q);
  return m2.iadd(h).imul(blinds.unblinder).umod(priv.modulus).toArrayLike(Buffer, 'be', len);
}
crt.getr = getr;
module.exports = crt;

}).call(this)}).call(this,require("buffer").Buffer)
},{"bn.js":127,"buffer":139,"randombytes":370}],127:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"buffer":105,"dup":26}],128:[function(require,module,exports){
'use strict';

module.exports = require('./browser/algorithms.json');

},{"./browser/algorithms.json":129}],129:[function(require,module,exports){
module.exports={
  "sha224WithRSAEncryption": {
    "sign": "rsa",
    "hash": "sha224",
    "id": "302d300d06096086480165030402040500041c"
  },
  "RSA-SHA224": {
    "sign": "ecdsa/rsa",
    "hash": "sha224",
    "id": "302d300d06096086480165030402040500041c"
  },
  "sha256WithRSAEncryption": {
    "sign": "rsa",
    "hash": "sha256",
    "id": "3031300d060960864801650304020105000420"
  },
  "RSA-SHA256": {
    "sign": "ecdsa/rsa",
    "hash": "sha256",
    "id": "3031300d060960864801650304020105000420"
  },
  "sha384WithRSAEncryption": {
    "sign": "rsa",
    "hash": "sha384",
    "id": "3041300d060960864801650304020205000430"
  },
  "RSA-SHA384": {
    "sign": "ecdsa/rsa",
    "hash": "sha384",
    "id": "3041300d060960864801650304020205000430"
  },
  "sha512WithRSAEncryption": {
    "sign": "rsa",
    "hash": "sha512",
    "id": "3051300d060960864801650304020305000440"
  },
  "RSA-SHA512": {
    "sign": "ecdsa/rsa",
    "hash": "sha512",
    "id": "3051300d060960864801650304020305000440"
  },
  "RSA-SHA1": {
    "sign": "rsa",
    "hash": "sha1",
    "id": "3021300906052b0e03021a05000414"
  },
  "ecdsa-with-SHA1": {
    "sign": "ecdsa",
    "hash": "sha1",
    "id": ""
  },
  "sha256": {
    "sign": "ecdsa",
    "hash": "sha256",
    "id": ""
  },
  "sha224": {
    "sign": "ecdsa",
    "hash": "sha224",
    "id": ""
  },
  "sha384": {
    "sign": "ecdsa",
    "hash": "sha384",
    "id": ""
  },
  "sha512": {
    "sign": "ecdsa",
    "hash": "sha512",
    "id": ""
  },
  "DSA-SHA": {
    "sign": "dsa",
    "hash": "sha1",
    "id": ""
  },
  "DSA-SHA1": {
    "sign": "dsa",
    "hash": "sha1",
    "id": ""
  },
  "DSA": {
    "sign": "dsa",
    "hash": "sha1",
    "id": ""
  },
  "DSA-WITH-SHA224": {
    "sign": "dsa",
    "hash": "sha224",
    "id": ""
  },
  "DSA-SHA224": {
    "sign": "dsa",
    "hash": "sha224",
    "id": ""
  },
  "DSA-WITH-SHA256": {
    "sign": "dsa",
    "hash": "sha256",
    "id": ""
  },
  "DSA-SHA256": {
    "sign": "dsa",
    "hash": "sha256",
    "id": ""
  },
  "DSA-WITH-SHA384": {
    "sign": "dsa",
    "hash": "sha384",
    "id": ""
  },
  "DSA-SHA384": {
    "sign": "dsa",
    "hash": "sha384",
    "id": ""
  },
  "DSA-WITH-SHA512": {
    "sign": "dsa",
    "hash": "sha512",
    "id": ""
  },
  "DSA-SHA512": {
    "sign": "dsa",
    "hash": "sha512",
    "id": ""
  },
  "DSA-RIPEMD160": {
    "sign": "dsa",
    "hash": "rmd160",
    "id": ""
  },
  "ripemd160WithRSA": {
    "sign": "rsa",
    "hash": "rmd160",
    "id": "3021300906052b2403020105000414"
  },
  "RSA-RIPEMD160": {
    "sign": "rsa",
    "hash": "rmd160",
    "id": "3021300906052b2403020105000414"
  },
  "md5WithRSAEncryption": {
    "sign": "rsa",
    "hash": "md5",
    "id": "3020300c06082a864886f70d020505000410"
  },
  "RSA-MD5": {
    "sign": "rsa",
    "hash": "md5",
    "id": "3020300c06082a864886f70d020505000410"
  }
}

},{}],130:[function(require,module,exports){
module.exports={
  "1.3.132.0.10": "secp256k1",
  "1.3.132.0.33": "p224",
  "1.2.840.10045.3.1.1": "p192",
  "1.2.840.10045.3.1.7": "p256",
  "1.3.132.0.34": "p384",
  "1.3.132.0.35": "p521"
}

},{}],131:[function(require,module,exports){
'use strict';

var Buffer = require('safe-buffer').Buffer;
var createHash = require('create-hash');
var stream = require('readable-stream');
var inherits = require('inherits');
var sign = require('./sign');
var verify = require('./verify');
var algorithms = require('./algorithms.json');
Object.keys(algorithms).forEach(function (key) {
  algorithms[key].id = Buffer.from(algorithms[key].id, 'hex');
  algorithms[key.toLowerCase()] = algorithms[key];
});
function Sign(algorithm) {
  stream.Writable.call(this);
  var data = algorithms[algorithm];
  if (!data) {
    throw new Error('Unknown message digest');
  }
  this._hashType = data.hash;
  this._hash = createHash(data.hash);
  this._tag = data.id;
  this._signType = data.sign;
}
inherits(Sign, stream.Writable);
Sign.prototype._write = function _write(data, _, done) {
  this._hash.update(data);
  done();
};
Sign.prototype.update = function update(data, enc) {
  this._hash.update(typeof data === 'string' ? Buffer.from(data, enc) : data);
  return this;
};
Sign.prototype.sign = function signMethod(key, enc) {
  this.end();
  var hash = this._hash.digest();
  var sig = sign(hash, key, this._hashType, this._signType, this._tag);
  return enc ? sig.toString(enc) : sig;
};
function Verify(algorithm) {
  stream.Writable.call(this);
  var data = algorithms[algorithm];
  if (!data) {
    throw new Error('Unknown message digest');
  }
  this._hash = createHash(data.hash);
  this._tag = data.id;
  this._signType = data.sign;
}
inherits(Verify, stream.Writable);
Verify.prototype._write = function _write(data, _, done) {
  this._hash.update(data);
  done();
};
Verify.prototype.update = function update(data, enc) {
  this._hash.update(typeof data === 'string' ? Buffer.from(data, enc) : data);
  return this;
};
Verify.prototype.verify = function verifyMethod(key, sig, enc) {
  var sigBuffer = typeof sig === 'string' ? Buffer.from(sig, enc) : sig;
  this.end();
  var hash = this._hash.digest();
  return verify(sigBuffer, hash, key, this._signType, this._tag);
};
function createSign(algorithm) {
  return new Sign(algorithm);
}
function createVerify(algorithm) {
  return new Verify(algorithm);
}
module.exports = {
  Sign: createSign,
  Verify: createVerify,
  createSign: createSign,
  createVerify: createVerify
};

},{"./algorithms.json":129,"./sign":132,"./verify":133,"create-hash":145,"inherits":135,"readable-stream":381,"safe-buffer":136}],132:[function(require,module,exports){
'use strict';

// much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js
var Buffer = require('safe-buffer').Buffer;
var createHmac = require('create-hmac');
var crt = require('browserify-rsa');
var EC = require('elliptic').ec;
var BN = require('bn.js');
var parseKeys = require('parse-asn1');
var curves = require('./curves.json');
var RSA_PKCS1_PADDING = 1;
function sign(hash, key, hashType, signType, tag) {
  var priv = parseKeys(key);
  if (priv.curve) {
    // rsa keys can be interpreted as ecdsa ones in openssl
    if (signType !== 'ecdsa' && signType !== 'ecdsa/rsa') {
      throw new Error('wrong private key type');
    }
    return ecSign(hash, priv);
  } else if (priv.type === 'dsa') {
    if (signType !== 'dsa') {
      throw new Error('wrong private key type');
    }
    return dsaSign(hash, priv, hashType);
  }
  if (signType !== 'rsa' && signType !== 'ecdsa/rsa') {
    throw new Error('wrong private key type');
  }
  if (key.padding !== undefined && key.padding !== RSA_PKCS1_PADDING) {
    throw new Error('illegal or unsupported padding mode');
  }
  hash = Buffer.concat([tag, hash]);
  var len = priv.modulus.byteLength();
  var pad = [0, 1];
  while (hash.length + pad.length + 1 < len) {
    pad.push(0xff);
  }
  pad.push(0x00);
  var i = -1;
  while (++i < hash.length) {
    pad.push(hash[i]);
  }
  var out = crt(pad, priv);
  return out;
}
function ecSign(hash, priv) {
  var curveId = curves[priv.curve.join('.')];
  if (!curveId) {
    throw new Error('unknown curve ' + priv.curve.join('.'));
  }
  var curve = new EC(curveId);
  var key = curve.keyFromPrivate(priv.privateKey);
  var out = key.sign(hash);
  return Buffer.from(out.toDER());
}
function dsaSign(hash, priv, algo) {
  var x = priv.params.priv_key;
  var p = priv.params.p;
  var q = priv.params.q;
  var g = priv.params.g;
  var r = new BN(0);
  var k;
  var H = bits2int(hash, q).mod(q);
  var s = false;
  var kv = getKey(x, q, hash, algo);
  while (s === false) {
    k = makeKey(q, kv, algo);
    r = makeR(g, k, p, q);
    s = k.invm(q).imul(H.add(x.mul(r))).mod(q);
    if (s.cmpn(0) === 0) {
      s = false;
      r = new BN(0);
    }
  }
  return toDER(r, s);
}
function toDER(r, s) {
  r = r.toArray();
  s = s.toArray();

  // Pad values
  if (r[0] & 0x80) {
    r = [0].concat(r);
  }
  if (s[0] & 0x80) {
    s = [0].concat(s);
  }
  var total = r.length + s.length + 4;
  var res = [0x30, total, 0x02, r.length];
  res = res.concat(r, [0x02, s.length], s);
  return Buffer.from(res);
}
function getKey(x, q, hash, algo) {
  x = Buffer.from(x.toArray());
  if (x.length < q.byteLength()) {
    var zeros = Buffer.alloc(q.byteLength() - x.length);
    x = Buffer.concat([zeros, x]);
  }
  var hlen = hash.length;
  var hbits = bits2octets(hash, q);
  var v = Buffer.alloc(hlen);
  v.fill(1);
  var k = Buffer.alloc(hlen);
  k = createHmac(algo, k).update(v).update(Buffer.from([0])).update(x).update(hbits).digest();
  v = createHmac(algo, k).update(v).digest();
  k = createHmac(algo, k).update(v).update(Buffer.from([1])).update(x).update(hbits).digest();
  v = createHmac(algo, k).update(v).digest();
  return {
    k: k,
    v: v
  };
}
function bits2int(obits, q) {
  var bits = new BN(obits);
  var shift = (obits.length << 3) - q.bitLength();
  if (shift > 0) {
    bits.ishrn(shift);
  }
  return bits;
}
function bits2octets(bits, q) {
  bits = bits2int(bits, q);
  bits = bits.mod(q);
  var out = Buffer.from(bits.toArray());
  if (out.length < q.byteLength()) {
    var zeros = Buffer.alloc(q.byteLength() - out.length);
    out = Buffer.concat([zeros, out]);
  }
  return out;
}
function makeKey(q, kv, algo) {
  var t;
  var k;
  do {
    t = Buffer.alloc(0);
    while (t.length * 8 < q.bitLength()) {
      kv.v = createHmac(algo, kv.k).update(kv.v).digest();
      t = Buffer.concat([t, kv.v]);
    }
    k = bits2int(t, q);
    kv.k = createHmac(algo, kv.k).update(kv.v).update(Buffer.from([0])).digest();
    kv.v = createHmac(algo, kv.k).update(kv.v).digest();
  } while (k.cmp(q) !== -1);
  return k;
}
function makeR(g, k, p, q) {
  return g.toRed(BN.mont(p)).redPow(k).fromRed().mod(q);
}
module.exports = sign;
module.exports.getKey = getKey;
module.exports.makeKey = makeKey;

},{"./curves.json":130,"bn.js":134,"browserify-rsa":126,"create-hmac":147,"elliptic":161,"parse-asn1":353,"safe-buffer":136}],133:[function(require,module,exports){
'use strict';

// much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js
var Buffer = require('safe-buffer').Buffer;
var BN = require('bn.js');
var EC = require('elliptic').ec;
var parseKeys = require('parse-asn1');
var curves = require('./curves.json');
function verify(sig, hash, key, signType, tag) {
  var pub = parseKeys(key);
  if (pub.type === 'ec') {
    // rsa keys can be interpreted as ecdsa ones in openssl
    if (signType !== 'ecdsa' && signType !== 'ecdsa/rsa') {
      throw new Error('wrong public key type');
    }
    return ecVerify(sig, hash, pub);
  } else if (pub.type === 'dsa') {
    if (signType !== 'dsa') {
      throw new Error('wrong public key type');
    }
    return dsaVerify(sig, hash, pub);
  }
  if (signType !== 'rsa' && signType !== 'ecdsa/rsa') {
    throw new Error('wrong public key type');
  }
  hash = Buffer.concat([tag, hash]);
  var len = pub.modulus.byteLength();
  var pad = [1];
  var padNum = 0;
  while (hash.length + pad.length + 2 < len) {
    pad.push(0xff);
    padNum += 1;
  }
  pad.push(0x00);
  var i = -1;
  while (++i < hash.length) {
    pad.push(hash[i]);
  }
  pad = Buffer.from(pad);
  var red = BN.mont(pub.modulus);
  sig = new BN(sig).toRed(red);
  sig = sig.redPow(new BN(pub.publicExponent));
  sig = Buffer.from(sig.fromRed().toArray());
  var out = padNum < 8 ? 1 : 0;
  len = Math.min(sig.length, pad.length);
  if (sig.length !== pad.length) {
    out = 1;
  }
  i = -1;
  while (++i < len) {
    out |= sig[i] ^ pad[i];
  }
  return out === 0;
}
function ecVerify(sig, hash, pub) {
  var curveId = curves[pub.data.algorithm.curve.join('.')];
  if (!curveId) {
    throw new Error('unknown curve ' + pub.data.algorithm.curve.join('.'));
  }
  var curve = new EC(curveId);
  var pubkey = pub.data.subjectPrivateKey.data;
  return curve.verify(hash, sig, pubkey);
}
function dsaVerify(sig, hash, pub) {
  var p = pub.data.p;
  var q = pub.data.q;
  var g = pub.data.g;
  var y = pub.data.pub_key;
  var unpacked = parseKeys.signature.decode(sig, 'der');
  var s = unpacked.s;
  var r = unpacked.r;
  checkValue(s, q);
  checkValue(r, q);
  var montp = BN.mont(p);
  var w = s.invm(q);
  var v = g.toRed(montp).redPow(new BN(hash).mul(w).mod(q)).fromRed().mul(y.toRed(montp).redPow(r.mul(w).mod(q)).fromRed()).mod(p).mod(q);
  return v.cmp(r) === 0;
}
function checkValue(b, q) {
  if (b.cmpn(0) <= 0) {
    throw new Error('invalid sig');
  }
  if (b.cmp(q) >= 0) {
    throw new Error('invalid sig');
  }
}
module.exports = verify;

},{"./curves.json":130,"bn.js":134,"elliptic":161,"parse-asn1":353,"safe-buffer":136}],134:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"buffer":105,"dup":26}],135:[function(require,module,exports){
"use strict";

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function TempCtor() {};
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
  };
}

},{}],136:[function(require,module,exports){
"use strict";

/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer');
var Buffer = buffer.Buffer;

// alternative to using Object.keys for old browsers
function copyProps(src, dst) {
  for (var key in src) {
    dst[key] = src[key];
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer;
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports);
  exports.Buffer = SafeBuffer;
}
function SafeBuffer(arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length);
}
SafeBuffer.prototype = Object.create(Buffer.prototype);

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer);
SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number');
  }
  return Buffer(arg, encodingOrOffset, length);
};
SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }
  var buf = Buffer(size);
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding);
    } else {
      buf.fill(fill);
    }
  } else {
    buf.fill(0);
  }
  return buf;
};
SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }
  return Buffer(size);
};
SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }
  return buffer.SlowBuffer(size);
};

},{"buffer":139}],137:[function(require,module,exports){
"use strict";

},{}],138:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";

module.exports = function xor(a, b) {
  var length = Math.min(a.length, b.length);
  var buffer = new Buffer(length);
  for (var i = 0; i < length; ++i) {
    buffer[i] = a[i] ^ b[i];
  }
  return buffer;
};

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":139}],139:[function(require,module,exports){
(function (Buffer){(function (){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict';

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var base64 = require('base64-js');
var ieee754 = require('ieee754');
exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;
var K_MAX_LENGTH = 0x7fffffff;
exports.kMaxLength = K_MAX_LENGTH;

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' && typeof console.error === 'function') {
  console.error('This browser lacks typed array (Uint8Array) support which is required by ' + '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.');
}
function typedArraySupport() {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1);
    arr.__proto__ = {
      __proto__: Uint8Array.prototype,
      foo: function foo() {
        return 42;
      }
    };
    return arr.foo() === 42;
  } catch (e) {
    return false;
  }
}
Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function get() {
    if (!Buffer.isBuffer(this)) return undefined;
    return this.buffer;
  }
});
Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function get() {
    if (!Buffer.isBuffer(this)) return undefined;
    return this.byteOffset;
  }
});
function createBuffer(length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"');
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length);
  buf.__proto__ = Buffer.prototype;
  return buf;
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer(arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError('The "string" argument must be of type string. Received type number');
    }
    return allocUnsafe(arg);
  }
  return from(arg, encodingOrOffset, length);
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null && Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  });
}
Buffer.poolSize = 8192; // not used by this implementation

function from(value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset);
  }
  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value);
  }
  if (value == null) {
    throw TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + _typeof(value));
  }
  if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
    return fromArrayBuffer(value, encodingOrOffset, length);
  }
  if (typeof value === 'number') {
    throw new TypeError('The "value" argument must not be of type number. Received type number');
  }
  var valueOf = value.valueOf && value.valueOf();
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length);
  }
  var b = fromObject(value);
  if (b) return b;
  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length);
  }
  throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + _typeof(value));
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length);
};

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype;
Buffer.__proto__ = Uint8Array;
function assertSize(size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number');
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"');
  }
}
function alloc(size, fill, encoding) {
  assertSize(size);
  if (size <= 0) {
    return createBuffer(size);
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string' ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
  }
  return createBuffer(size);
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding);
};
function allocUnsafe(size) {
  assertSize(size);
  return createBuffer(size < 0 ? 0 : checked(size) | 0);
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size);
};
function fromString(string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }
  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding);
  }
  var length = byteLength(string, encoding) | 0;
  var buf = createBuffer(length);
  var actual = buf.write(string, encoding);
  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual);
  }
  return buf;
}
function fromArrayLike(array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  var buf = createBuffer(length);
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255;
  }
  return buf;
}
function fromArrayBuffer(array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds');
  }
  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds');
  }
  var buf;
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array);
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset);
  } else {
    buf = new Uint8Array(array, byteOffset, length);
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype;
  return buf;
}
function fromObject(obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0;
    var buf = createBuffer(len);
    if (buf.length === 0) {
      return buf;
    }
    obj.copy(buf, 0, 0, len);
    return buf;
  }
  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0);
    }
    return fromArrayLike(obj);
  }
  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data);
  }
}
function checked(length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes');
  }
  return length | 0;
}
function SlowBuffer(length) {
  if (+length != length) {
    // eslint-disable-line eqeqeq
    length = 0;
  }
  return Buffer.alloc(+length);
}
Buffer.isBuffer = function isBuffer(b) {
  return b != null && b._isBuffer === true && b !== Buffer.prototype; // so Buffer.isBuffer(Buffer.prototype) will be false
};
Buffer.compare = function compare(a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
  }
  if (a === b) return 0;
  var x = a.length;
  var y = b.length;
  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }
  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};
Buffer.isEncoding = function isEncoding(encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true;
    default:
      return false;
  }
};
Buffer.concat = function concat(list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }
  if (list.length === 0) {
    return Buffer.alloc(0);
  }
  var i;
  if (length === undefined) {
    length = 0;
    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }
  var buffer = Buffer.allocUnsafe(length);
  var pos = 0;
  for (i = 0; i < list.length; ++i) {
    var buf = list[i];
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf);
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer;
};
function byteLength(string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length;
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength;
  }
  if (typeof string !== 'string') {
    throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' + 'Received type ' + _typeof(string));
  }
  var len = string.length;
  var mustMatch = arguments.length > 2 && arguments[2] === true;
  if (!mustMatch && len === 0) return 0;

  // Use a for loop to avoid recursion
  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len;
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length;
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2;
      case 'hex':
        return len >>> 1;
      case 'base64':
        return base64ToBytes(string).length;
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length; // assume utf8
        }
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer.byteLength = byteLength;
function slowToString(encoding, start, end) {
  var loweredCase = false;

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0;
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return '';
  }
  if (end === undefined || end > this.length) {
    end = this.length;
  }
  if (end <= 0) {
    return '';
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0;
  start >>>= 0;
  if (end <= start) {
    return '';
  }
  if (!encoding) encoding = 'utf8';
  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end);
      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end);
      case 'ascii':
        return asciiSlice(this, start, end);
      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end);
      case 'base64':
        return base64Slice(this, start, end);
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end);
      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true;
function swap(b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}
Buffer.prototype.swap16 = function swap16() {
  var len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits');
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }
  return this;
};
Buffer.prototype.swap32 = function swap32() {
  var len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits');
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }
  return this;
};
Buffer.prototype.swap64 = function swap64() {
  var len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits');
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }
  return this;
};
Buffer.prototype.toString = function toString() {
  var length = this.length;
  if (length === 0) return '';
  if (arguments.length === 0) return utf8Slice(this, 0, length);
  return slowToString.apply(this, arguments);
};
Buffer.prototype.toLocaleString = Buffer.prototype.toString;
Buffer.prototype.equals = function equals(b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
  if (this === b) return true;
  return Buffer.compare(this, b) === 0;
};
Buffer.prototype.inspect = function inspect() {
  var str = '';
  var max = exports.INSPECT_MAX_BYTES;
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();
  if (this.length > max) str += ' ... ';
  return '<Buffer ' + str + '>';
};
Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength);
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. ' + 'Received type ' + _typeof(target));
  }
  if (start === undefined) {
    start = 0;
  }
  if (end === undefined) {
    end = target ? target.length : 0;
  }
  if (thisStart === undefined) {
    thisStart = 0;
  }
  if (thisEnd === undefined) {
    thisEnd = this.length;
  }
  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index');
  }
  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }
  if (thisStart >= thisEnd) {
    return -1;
  }
  if (start >= end) {
    return 1;
  }
  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target) return 0;
  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);
  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);
  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break;
    }
  }
  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1;

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000;
  }
  byteOffset = +byteOffset; // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir) return -1;else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;else return -1;
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding);
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1;
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === 'number') {
    val = val & 0xFF; // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }
  throw new TypeError('val must be string, number or Buffer');
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;
  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();
    if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }
  function read(buf, i) {
    if (indexSize === 1) {
      return buf[i];
    } else {
      return buf.readUInt16BE(i * indexSize);
    }
  }
  var i;
  if (dir) {
    var foundIndex = -1;
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
    for (i = byteOffset; i >= 0; i--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false;
          break;
        }
      }
      if (found) return i;
    }
  }
  return -1;
}
Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }
  var strLen = string.length;
  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (numberIsNaN(parsed)) return i;
    buf[offset + i] = parsed;
  }
  return i;
}
function utf8Write(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}
function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}
function latin1Write(buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length);
}
function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}
function ucs2Write(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}
Buffer.prototype.write = function write(string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0;
    // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0;
    if (isFinite(length)) {
      length = length >>> 0;
      if (encoding === undefined) encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    }
  } else {
    throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
  }
  var remaining = this.length - offset;
  if (length === undefined || length > remaining) length = remaining;
  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds');
  }
  if (!encoding) encoding = 'utf8';
  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length);
      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length);
      case 'ascii':
        return asciiWrite(this, string, offset, length);
      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length);
      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length);
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length);
      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};
Buffer.prototype.toJSON = function toJSON() {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};
function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf);
  } else {
    return base64.fromByteArray(buf.slice(start, end));
  }
}
function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];
  var i = start;
  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;
    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }
    res.push(codePoint);
    i += bytesPerSequence;
  }
  return decodeCodePointsArray(res);
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000;
function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = '';
  var i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }
  return res;
}
function asciiSlice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);
  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F);
  }
  return ret;
}
function latin1Slice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);
  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret;
}
function hexSlice(buf, start, end) {
  var len = buf.length;
  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;
  var out = '';
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i]);
  }
  return out;
}
function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = '';
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res;
}
Buffer.prototype.slice = function slice(start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;
  if (start < 0) {
    start += len;
    if (start < 0) start = 0;
  } else if (start > len) {
    start = len;
  }
  if (end < 0) {
    end += len;
    if (end < 0) end = 0;
  } else if (end > len) {
    end = len;
  }
  if (end < start) end = start;
  var newBuf = this.subarray(start, end);
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype;
  return newBuf;
};

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}
Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }
  return val;
};
Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length);
  }
  var val = this[offset + --byteLength];
  var mul = 1;
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul;
  }
  return val;
};
Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 1, this.length);
  return this[offset];
};
Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] | this[offset + 1] << 8;
};
Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] << 8 | this[offset + 1];
};
Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};
Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};
Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }
  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};
Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul;
  }
  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};
Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 1, this.length);
  if (!(this[offset] & 0x80)) return this[offset];
  return (0xff - this[offset] + 1) * -1;
};
Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset] | this[offset + 1] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | this[offset] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};
Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};
Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, true, 23, 4);
};
Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, false, 23, 4);
};
Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, true, 52, 8);
};
Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, false, 52, 8);
};
function checkInt(buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
}
Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }
  var mul = 1;
  var i = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }
  return offset + byteLength;
};
Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }
  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }
  return offset + byteLength;
};
Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
  this[offset] = value & 0xff;
  return offset + 1;
};
Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  this[offset] = value & 0xff;
  this[offset + 1] = value >>> 8;
  return offset + 2;
};
Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  this[offset] = value >>> 8;
  this[offset + 1] = value & 0xff;
  return offset + 2;
};
Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  this[offset + 3] = value >>> 24;
  this[offset + 2] = value >>> 16;
  this[offset + 1] = value >>> 8;
  this[offset] = value & 0xff;
  return offset + 4;
};
Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  this[offset] = value >>> 24;
  this[offset + 1] = value >>> 16;
  this[offset + 2] = value >>> 8;
  this[offset + 3] = value & 0xff;
  return offset + 4;
};
Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }
  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }
  return offset + byteLength;
};
Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }
  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }
  return offset + byteLength;
};
Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
  if (value < 0) value = 0xff + value + 1;
  this[offset] = value & 0xff;
  return offset + 1;
};
Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  this[offset] = value & 0xff;
  this[offset + 1] = value >>> 8;
  return offset + 2;
};
Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  this[offset] = value >>> 8;
  this[offset + 1] = value & 0xff;
  return offset + 2;
};
Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  this[offset] = value & 0xff;
  this[offset + 1] = value >>> 8;
  this[offset + 2] = value >>> 16;
  this[offset + 3] = value >>> 24;
  return offset + 4;
};
Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (value < 0) value = 0xffffffff + value + 1;
  this[offset] = value >>> 24;
  this[offset + 1] = value >>> 16;
  this[offset + 2] = value >>> 8;
  this[offset + 3] = value & 0xff;
  return offset + 4;
};
function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
  if (offset < 0) throw new RangeError('Index out of range');
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}
Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert);
};
Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert);
};
function writeDouble(buf, value, offset, littleEndian, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}
Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert);
};
Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert);
};

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy(target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer');
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end > 0 && end < start) end = start;

  // Copy 0 bytes; we're done
  if (end === start) return 0;
  if (target.length === 0 || this.length === 0) return 0;

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds');
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range');
  if (end < 0) throw new RangeError('sourceEnd out of bounds');

  // Are we oob?
  if (end > this.length) end = this.length;
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }
  var len = end - start;
  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end);
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start];
    }
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
  }
  return len;
};

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill(val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string');
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding);
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0);
      if (encoding === 'utf8' && code < 128 || encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code;
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index');
  }
  if (end <= start) {
    return this;
  }
  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;
  if (!val) val = 0;
  var i;
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
    var len = bytes.length;
    if (len === 0) {
      throw new TypeError('The value "' + val + '" is invalid for argument "value"');
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }
  return this;
};

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
function base64clean(str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0];
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '');
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return '';
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '=';
  }
  return str;
}
function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}
function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];
  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i);

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        }

        // valid lead
        leadSurrogate = codePoint;
        continue;
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue;
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }
    leadSurrogate = null;

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break;
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break;
      bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break;
      bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break;
      bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else {
      throw new Error('Invalid code point');
    }
  }
  return bytes;
}
function asciiToBytes(str) {
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
  }
  return byteArray;
}
function utf16leToBytes(str, units) {
  var c, hi, lo;
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break;
    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }
  return byteArray;
}
function base64ToBytes(str) {
  return base64.toByteArray(base64clean(str));
}
function blitBuffer(src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length) break;
    dst[i + offset] = src[i];
  }
  return i;
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance(obj, type) {
  return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
}
function numberIsNaN(obj) {
  // For IE11 support
  return obj !== obj; // eslint-disable-line no-self-compare
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"base64-js":100,"buffer":139,"ieee754":326}],140:[function(require,module,exports){
'use strict';

var GetIntrinsic = require('get-intrinsic');
var callBind = require('./');
var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));
module.exports = function callBoundIntrinsic(name, allowMissing) {
  var intrinsic = GetIntrinsic(name, !!allowMissing);
  if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
    return callBind(intrinsic);
  }
  return intrinsic;
};

},{"./":141,"get-intrinsic":305}],141:[function(require,module,exports){
'use strict';

var bind = require('function-bind');
var GetIntrinsic = require('get-intrinsic');
var setFunctionLength = require('set-function-length');
var $TypeError = require('es-errors/type');
var $apply = GetIntrinsic('%Function.prototype.apply%');
var $call = GetIntrinsic('%Function.prototype.call%');
var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);
var $defineProperty = require('es-define-property');
var $max = GetIntrinsic('%Math.max%');
module.exports = function callBind(originalFunction) {
  if (typeof originalFunction !== 'function') {
    throw new $TypeError('a function is required');
  }
  var func = $reflectApply(bind, $call, arguments);
  return setFunctionLength(func, 1 + $max(0, originalFunction.length - (arguments.length - 1)), true);
};
var applyBind = function applyBind() {
  return $reflectApply(bind, $apply, arguments);
};
if ($defineProperty) {
  $defineProperty(module.exports, 'apply', {
    value: applyBind
  });
} else {
  module.exports.apply = applyBind;
}

},{"es-define-property":178,"es-errors/type":184,"function-bind":304,"get-intrinsic":305,"set-function-length":392}],142:[function(require,module,exports){
"use strict";

var Buffer = require('safe-buffer').Buffer;
var Transform = require('stream').Transform;
var StringDecoder = require('string_decoder').StringDecoder;
var inherits = require('inherits');
function CipherBase(hashMode) {
  Transform.call(this);
  this.hashMode = typeof hashMode === 'string';
  if (this.hashMode) {
    this[hashMode] = this._finalOrDigest;
  } else {
    this["final"] = this._finalOrDigest;
  }
  if (this._final) {
    this.__final = this._final;
    this._final = null;
  }
  this._decoder = null;
  this._encoding = null;
}
inherits(CipherBase, Transform);
CipherBase.prototype.update = function (data, inputEnc, outputEnc) {
  if (typeof data === 'string') {
    data = Buffer.from(data, inputEnc);
  }
  var outData = this._update(data);
  if (this.hashMode) return this;
  if (outputEnc) {
    outData = this._toString(outData, outputEnc);
  }
  return outData;
};
CipherBase.prototype.setAutoPadding = function () {};
CipherBase.prototype.getAuthTag = function () {
  throw new Error('trying to get auth tag in unsupported state');
};
CipherBase.prototype.setAuthTag = function () {
  throw new Error('trying to set auth tag in unsupported state');
};
CipherBase.prototype.setAAD = function () {
  throw new Error('trying to set aad in unsupported state');
};
CipherBase.prototype._transform = function (data, _, next) {
  var err;
  try {
    if (this.hashMode) {
      this._update(data);
    } else {
      this.push(this._update(data));
    }
  } catch (e) {
    err = e;
  } finally {
    next(err);
  }
};
CipherBase.prototype._flush = function (done) {
  var err;
  try {
    this.push(this.__final());
  } catch (e) {
    err = e;
  }
  done(err);
};
CipherBase.prototype._finalOrDigest = function (outputEnc) {
  var outData = this.__final() || Buffer.alloc(0);
  if (outputEnc) {
    outData = this._toString(outData, outputEnc, true);
  }
  return outData;
};
CipherBase.prototype._toString = function (value, enc, fin) {
  if (!this._decoder) {
    this._decoder = new StringDecoder(enc);
    this._encoding = enc;
  }
  if (this._encoding !== enc) throw new Error('can\'t switch encodings');
  var out = this._decoder.write(value);
  if (fin) {
    out += this._decoder.end();
  }
  return out;
};
module.exports = CipherBase;

},{"inherits":327,"safe-buffer":384,"stream":401,"string_decoder":417}],143:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;
function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;
function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;
function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;
function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;
function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;
function isSymbol(arg) {
  return _typeof(arg) === 'symbol';
}
exports.isSymbol = isSymbol;
function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;
function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;
function isObject(arg) {
  return _typeof(arg) === 'object' && arg !== null;
}
exports.isObject = isObject;
function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;
function isError(e) {
  return objectToString(e) === '[object Error]' || e instanceof Error;
}
exports.isError = isError;
function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;
function isPrimitive(arg) {
  return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || _typeof(arg) === 'symbol' ||
  // ES6 symbol
  typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;
exports.isBuffer = require('buffer').Buffer.isBuffer;
function objectToString(o) {
  return Object.prototype.toString.call(o);
}

},{"buffer":139}],144:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";

var elliptic = require('elliptic');
var BN = require('bn.js');
module.exports = function createECDH(curve) {
  return new ECDH(curve);
};
var aliases = {
  secp256k1: {
    name: 'secp256k1',
    byteLength: 32
  },
  secp224r1: {
    name: 'p224',
    byteLength: 28
  },
  prime256v1: {
    name: 'p256',
    byteLength: 32
  },
  prime192v1: {
    name: 'p192',
    byteLength: 24
  },
  ed25519: {
    name: 'ed25519',
    byteLength: 32
  },
  secp384r1: {
    name: 'p384',
    byteLength: 48
  },
  secp521r1: {
    name: 'p521',
    byteLength: 66
  }
};
aliases.p224 = aliases.secp224r1;
aliases.p256 = aliases.secp256r1 = aliases.prime256v1;
aliases.p192 = aliases.secp192r1 = aliases.prime192v1;
aliases.p384 = aliases.secp384r1;
aliases.p521 = aliases.secp521r1;
function ECDH(curve) {
  this.curveType = aliases[curve];
  if (!this.curveType) {
    this.curveType = {
      name: curve
    };
  }
  this.curve = new elliptic.ec(this.curveType.name); // eslint-disable-line new-cap
  this.keys = void 0;
}
ECDH.prototype.generateKeys = function (enc, format) {
  this.keys = this.curve.genKeyPair();
  return this.getPublicKey(enc, format);
};
ECDH.prototype.computeSecret = function (other, inenc, enc) {
  inenc = inenc || 'utf8';
  if (!Buffer.isBuffer(other)) {
    other = new Buffer(other, inenc);
  }
  var otherPub = this.curve.keyFromPublic(other).getPublic();
  var out = otherPub.mul(this.keys.getPrivate()).getX();
  return formatReturnValue(out, enc, this.curveType.byteLength);
};
ECDH.prototype.getPublicKey = function (enc, format) {
  var key = this.keys.getPublic(format === 'compressed', true);
  if (format === 'hybrid') {
    if (key[key.length - 1] % 2) {
      key[0] = 7;
    } else {
      key[0] = 6;
    }
  }
  return formatReturnValue(key, enc);
};
ECDH.prototype.getPrivateKey = function (enc) {
  return formatReturnValue(this.keys.getPrivate(), enc);
};
ECDH.prototype.setPublicKey = function (pub, enc) {
  enc = enc || 'utf8';
  if (!Buffer.isBuffer(pub)) {
    pub = new Buffer(pub, enc);
  }
  this.keys._importPublic(pub);
  return this;
};
ECDH.prototype.setPrivateKey = function (priv, enc) {
  enc = enc || 'utf8';
  if (!Buffer.isBuffer(priv)) {
    priv = new Buffer(priv, enc);
  }
  var _priv = new BN(priv);
  _priv = _priv.toString(16);
  this.keys = this.curve.genKeyPair();
  this.keys._importPrivate(_priv);
  return this;
};
function formatReturnValue(bn, enc, len) {
  if (!Array.isArray(bn)) {
    bn = bn.toArray();
  }
  var buf = new Buffer(bn);
  if (len && buf.length < len) {
    var zeros = new Buffer(len - buf.length);
    zeros.fill(0);
    buf = Buffer.concat([zeros, buf]);
  }
  if (!enc) {
    return buf;
  } else {
    return buf.toString(enc);
  }
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"bn.js":103,"buffer":139,"elliptic":161}],145:[function(require,module,exports){
'use strict';

var inherits = require('inherits');
var MD5 = require('md5.js');
var RIPEMD160 = require('ripemd160');
var sha = require('sha.js');
var Base = require('cipher-base');
function Hash(hash) {
  Base.call(this, 'digest');
  this._hash = hash;
}
inherits(Hash, Base);
Hash.prototype._update = function (data) {
  this._hash.update(data);
};
Hash.prototype._final = function () {
  return this._hash.digest();
};
module.exports = function createHash(alg) {
  alg = alg.toLowerCase();
  if (alg === 'md5') return new MD5();
  if (alg === 'rmd160' || alg === 'ripemd160') return new RIPEMD160();
  return new Hash(sha(alg));
};

},{"cipher-base":142,"inherits":327,"md5.js":340,"ripemd160":382,"sha.js":394}],146:[function(require,module,exports){
"use strict";

var MD5 = require('md5.js');
module.exports = function (buffer) {
  return new MD5().update(buffer).digest();
};

},{"md5.js":340}],147:[function(require,module,exports){
'use strict';

var inherits = require('inherits');
var Legacy = require('./legacy');
var Base = require('cipher-base');
var Buffer = require('safe-buffer').Buffer;
var md5 = require('create-hash/md5');
var RIPEMD160 = require('ripemd160');
var sha = require('sha.js');
var ZEROS = Buffer.alloc(128);
function Hmac(alg, key) {
  Base.call(this, 'digest');
  if (typeof key === 'string') {
    key = Buffer.from(key);
  }
  var blocksize = alg === 'sha512' || alg === 'sha384' ? 128 : 64;
  this._alg = alg;
  this._key = key;
  if (key.length > blocksize) {
    var hash = alg === 'rmd160' ? new RIPEMD160() : sha(alg);
    key = hash.update(key).digest();
  } else if (key.length < blocksize) {
    key = Buffer.concat([key, ZEROS], blocksize);
  }
  var ipad = this._ipad = Buffer.allocUnsafe(blocksize);
  var opad = this._opad = Buffer.allocUnsafe(blocksize);
  for (var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36;
    opad[i] = key[i] ^ 0x5C;
  }
  this._hash = alg === 'rmd160' ? new RIPEMD160() : sha(alg);
  this._hash.update(ipad);
}
inherits(Hmac, Base);
Hmac.prototype._update = function (data) {
  this._hash.update(data);
};
Hmac.prototype._final = function () {
  var h = this._hash.digest();
  var hash = this._alg === 'rmd160' ? new RIPEMD160() : sha(this._alg);
  return hash.update(this._opad).update(h).digest();
};
module.exports = function createHmac(alg, key) {
  alg = alg.toLowerCase();
  if (alg === 'rmd160' || alg === 'ripemd160') {
    return new Hmac('rmd160', key);
  }
  if (alg === 'md5') {
    return new Legacy(md5, key);
  }
  return new Hmac(alg, key);
};

},{"./legacy":148,"cipher-base":142,"create-hash/md5":146,"inherits":327,"ripemd160":382,"safe-buffer":384,"sha.js":394}],148:[function(require,module,exports){
'use strict';

var inherits = require('inherits');
var Buffer = require('safe-buffer').Buffer;
var Base = require('cipher-base');
var ZEROS = Buffer.alloc(128);
var blocksize = 64;
function Hmac(alg, key) {
  Base.call(this, 'digest');
  if (typeof key === 'string') {
    key = Buffer.from(key);
  }
  this._alg = alg;
  this._key = key;
  if (key.length > blocksize) {
    key = alg(key);
  } else if (key.length < blocksize) {
    key = Buffer.concat([key, ZEROS], blocksize);
  }
  var ipad = this._ipad = Buffer.allocUnsafe(blocksize);
  var opad = this._opad = Buffer.allocUnsafe(blocksize);
  for (var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36;
    opad[i] = key[i] ^ 0x5C;
  }
  this._hash = [ipad];
}
inherits(Hmac, Base);
Hmac.prototype._update = function (data) {
  this._hash.push(data);
};
Hmac.prototype._final = function () {
  var h = this._alg(Buffer.concat(this._hash));
  return this._alg(Buffer.concat([this._opad, h]));
};
module.exports = Hmac;

},{"cipher-base":142,"inherits":327,"safe-buffer":384}],149:[function(require,module,exports){
'use strict';

exports.randomBytes = exports.rng = exports.pseudoRandomBytes = exports.prng = require('randombytes');
exports.createHash = exports.Hash = require('create-hash');
exports.createHmac = exports.Hmac = require('create-hmac');
var algos = require('browserify-sign/algos');
var algoKeys = Object.keys(algos);
var hashes = ['sha1', 'sha224', 'sha256', 'sha384', 'sha512', 'md5', 'rmd160'].concat(algoKeys);
exports.getHashes = function () {
  return hashes;
};
var p = require('pbkdf2');
exports.pbkdf2 = p.pbkdf2;
exports.pbkdf2Sync = p.pbkdf2Sync;
var aes = require('browserify-cipher');
exports.Cipher = aes.Cipher;
exports.createCipher = aes.createCipher;
exports.Cipheriv = aes.Cipheriv;
exports.createCipheriv = aes.createCipheriv;
exports.Decipher = aes.Decipher;
exports.createDecipher = aes.createDecipher;
exports.Decipheriv = aes.Decipheriv;
exports.createDecipheriv = aes.createDecipheriv;
exports.getCiphers = aes.getCiphers;
exports.listCiphers = aes.listCiphers;
var dh = require('diffie-hellman');
exports.DiffieHellmanGroup = dh.DiffieHellmanGroup;
exports.createDiffieHellmanGroup = dh.createDiffieHellmanGroup;
exports.getDiffieHellman = dh.getDiffieHellman;
exports.createDiffieHellman = dh.createDiffieHellman;
exports.DiffieHellman = dh.DiffieHellman;
var sign = require('browserify-sign');
exports.createSign = sign.createSign;
exports.Sign = sign.Sign;
exports.createVerify = sign.createVerify;
exports.Verify = sign.Verify;
exports.createECDH = require('create-ecdh');
var publicEncrypt = require('public-encrypt');
exports.publicEncrypt = publicEncrypt.publicEncrypt;
exports.privateEncrypt = publicEncrypt.privateEncrypt;
exports.publicDecrypt = publicEncrypt.publicDecrypt;
exports.privateDecrypt = publicEncrypt.privateDecrypt;

// the least I can do is make error messages for the rest of the node.js/crypto api.
// ;[
//   'createCredentials'
// ].forEach(function (name) {
//   exports[name] = function () {
//     throw new Error([
//       'sorry, ' + name + ' is not implemented yet',
//       'we accept pull requests',
//       'https://github.com/crypto-browserify/crypto-browserify'
//     ].join('\n'))
//   }
// })

var rf = require('randomfill');
exports.randomFill = rf.randomFill;
exports.randomFillSync = rf.randomFillSync;
exports.createCredentials = function () {
  throw new Error(['sorry, createCredentials is not implemented yet', 'we accept pull requests', 'https://github.com/crypto-browserify/crypto-browserify'].join('\n'));
};
exports.constants = {
  'DH_CHECK_P_NOT_SAFE_PRIME': 2,
  'DH_CHECK_P_NOT_PRIME': 1,
  'DH_UNABLE_TO_CHECK_GENERATOR': 4,
  'DH_NOT_SUITABLE_GENERATOR': 8,
  'NPN_ENABLED': 1,
  'ALPN_ENABLED': 1,
  'RSA_PKCS1_PADDING': 1,
  'RSA_SSLV23_PADDING': 2,
  'RSA_NO_PADDING': 3,
  'RSA_PKCS1_OAEP_PADDING': 4,
  'RSA_X931_PADDING': 5,
  'RSA_PKCS1_PSS_PADDING': 6,
  'POINT_CONVERSION_COMPRESSED': 2,
  'POINT_CONVERSION_UNCOMPRESSED': 4,
  'POINT_CONVERSION_HYBRID': 6
};

},{"browserify-cipher":123,"browserify-sign":131,"browserify-sign/algos":128,"create-ecdh":144,"create-hash":145,"create-hmac":147,"diffie-hellman":157,"pbkdf2":356,"public-encrypt":364,"randombytes":370,"randomfill":371}],150:[function(require,module,exports){
'use strict';

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var $defineProperty = require('es-define-property');
var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var gopd = require('gopd');

/** @type {import('.')} */
module.exports = function defineDataProperty(obj, property, value) {
  if (!obj || _typeof(obj) !== 'object' && typeof obj !== 'function') {
    throw new $TypeError('`obj` must be an object or a function`');
  }
  if (typeof property !== 'string' && _typeof(property) !== 'symbol') {
    throw new $TypeError('`property` must be a string or a symbol`');
  }
  if (arguments.length > 3 && typeof arguments[3] !== 'boolean' && arguments[3] !== null) {
    throw new $TypeError('`nonEnumerable`, if provided, must be a boolean or null');
  }
  if (arguments.length > 4 && typeof arguments[4] !== 'boolean' && arguments[4] !== null) {
    throw new $TypeError('`nonWritable`, if provided, must be a boolean or null');
  }
  if (arguments.length > 5 && typeof arguments[5] !== 'boolean' && arguments[5] !== null) {
    throw new $TypeError('`nonConfigurable`, if provided, must be a boolean or null');
  }
  if (arguments.length > 6 && typeof arguments[6] !== 'boolean') {
    throw new $TypeError('`loose`, if provided, must be a boolean');
  }
  var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
  var nonWritable = arguments.length > 4 ? arguments[4] : null;
  var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
  var loose = arguments.length > 6 ? arguments[6] : false;

  /* @type {false | TypedPropertyDescriptor<unknown>} */
  var desc = !!gopd && gopd(obj, property);
  if ($defineProperty) {
    $defineProperty(obj, property, {
      configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
      enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
      value: value,
      writable: nonWritable === null && desc ? desc.writable : !nonWritable
    });
  } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
    // must fall back to [[Set]], and was not explicitly asked to make non-enumerable, non-writable, or non-configurable
    obj[property] = value; // eslint-disable-line no-param-reassign
  } else {
    throw new $SyntaxError('This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.');
  }
};

},{"es-define-property":178,"es-errors/syntax":183,"es-errors/type":184,"gopd":306}],151:[function(require,module,exports){
'use strict';

exports.utils = require('./des/utils');
exports.Cipher = require('./des/cipher');
exports.DES = require('./des/des');
exports.CBC = require('./des/cbc');
exports.EDE = require('./des/ede');

},{"./des/cbc":152,"./des/cipher":153,"./des/des":154,"./des/ede":155,"./des/utils":156}],152:[function(require,module,exports){
'use strict';

var assert = require('minimalistic-assert');
var inherits = require('inherits');
var proto = {};
function CBCState(iv) {
  assert.equal(iv.length, 8, 'Invalid IV length');
  this.iv = new Array(8);
  for (var i = 0; i < this.iv.length; i++) this.iv[i] = iv[i];
}
function instantiate(Base) {
  function CBC(options) {
    Base.call(this, options);
    this._cbcInit();
  }
  inherits(CBC, Base);
  var keys = Object.keys(proto);
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    CBC.prototype[key] = proto[key];
  }
  CBC.create = function create(options) {
    return new CBC(options);
  };
  return CBC;
}
exports.instantiate = instantiate;
proto._cbcInit = function _cbcInit() {
  var state = new CBCState(this.options.iv);
  this._cbcState = state;
};
proto._update = function _update(inp, inOff, out, outOff) {
  var state = this._cbcState;
  var superProto = this.constructor.super_.prototype;
  var iv = state.iv;
  if (this.type === 'encrypt') {
    for (var i = 0; i < this.blockSize; i++) iv[i] ^= inp[inOff + i];
    superProto._update.call(this, iv, 0, out, outOff);
    for (var i = 0; i < this.blockSize; i++) iv[i] = out[outOff + i];
  } else {
    superProto._update.call(this, inp, inOff, out, outOff);
    for (var i = 0; i < this.blockSize; i++) out[outOff + i] ^= iv[i];
    for (var i = 0; i < this.blockSize; i++) iv[i] = inp[inOff + i];
  }
};

},{"inherits":327,"minimalistic-assert":342}],153:[function(require,module,exports){
'use strict';

var assert = require('minimalistic-assert');
function Cipher(options) {
  this.options = options;
  this.type = this.options.type;
  this.blockSize = 8;
  this._init();
  this.buffer = new Array(this.blockSize);
  this.bufferOff = 0;
  this.padding = options.padding !== false;
}
module.exports = Cipher;
Cipher.prototype._init = function _init() {
  // Might be overrided
};
Cipher.prototype.update = function update(data) {
  if (data.length === 0) return [];
  if (this.type === 'decrypt') return this._updateDecrypt(data);else return this._updateEncrypt(data);
};
Cipher.prototype._buffer = function _buffer(data, off) {
  // Append data to buffer
  var min = Math.min(this.buffer.length - this.bufferOff, data.length - off);
  for (var i = 0; i < min; i++) this.buffer[this.bufferOff + i] = data[off + i];
  this.bufferOff += min;

  // Shift next
  return min;
};
Cipher.prototype._flushBuffer = function _flushBuffer(out, off) {
  this._update(this.buffer, 0, out, off);
  this.bufferOff = 0;
  return this.blockSize;
};
Cipher.prototype._updateEncrypt = function _updateEncrypt(data) {
  var inputOff = 0;
  var outputOff = 0;
  var count = (this.bufferOff + data.length) / this.blockSize | 0;
  var out = new Array(count * this.blockSize);
  if (this.bufferOff !== 0) {
    inputOff += this._buffer(data, inputOff);
    if (this.bufferOff === this.buffer.length) outputOff += this._flushBuffer(out, outputOff);
  }

  // Write blocks
  var max = data.length - (data.length - inputOff) % this.blockSize;
  for (; inputOff < max; inputOff += this.blockSize) {
    this._update(data, inputOff, out, outputOff);
    outputOff += this.blockSize;
  }

  // Queue rest
  for (; inputOff < data.length; inputOff++, this.bufferOff++) this.buffer[this.bufferOff] = data[inputOff];
  return out;
};
Cipher.prototype._updateDecrypt = function _updateDecrypt(data) {
  var inputOff = 0;
  var outputOff = 0;
  var count = Math.ceil((this.bufferOff + data.length) / this.blockSize) - 1;
  var out = new Array(count * this.blockSize);

  // TODO(indutny): optimize it, this is far from optimal
  for (; count > 0; count--) {
    inputOff += this._buffer(data, inputOff);
    outputOff += this._flushBuffer(out, outputOff);
  }

  // Buffer rest of the input
  inputOff += this._buffer(data, inputOff);
  return out;
};
Cipher.prototype["final"] = function _final(buffer) {
  var first;
  if (buffer) first = this.update(buffer);
  var last;
  if (this.type === 'encrypt') last = this._finalEncrypt();else last = this._finalDecrypt();
  if (first) return first.concat(last);else return last;
};
Cipher.prototype._pad = function _pad(buffer, off) {
  if (off === 0) return false;
  while (off < buffer.length) buffer[off++] = 0;
  return true;
};
Cipher.prototype._finalEncrypt = function _finalEncrypt() {
  if (!this._pad(this.buffer, this.bufferOff)) return [];
  var out = new Array(this.blockSize);
  this._update(this.buffer, 0, out, 0);
  return out;
};
Cipher.prototype._unpad = function _unpad(buffer) {
  return buffer;
};
Cipher.prototype._finalDecrypt = function _finalDecrypt() {
  assert.equal(this.bufferOff, this.blockSize, 'Not enough data to decrypt');
  var out = new Array(this.blockSize);
  this._flushBuffer(out, 0);
  return this._unpad(out);
};

},{"minimalistic-assert":342}],154:[function(require,module,exports){
'use strict';

var assert = require('minimalistic-assert');
var inherits = require('inherits');
var utils = require('./utils');
var Cipher = require('./cipher');
function DESState() {
  this.tmp = new Array(2);
  this.keys = null;
}
function DES(options) {
  Cipher.call(this, options);
  var state = new DESState();
  this._desState = state;
  this.deriveKeys(state, options.key);
}
inherits(DES, Cipher);
module.exports = DES;
DES.create = function create(options) {
  return new DES(options);
};
var shiftTable = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1];
DES.prototype.deriveKeys = function deriveKeys(state, key) {
  state.keys = new Array(16 * 2);
  assert.equal(key.length, this.blockSize, 'Invalid key length');
  var kL = utils.readUInt32BE(key, 0);
  var kR = utils.readUInt32BE(key, 4);
  utils.pc1(kL, kR, state.tmp, 0);
  kL = state.tmp[0];
  kR = state.tmp[1];
  for (var i = 0; i < state.keys.length; i += 2) {
    var shift = shiftTable[i >>> 1];
    kL = utils.r28shl(kL, shift);
    kR = utils.r28shl(kR, shift);
    utils.pc2(kL, kR, state.keys, i);
  }
};
DES.prototype._update = function _update(inp, inOff, out, outOff) {
  var state = this._desState;
  var l = utils.readUInt32BE(inp, inOff);
  var r = utils.readUInt32BE(inp, inOff + 4);

  // Initial Permutation
  utils.ip(l, r, state.tmp, 0);
  l = state.tmp[0];
  r = state.tmp[1];
  if (this.type === 'encrypt') this._encrypt(state, l, r, state.tmp, 0);else this._decrypt(state, l, r, state.tmp, 0);
  l = state.tmp[0];
  r = state.tmp[1];
  utils.writeUInt32BE(out, l, outOff);
  utils.writeUInt32BE(out, r, outOff + 4);
};
DES.prototype._pad = function _pad(buffer, off) {
  if (this.padding === false) {
    return false;
  }
  var value = buffer.length - off;
  for (var i = off; i < buffer.length; i++) buffer[i] = value;
  return true;
};
DES.prototype._unpad = function _unpad(buffer) {
  if (this.padding === false) {
    return buffer;
  }
  var pad = buffer[buffer.length - 1];
  for (var i = buffer.length - pad; i < buffer.length; i++) assert.equal(buffer[i], pad);
  return buffer.slice(0, buffer.length - pad);
};
DES.prototype._encrypt = function _encrypt(state, lStart, rStart, out, off) {
  var l = lStart;
  var r = rStart;

  // Apply f() x16 times
  for (var i = 0; i < state.keys.length; i += 2) {
    var keyL = state.keys[i];
    var keyR = state.keys[i + 1];

    // f(r, k)
    utils.expand(r, state.tmp, 0);
    keyL ^= state.tmp[0];
    keyR ^= state.tmp[1];
    var s = utils.substitute(keyL, keyR);
    var f = utils.permute(s);
    var t = r;
    r = (l ^ f) >>> 0;
    l = t;
  }

  // Reverse Initial Permutation
  utils.rip(r, l, out, off);
};
DES.prototype._decrypt = function _decrypt(state, lStart, rStart, out, off) {
  var l = rStart;
  var r = lStart;

  // Apply f() x16 times
  for (var i = state.keys.length - 2; i >= 0; i -= 2) {
    var keyL = state.keys[i];
    var keyR = state.keys[i + 1];

    // f(r, k)
    utils.expand(l, state.tmp, 0);
    keyL ^= state.tmp[0];
    keyR ^= state.tmp[1];
    var s = utils.substitute(keyL, keyR);
    var f = utils.permute(s);
    var t = l;
    l = (r ^ f) >>> 0;
    r = t;
  }

  // Reverse Initial Permutation
  utils.rip(l, r, out, off);
};

},{"./cipher":153,"./utils":156,"inherits":327,"minimalistic-assert":342}],155:[function(require,module,exports){
'use strict';

var assert = require('minimalistic-assert');
var inherits = require('inherits');
var Cipher = require('./cipher');
var DES = require('./des');
function EDEState(type, key) {
  assert.equal(key.length, 24, 'Invalid key length');
  var k1 = key.slice(0, 8);
  var k2 = key.slice(8, 16);
  var k3 = key.slice(16, 24);
  if (type === 'encrypt') {
    this.ciphers = [DES.create({
      type: 'encrypt',
      key: k1
    }), DES.create({
      type: 'decrypt',
      key: k2
    }), DES.create({
      type: 'encrypt',
      key: k3
    })];
  } else {
    this.ciphers = [DES.create({
      type: 'decrypt',
      key: k3
    }), DES.create({
      type: 'encrypt',
      key: k2
    }), DES.create({
      type: 'decrypt',
      key: k1
    })];
  }
}
function EDE(options) {
  Cipher.call(this, options);
  var state = new EDEState(this.type, this.options.key);
  this._edeState = state;
}
inherits(EDE, Cipher);
module.exports = EDE;
EDE.create = function create(options) {
  return new EDE(options);
};
EDE.prototype._update = function _update(inp, inOff, out, outOff) {
  var state = this._edeState;
  state.ciphers[0]._update(inp, inOff, out, outOff);
  state.ciphers[1]._update(out, outOff, out, outOff);
  state.ciphers[2]._update(out, outOff, out, outOff);
};
EDE.prototype._pad = DES.prototype._pad;
EDE.prototype._unpad = DES.prototype._unpad;

},{"./cipher":153,"./des":154,"inherits":327,"minimalistic-assert":342}],156:[function(require,module,exports){
'use strict';

exports.readUInt32BE = function readUInt32BE(bytes, off) {
  var res = bytes[0 + off] << 24 | bytes[1 + off] << 16 | bytes[2 + off] << 8 | bytes[3 + off];
  return res >>> 0;
};
exports.writeUInt32BE = function writeUInt32BE(bytes, value, off) {
  bytes[0 + off] = value >>> 24;
  bytes[1 + off] = value >>> 16 & 0xff;
  bytes[2 + off] = value >>> 8 & 0xff;
  bytes[3 + off] = value & 0xff;
};
exports.ip = function ip(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;
  for (var i = 6; i >= 0; i -= 2) {
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= inR >>> j + i & 1;
    }
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= inL >>> j + i & 1;
    }
  }
  for (var i = 6; i >= 0; i -= 2) {
    for (var j = 1; j <= 25; j += 8) {
      outR <<= 1;
      outR |= inR >>> j + i & 1;
    }
    for (var j = 1; j <= 25; j += 8) {
      outR <<= 1;
      outR |= inL >>> j + i & 1;
    }
  }
  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};
exports.rip = function rip(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;
  for (var i = 0; i < 4; i++) {
    for (var j = 24; j >= 0; j -= 8) {
      outL <<= 1;
      outL |= inR >>> j + i & 1;
      outL <<= 1;
      outL |= inL >>> j + i & 1;
    }
  }
  for (var i = 4; i < 8; i++) {
    for (var j = 24; j >= 0; j -= 8) {
      outR <<= 1;
      outR |= inR >>> j + i & 1;
      outR <<= 1;
      outR |= inL >>> j + i & 1;
    }
  }
  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};
exports.pc1 = function pc1(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  // 7, 15, 23, 31, 39, 47, 55, 63
  // 6, 14, 22, 30, 39, 47, 55, 63
  // 5, 13, 21, 29, 39, 47, 55, 63
  // 4, 12, 20, 28
  for (var i = 7; i >= 5; i--) {
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= inR >> j + i & 1;
    }
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= inL >> j + i & 1;
    }
  }
  for (var j = 0; j <= 24; j += 8) {
    outL <<= 1;
    outL |= inR >> j + i & 1;
  }

  // 1, 9, 17, 25, 33, 41, 49, 57
  // 2, 10, 18, 26, 34, 42, 50, 58
  // 3, 11, 19, 27, 35, 43, 51, 59
  // 36, 44, 52, 60
  for (var i = 1; i <= 3; i++) {
    for (var j = 0; j <= 24; j += 8) {
      outR <<= 1;
      outR |= inR >> j + i & 1;
    }
    for (var j = 0; j <= 24; j += 8) {
      outR <<= 1;
      outR |= inL >> j + i & 1;
    }
  }
  for (var j = 0; j <= 24; j += 8) {
    outR <<= 1;
    outR |= inL >> j + i & 1;
  }
  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};
exports.r28shl = function r28shl(num, shift) {
  return num << shift & 0xfffffff | num >>> 28 - shift;
};
var pc2table = [
// inL => outL
14, 11, 17, 4, 27, 23, 25, 0, 13, 22, 7, 18, 5, 9, 16, 24, 2, 20, 12, 21, 1, 8, 15, 26,
// inR => outR
15, 4, 25, 19, 9, 1, 26, 16, 5, 11, 23, 8, 12, 7, 17, 0, 22, 3, 10, 14, 6, 20, 27, 24];
exports.pc2 = function pc2(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;
  var len = pc2table.length >>> 1;
  for (var i = 0; i < len; i++) {
    outL <<= 1;
    outL |= inL >>> pc2table[i] & 0x1;
  }
  for (var i = len; i < pc2table.length; i++) {
    outR <<= 1;
    outR |= inR >>> pc2table[i] & 0x1;
  }
  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};
exports.expand = function expand(r, out, off) {
  var outL = 0;
  var outR = 0;
  outL = (r & 1) << 5 | r >>> 27;
  for (var i = 23; i >= 15; i -= 4) {
    outL <<= 6;
    outL |= r >>> i & 0x3f;
  }
  for (var i = 11; i >= 3; i -= 4) {
    outR |= r >>> i & 0x3f;
    outR <<= 6;
  }
  outR |= (r & 0x1f) << 1 | r >>> 31;
  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};
var sTable = [14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1, 3, 10, 10, 6, 6, 12, 12, 11, 5, 9, 9, 5, 0, 3, 7, 8, 4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7, 15, 5, 12, 11, 9, 3, 7, 14, 3, 10, 10, 0, 5, 6, 0, 13, 15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14, 9, 12, 7, 0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5, 0, 13, 14, 8, 7, 10, 11, 1, 10, 3, 4, 15, 13, 4, 1, 2, 5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14, 15, 9, 10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5, 10, 1, 2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1, 13, 1, 6, 10, 4, 13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7, 11, 4, 1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7, 12, 7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6, 15, 9, 0, 10, 3, 1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9, 10, 3, 6, 15, 9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8, 15, 9, 1, 4, 3, 5, 14, 11, 5, 12, 2, 7, 8, 2, 4, 14, 2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1, 8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14, 8, 9, 6, 4, 11, 2, 8, 1, 12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13, 15, 6, 9, 15, 12, 0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3, 12, 10, 1, 15, 10, 4, 15, 2, 9, 7, 2, 12, 6, 9, 8, 5, 0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11, 8, 9, 4, 14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10, 7, 11, 0, 14, 4, 1, 10, 7, 1, 6, 13, 0, 11, 8, 6, 13, 4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1, 13, 10, 3, 14, 12, 3, 9, 5, 7, 12, 5, 2, 10, 15, 6, 8, 1, 6, 1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10, 14, 7, 10, 9, 15, 5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12, 13, 1, 2, 15, 8, 13, 4, 8, 6, 10, 15, 3, 11, 7, 1, 4, 10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2, 7, 2, 11, 1, 4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13, 0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11];
exports.substitute = function substitute(inL, inR) {
  var out = 0;
  for (var i = 0; i < 4; i++) {
    var b = inL >>> 18 - i * 6 & 0x3f;
    var sb = sTable[i * 0x40 + b];
    out <<= 4;
    out |= sb;
  }
  for (var i = 0; i < 4; i++) {
    var b = inR >>> 18 - i * 6 & 0x3f;
    var sb = sTable[4 * 0x40 + i * 0x40 + b];
    out <<= 4;
    out |= sb;
  }
  return out >>> 0;
};
var permuteTable = [16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22, 30, 24, 8, 18, 0, 5, 29, 23, 13, 19, 2, 26, 10, 21, 28, 7];
exports.permute = function permute(num) {
  var out = 0;
  for (var i = 0; i < permuteTable.length; i++) {
    out <<= 1;
    out |= num >>> permuteTable[i] & 0x1;
  }
  return out >>> 0;
};
exports.padSplit = function padSplit(num, size, group) {
  var str = num.toString(2);
  while (str.length < size) str = '0' + str;
  var out = [];
  for (var i = 0; i < size; i += group) out.push(str.slice(i, i + group));
  return out.join(' ');
};

},{}],157:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";

var generatePrime = require('./lib/generatePrime');
var primes = require('./lib/primes.json');
var DH = require('./lib/dh');
function getDiffieHellman(mod) {
  var prime = new Buffer(primes[mod].prime, 'hex');
  var gen = new Buffer(primes[mod].gen, 'hex');
  return new DH(prime, gen);
}
var ENCODINGS = {
  'binary': true,
  'hex': true,
  'base64': true
};
function createDiffieHellman(prime, enc, generator, genc) {
  if (Buffer.isBuffer(enc) || ENCODINGS[enc] === undefined) {
    return createDiffieHellman(prime, 'binary', enc, generator);
  }
  enc = enc || 'binary';
  genc = genc || 'binary';
  generator = generator || new Buffer([2]);
  if (!Buffer.isBuffer(generator)) {
    generator = new Buffer(generator, genc);
  }
  if (typeof prime === 'number') {
    return new DH(generatePrime(prime, generator), generator, true);
  }
  if (!Buffer.isBuffer(prime)) {
    prime = new Buffer(prime, enc);
  }
  return new DH(prime, generator, true);
}
exports.DiffieHellmanGroup = exports.createDiffieHellmanGroup = exports.getDiffieHellman = getDiffieHellman;
exports.createDiffieHellman = exports.DiffieHellman = createDiffieHellman;

}).call(this)}).call(this,require("buffer").Buffer)
},{"./lib/dh":158,"./lib/generatePrime":159,"./lib/primes.json":160,"buffer":139}],158:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";

var BN = require('bn.js');
var MillerRabin = require('miller-rabin');
var millerRabin = new MillerRabin();
var TWENTYFOUR = new BN(24);
var ELEVEN = new BN(11);
var TEN = new BN(10);
var THREE = new BN(3);
var SEVEN = new BN(7);
var primes = require('./generatePrime');
var randomBytes = require('randombytes');
module.exports = DH;
function setPublicKey(pub, enc) {
  enc = enc || 'utf8';
  if (!Buffer.isBuffer(pub)) {
    pub = new Buffer(pub, enc);
  }
  this._pub = new BN(pub);
  return this;
}
function setPrivateKey(priv, enc) {
  enc = enc || 'utf8';
  if (!Buffer.isBuffer(priv)) {
    priv = new Buffer(priv, enc);
  }
  this._priv = new BN(priv);
  return this;
}
var primeCache = {};
function checkPrime(prime, generator) {
  var gen = generator.toString('hex');
  var hex = [gen, prime.toString(16)].join('_');
  if (hex in primeCache) {
    return primeCache[hex];
  }
  var error = 0;
  if (prime.isEven() || !primes.simpleSieve || !primes.fermatTest(prime) || !millerRabin.test(prime)) {
    //not a prime so +1
    error += 1;
    if (gen === '02' || gen === '05') {
      // we'd be able to check the generator
      // it would fail so +8
      error += 8;
    } else {
      //we wouldn't be able to test the generator
      // so +4
      error += 4;
    }
    primeCache[hex] = error;
    return error;
  }
  if (!millerRabin.test(prime.shrn(1))) {
    //not a safe prime
    error += 2;
  }
  var rem;
  switch (gen) {
    case '02':
      if (prime.mod(TWENTYFOUR).cmp(ELEVEN)) {
        // unsuidable generator
        error += 8;
      }
      break;
    case '05':
      rem = prime.mod(TEN);
      if (rem.cmp(THREE) && rem.cmp(SEVEN)) {
        // prime mod 10 needs to equal 3 or 7
        error += 8;
      }
      break;
    default:
      error += 4;
  }
  primeCache[hex] = error;
  return error;
}
function DH(prime, generator, malleable) {
  this.setGenerator(generator);
  this.__prime = new BN(prime);
  this._prime = BN.mont(this.__prime);
  this._primeLen = prime.length;
  this._pub = undefined;
  this._priv = undefined;
  this._primeCode = undefined;
  if (malleable) {
    this.setPublicKey = setPublicKey;
    this.setPrivateKey = setPrivateKey;
  } else {
    this._primeCode = 8;
  }
}
Object.defineProperty(DH.prototype, 'verifyError', {
  enumerable: true,
  get: function get() {
    if (typeof this._primeCode !== 'number') {
      this._primeCode = checkPrime(this.__prime, this.__gen);
    }
    return this._primeCode;
  }
});
DH.prototype.generateKeys = function () {
  if (!this._priv) {
    this._priv = new BN(randomBytes(this._primeLen));
  }
  this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed();
  return this.getPublicKey();
};
DH.prototype.computeSecret = function (other) {
  other = new BN(other);
  other = other.toRed(this._prime);
  var secret = other.redPow(this._priv).fromRed();
  var out = new Buffer(secret.toArray());
  var prime = this.getPrime();
  if (out.length < prime.length) {
    var front = new Buffer(prime.length - out.length);
    front.fill(0);
    out = Buffer.concat([front, out]);
  }
  return out;
};
DH.prototype.getPublicKey = function getPublicKey(enc) {
  return formatReturnValue(this._pub, enc);
};
DH.prototype.getPrivateKey = function getPrivateKey(enc) {
  return formatReturnValue(this._priv, enc);
};
DH.prototype.getPrime = function (enc) {
  return formatReturnValue(this.__prime, enc);
};
DH.prototype.getGenerator = function (enc) {
  return formatReturnValue(this._gen, enc);
};
DH.prototype.setGenerator = function (gen, enc) {
  enc = enc || 'utf8';
  if (!Buffer.isBuffer(gen)) {
    gen = new Buffer(gen, enc);
  }
  this.__gen = gen;
  this._gen = new BN(gen);
  return this;
};
function formatReturnValue(bn, enc) {
  var buf = new Buffer(bn.toArray());
  if (!enc) {
    return buf;
  } else {
    return buf.toString(enc);
  }
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"./generatePrime":159,"bn.js":103,"buffer":139,"miller-rabin":341,"randombytes":370}],159:[function(require,module,exports){
"use strict";

var randomBytes = require('randombytes');
module.exports = findPrime;
findPrime.simpleSieve = simpleSieve;
findPrime.fermatTest = fermatTest;
var BN = require('bn.js');
var TWENTYFOUR = new BN(24);
var MillerRabin = require('miller-rabin');
var millerRabin = new MillerRabin();
var ONE = new BN(1);
var TWO = new BN(2);
var FIVE = new BN(5);
var SIXTEEN = new BN(16);
var EIGHT = new BN(8);
var TEN = new BN(10);
var THREE = new BN(3);
var SEVEN = new BN(7);
var ELEVEN = new BN(11);
var FOUR = new BN(4);
var TWELVE = new BN(12);
var primes = null;
function _getPrimes() {
  if (primes !== null) return primes;
  var limit = 0x100000;
  var res = [];
  res[0] = 2;
  for (var i = 1, k = 3; k < limit; k += 2) {
    var sqrt = Math.ceil(Math.sqrt(k));
    for (var j = 0; j < i && res[j] <= sqrt; j++) if (k % res[j] === 0) break;
    if (i !== j && res[j] <= sqrt) continue;
    res[i++] = k;
  }
  primes = res;
  return res;
}
function simpleSieve(p) {
  var primes = _getPrimes();
  for (var i = 0; i < primes.length; i++) if (p.modn(primes[i]) === 0) {
    if (p.cmpn(primes[i]) === 0) {
      return true;
    } else {
      return false;
    }
  }
  return true;
}
function fermatTest(p) {
  var red = BN.mont(p);
  return TWO.toRed(red).redPow(p.subn(1)).fromRed().cmpn(1) === 0;
}
function findPrime(bits, gen) {
  if (bits < 16) {
    // this is what openssl does
    if (gen === 2 || gen === 5) {
      return new BN([0x8c, 0x7b]);
    } else {
      return new BN([0x8c, 0x27]);
    }
  }
  gen = new BN(gen);
  var num, n2;
  while (true) {
    num = new BN(randomBytes(Math.ceil(bits / 8)));
    while (num.bitLength() > bits) {
      num.ishrn(1);
    }
    if (num.isEven()) {
      num.iadd(ONE);
    }
    if (!num.testn(1)) {
      num.iadd(TWO);
    }
    if (!gen.cmp(TWO)) {
      while (num.mod(TWENTYFOUR).cmp(ELEVEN)) {
        num.iadd(FOUR);
      }
    } else if (!gen.cmp(FIVE)) {
      while (num.mod(TEN).cmp(THREE)) {
        num.iadd(FOUR);
      }
    }
    n2 = num.shrn(1);
    if (simpleSieve(n2) && simpleSieve(num) && fermatTest(n2) && fermatTest(num) && millerRabin.test(n2) && millerRabin.test(num)) {
      return num;
    }
  }
}

},{"bn.js":103,"miller-rabin":341,"randombytes":370}],160:[function(require,module,exports){
module.exports={
    "modp1": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
    },
    "modp2": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
    },
    "modp5": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
    },
    "modp14": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
    },
    "modp15": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
    },
    "modp16": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
    },
    "modp17": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
    },
    "modp18": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
    }
}
},{}],161:[function(require,module,exports){
'use strict';

var elliptic = exports;
elliptic.version = require('../package.json').version;
elliptic.utils = require('./elliptic/utils');
elliptic.rand = require('brorand');
elliptic.curve = require('./elliptic/curve');
elliptic.curves = require('./elliptic/curves');

// Protocols
elliptic.ec = require('./elliptic/ec');
elliptic.eddsa = require('./elliptic/eddsa');

},{"../package.json":177,"./elliptic/curve":164,"./elliptic/curves":167,"./elliptic/ec":168,"./elliptic/eddsa":171,"./elliptic/utils":175,"brorand":104}],162:[function(require,module,exports){
'use strict';

var BN = require('bn.js');
var utils = require('../utils');
var getNAF = utils.getNAF;
var getJSF = utils.getJSF;
var assert = utils.assert;
function BaseCurve(type, conf) {
  this.type = type;
  this.p = new BN(conf.p, 16);

  // Use Montgomery, when there is no fast reduction for the prime
  this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);

  // Useful for many curves
  this.zero = new BN(0).toRed(this.red);
  this.one = new BN(1).toRed(this.red);
  this.two = new BN(2).toRed(this.red);

  // Curve configuration, optional
  this.n = conf.n && new BN(conf.n, 16);
  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);

  // Temporary arrays
  this._wnafT1 = new Array(4);
  this._wnafT2 = new Array(4);
  this._wnafT3 = new Array(4);
  this._wnafT4 = new Array(4);
  this._bitLength = this.n ? this.n.bitLength() : 0;

  // Generalized Greg Maxwell's trick
  var adjustCount = this.n && this.p.div(this.n);
  if (!adjustCount || adjustCount.cmpn(100) > 0) {
    this.redN = null;
  } else {
    this._maxwellTrick = true;
    this.redN = this.n.toRed(this.red);
  }
}
module.exports = BaseCurve;
BaseCurve.prototype.point = function point() {
  throw new Error('Not implemented');
};
BaseCurve.prototype.validate = function validate() {
  throw new Error('Not implemented');
};
BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
  assert(p.precomputed);
  var doubles = p._getDoubles();
  var naf = getNAF(k, 1, this._bitLength);
  var I = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
  I /= 3;

  // Translate into more windowed form
  var repr = [];
  var j;
  var nafW;
  for (j = 0; j < naf.length; j += doubles.step) {
    nafW = 0;
    for (var l = j + doubles.step - 1; l >= j; l--) nafW = (nafW << 1) + naf[l];
    repr.push(nafW);
  }
  var a = this.jpoint(null, null, null);
  var b = this.jpoint(null, null, null);
  for (var i = I; i > 0; i--) {
    for (j = 0; j < repr.length; j++) {
      nafW = repr[j];
      if (nafW === i) b = b.mixedAdd(doubles.points[j]);else if (nafW === -i) b = b.mixedAdd(doubles.points[j].neg());
    }
    a = a.add(b);
  }
  return a.toP();
};
BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
  var w = 4;

  // Precompute window
  var nafPoints = p._getNAFPoints(w);
  w = nafPoints.wnd;
  var wnd = nafPoints.points;

  // Get NAF form
  var naf = getNAF(k, w, this._bitLength);

  // Add `this`*(N+1) for every w-NAF index
  var acc = this.jpoint(null, null, null);
  for (var i = naf.length - 1; i >= 0; i--) {
    // Count zeroes
    for (var l = 0; i >= 0 && naf[i] === 0; i--) l++;
    if (i >= 0) l++;
    acc = acc.dblp(l);
    if (i < 0) break;
    var z = naf[i];
    assert(z !== 0);
    if (p.type === 'affine') {
      // J +- P
      if (z > 0) acc = acc.mixedAdd(wnd[z - 1 >> 1]);else acc = acc.mixedAdd(wnd[-z - 1 >> 1].neg());
    } else {
      // J +- J
      if (z > 0) acc = acc.add(wnd[z - 1 >> 1]);else acc = acc.add(wnd[-z - 1 >> 1].neg());
    }
  }
  return p.type === 'affine' ? acc.toP() : acc;
};
BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {
  var wndWidth = this._wnafT1;
  var wnd = this._wnafT2;
  var naf = this._wnafT3;

  // Fill all arrays
  var max = 0;
  var i;
  var j;
  var p;
  for (i = 0; i < len; i++) {
    p = points[i];
    var nafPoints = p._getNAFPoints(defW);
    wndWidth[i] = nafPoints.wnd;
    wnd[i] = nafPoints.points;
  }

  // Comb small window NAFs
  for (i = len - 1; i >= 1; i -= 2) {
    var a = i - 1;
    var b = i;
    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
      naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);
      naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);
      max = Math.max(naf[a].length, max);
      max = Math.max(naf[b].length, max);
      continue;
    }
    var comb = [points[a], /* 1 */
    null, /* 3 */
    null, /* 5 */
    points[b] /* 7 */];

    // Try to avoid Projective points, if possible
    if (points[a].y.cmp(points[b].y) === 0) {
      comb[1] = points[a].add(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].add(points[b].neg());
    } else {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    }
    var index = [-3, /* -1 -1 */
    -1, /* -1 0 */
    -5, /* -1 1 */
    -7, /* 0 -1 */
    0, /* 0 0 */
    7, /* 0 1 */
    5, /* 1 -1 */
    1, /* 1 0 */
    3 /* 1 1 */];
    var jsf = getJSF(coeffs[a], coeffs[b]);
    max = Math.max(jsf[0].length, max);
    naf[a] = new Array(max);
    naf[b] = new Array(max);
    for (j = 0; j < max; j++) {
      var ja = jsf[0][j] | 0;
      var jb = jsf[1][j] | 0;
      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
      naf[b][j] = 0;
      wnd[a] = comb;
    }
  }
  var acc = this.jpoint(null, null, null);
  var tmp = this._wnafT4;
  for (i = max; i >= 0; i--) {
    var k = 0;
    while (i >= 0) {
      var zero = true;
      for (j = 0; j < len; j++) {
        tmp[j] = naf[j][i] | 0;
        if (tmp[j] !== 0) zero = false;
      }
      if (!zero) break;
      k++;
      i--;
    }
    if (i >= 0) k++;
    acc = acc.dblp(k);
    if (i < 0) break;
    for (j = 0; j < len; j++) {
      var z = tmp[j];
      p;
      if (z === 0) continue;else if (z > 0) p = wnd[j][z - 1 >> 1];else if (z < 0) p = wnd[j][-z - 1 >> 1].neg();
      if (p.type === 'affine') acc = acc.mixedAdd(p);else acc = acc.add(p);
    }
  }
  // Zeroify references
  for (i = 0; i < len; i++) wnd[i] = null;
  if (jacobianResult) return acc;else return acc.toP();
};
function BasePoint(curve, type) {
  this.curve = curve;
  this.type = type;
  this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;
BasePoint.prototype.eq = function eq( /*other*/
) {
  throw new Error('Not implemented');
};
BasePoint.prototype.validate = function validate() {
  return this.curve.validate(this);
};
BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  bytes = utils.toArray(bytes, enc);
  var len = this.p.byteLength();

  // uncompressed, hybrid-odd, hybrid-even
  if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) && bytes.length - 1 === 2 * len) {
    if (bytes[0] === 0x06) assert(bytes[bytes.length - 1] % 2 === 0);else if (bytes[0] === 0x07) assert(bytes[bytes.length - 1] % 2 === 1);
    var res = this.point(bytes.slice(1, 1 + len), bytes.slice(1 + len, 1 + 2 * len));
    return res;
  } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) && bytes.length - 1 === len) {
    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);
  }
  throw new Error('Unknown point format');
};
BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
  return this.encode(enc, true);
};
BasePoint.prototype._encode = function _encode(compact) {
  var len = this.curve.p.byteLength();
  var x = this.getX().toArray('be', len);
  if (compact) return [this.getY().isEven() ? 0x02 : 0x03].concat(x);
  return [0x04].concat(x, this.getY().toArray('be', len));
};
BasePoint.prototype.encode = function encode(enc, compact) {
  return utils.encode(this._encode(compact), enc);
};
BasePoint.prototype.precompute = function precompute(power) {
  if (this.precomputed) return this;
  var precomputed = {
    doubles: null,
    naf: null,
    beta: null
  };
  precomputed.naf = this._getNAFPoints(8);
  precomputed.doubles = this._getDoubles(4, power);
  precomputed.beta = this._getBeta();
  this.precomputed = precomputed;
  return this;
};
BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
  if (!this.precomputed) return false;
  var doubles = this.precomputed.doubles;
  if (!doubles) return false;
  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
};
BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
  if (this.precomputed && this.precomputed.doubles) return this.precomputed.doubles;
  var doubles = [this];
  var acc = this;
  for (var i = 0; i < power; i += step) {
    for (var j = 0; j < step; j++) acc = acc.dbl();
    doubles.push(acc);
  }
  return {
    step: step,
    points: doubles
  };
};
BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
  if (this.precomputed && this.precomputed.naf) return this.precomputed.naf;
  var res = [this];
  var max = (1 << wnd) - 1;
  var dbl = max === 1 ? null : this.dbl();
  for (var i = 1; i < max; i++) res[i] = res[i - 1].add(dbl);
  return {
    wnd: wnd,
    points: res
  };
};
BasePoint.prototype._getBeta = function _getBeta() {
  return null;
};
BasePoint.prototype.dblp = function dblp(k) {
  var r = this;
  for (var i = 0; i < k; i++) r = r.dbl();
  return r;
};

},{"../utils":175,"bn.js":103}],163:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var BN = require('bn.js');
var inherits = require('inherits');
var Base = require('./base');
var assert = utils.assert;
function EdwardsCurve(conf) {
  // NOTE: Important as we are creating point in Base.call()
  this.twisted = (conf.a | 0) !== 1;
  this.mOneA = this.twisted && (conf.a | 0) === -1;
  this.extended = this.mOneA;
  Base.call(this, 'edwards', conf);
  this.a = new BN(conf.a, 16).umod(this.red.m);
  this.a = this.a.toRed(this.red);
  this.c = new BN(conf.c, 16).toRed(this.red);
  this.c2 = this.c.redSqr();
  this.d = new BN(conf.d, 16).toRed(this.red);
  this.dd = this.d.redAdd(this.d);
  assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
  this.oneC = (conf.c | 0) === 1;
}
inherits(EdwardsCurve, Base);
module.exports = EdwardsCurve;
EdwardsCurve.prototype._mulA = function _mulA(num) {
  if (this.mOneA) return num.redNeg();else return this.a.redMul(num);
};
EdwardsCurve.prototype._mulC = function _mulC(num) {
  if (this.oneC) return num;else return this.c.redMul(num);
};

// Just for compatibility with Short curve
EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
  return this.point(x, y, z, t);
};
EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new BN(x, 16);
  if (!x.red) x = x.toRed(this.red);
  var x2 = x.redSqr();
  var rhs = this.c2.redSub(this.a.redMul(x2));
  var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));
  var y2 = rhs.redMul(lhs.redInvm());
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0) throw new Error('invalid point');
  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd) y = y.redNeg();
  return this.point(x, y);
};
EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
  y = new BN(y, 16);
  if (!y.red) y = y.toRed(this.red);

  // x^2 = (y^2 - c^2) / (c^2 d y^2 - a)
  var y2 = y.redSqr();
  var lhs = y2.redSub(this.c2);
  var rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a);
  var x2 = lhs.redMul(rhs.redInvm());
  if (x2.cmp(this.zero) === 0) {
    if (odd) throw new Error('invalid point');else return this.point(this.zero, y);
  }
  var x = x2.redSqrt();
  if (x.redSqr().redSub(x2).cmp(this.zero) !== 0) throw new Error('invalid point');
  if (x.fromRed().isOdd() !== odd) x = x.redNeg();
  return this.point(x, y);
};
EdwardsCurve.prototype.validate = function validate(point) {
  if (point.isInfinity()) return true;

  // Curve: A * X^2 + Y^2 = C^2 * (1 + D * X^2 * Y^2)
  point.normalize();
  var x2 = point.x.redSqr();
  var y2 = point.y.redSqr();
  var lhs = x2.redMul(this.a).redAdd(y2);
  var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));
  return lhs.cmp(rhs) === 0;
};
function Point(curve, x, y, z, t) {
  Base.BasePoint.call(this, curve, 'projective');
  if (x === null && y === null && z === null) {
    this.x = this.curve.zero;
    this.y = this.curve.one;
    this.z = this.curve.one;
    this.t = this.curve.zero;
    this.zOne = true;
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    this.z = z ? new BN(z, 16) : this.curve.one;
    this.t = t && new BN(t, 16);
    if (!this.x.red) this.x = this.x.toRed(this.curve.red);
    if (!this.y.red) this.y = this.y.toRed(this.curve.red);
    if (!this.z.red) this.z = this.z.toRed(this.curve.red);
    if (this.t && !this.t.red) this.t = this.t.toRed(this.curve.red);
    this.zOne = this.z === this.curve.one;

    // Use extended coordinates
    if (this.curve.extended && !this.t) {
      this.t = this.x.redMul(this.y);
      if (!this.zOne) this.t = this.t.redMul(this.z.redInvm());
    }
  }
}
inherits(Point, Base.BasePoint);
EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
  return Point.fromJSON(this, obj);
};
EdwardsCurve.prototype.point = function point(x, y, z, t) {
  return new Point(this, x, y, z, t);
};
Point.fromJSON = function fromJSON(curve, obj) {
  return new Point(curve, obj[0], obj[1], obj[2]);
};
Point.prototype.inspect = function inspect() {
  if (this.isInfinity()) return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) + ' y: ' + this.y.fromRed().toString(16, 2) + ' z: ' + this.z.fromRed().toString(16, 2) + '>';
};
Point.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
};
Point.prototype._extDbl = function _extDbl() {
  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
  //     #doubling-dbl-2008-hwcd
  // 4M + 4S

  // A = X1^2
  var a = this.x.redSqr();
  // B = Y1^2
  var b = this.y.redSqr();
  // C = 2 * Z1^2
  var c = this.z.redSqr();
  c = c.redIAdd(c);
  // D = a * A
  var d = this.curve._mulA(a);
  // E = (X1 + Y1)^2 - A - B
  var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
  // G = D + B
  var g = d.redAdd(b);
  // F = G - C
  var f = g.redSub(c);
  // H = D - B
  var h = d.redSub(b);
  // X3 = E * F
  var nx = e.redMul(f);
  // Y3 = G * H
  var ny = g.redMul(h);
  // T3 = E * H
  var nt = e.redMul(h);
  // Z3 = F * G
  var nz = f.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};
Point.prototype._projDbl = function _projDbl() {
  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
  //     #doubling-dbl-2008-bbjlp
  //     #doubling-dbl-2007-bl
  // and others
  // Generally 3M + 4S or 2M + 4S

  // B = (X1 + Y1)^2
  var b = this.x.redAdd(this.y).redSqr();
  // C = X1^2
  var c = this.x.redSqr();
  // D = Y1^2
  var d = this.y.redSqr();
  var nx;
  var ny;
  var nz;
  var e;
  var h;
  var j;
  if (this.curve.twisted) {
    // E = a * C
    e = this.curve._mulA(c);
    // F = E + D
    var f = e.redAdd(d);
    if (this.zOne) {
      // X3 = (B - C - D) * (F - 2)
      nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
      // Y3 = F * (E - D)
      ny = f.redMul(e.redSub(d));
      // Z3 = F^2 - 2 * F
      nz = f.redSqr().redSub(f).redSub(f);
    } else {
      // H = Z1^2
      h = this.z.redSqr();
      // J = F - 2 * H
      j = f.redSub(h).redISub(h);
      // X3 = (B-C-D)*J
      nx = b.redSub(c).redISub(d).redMul(j);
      // Y3 = F * (E - D)
      ny = f.redMul(e.redSub(d));
      // Z3 = F * J
      nz = f.redMul(j);
    }
  } else {
    // E = C + D
    e = c.redAdd(d);
    // H = (c * Z1)^2
    h = this.curve._mulC(this.z).redSqr();
    // J = E - 2 * H
    j = e.redSub(h).redSub(h);
    // X3 = c * (B - E) * J
    nx = this.curve._mulC(b.redISub(e)).redMul(j);
    // Y3 = c * E * (C - D)
    ny = this.curve._mulC(e).redMul(c.redISub(d));
    // Z3 = E * J
    nz = e.redMul(j);
  }
  return this.curve.point(nx, ny, nz);
};
Point.prototype.dbl = function dbl() {
  if (this.isInfinity()) return this;

  // Double in extended coordinates
  if (this.curve.extended) return this._extDbl();else return this._projDbl();
};
Point.prototype._extAdd = function _extAdd(p) {
  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
  //     #addition-add-2008-hwcd-3
  // 8M

  // A = (Y1 - X1) * (Y2 - X2)
  var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
  // B = (Y1 + X1) * (Y2 + X2)
  var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
  // C = T1 * k * T2
  var c = this.t.redMul(this.curve.dd).redMul(p.t);
  // D = Z1 * 2 * Z2
  var d = this.z.redMul(p.z.redAdd(p.z));
  // E = B - A
  var e = b.redSub(a);
  // F = D - C
  var f = d.redSub(c);
  // G = D + C
  var g = d.redAdd(c);
  // H = B + A
  var h = b.redAdd(a);
  // X3 = E * F
  var nx = e.redMul(f);
  // Y3 = G * H
  var ny = g.redMul(h);
  // T3 = E * H
  var nt = e.redMul(h);
  // Z3 = F * G
  var nz = f.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};
Point.prototype._projAdd = function _projAdd(p) {
  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
  //     #addition-add-2008-bbjlp
  //     #addition-add-2007-bl
  // 10M + 1S

  // A = Z1 * Z2
  var a = this.z.redMul(p.z);
  // B = A^2
  var b = a.redSqr();
  // C = X1 * X2
  var c = this.x.redMul(p.x);
  // D = Y1 * Y2
  var d = this.y.redMul(p.y);
  // E = d * C * D
  var e = this.curve.d.redMul(c).redMul(d);
  // F = B - E
  var f = b.redSub(e);
  // G = B + E
  var g = b.redAdd(e);
  // X3 = A * F * ((X1 + Y1) * (X2 + Y2) - C - D)
  var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
  var nx = a.redMul(f).redMul(tmp);
  var ny;
  var nz;
  if (this.curve.twisted) {
    // Y3 = A * G * (D - a * C)
    ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
    // Z3 = F * G
    nz = f.redMul(g);
  } else {
    // Y3 = A * G * (D - C)
    ny = a.redMul(g).redMul(d.redSub(c));
    // Z3 = c * F * G
    nz = this.curve._mulC(f).redMul(g);
  }
  return this.curve.point(nx, ny, nz);
};
Point.prototype.add = function add(p) {
  if (this.isInfinity()) return p;
  if (p.isInfinity()) return this;
  if (this.curve.extended) return this._extAdd(p);else return this._projAdd(p);
};
Point.prototype.mul = function mul(k) {
  if (this._hasDoubles(k)) return this.curve._fixedNafMul(this, k);else return this.curve._wnafMul(this, k);
};
Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
  return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, false);
};
Point.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
  return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, true);
};
Point.prototype.normalize = function normalize() {
  if (this.zOne) return this;

  // Normalize coordinates
  var zi = this.z.redInvm();
  this.x = this.x.redMul(zi);
  this.y = this.y.redMul(zi);
  if (this.t) this.t = this.t.redMul(zi);
  this.z = this.curve.one;
  this.zOne = true;
  return this;
};
Point.prototype.neg = function neg() {
  return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg());
};
Point.prototype.getX = function getX() {
  this.normalize();
  return this.x.fromRed();
};
Point.prototype.getY = function getY() {
  this.normalize();
  return this.y.fromRed();
};
Point.prototype.eq = function eq(other) {
  return this === other || this.getX().cmp(other.getX()) === 0 && this.getY().cmp(other.getY()) === 0;
};
Point.prototype.eqXToP = function eqXToP(x) {
  var rx = x.toRed(this.curve.red).redMul(this.z);
  if (this.x.cmp(rx) === 0) return true;
  var xc = x.clone();
  var t = this.curve.redN.redMul(this.z);
  for (;;) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0) return false;
    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0) return true;
  }
};

// Compatibility with BaseCurve
Point.prototype.toP = Point.prototype.normalize;
Point.prototype.mixedAdd = Point.prototype.add;

},{"../utils":175,"./base":162,"bn.js":103,"inherits":176}],164:[function(require,module,exports){
'use strict';

var curve = exports;
curve.base = require('./base');
curve["short"] = require('./short');
curve.mont = require('./mont');
curve.edwards = require('./edwards');

},{"./base":162,"./edwards":163,"./mont":165,"./short":166}],165:[function(require,module,exports){
'use strict';

var BN = require('bn.js');
var inherits = require('inherits');
var Base = require('./base');
var utils = require('../utils');
function MontCurve(conf) {
  Base.call(this, 'mont', conf);
  this.a = new BN(conf.a, 16).toRed(this.red);
  this.b = new BN(conf.b, 16).toRed(this.red);
  this.i4 = new BN(4).toRed(this.red).redInvm();
  this.two = new BN(2).toRed(this.red);
  this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}
inherits(MontCurve, Base);
module.exports = MontCurve;
MontCurve.prototype.validate = function validate(point) {
  var x = point.normalize().x;
  var x2 = x.redSqr();
  var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
  var y = rhs.redSqrt();
  return y.redSqr().cmp(rhs) === 0;
};
function Point(curve, x, z) {
  Base.BasePoint.call(this, curve, 'projective');
  if (x === null && z === null) {
    this.x = this.curve.one;
    this.z = this.curve.zero;
  } else {
    this.x = new BN(x, 16);
    this.z = new BN(z, 16);
    if (!this.x.red) this.x = this.x.toRed(this.curve.red);
    if (!this.z.red) this.z = this.z.toRed(this.curve.red);
  }
}
inherits(Point, Base.BasePoint);
MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  return this.point(utils.toArray(bytes, enc), 1);
};
MontCurve.prototype.point = function point(x, z) {
  return new Point(this, x, z);
};
MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
  return Point.fromJSON(this, obj);
};
Point.prototype.precompute = function precompute() {
  // No-op
};
Point.prototype._encode = function _encode() {
  return this.getX().toArray('be', this.curve.p.byteLength());
};
Point.fromJSON = function fromJSON(curve, obj) {
  return new Point(curve, obj[0], obj[1] || curve.one);
};
Point.prototype.inspect = function inspect() {
  if (this.isInfinity()) return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) + ' z: ' + this.z.fromRed().toString(16, 2) + '>';
};
Point.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};
Point.prototype.dbl = function dbl() {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#doubling-dbl-1987-m-3
  // 2M + 2S + 4A

  // A = X1 + Z1
  var a = this.x.redAdd(this.z);
  // AA = A^2
  var aa = a.redSqr();
  // B = X1 - Z1
  var b = this.x.redSub(this.z);
  // BB = B^2
  var bb = b.redSqr();
  // C = AA - BB
  var c = aa.redSub(bb);
  // X3 = AA * BB
  var nx = aa.redMul(bb);
  // Z3 = C * (BB + A24 * C)
  var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
  return this.curve.point(nx, nz);
};
Point.prototype.add = function add() {
  throw new Error('Not supported on Montgomery curve');
};
Point.prototype.diffAdd = function diffAdd(p, diff) {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#diffadd-dadd-1987-m-3
  // 4M + 2S + 6A

  // A = X2 + Z2
  var a = this.x.redAdd(this.z);
  // B = X2 - Z2
  var b = this.x.redSub(this.z);
  // C = X3 + Z3
  var c = p.x.redAdd(p.z);
  // D = X3 - Z3
  var d = p.x.redSub(p.z);
  // DA = D * A
  var da = d.redMul(a);
  // CB = C * B
  var cb = c.redMul(b);
  // X5 = Z1 * (DA + CB)^2
  var nx = diff.z.redMul(da.redAdd(cb).redSqr());
  // Z5 = X1 * (DA - CB)^2
  var nz = diff.x.redMul(da.redISub(cb).redSqr());
  return this.curve.point(nx, nz);
};
Point.prototype.mul = function mul(k) {
  var t = k.clone();
  var a = this; // (N / 2) * Q + Q
  var b = this.curve.point(null, null); // (N / 2) * Q
  var c = this; // Q

  for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1)) bits.push(t.andln(1));
  for (var i = bits.length - 1; i >= 0; i--) {
    if (bits[i] === 0) {
      // N * Q + Q = ((N / 2) * Q + Q)) + (N / 2) * Q
      a = a.diffAdd(b, c);
      // N * Q = 2 * ((N / 2) * Q + Q))
      b = b.dbl();
    } else {
      // N * Q = ((N / 2) * Q + Q) + ((N / 2) * Q)
      b = a.diffAdd(b, c);
      // N * Q + Q = 2 * ((N / 2) * Q + Q)
      a = a.dbl();
    }
  }
  return b;
};
Point.prototype.mulAdd = function mulAdd() {
  throw new Error('Not supported on Montgomery curve');
};
Point.prototype.jumlAdd = function jumlAdd() {
  throw new Error('Not supported on Montgomery curve');
};
Point.prototype.eq = function eq(other) {
  return this.getX().cmp(other.getX()) === 0;
};
Point.prototype.normalize = function normalize() {
  this.x = this.x.redMul(this.z.redInvm());
  this.z = this.curve.one;
  return this;
};
Point.prototype.getX = function getX() {
  // Normalize coordinates
  this.normalize();
  return this.x.fromRed();
};

},{"../utils":175,"./base":162,"bn.js":103,"inherits":176}],166:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var BN = require('bn.js');
var inherits = require('inherits');
var Base = require('./base');
var assert = utils.assert;
function ShortCurve(conf) {
  Base.call(this, 'short', conf);
  this.a = new BN(conf.a, 16).toRed(this.red);
  this.b = new BN(conf.b, 16).toRed(this.red);
  this.tinv = this.two.redInvm();
  this.zeroA = this.a.fromRed().cmpn(0) === 0;
  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;

  // If the curve is endomorphic, precalculate beta and lambda
  this.endo = this._getEndomorphism(conf);
  this._endoWnafT1 = new Array(4);
  this._endoWnafT2 = new Array(4);
}
inherits(ShortCurve, Base);
module.exports = ShortCurve;
ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
  // No efficient endomorphism
  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1) return;

  // Compute beta and lambda, that lambda * P = (beta * Px; Py)
  var beta;
  var lambda;
  if (conf.beta) {
    beta = new BN(conf.beta, 16).toRed(this.red);
  } else {
    var betas = this._getEndoRoots(this.p);
    // Choose the smallest beta
    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
    beta = beta.toRed(this.red);
  }
  if (conf.lambda) {
    lambda = new BN(conf.lambda, 16);
  } else {
    // Choose the lambda that is matching selected beta
    var lambdas = this._getEndoRoots(this.n);
    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
      lambda = lambdas[0];
    } else {
      lambda = lambdas[1];
      assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
    }
  }

  // Get basis vectors, used for balanced length-two representation
  var basis;
  if (conf.basis) {
    basis = conf.basis.map(function (vec) {
      return {
        a: new BN(vec.a, 16),
        b: new BN(vec.b, 16)
      };
    });
  } else {
    basis = this._getEndoBasis(lambda);
  }
  return {
    beta: beta,
    lambda: lambda,
    basis: basis
  };
};
ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
  // Find roots of for x^2 + x + 1 in F
  // Root = (-1 +- Sqrt(-3)) / 2
  //
  var red = num === this.p ? this.red : BN.mont(num);
  var tinv = new BN(2).toRed(red).redInvm();
  var ntinv = tinv.redNeg();
  var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);
  var l1 = ntinv.redAdd(s).fromRed();
  var l2 = ntinv.redSub(s).fromRed();
  return [l1, l2];
};
ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
  // aprxSqrt >= sqrt(this.n)
  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));

  // 3.74
  // Run EGCD, until r(L + 1) < aprxSqrt
  var u = lambda;
  var v = this.n.clone();
  var x1 = new BN(1);
  var y1 = new BN(0);
  var x2 = new BN(0);
  var y2 = new BN(1);

  // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)
  var a0;
  var b0;
  // First vector
  var a1;
  var b1;
  // Second vector
  var a2;
  var b2;
  var prevR;
  var i = 0;
  var r;
  var x;
  while (u.cmpn(0) !== 0) {
    var q = v.div(u);
    r = v.sub(q.mul(u));
    x = x2.sub(q.mul(x1));
    var y = y2.sub(q.mul(y1));
    if (!a1 && r.cmp(aprxSqrt) < 0) {
      a0 = prevR.neg();
      b0 = x1;
      a1 = r.neg();
      b1 = x;
    } else if (a1 && ++i === 2) {
      break;
    }
    prevR = r;
    v = u;
    u = r;
    x2 = x1;
    x1 = x;
    y2 = y1;
    y1 = y;
  }
  a2 = r.neg();
  b2 = x;
  var len1 = a1.sqr().add(b1.sqr());
  var len2 = a2.sqr().add(b2.sqr());
  if (len2.cmp(len1) >= 0) {
    a2 = a0;
    b2 = b0;
  }

  // Normalize signs
  if (a1.negative) {
    a1 = a1.neg();
    b1 = b1.neg();
  }
  if (a2.negative) {
    a2 = a2.neg();
    b2 = b2.neg();
  }
  return [{
    a: a1,
    b: b1
  }, {
    a: a2,
    b: b2
  }];
};
ShortCurve.prototype._endoSplit = function _endoSplit(k) {
  var basis = this.endo.basis;
  var v1 = basis[0];
  var v2 = basis[1];
  var c1 = v2.b.mul(k).divRound(this.n);
  var c2 = v1.b.neg().mul(k).divRound(this.n);
  var p1 = c1.mul(v1.a);
  var p2 = c2.mul(v2.a);
  var q1 = c1.mul(v1.b);
  var q2 = c2.mul(v2.b);

  // Calculate answer
  var k1 = k.sub(p1).sub(p2);
  var k2 = q1.add(q2).neg();
  return {
    k1: k1,
    k2: k2
  };
};
ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new BN(x, 16);
  if (!x.red) x = x.toRed(this.red);
  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0) throw new Error('invalid point');

  // XXX Is there any way to tell if the number is odd without converting it
  // to non-red form?
  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd) y = y.redNeg();
  return this.point(x, y);
};
ShortCurve.prototype.validate = function validate(point) {
  if (point.inf) return true;
  var x = point.x;
  var y = point.y;
  var ax = this.a.redMul(x);
  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
  return y.redSqr().redISub(rhs).cmpn(0) === 0;
};
ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
  var npoints = this._endoWnafT1;
  var ncoeffs = this._endoWnafT2;
  for (var i = 0; i < points.length; i++) {
    var split = this._endoSplit(coeffs[i]);
    var p = points[i];
    var beta = p._getBeta();
    if (split.k1.negative) {
      split.k1.ineg();
      p = p.neg(true);
    }
    if (split.k2.negative) {
      split.k2.ineg();
      beta = beta.neg(true);
    }
    npoints[i * 2] = p;
    npoints[i * 2 + 1] = beta;
    ncoeffs[i * 2] = split.k1;
    ncoeffs[i * 2 + 1] = split.k2;
  }
  var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);

  // Clean-up references to points and coefficients
  for (var j = 0; j < i * 2; j++) {
    npoints[j] = null;
    ncoeffs[j] = null;
  }
  return res;
};
function Point(curve, x, y, isRed) {
  Base.BasePoint.call(this, curve, 'affine');
  if (x === null && y === null) {
    this.x = null;
    this.y = null;
    this.inf = true;
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    // Force redgomery representation when loading from JSON
    if (isRed) {
      this.x.forceRed(this.curve.red);
      this.y.forceRed(this.curve.red);
    }
    if (!this.x.red) this.x = this.x.toRed(this.curve.red);
    if (!this.y.red) this.y = this.y.toRed(this.curve.red);
    this.inf = false;
  }
}
inherits(Point, Base.BasePoint);
ShortCurve.prototype.point = function point(x, y, isRed) {
  return new Point(this, x, y, isRed);
};
ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
  return Point.fromJSON(this, obj, red);
};
Point.prototype._getBeta = function _getBeta() {
  if (!this.curve.endo) return;
  var pre = this.precomputed;
  if (pre && pre.beta) return pre.beta;
  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
  if (pre) {
    var curve = this.curve;
    var endoMul = function endoMul(p) {
      return curve.point(p.x.redMul(curve.endo.beta), p.y);
    };
    pre.beta = beta;
    beta.precomputed = {
      beta: null,
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(endoMul)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(endoMul)
      }
    };
  }
  return beta;
};
Point.prototype.toJSON = function toJSON() {
  if (!this.precomputed) return [this.x, this.y];
  return [this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }];
};
Point.fromJSON = function fromJSON(curve, obj, red) {
  if (typeof obj === 'string') obj = JSON.parse(obj);
  var res = curve.point(obj[0], obj[1], red);
  if (!obj[2]) return res;
  function obj2point(obj) {
    return curve.point(obj[0], obj[1], red);
  }
  var pre = obj[2];
  res.precomputed = {
    beta: null,
    doubles: pre.doubles && {
      step: pre.doubles.step,
      points: [res].concat(pre.doubles.points.map(obj2point))
    },
    naf: pre.naf && {
      wnd: pre.naf.wnd,
      points: [res].concat(pre.naf.points.map(obj2point))
    }
  };
  return res;
};
Point.prototype.inspect = function inspect() {
  if (this.isInfinity()) return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) + ' y: ' + this.y.fromRed().toString(16, 2) + '>';
};
Point.prototype.isInfinity = function isInfinity() {
  return this.inf;
};
Point.prototype.add = function add(p) {
  // O + P = P
  if (this.inf) return p;

  // P + O = P
  if (p.inf) return this;

  // P + P = 2P
  if (this.eq(p)) return this.dbl();

  // P + (-P) = O
  if (this.neg().eq(p)) return this.curve.point(null, null);

  // P + Q = O
  if (this.x.cmp(p.x) === 0) return this.curve.point(null, null);
  var c = this.y.redSub(p.y);
  if (c.cmpn(0) !== 0) c = c.redMul(this.x.redSub(p.x).redInvm());
  var nx = c.redSqr().redISub(this.x).redISub(p.x);
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};
Point.prototype.dbl = function dbl() {
  if (this.inf) return this;

  // 2P = O
  var ys1 = this.y.redAdd(this.y);
  if (ys1.cmpn(0) === 0) return this.curve.point(null, null);
  var a = this.curve.a;
  var x2 = this.x.redSqr();
  var dyinv = ys1.redInvm();
  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);
  var nx = c.redSqr().redISub(this.x.redAdd(this.x));
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};
Point.prototype.getX = function getX() {
  return this.x.fromRed();
};
Point.prototype.getY = function getY() {
  return this.y.fromRed();
};
Point.prototype.mul = function mul(k) {
  k = new BN(k, 16);
  if (this.isInfinity()) return this;else if (this._hasDoubles(k)) return this.curve._fixedNafMul(this, k);else if (this.curve.endo) return this.curve._endoWnafMulAdd([this], [k]);else return this.curve._wnafMul(this, k);
};
Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
  var points = [this, p2];
  var coeffs = [k1, k2];
  if (this.curve.endo) return this.curve._endoWnafMulAdd(points, coeffs);else return this.curve._wnafMulAdd(1, points, coeffs, 2);
};
Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
  var points = [this, p2];
  var coeffs = [k1, k2];
  if (this.curve.endo) return this.curve._endoWnafMulAdd(points, coeffs, true);else return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
};
Point.prototype.eq = function eq(p) {
  return this === p || this.inf === p.inf && (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
};
Point.prototype.neg = function neg(_precompute) {
  if (this.inf) return this;
  var res = this.curve.point(this.x, this.y.redNeg());
  if (_precompute && this.precomputed) {
    var pre = this.precomputed;
    var negate = function negate(p) {
      return p.neg();
    };
    res.precomputed = {
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(negate)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(negate)
      }
    };
  }
  return res;
};
Point.prototype.toJ = function toJ() {
  if (this.inf) return this.curve.jpoint(null, null, null);
  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
  return res;
};
function JPoint(curve, x, y, z) {
  Base.BasePoint.call(this, curve, 'jacobian');
  if (x === null && y === null && z === null) {
    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = new BN(0);
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    this.z = new BN(z, 16);
  }
  if (!this.x.red) this.x = this.x.toRed(this.curve.red);
  if (!this.y.red) this.y = this.y.toRed(this.curve.red);
  if (!this.z.red) this.z = this.z.toRed(this.curve.red);
  this.zOne = this.z === this.curve.one;
}
inherits(JPoint, Base.BasePoint);
ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
  return new JPoint(this, x, y, z);
};
JPoint.prototype.toP = function toP() {
  if (this.isInfinity()) return this.curve.point(null, null);
  var zinv = this.z.redInvm();
  var zinv2 = zinv.redSqr();
  var ax = this.x.redMul(zinv2);
  var ay = this.y.redMul(zinv2).redMul(zinv);
  return this.curve.point(ax, ay);
};
JPoint.prototype.neg = function neg() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
JPoint.prototype.add = function add(p) {
  // O + P = P
  if (this.isInfinity()) return p;

  // P + O = P
  if (p.isInfinity()) return this;

  // 12M + 4S + 7A
  var pz2 = p.z.redSqr();
  var z2 = this.z.redSqr();
  var u1 = this.x.redMul(pz2);
  var u2 = p.x.redMul(z2);
  var s1 = this.y.redMul(pz2.redMul(p.z));
  var s2 = p.y.redMul(z2.redMul(this.z));
  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0) return this.curve.jpoint(null, null, null);else return this.dbl();
  }
  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);
  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(p.z).redMul(h);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.mixedAdd = function mixedAdd(p) {
  // O + P = P
  if (this.isInfinity()) return p.toJ();

  // P + O = P
  if (p.isInfinity()) return this;

  // 8M + 3S + 7A
  var z2 = this.z.redSqr();
  var u1 = this.x;
  var u2 = p.x.redMul(z2);
  var s1 = this.y;
  var s2 = p.y.redMul(z2).redMul(this.z);
  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0) return this.curve.jpoint(null, null, null);else return this.dbl();
  }
  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);
  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(h);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.dblp = function dblp(pow) {
  if (pow === 0) return this;
  if (this.isInfinity()) return this;
  if (!pow) return this.dbl();
  var i;
  if (this.curve.zeroA || this.curve.threeA) {
    var r = this;
    for (i = 0; i < pow; i++) r = r.dbl();
    return r;
  }

  // 1M + 2S + 1A + N * (4S + 5M + 8A)
  // N = 1 => 6M + 6S + 9A
  var a = this.curve.a;
  var tinv = this.curve.tinv;
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();

  // Reuse results
  var jyd = jy.redAdd(jy);
  for (i = 0; i < pow; i++) {
    var jx2 = jx.redSqr();
    var jyd2 = jyd.redSqr();
    var jyd4 = jyd2.redSqr();
    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
    var t1 = jx.redMul(jyd2);
    var nx = c.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var dny = c.redMul(t2);
    dny = dny.redIAdd(dny).redISub(jyd4);
    var nz = jyd.redMul(jz);
    if (i + 1 < pow) jz4 = jz4.redMul(jyd4);
    jx = nx;
    jz = nz;
    jyd = dny;
  }
  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
};
JPoint.prototype.dbl = function dbl() {
  if (this.isInfinity()) return this;
  if (this.curve.zeroA) return this._zeroDbl();else if (this.curve.threeA) return this._threeDbl();else return this._dbl();
};
JPoint.prototype._zeroDbl = function _zeroDbl() {
  var nx;
  var ny;
  var nz;
  // Z = 1
  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 14A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a; a = 0
    var m = xx.redAdd(xx).redIAdd(xx);
    // T = M ^ 2 - 2*S
    var t = m.redSqr().redISub(s).redISub(s);

    // 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);

    // X3 = T
    nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2*Y1
    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-dbl-2009-l
    // 2M + 5S + 13A

    // A = X1^2
    var a = this.x.redSqr();
    // B = Y1^2
    var b = this.y.redSqr();
    // C = B^2
    var c = b.redSqr();
    // D = 2 * ((X1 + B)^2 - A - C)
    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
    d = d.redIAdd(d);
    // E = 3 * A
    var e = a.redAdd(a).redIAdd(a);
    // F = E^2
    var f = e.redSqr();

    // 8 * C
    var c8 = c.redIAdd(c);
    c8 = c8.redIAdd(c8);
    c8 = c8.redIAdd(c8);

    // X3 = F - 2 * D
    nx = f.redISub(d).redISub(d);
    // Y3 = E * (D - X3) - 8 * C
    ny = e.redMul(d.redISub(nx)).redISub(c8);
    // Z3 = 2 * Y1 * Z1
    nz = this.y.redMul(this.z);
    nz = nz.redIAdd(nz);
  }
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype._threeDbl = function _threeDbl() {
  var nx;
  var ny;
  var nz;
  // Z = 1
  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 15A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a
    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
    // T = M^2 - 2 * S
    var t = m.redSqr().redISub(s).redISub(s);
    // X3 = T
    nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2 * Y1
    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b
    // 3M + 5S

    // delta = Z1^2
    var delta = this.z.redSqr();
    // gamma = Y1^2
    var gamma = this.y.redSqr();
    // beta = X1 * gamma
    var beta = this.x.redMul(gamma);
    // alpha = 3 * (X1 - delta) * (X1 + delta)
    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
    alpha = alpha.redAdd(alpha).redIAdd(alpha);
    // X3 = alpha^2 - 8 * beta
    var beta4 = beta.redIAdd(beta);
    beta4 = beta4.redIAdd(beta4);
    var beta8 = beta4.redAdd(beta4);
    nx = alpha.redSqr().redISub(beta8);
    // Z3 = (Y1 + Z1)^2 - gamma - delta
    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2
    var ggamma8 = gamma.redSqr();
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
  }
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype._dbl = function _dbl() {
  var a = this.curve.a;

  // 4M + 6S + 10A
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();
  var jx2 = jx.redSqr();
  var jy2 = jy.redSqr();
  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
  var jxd4 = jx.redAdd(jx);
  jxd4 = jxd4.redIAdd(jxd4);
  var t1 = jxd4.redMul(jy2);
  var nx = c.redSqr().redISub(t1.redAdd(t1));
  var t2 = t1.redISub(nx);
  var jyd8 = jy2.redSqr();
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  var ny = c.redMul(t2).redISub(jyd8);
  var nz = jy.redAdd(jy).redMul(jz);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.trpl = function trpl() {
  if (!this.curve.zeroA) return this.dbl().add(this);

  // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl
  // 5M + 10S + ...

  // XX = X1^2
  var xx = this.x.redSqr();
  // YY = Y1^2
  var yy = this.y.redSqr();
  // ZZ = Z1^2
  var zz = this.z.redSqr();
  // YYYY = YY^2
  var yyyy = yy.redSqr();
  // M = 3 * XX + a * ZZ2; a = 0
  var m = xx.redAdd(xx).redIAdd(xx);
  // MM = M^2
  var mm = m.redSqr();
  // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM
  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
  e = e.redIAdd(e);
  e = e.redAdd(e).redIAdd(e);
  e = e.redISub(mm);
  // EE = E^2
  var ee = e.redSqr();
  // T = 16*YYYY
  var t = yyyy.redIAdd(yyyy);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  // U = (M + E)^2 - MM - EE - T
  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
  // X3 = 4 * (X1 * EE - 4 * YY * U)
  var yyu4 = yy.redMul(u);
  yyu4 = yyu4.redIAdd(yyu4);
  yyu4 = yyu4.redIAdd(yyu4);
  var nx = this.x.redMul(ee).redISub(yyu4);
  nx = nx.redIAdd(nx);
  nx = nx.redIAdd(nx);
  // Y3 = 8 * Y1 * (U * (T - U) - E * EE)
  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  // Z3 = (Z1 + E)^2 - ZZ - EE
  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);
  return this.curve.jpoint(nx, ny, nz);
};
JPoint.prototype.mul = function mul(k, kbase) {
  k = new BN(k, kbase);
  return this.curve._wnafMul(this, k);
};
JPoint.prototype.eq = function eq(p) {
  if (p.type === 'affine') return this.eq(p.toJ());
  if (this === p) return true;

  // x1 * z2^2 == x2 * z1^2
  var z2 = this.z.redSqr();
  var pz2 = p.z.redSqr();
  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0) return false;

  // y1 * z2^3 == y2 * z1^3
  var z3 = z2.redMul(this.z);
  var pz3 = pz2.redMul(p.z);
  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
};
JPoint.prototype.eqXToP = function eqXToP(x) {
  var zs = this.z.redSqr();
  var rx = x.toRed(this.curve.red).redMul(zs);
  if (this.x.cmp(rx) === 0) return true;
  var xc = x.clone();
  var t = this.curve.redN.redMul(zs);
  for (;;) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0) return false;
    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0) return true;
  }
};
JPoint.prototype.inspect = function inspect() {
  if (this.isInfinity()) return '<EC JPoint Infinity>';
  return '<EC JPoint x: ' + this.x.toString(16, 2) + ' y: ' + this.y.toString(16, 2) + ' z: ' + this.z.toString(16, 2) + '>';
};
JPoint.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};

},{"../utils":175,"./base":162,"bn.js":103,"inherits":176}],167:[function(require,module,exports){
'use strict';

var curves = exports;
var hash = require('hash.js');
var curve = require('./curve');
var utils = require('./utils');
var assert = utils.assert;
function PresetCurve(options) {
  if (options.type === 'short') this.curve = new curve["short"](options);else if (options.type === 'edwards') this.curve = new curve.edwards(options);else this.curve = new curve.mont(options);
  this.g = this.curve.g;
  this.n = this.curve.n;
  this.hash = options.hash;
  assert(this.g.validate(), 'Invalid curve');
  assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');
}
curves.PresetCurve = PresetCurve;
function defineCurve(name, options) {
  Object.defineProperty(curves, name, {
    configurable: true,
    enumerable: true,
    get: function get() {
      var curve = new PresetCurve(options);
      Object.defineProperty(curves, name, {
        configurable: true,
        enumerable: true,
        value: curve
      });
      return curve;
    }
  });
}
defineCurve('p192', {
  type: 'short',
  prime: 'p192',
  p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',
  b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',
  n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',
  hash: hash.sha256,
  gRed: false,
  g: ['188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012', '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811']
});
defineCurve('p224', {
  type: 'short',
  prime: 'p224',
  p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',
  b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',
  n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',
  hash: hash.sha256,
  gRed: false,
  g: ['b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21', 'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34']
});
defineCurve('p256', {
  type: 'short',
  prime: null,
  p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',
  a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',
  b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',
  n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',
  hash: hash.sha256,
  gRed: false,
  g: ['6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296', '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5']
});
defineCurve('p384', {
  type: 'short',
  prime: null,
  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' + 'fffffffe ffffffff 00000000 00000000 ffffffff',
  a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' + 'fffffffe ffffffff 00000000 00000000 fffffffc',
  b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' + '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',
  n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' + 'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',
  hash: hash.sha384,
  gRed: false,
  g: ['aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' + '5502f25d bf55296c 3a545e38 72760ab7', '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' + '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f']
});
defineCurve('p521', {
  type: 'short',
  prime: null,
  p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' + 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' + 'ffffffff ffffffff ffffffff ffffffff ffffffff',
  a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' + 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' + 'ffffffff ffffffff ffffffff ffffffff fffffffc',
  b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' + '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' + '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',
  n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' + 'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' + 'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',
  hash: hash.sha512,
  gRed: false,
  g: ['000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' + '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' + 'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66', '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' + '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' + '3fad0761 353c7086 a272c240 88be9476 9fd16650']
});
defineCurve('curve25519', {
  type: 'mont',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '76d06',
  b: '1',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: hash.sha256,
  gRed: false,
  g: ['9']
});
defineCurve('ed25519', {
  type: 'edwards',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '-1',
  c: '1',
  // -121665 * (121666^(-1)) (mod P)
  d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: hash.sha256,
  gRed: false,
  g: ['216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',
  // 4/5
  '6666666666666666666666666666666666666666666666666666666666666658']
});
var pre;
try {
  pre = require('./precomputed/secp256k1');
} catch (e) {
  pre = undefined;
}
defineCurve('secp256k1', {
  type: 'short',
  prime: 'k256',
  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',
  a: '0',
  b: '7',
  n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',
  h: '1',
  hash: hash.sha256,
  // Precomputed endomorphism
  beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',
  lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',
  basis: [{
    a: '3086d221a7d46bcde86c90e49284eb15',
    b: '-e4437ed6010e88286f547fa90abfe4c3'
  }, {
    a: '114ca50f7a8e2f3f657c1108d9d44cfd8',
    b: '3086d221a7d46bcde86c90e49284eb15'
  }],
  gRed: false,
  g: ['79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798', '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8', pre]
});

},{"./curve":164,"./precomputed/secp256k1":174,"./utils":175,"hash.js":312}],168:[function(require,module,exports){
'use strict';

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var BN = require('bn.js');
var HmacDRBG = require('hmac-drbg');
var utils = require('../utils');
var curves = require('../curves');
var rand = require('brorand');
var assert = utils.assert;
var KeyPair = require('./key');
var Signature = require('./signature');
function EC(options) {
  if (!(this instanceof EC)) return new EC(options);

  // Shortcut `elliptic.ec(curve-name)`
  if (typeof options === 'string') {
    assert(Object.prototype.hasOwnProperty.call(curves, options), 'Unknown curve ' + options);
    options = curves[options];
  }

  // Shortcut for `elliptic.ec(elliptic.curves.curveName)`
  if (options instanceof curves.PresetCurve) options = {
    curve: options
  };
  this.curve = options.curve.curve;
  this.n = this.curve.n;
  this.nh = this.n.ushrn(1);
  this.g = this.curve.g;

  // Point on curve
  this.g = options.curve.g;
  this.g.precompute(options.curve.n.bitLength() + 1);

  // Hash for function for DRBG
  this.hash = options.hash || options.curve.hash;
}
module.exports = EC;
EC.prototype.keyPair = function keyPair(options) {
  return new KeyPair(this, options);
};
EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
  return KeyPair.fromPrivate(this, priv, enc);
};
EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
  return KeyPair.fromPublic(this, pub, enc);
};
EC.prototype.genKeyPair = function genKeyPair(options) {
  if (!options) options = {};

  // Instantiate Hmac_DRBG
  var drbg = new HmacDRBG({
    hash: this.hash,
    pers: options.pers,
    persEnc: options.persEnc || 'utf8',
    entropy: options.entropy || rand(this.hash.hmacStrength),
    entropyEnc: options.entropy && options.entropyEnc || 'utf8',
    nonce: this.n.toArray()
  });
  var bytes = this.n.byteLength();
  var ns2 = this.n.sub(new BN(2));
  for (;;) {
    var priv = new BN(drbg.generate(bytes));
    if (priv.cmp(ns2) > 0) continue;
    priv.iaddn(1);
    return this.keyFromPrivate(priv);
  }
};
EC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
  var delta = msg.byteLength() * 8 - this.n.bitLength();
  if (delta > 0) msg = msg.ushrn(delta);
  if (!truncOnly && msg.cmp(this.n) >= 0) return msg.sub(this.n);else return msg;
};
EC.prototype.sign = function sign(msg, key, enc, options) {
  if (_typeof(enc) === 'object') {
    options = enc;
    enc = null;
  }
  if (!options) options = {};
  key = this.keyFromPrivate(key, enc);
  msg = this._truncateToN(new BN(msg, 16));

  // Zero-extend key to provide enough entropy
  var bytes = this.n.byteLength();
  var bkey = key.getPrivate().toArray('be', bytes);

  // Zero-extend nonce to have the same byte size as N
  var nonce = msg.toArray('be', bytes);

  // Instantiate Hmac_DRBG
  var drbg = new HmacDRBG({
    hash: this.hash,
    entropy: bkey,
    nonce: nonce,
    pers: options.pers,
    persEnc: options.persEnc || 'utf8'
  });

  // Number of bytes to generate
  var ns1 = this.n.sub(new BN(1));
  for (var iter = 0;; iter++) {
    var k = options.k ? options.k(iter) : new BN(drbg.generate(this.n.byteLength()));
    k = this._truncateToN(k, true);
    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0) continue;
    var kp = this.g.mul(k);
    if (kp.isInfinity()) continue;
    var kpX = kp.getX();
    var r = kpX.umod(this.n);
    if (r.cmpn(0) === 0) continue;
    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
    s = s.umod(this.n);
    if (s.cmpn(0) === 0) continue;
    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r) !== 0 ? 2 : 0);

    // Use complement of `s`, if it is > `n / 2`
    if (options.canonical && s.cmp(this.nh) > 0) {
      s = this.n.sub(s);
      recoveryParam ^= 1;
    }
    return new Signature({
      r: r,
      s: s,
      recoveryParam: recoveryParam
    });
  }
};
EC.prototype.verify = function verify(msg, signature, key, enc) {
  msg = this._truncateToN(new BN(msg, 16));
  key = this.keyFromPublic(key, enc);
  signature = new Signature(signature, 'hex');

  // Perform primitive values validation
  var r = signature.r;
  var s = signature.s;
  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0) return false;
  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0) return false;

  // Validate signature
  var sinv = s.invm(this.n);
  var u1 = sinv.mul(msg).umod(this.n);
  var u2 = sinv.mul(r).umod(this.n);
  var p;
  if (!this.curve._maxwellTrick) {
    p = this.g.mulAdd(u1, key.getPublic(), u2);
    if (p.isInfinity()) return false;
    return p.getX().umod(this.n).cmp(r) === 0;
  }

  // NOTE: Greg Maxwell's trick, inspired by:
  // https://git.io/vad3K

  p = this.g.jmulAdd(u1, key.getPublic(), u2);
  if (p.isInfinity()) return false;

  // Compare `p.x` of Jacobian point with `r`,
  // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the
  // inverse of `p.z^2`
  return p.eqXToP(r);
};
EC.prototype.recoverPubKey = function (msg, signature, j, enc) {
  assert((3 & j) === j, 'The recovery param is more than two bits');
  signature = new Signature(signature, enc);
  var n = this.n;
  var e = new BN(msg);
  var r = signature.r;
  var s = signature.s;

  // A set LSB signifies that the y-coordinate is odd
  var isYOdd = j & 1;
  var isSecondKey = j >> 1;
  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey) throw new Error('Unable to find sencond key candinate');

  // 1.1. Let x = r + jn.
  if (isSecondKey) r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);else r = this.curve.pointFromX(r, isYOdd);
  var rInv = signature.r.invm(n);
  var s1 = n.sub(e).mul(rInv).umod(n);
  var s2 = s.mul(rInv).umod(n);

  // 1.6.1 Compute Q = r^-1 (sR -  eG)
  //               Q = r^-1 (sR + -eG)
  return this.g.mulAdd(s1, r, s2);
};
EC.prototype.getKeyRecoveryParam = function (e, signature, Q, enc) {
  signature = new Signature(signature, enc);
  if (signature.recoveryParam !== null) return signature.recoveryParam;
  for (var i = 0; i < 4; i++) {
    var Qprime;
    try {
      Qprime = this.recoverPubKey(e, signature, i);
    } catch (e) {
      continue;
    }
    if (Qprime.eq(Q)) return i;
  }
  throw new Error('Unable to find valid recovery factor');
};

},{"../curves":167,"../utils":175,"./key":169,"./signature":170,"bn.js":103,"brorand":104,"hmac-drbg":325}],169:[function(require,module,exports){
'use strict';

var BN = require('bn.js');
var utils = require('../utils');
var assert = utils.assert;
function KeyPair(ec, options) {
  this.ec = ec;
  this.priv = null;
  this.pub = null;

  // KeyPair(ec, { priv: ..., pub: ... })
  if (options.priv) this._importPrivate(options.priv, options.privEnc);
  if (options.pub) this._importPublic(options.pub, options.pubEnc);
}
module.exports = KeyPair;
KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
  if (pub instanceof KeyPair) return pub;
  return new KeyPair(ec, {
    pub: pub,
    pubEnc: enc
  });
};
KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
  if (priv instanceof KeyPair) return priv;
  return new KeyPair(ec, {
    priv: priv,
    privEnc: enc
  });
};
KeyPair.prototype.validate = function validate() {
  var pub = this.getPublic();
  if (pub.isInfinity()) return {
    result: false,
    reason: 'Invalid public key'
  };
  if (!pub.validate()) return {
    result: false,
    reason: 'Public key is not a point'
  };
  if (!pub.mul(this.ec.curve.n).isInfinity()) return {
    result: false,
    reason: 'Public key * N != O'
  };
  return {
    result: true,
    reason: null
  };
};
KeyPair.prototype.getPublic = function getPublic(compact, enc) {
  // compact is optional argument
  if (typeof compact === 'string') {
    enc = compact;
    compact = null;
  }
  if (!this.pub) this.pub = this.ec.g.mul(this.priv);
  if (!enc) return this.pub;
  return this.pub.encode(enc, compact);
};
KeyPair.prototype.getPrivate = function getPrivate(enc) {
  if (enc === 'hex') return this.priv.toString(16, 2);else return this.priv;
};
KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
  this.priv = new BN(key, enc || 16);

  // Ensure that the priv won't be bigger than n, otherwise we may fail
  // in fixed multiplication method
  this.priv = this.priv.umod(this.ec.curve.n);
};
KeyPair.prototype._importPublic = function _importPublic(key, enc) {
  if (key.x || key.y) {
    // Montgomery points only have an `x` coordinate.
    // Weierstrass/Edwards points on the other hand have both `x` and
    // `y` coordinates.
    if (this.ec.curve.type === 'mont') {
      assert(key.x, 'Need x coordinate');
    } else if (this.ec.curve.type === 'short' || this.ec.curve.type === 'edwards') {
      assert(key.x && key.y, 'Need both x and y coordinate');
    }
    this.pub = this.ec.curve.point(key.x, key.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(key, enc);
};

// ECDH
KeyPair.prototype.derive = function derive(pub) {
  if (!pub.validate()) {
    assert(pub.validate(), 'public point not validated');
  }
  return pub.mul(this.priv).getX();
};

// ECDSA
KeyPair.prototype.sign = function sign(msg, enc, options) {
  return this.ec.sign(msg, this, enc, options);
};
KeyPair.prototype.verify = function verify(msg, signature) {
  return this.ec.verify(msg, signature, this);
};
KeyPair.prototype.inspect = function inspect() {
  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) + ' pub: ' + (this.pub && this.pub.inspect()) + ' >';
};

},{"../utils":175,"bn.js":103}],170:[function(require,module,exports){
'use strict';

var BN = require('bn.js');
var utils = require('../utils');
var assert = utils.assert;
function Signature(options, enc) {
  if (options instanceof Signature) return options;
  if (this._importDER(options, enc)) return;
  assert(options.r && options.s, 'Signature without r or s');
  this.r = new BN(options.r, 16);
  this.s = new BN(options.s, 16);
  if (options.recoveryParam === undefined) this.recoveryParam = null;else this.recoveryParam = options.recoveryParam;
}
module.exports = Signature;
function Position() {
  this.place = 0;
}
function getLength(buf, p) {
  var initial = buf[p.place++];
  if (!(initial & 0x80)) {
    return initial;
  }
  var octetLen = initial & 0xf;

  // Indefinite length or overflow
  if (octetLen === 0 || octetLen > 4) {
    return false;
  }
  var val = 0;
  for (var i = 0, off = p.place; i < octetLen; i++, off++) {
    val <<= 8;
    val |= buf[off];
    val >>>= 0;
  }

  // Leading zeroes
  if (val <= 0x7f) {
    return false;
  }
  p.place = off;
  return val;
}
function rmPadding(buf) {
  var i = 0;
  var len = buf.length - 1;
  while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {
    i++;
  }
  if (i === 0) {
    return buf;
  }
  return buf.slice(i);
}
Signature.prototype._importDER = function _importDER(data, enc) {
  data = utils.toArray(data, enc);
  var p = new Position();
  if (data[p.place++] !== 0x30) {
    return false;
  }
  var len = getLength(data, p);
  if (len === false) {
    return false;
  }
  if (len + p.place !== data.length) {
    return false;
  }
  if (data[p.place++] !== 0x02) {
    return false;
  }
  var rlen = getLength(data, p);
  if (rlen === false) {
    return false;
  }
  var r = data.slice(p.place, rlen + p.place);
  p.place += rlen;
  if (data[p.place++] !== 0x02) {
    return false;
  }
  var slen = getLength(data, p);
  if (slen === false) {
    return false;
  }
  if (data.length !== slen + p.place) {
    return false;
  }
  var s = data.slice(p.place, slen + p.place);
  if (r[0] === 0) {
    if (r[1] & 0x80) {
      r = r.slice(1);
    } else {
      // Leading zeroes
      return false;
    }
  }
  if (s[0] === 0) {
    if (s[1] & 0x80) {
      s = s.slice(1);
    } else {
      // Leading zeroes
      return false;
    }
  }
  this.r = new BN(r);
  this.s = new BN(s);
  this.recoveryParam = null;
  return true;
};
function constructLength(arr, len) {
  if (len < 0x80) {
    arr.push(len);
    return;
  }
  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
  arr.push(octets | 0x80);
  while (--octets) {
    arr.push(len >>> (octets << 3) & 0xff);
  }
  arr.push(len);
}
Signature.prototype.toDER = function toDER(enc) {
  var r = this.r.toArray();
  var s = this.s.toArray();

  // Pad values
  if (r[0] & 0x80) r = [0].concat(r);
  // Pad values
  if (s[0] & 0x80) s = [0].concat(s);
  r = rmPadding(r);
  s = rmPadding(s);
  while (!s[0] && !(s[1] & 0x80)) {
    s = s.slice(1);
  }
  var arr = [0x02];
  constructLength(arr, r.length);
  arr = arr.concat(r);
  arr.push(0x02);
  constructLength(arr, s.length);
  var backHalf = arr.concat(s);
  var res = [0x30];
  constructLength(res, backHalf.length);
  res = res.concat(backHalf);
  return utils.encode(res, enc);
};

},{"../utils":175,"bn.js":103}],171:[function(require,module,exports){
'use strict';

var hash = require('hash.js');
var curves = require('../curves');
var utils = require('../utils');
var assert = utils.assert;
var parseBytes = utils.parseBytes;
var KeyPair = require('./key');
var Signature = require('./signature');
function EDDSA(curve) {
  assert(curve === 'ed25519', 'only tested with ed25519 so far');
  if (!(this instanceof EDDSA)) return new EDDSA(curve);
  curve = curves[curve].curve;
  this.curve = curve;
  this.g = curve.g;
  this.g.precompute(curve.n.bitLength() + 1);
  this.pointClass = curve.point().constructor;
  this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
  this.hash = hash.sha512;
}
module.exports = EDDSA;

/**
* @param {Array|String} message - message bytes
* @param {Array|String|KeyPair} secret - secret bytes or a keypair
* @returns {Signature} - signature
*/
EDDSA.prototype.sign = function sign(message, secret) {
  message = parseBytes(message);
  var key = this.keyFromSecret(secret);
  var r = this.hashInt(key.messagePrefix(), message);
  var R = this.g.mul(r);
  var Rencoded = this.encodePoint(R);
  var s_ = this.hashInt(Rencoded, key.pubBytes(), message).mul(key.priv());
  var S = r.add(s_).umod(this.curve.n);
  return this.makeSignature({
    R: R,
    S: S,
    Rencoded: Rencoded
  });
};

/**
* @param {Array} message - message bytes
* @param {Array|String|Signature} sig - sig bytes
* @param {Array|String|Point|KeyPair} pub - public key
* @returns {Boolean} - true if public key matches sig of message
*/
EDDSA.prototype.verify = function verify(message, sig, pub) {
  message = parseBytes(message);
  sig = this.makeSignature(sig);
  var key = this.keyFromPublic(pub);
  var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
  var SG = this.g.mul(sig.S());
  var RplusAh = sig.R().add(key.pub().mul(h));
  return RplusAh.eq(SG);
};
EDDSA.prototype.hashInt = function hashInt() {
  var hash = this.hash();
  for (var i = 0; i < arguments.length; i++) hash.update(arguments[i]);
  return utils.intFromLE(hash.digest()).umod(this.curve.n);
};
EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
  return KeyPair.fromPublic(this, pub);
};
EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
  return KeyPair.fromSecret(this, secret);
};
EDDSA.prototype.makeSignature = function makeSignature(sig) {
  if (sig instanceof Signature) return sig;
  return new Signature(this, sig);
};

/**
* * https://tools.ietf.org/html/draft-josefsson-eddsa-ed25519-03#section-5.2
*
* EDDSA defines methods for encoding and decoding points and integers. These are
* helper convenience methods, that pass along to utility functions implied
* parameters.
*
*/
EDDSA.prototype.encodePoint = function encodePoint(point) {
  var enc = point.getY().toArray('le', this.encodingLength);
  enc[this.encodingLength - 1] |= point.getX().isOdd() ? 0x80 : 0;
  return enc;
};
EDDSA.prototype.decodePoint = function decodePoint(bytes) {
  bytes = utils.parseBytes(bytes);
  var lastIx = bytes.length - 1;
  var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~0x80);
  var xIsOdd = (bytes[lastIx] & 0x80) !== 0;
  var y = utils.intFromLE(normed);
  return this.curve.pointFromY(y, xIsOdd);
};
EDDSA.prototype.encodeInt = function encodeInt(num) {
  return num.toArray('le', this.encodingLength);
};
EDDSA.prototype.decodeInt = function decodeInt(bytes) {
  return utils.intFromLE(bytes);
};
EDDSA.prototype.isPoint = function isPoint(val) {
  return val instanceof this.pointClass;
};

},{"../curves":167,"../utils":175,"./key":172,"./signature":173,"hash.js":312}],172:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var assert = utils.assert;
var parseBytes = utils.parseBytes;
var cachedProperty = utils.cachedProperty;

/**
* @param {EDDSA} eddsa - instance
* @param {Object} params - public/private key parameters
*
* @param {Array<Byte>} [params.secret] - secret seed bytes
* @param {Point} [params.pub] - public key point (aka `A` in eddsa terms)
* @param {Array<Byte>} [params.pub] - public key point encoded as bytes
*
*/
function KeyPair(eddsa, params) {
  this.eddsa = eddsa;
  this._secret = parseBytes(params.secret);
  if (eddsa.isPoint(params.pub)) this._pub = params.pub;else this._pubBytes = parseBytes(params.pub);
}
KeyPair.fromPublic = function fromPublic(eddsa, pub) {
  if (pub instanceof KeyPair) return pub;
  return new KeyPair(eddsa, {
    pub: pub
  });
};
KeyPair.fromSecret = function fromSecret(eddsa, secret) {
  if (secret instanceof KeyPair) return secret;
  return new KeyPair(eddsa, {
    secret: secret
  });
};
KeyPair.prototype.secret = function secret() {
  return this._secret;
};
cachedProperty(KeyPair, 'pubBytes', function pubBytes() {
  return this.eddsa.encodePoint(this.pub());
});
cachedProperty(KeyPair, 'pub', function pub() {
  if (this._pubBytes) return this.eddsa.decodePoint(this._pubBytes);
  return this.eddsa.g.mul(this.priv());
});
cachedProperty(KeyPair, 'privBytes', function privBytes() {
  var eddsa = this.eddsa;
  var hash = this.hash();
  var lastIx = eddsa.encodingLength - 1;
  var a = hash.slice(0, eddsa.encodingLength);
  a[0] &= 248;
  a[lastIx] &= 127;
  a[lastIx] |= 64;
  return a;
});
cachedProperty(KeyPair, 'priv', function priv() {
  return this.eddsa.decodeInt(this.privBytes());
});
cachedProperty(KeyPair, 'hash', function hash() {
  return this.eddsa.hash().update(this.secret()).digest();
});
cachedProperty(KeyPair, 'messagePrefix', function messagePrefix() {
  return this.hash().slice(this.eddsa.encodingLength);
});
KeyPair.prototype.sign = function sign(message) {
  assert(this._secret, 'KeyPair can only verify');
  return this.eddsa.sign(message, this);
};
KeyPair.prototype.verify = function verify(message, sig) {
  return this.eddsa.verify(message, sig, this);
};
KeyPair.prototype.getSecret = function getSecret(enc) {
  assert(this._secret, 'KeyPair is public only');
  return utils.encode(this.secret(), enc);
};
KeyPair.prototype.getPublic = function getPublic(enc) {
  return utils.encode(this.pubBytes(), enc);
};
module.exports = KeyPair;

},{"../utils":175}],173:[function(require,module,exports){
'use strict';

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var BN = require('bn.js');
var utils = require('../utils');
var assert = utils.assert;
var cachedProperty = utils.cachedProperty;
var parseBytes = utils.parseBytes;

/**
* @param {EDDSA} eddsa - eddsa instance
* @param {Array<Bytes>|Object} sig -
* @param {Array<Bytes>|Point} [sig.R] - R point as Point or bytes
* @param {Array<Bytes>|bn} [sig.S] - S scalar as bn or bytes
* @param {Array<Bytes>} [sig.Rencoded] - R point encoded
* @param {Array<Bytes>} [sig.Sencoded] - S scalar encoded
*/
function Signature(eddsa, sig) {
  this.eddsa = eddsa;
  if (_typeof(sig) !== 'object') sig = parseBytes(sig);
  if (Array.isArray(sig)) {
    sig = {
      R: sig.slice(0, eddsa.encodingLength),
      S: sig.slice(eddsa.encodingLength)
    };
  }
  assert(sig.R && sig.S, 'Signature without R or S');
  if (eddsa.isPoint(sig.R)) this._R = sig.R;
  if (sig.S instanceof BN) this._S = sig.S;
  this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
  this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
}
cachedProperty(Signature, 'S', function S() {
  return this.eddsa.decodeInt(this.Sencoded());
});
cachedProperty(Signature, 'R', function R() {
  return this.eddsa.decodePoint(this.Rencoded());
});
cachedProperty(Signature, 'Rencoded', function Rencoded() {
  return this.eddsa.encodePoint(this.R());
});
cachedProperty(Signature, 'Sencoded', function Sencoded() {
  return this.eddsa.encodeInt(this.S());
});
Signature.prototype.toBytes = function toBytes() {
  return this.Rencoded().concat(this.Sencoded());
};
Signature.prototype.toHex = function toHex() {
  return utils.encode(this.toBytes(), 'hex').toUpperCase();
};
module.exports = Signature;

},{"../utils":175,"bn.js":103}],174:[function(require,module,exports){
"use strict";

module.exports = {
  doubles: {
    step: 4,
    points: [['e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a', 'f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821'], ['8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508', '11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf'], ['175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739', 'd3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695'], ['363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640', '4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9'], ['8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c', '4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36'], ['723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda', '96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f'], ['eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa', '5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999'], ['100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0', 'cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09'], ['e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d', '9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d'], ['feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d', 'e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088'], ['da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1', '9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d'], ['53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0', '5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8'], ['8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047', '10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a'], ['385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862', '283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453'], ['6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7', '7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160'], ['3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd', '56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0'], ['85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83', '7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6'], ['948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a', '53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589'], ['6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8', 'bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17'], ['e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d', '4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda'], ['e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725', '7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd'], ['213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754', '4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2'], ['4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c', '17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6'], ['fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6', '6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f'], ['76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39', 'c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01'], ['c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891', '893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3'], ['d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b', 'febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f'], ['b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03', '2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7'], ['e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d', 'eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78'], ['a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070', '7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1'], ['90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4', 'e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150'], ['8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da', '662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82'], ['e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11', '1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc'], ['8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e', 'efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b'], ['e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41', '2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51'], ['b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef', '67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45'], ['d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8', 'db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120'], ['324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d', '648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84'], ['4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96', '35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d'], ['9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd', 'ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d'], ['6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5', '9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8'], ['a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266', '40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8'], ['7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71', '34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac'], ['928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac', 'c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f'], ['85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751', '1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962'], ['ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e', '493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907'], ['827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241', 'c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec'], ['eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3', 'be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d'], ['e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f', '4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414'], ['1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19', 'aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd'], ['146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be', 'b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0'], ['fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9', '6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811'], ['da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2', '8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1'], ['a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13', '7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c'], ['174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c', 'ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73'], ['959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba', '2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd'], ['d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151', 'e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405'], ['64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073', 'd99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589'], ['8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458', '38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e'], ['13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b', '69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27'], ['bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366', 'd3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1'], ['8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa', '40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482'], ['8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0', '620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945'], ['dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787', '7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573'], ['f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e', 'ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82']]
  },
  naf: {
    wnd: 7,
    points: [['f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9', '388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672'], ['2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4', 'd8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6'], ['5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc', '6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da'], ['acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe', 'cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37'], ['774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb', 'd984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b'], ['f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8', 'ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81'], ['d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e', '581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58'], ['defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34', '4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77'], ['2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c', '85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a'], ['352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5', '321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c'], ['2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f', '2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67'], ['9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714', '73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402'], ['daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729', 'a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55'], ['c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db', '2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482'], ['6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4', 'e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82'], ['1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5', 'b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396'], ['605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479', '2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49'], ['62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d', '80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf'], ['80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f', '1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a'], ['7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb', 'd0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7'], ['d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9', 'eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933'], ['49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963', '758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a'], ['77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74', '958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6'], ['f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530', 'e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37'], ['463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b', '5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e'], ['f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247', 'cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6'], ['caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1', 'cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476'], ['2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120', '4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40'], ['7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435', '91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61'], ['754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18', '673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683'], ['e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8', '59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5'], ['186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb', '3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b'], ['df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f', '55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417'], ['5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143', 'efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868'], ['290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba', 'e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a'], ['af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45', 'f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6'], ['766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a', '744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996'], ['59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e', 'c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e'], ['f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8', 'e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d'], ['7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c', '30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2'], ['948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519', 'e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e'], ['7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab', '100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437'], ['3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca', 'ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311'], ['d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf', '8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4'], ['1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610', '68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575'], ['733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4', 'f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d'], ['15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c', 'd56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d'], ['a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940', 'edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629'], ['e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980', 'a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06'], ['311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3', '66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374'], ['34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf', '9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee'], ['f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63', '4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1'], ['d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448', 'fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b'], ['32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf', '5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661'], ['7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5', '8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6'], ['ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6', '8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e'], ['16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5', '5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d'], ['eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99', 'f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc'], ['78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51', 'f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4'], ['494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5', '42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c'], ['a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5', '204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b'], ['c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997', '4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913'], ['841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881', '73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154'], ['5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5', '39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865'], ['36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66', 'd2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc'], ['336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726', 'ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224'], ['8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede', '6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e'], ['1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94', '60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6'], ['85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31', '3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511'], ['29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51', 'b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b'], ['a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252', 'ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2'], ['4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5', 'cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c'], ['d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b', '6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3'], ['ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4', '322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d'], ['af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f', '6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700'], ['e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889', '2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4'], ['591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246', 'b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196'], ['11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984', '998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4'], ['3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a', 'b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257'], ['cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030', 'bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13'], ['c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197', '6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096'], ['c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593', 'c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38'], ['a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef', '21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f'], ['347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38', '60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448'], ['da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a', '49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a'], ['c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111', '5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4'], ['4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502', '7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437'], ['3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea', 'be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7'], ['cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26', '8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d'], ['b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986', '39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a'], ['d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e', '62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54'], ['48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4', '25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77'], ['dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda', 'ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517'], ['6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859', 'cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10'], ['e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f', 'f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125'], ['eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c', '6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e'], ['13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942', 'fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1'], ['ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a', '1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2'], ['b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80', '5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423'], ['ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d', '438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8'], ['8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1', 'cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758'], ['52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63', 'c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375'], ['e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352', '6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d'], ['7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193', 'ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec'], ['5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00', '9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0'], ['32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58', 'ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c'], ['e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7', 'd3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4'], ['8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8', 'c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f'], ['4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e', '67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649'], ['3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d', 'cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826'], ['674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b', '299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5'], ['d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f', 'f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87'], ['30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6', '462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b'], ['be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297', '62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc'], ['93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a', '7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c'], ['b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c', 'ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f'], ['d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52', '4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a'], ['d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb', 'bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46'], ['463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065', 'bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f'], ['7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917', '603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03'], ['74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9', 'cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08'], ['30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3', '553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8'], ['9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57', '712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373'], ['176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66', 'ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3'], ['75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8', '9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8'], ['809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721', '9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1'], ['1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180', '4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9']]
  }
};

},{}],175:[function(require,module,exports){
'use strict';

var utils = exports;
var BN = require('bn.js');
var minAssert = require('minimalistic-assert');
var minUtils = require('minimalistic-crypto-utils');
utils.assert = minAssert;
utils.toArray = minUtils.toArray;
utils.zero2 = minUtils.zero2;
utils.toHex = minUtils.toHex;
utils.encode = minUtils.encode;

// Represent num in a w-NAF form
function getNAF(num, w, bits) {
  var naf = new Array(Math.max(num.bitLength(), bits) + 1);
  var i;
  for (i = 0; i < naf.length; i += 1) {
    naf[i] = 0;
  }
  var ws = 1 << w + 1;
  var k = num.clone();
  for (i = 0; i < naf.length; i++) {
    var z;
    var mod = k.andln(ws - 1);
    if (k.isOdd()) {
      if (mod > (ws >> 1) - 1) z = (ws >> 1) - mod;else z = mod;
      k.isubn(z);
    } else {
      z = 0;
    }
    naf[i] = z;
    k.iushrn(1);
  }
  return naf;
}
utils.getNAF = getNAF;

// Represent k1, k2 in a Joint Sparse Form
function getJSF(k1, k2) {
  var jsf = [[], []];
  k1 = k1.clone();
  k2 = k2.clone();
  var d1 = 0;
  var d2 = 0;
  var m8;
  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
    // First phase
    var m14 = k1.andln(3) + d1 & 3;
    var m24 = k2.andln(3) + d2 & 3;
    if (m14 === 3) m14 = -1;
    if (m24 === 3) m24 = -1;
    var u1;
    if ((m14 & 1) === 0) {
      u1 = 0;
    } else {
      m8 = k1.andln(7) + d1 & 7;
      if ((m8 === 3 || m8 === 5) && m24 === 2) u1 = -m14;else u1 = m14;
    }
    jsf[0].push(u1);
    var u2;
    if ((m24 & 1) === 0) {
      u2 = 0;
    } else {
      m8 = k2.andln(7) + d2 & 7;
      if ((m8 === 3 || m8 === 5) && m14 === 2) u2 = -m24;else u2 = m24;
    }
    jsf[1].push(u2);

    // Second phase
    if (2 * d1 === u1 + 1) d1 = 1 - d1;
    if (2 * d2 === u2 + 1) d2 = 1 - d2;
    k1.iushrn(1);
    k2.iushrn(1);
  }
  return jsf;
}
utils.getJSF = getJSF;
function cachedProperty(obj, name, computer) {
  var key = '_' + name;
  obj.prototype[name] = function cachedProperty() {
    return this[key] !== undefined ? this[key] : this[key] = computer.call(this);
  };
}
utils.cachedProperty = cachedProperty;
function parseBytes(bytes) {
  return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') : bytes;
}
utils.parseBytes = parseBytes;
function intFromLE(bytes) {
  return new BN(bytes, 'hex', 'le');
}
utils.intFromLE = intFromLE;

},{"bn.js":103,"minimalistic-assert":342,"minimalistic-crypto-utils":343}],176:[function(require,module,exports){
arguments[4][135][0].apply(exports,arguments)
},{"dup":135}],177:[function(require,module,exports){
module.exports={
  "name": "elliptic",
  "version": "6.5.5",
  "description": "EC cryptography",
  "main": "lib/elliptic.js",
  "files": [
    "lib"
  ],
  "scripts": {
    "lint": "eslint lib test",
    "lint:fix": "npm run lint -- --fix",
    "unit": "istanbul test _mocha --reporter=spec test/index.js",
    "test": "npm run lint && npm run unit",
    "version": "grunt dist && git add dist/"
  },
  "repository": {
    "type": "git",
    "url": "git@github.com:indutny/elliptic"
  },
  "keywords": [
    "EC",
    "Elliptic",
    "curve",
    "Cryptography"
  ],
  "author": "Fedor Indutny <fedor@indutny.com>",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/indutny/elliptic/issues"
  },
  "homepage": "https://github.com/indutny/elliptic",
  "devDependencies": {
    "brfs": "^2.0.2",
    "coveralls": "^3.1.0",
    "eslint": "^7.6.0",
    "grunt": "^1.2.1",
    "grunt-browserify": "^5.3.0",
    "grunt-cli": "^1.3.2",
    "grunt-contrib-connect": "^3.0.0",
    "grunt-contrib-copy": "^1.0.0",
    "grunt-contrib-uglify": "^5.0.0",
    "grunt-mocha-istanbul": "^5.0.2",
    "grunt-saucelabs": "^9.0.1",
    "istanbul": "^0.4.5",
    "mocha": "^8.0.1"
  },
  "dependencies": {
    "bn.js": "^4.11.9",
    "brorand": "^1.1.0",
    "hash.js": "^1.0.0",
    "hmac-drbg": "^1.0.1",
    "inherits": "^2.0.4",
    "minimalistic-assert": "^1.0.1",
    "minimalistic-crypto-utils": "^1.0.1"
  }
}

},{}],178:[function(require,module,exports){
'use strict';

var GetIntrinsic = require('get-intrinsic');

/** @type {import('.')} */
var $defineProperty = GetIntrinsic('%Object.defineProperty%', true) || false;
if ($defineProperty) {
  try {
    $defineProperty({}, 'a', {
      value: 1
    });
  } catch (e) {
    // IE 8 has a broken defineProperty
    $defineProperty = false;
  }
}
module.exports = $defineProperty;

},{"get-intrinsic":305}],179:[function(require,module,exports){
'use strict';

/** @type {import('./eval')} */
module.exports = EvalError;

},{}],180:[function(require,module,exports){
'use strict';

/** @type {import('.')} */
module.exports = Error;

},{}],181:[function(require,module,exports){
'use strict';

/** @type {import('./range')} */
module.exports = RangeError;

},{}],182:[function(require,module,exports){
'use strict';

/** @type {import('./ref')} */
module.exports = ReferenceError;

},{}],183:[function(require,module,exports){
'use strict';

/** @type {import('./syntax')} */
module.exports = SyntaxError;

},{}],184:[function(require,module,exports){
'use strict';

/** @type {import('./type')} */
module.exports = TypeError;

},{}],185:[function(require,module,exports){
'use strict';

/** @type {import('./uri')} */
module.exports = URIError;

},{}],186:[function(require,module,exports){
"use strict";

/* Do NOT modify this file; see /src.ts/_admin/update-version.ts */
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.version = void 0;
/**
 *  The current version of Ethers.
 */
exports.version = "6.13.1";

},{}],187:[function(require,module,exports){
"use strict";

/**
 *  When sending values to or receiving values from a [[Contract]], the
 *  data is generally encoded using the [ABI standard](link-solc-abi).
 *
 *  The AbiCoder provides a utility to encode values to ABI data and
 *  decode values from ABI data.
 *
 *  Most of the time, developers should favour the [[Contract]] class,
 *  which further abstracts a lot of the finer details of ABI data.
 *
 *  @_section api/abi/abi-coder:ABI Encoding
 */
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AbiCoder = void 0;
// See: https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI
var index_js_1 = require("../utils/index.js");
var abstract_coder_js_1 = require("./coders/abstract-coder.js");
var address_js_1 = require("./coders/address.js");
var array_js_1 = require("./coders/array.js");
var boolean_js_1 = require("./coders/boolean.js");
var bytes_js_1 = require("./coders/bytes.js");
var fixed_bytes_js_1 = require("./coders/fixed-bytes.js");
var null_js_1 = require("./coders/null.js");
var number_js_1 = require("./coders/number.js");
var string_js_1 = require("./coders/string.js");
var tuple_js_1 = require("./coders/tuple.js");
var fragments_js_1 = require("./fragments.js");
var index_js_2 = require("../address/index.js");
var index_js_3 = require("../utils/index.js");
// https://docs.soliditylang.org/en/v0.8.17/control-structures.html
var PanicReasons = new Map();
PanicReasons.set(0x00, "GENERIC_PANIC");
PanicReasons.set(0x01, "ASSERT_FALSE");
PanicReasons.set(0x11, "OVERFLOW");
PanicReasons.set(0x12, "DIVIDE_BY_ZERO");
PanicReasons.set(0x21, "ENUM_RANGE_ERROR");
PanicReasons.set(0x22, "BAD_STORAGE_DATA");
PanicReasons.set(0x31, "STACK_UNDERFLOW");
PanicReasons.set(0x32, "ARRAY_RANGE_ERROR");
PanicReasons.set(0x41, "OUT_OF_MEMORY");
PanicReasons.set(0x51, "UNINITIALIZED_FUNCTION_CALL");
var paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);
var paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);
var defaultCoder = null;
var defaultMaxInflation = 1024;
function _getBuiltinCallException(action, tx, data, abiCoder) {
  var message = "missing revert data";
  var reason = null;
  var invocation = null;
  var revert = null;
  if (data) {
    message = "execution reverted";
    var bytes = (0, index_js_3.getBytes)(data);
    data = (0, index_js_3.hexlify)(data);
    if (bytes.length === 0) {
      message += " (no data present; likely require(false) occurred";
      reason = "require(false)";
    } else if (bytes.length % 32 !== 4) {
      message += " (could not decode reason; invalid data length)";
    } else if ((0, index_js_3.hexlify)(bytes.slice(0, 4)) === "0x08c379a0") {
      // Error(string)
      try {
        reason = abiCoder.decode(["string"], bytes.slice(4))[0];
        revert = {
          signature: "Error(string)",
          name: "Error",
          args: [reason]
        };
        message += ": ".concat(JSON.stringify(reason));
      } catch (error) {
        message += " (could not decode reason; invalid string data)";
      }
    } else if ((0, index_js_3.hexlify)(bytes.slice(0, 4)) === "0x4e487b71") {
      // Panic(uint256)
      try {
        var code = Number(abiCoder.decode(["uint256"], bytes.slice(4))[0]);
        revert = {
          signature: "Panic(uint256)",
          name: "Panic",
          args: [code]
        };
        reason = "Panic due to ".concat(PanicReasons.get(code) || "UNKNOWN", "(").concat(code, ")");
        message += ": ".concat(reason);
      } catch (error) {
        message += " (could not decode panic code)";
      }
    } else {
      message += " (unknown custom error)";
    }
  }
  var transaction = {
    to: tx.to ? (0, index_js_2.getAddress)(tx.to) : null,
    data: tx.data || "0x"
  };
  if (tx.from) {
    transaction.from = (0, index_js_2.getAddress)(tx.from);
  }
  return (0, index_js_3.makeError)(message, "CALL_EXCEPTION", {
    action: action,
    data: data,
    reason: reason,
    transaction: transaction,
    invocation: invocation,
    revert: revert
  });
}
/**
 *  The **AbiCoder** is a low-level class responsible for encoding JavaScript
 *  values into binary data and decoding binary data into JavaScript values.
 */
var _AbiCoder_brand = /*#__PURE__*/new WeakSet();
var AbiCoder = /*#__PURE__*/function () {
  function AbiCoder() {
    _classCallCheck(this, AbiCoder);
    _classPrivateMethodInitSpec(this, _AbiCoder_brand);
  }
  return _createClass(AbiCoder, [{
    key: "getDefaultValue",
    value:
    /**
     *  Get the default values for the given %%types%%.
     *
     *  For example, a ``uint`` is by default ``0`` and ``bool``
     *  is by default ``false``.
     */
    function getDefaultValue(types) {
      var _this = this;
      var coders = types.map(function (type) {
        return _assertClassBrand(_AbiCoder_brand, _this, _getCoder).call(_this, fragments_js_1.ParamType.from(type));
      });
      var coder = new tuple_js_1.TupleCoder(coders, "_");
      return coder.defaultValue();
    }
    /**
     *  Encode the %%values%% as the %%types%% into ABI data.
     *
     *  @returns DataHexstring
     */
  }, {
    key: "encode",
    value: function encode(types, values) {
      var _this2 = this;
      (0, index_js_1.assertArgumentCount)(values.length, types.length, "types/values length mismatch");
      var coders = types.map(function (type) {
        return _assertClassBrand(_AbiCoder_brand, _this2, _getCoder).call(_this2, fragments_js_1.ParamType.from(type));
      });
      var coder = new tuple_js_1.TupleCoder(coders, "_");
      var writer = new abstract_coder_js_1.Writer();
      coder.encode(writer, values);
      return writer.data;
    }
    /**
     *  Decode the ABI %%data%% as the %%types%% into values.
     *
     *  If %%loose%% decoding is enabled, then strict padding is
     *  not enforced. Some older versions of Solidity incorrectly
     *  padded event data emitted from ``external`` functions.
     */
  }, {
    key: "decode",
    value: function decode(types, data, loose) {
      var _this3 = this;
      var coders = types.map(function (type) {
        return _assertClassBrand(_AbiCoder_brand, _this3, _getCoder).call(_this3, fragments_js_1.ParamType.from(type));
      });
      var coder = new tuple_js_1.TupleCoder(coders, "_");
      return coder.decode(new abstract_coder_js_1.Reader(data, loose, defaultMaxInflation));
    }
  }], [{
    key: "_setDefaultMaxInflation",
    value: function _setDefaultMaxInflation(value) {
      (0, index_js_1.assertArgument)(typeof value === "number" && Number.isInteger(value), "invalid defaultMaxInflation factor", "value", value);
      defaultMaxInflation = value;
    }
    /**
     *  Returns the shared singleton instance of a default [[AbiCoder]].
     *
     *  On the first call, the instance is created internally.
     */
  }, {
    key: "defaultAbiCoder",
    value: function defaultAbiCoder() {
      if (defaultCoder == null) {
        defaultCoder = new AbiCoder();
      }
      return defaultCoder;
    }
    /**
     *  Returns an ethers-compatible [[CallExceptionError]] Error for the given
     *  result %%data%% for the [[CallExceptionAction]] %%action%% against
     *  the Transaction %%tx%%.
     */
  }, {
    key: "getBuiltinCallException",
    value: function getBuiltinCallException(action, tx, data) {
      return _getBuiltinCallException(action, tx, data, AbiCoder.defaultAbiCoder());
    }
  }]);
}();
function _getCoder(param) {
  var _this4 = this;
  if (param.isArray()) {
    return new array_js_1.ArrayCoder(_assertClassBrand(_AbiCoder_brand, this, _getCoder).call(this, param.arrayChildren), param.arrayLength, param.name);
  }
  if (param.isTuple()) {
    return new tuple_js_1.TupleCoder(param.components.map(function (c) {
      return _assertClassBrand(_AbiCoder_brand, _this4, _getCoder).call(_this4, c);
    }), param.name);
  }
  switch (param.baseType) {
    case "address":
      return new address_js_1.AddressCoder(param.name);
    case "bool":
      return new boolean_js_1.BooleanCoder(param.name);
    case "string":
      return new string_js_1.StringCoder(param.name);
    case "bytes":
      return new bytes_js_1.BytesCoder(param.name);
    case "":
      return new null_js_1.NullCoder(param.name);
  }
  // u?int[0-9]*
  var match = param.type.match(paramTypeNumber);
  if (match) {
    var size = parseInt(match[2] || "256");
    (0, index_js_1.assertArgument)(size !== 0 && size <= 256 && size % 8 === 0, "invalid " + match[1] + " bit length", "param", param);
    return new number_js_1.NumberCoder(size / 8, match[1] === "int", param.name);
  }
  // bytes[0-9]+
  match = param.type.match(paramTypeBytes);
  if (match) {
    var _size = parseInt(match[1]);
    (0, index_js_1.assertArgument)(_size !== 0 && _size <= 32, "invalid bytes length", "param", param);
    return new fixed_bytes_js_1.FixedBytesCoder(_size, param.name);
  }
  (0, index_js_1.assertArgument)(false, "invalid type", "type", param.type);
}
exports.AbiCoder = AbiCoder;

},{"../address/index.js":207,"../utils/index.js":276,"./coders/abstract-coder.js":189,"./coders/address.js":190,"./coders/array.js":192,"./coders/boolean.js":193,"./coders/bytes.js":194,"./coders/fixed-bytes.js":195,"./coders/null.js":196,"./coders/number.js":197,"./coders/string.js":198,"./coders/tuple.js":199,"./fragments.js":200}],188:[function(require,module,exports){
"use strict";

/**
 *  About bytes32 strings...
 *
 *  @_docloc: api/utils:Bytes32 Strings
 */
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.decodeBytes32String = exports.encodeBytes32String = void 0;
var index_js_1 = require("../utils/index.js");
/**
 *  Encodes %%text%% as a Bytes32 string.
 */
function encodeBytes32String(text) {
  // Get the bytes
  var bytes = (0, index_js_1.toUtf8Bytes)(text);
  // Check we have room for null-termination
  if (bytes.length > 31) {
    throw new Error("bytes32 string must be less than 32 bytes");
  }
  // Zero-pad (implicitly null-terminates)
  return (0, index_js_1.zeroPadBytes)(bytes, 32);
}
exports.encodeBytes32String = encodeBytes32String;
/**
 *  Encodes the Bytes32-encoded %%bytes%% into a string.
 */
function decodeBytes32String(_bytes) {
  var data = (0, index_js_1.getBytes)(_bytes, "bytes");
  // Must be 32 bytes with a null-termination
  if (data.length !== 32) {
    throw new Error("invalid bytes32 - not 32 bytes long");
  }
  if (data[31] !== 0) {
    throw new Error("invalid bytes32 string - no null terminator");
  }
  // Find the null termination
  var length = 31;
  while (data[length - 1] === 0) {
    length--;
  }
  // Determine the string value
  return (0, index_js_1.toUtf8String)(data.slice(0, length));
}
exports.decodeBytes32String = decodeBytes32String;

},{"../utils/index.js":276}],189:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _wrapNativeSuper(t) { var r = "function" == typeof Map ? new Map() : void 0; return _wrapNativeSuper = function _wrapNativeSuper(t) { if (null === t || !_isNativeFunction(t)) return t; if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function"); if (void 0 !== r) { if (r.has(t)) return r.get(t); r.set(t, Wrapper); } function Wrapper() { return _construct(t, arguments, _getPrototypeOf(this).constructor); } return Wrapper.prototype = Object.create(t.prototype, { constructor: { value: Wrapper, enumerable: !1, writable: !0, configurable: !0 } }), _setPrototypeOf(Wrapper, t); }, _wrapNativeSuper(t); }
function _construct(t, e, r) { if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments); var o = [null]; o.push.apply(o, e); var p = new (t.bind.apply(t, o))(); return r && _setPrototypeOf(p, r.prototype), p; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _isNativeFunction(t) { try { return -1 !== Function.toString.call(t).indexOf("[native code]"); } catch (n) { return "function" == typeof t; } }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Reader = exports.Writer = exports.Coder = exports.checkResultErrors = exports.Result = exports.WordSize = void 0;
var index_js_1 = require("../../utils/index.js");
/**
 * @_ignore:
 */
exports.WordSize = 32;
var Padding = new Uint8Array(exports.WordSize);
// Properties used to immediate pass through to the underlying object
// - `then` is used to detect if an object is a Promise for await
var passProperties = ["then"];
var _guard = {};
var resultNames = new WeakMap();
function getNames(result) {
  return resultNames.get(result);
}
function setNames(result, names) {
  resultNames.set(result, names);
}
function throwError(name, error) {
  var wrapped = new Error("deferred error during ABI decoding triggered accessing ".concat(name));
  wrapped.error = error;
  throw wrapped;
}
function _toObject(names, items, deep) {
  if (names.indexOf(null) >= 0) {
    return items.map(function (item, index) {
      if (item instanceof Result) {
        return _toObject(getNames(item), item, deep);
      }
      return item;
    });
  }
  return names.reduce(function (accum, name, index) {
    var item = items.getValue(name);
    if (!(name in accum)) {
      if (deep && item instanceof Result) {
        item = _toObject(getNames(item), item, deep);
      }
      accum[name] = item;
    }
    return accum;
  }, {});
}
/**
 *  A [[Result]] is a sub-class of Array, which allows accessing any
 *  of its values either positionally by its index or, if keys are
 *  provided by its name.
 *
 *  @_docloc: api/abi
 */
var _names2 = /*#__PURE__*/new WeakMap();
var Result = /*#__PURE__*/function (_Array) {
  /**
   *  @private
   */
  function Result() {
    var _this;
    _classCallCheck(this, Result);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    // To properly sub-class Array so the other built-in
    // functions work, the constructor has to behave fairly
    // well. So, in the event we are created via fromItems()
    // we build the read-only Result object we want, but on
    // any other input, we use the default constructor
    // constructor(guard: any, items: Array<any>, keys?: Array<null | string>);
    var guard = args[0];
    var items = args[1];
    var names = (args[2] || []).slice();
    var wrap = true;
    if (guard !== _guard) {
      items = args;
      names = [];
      wrap = false;
    }
    // Can't just pass in ...items since an array of length 1
    // is a special case in the super.
    _this = _callSuper(this, Result, [items.length]);
    // No longer used; but cannot be removed as it will remove the
    // #private field from the .d.ts which may break backwards
    // compatibility
    _classPrivateFieldInitSpec(_this, _names2, void 0);
    items.forEach(function (item, index) {
      _this[index] = item;
    });
    // Find all unique keys
    var nameCounts = names.reduce(function (accum, name) {
      if (typeof name === "string") {
        accum.set(name, (accum.get(name) || 0) + 1);
      }
      return accum;
    }, new Map());
    // Remove any key thats not unique
    setNames(_this, Object.freeze(items.map(function (item, index) {
      var name = names[index];
      if (name != null && nameCounts.get(name) === 1) {
        return name;
      }
      return null;
    })));
    // Dummy operations to prevent TypeScript from complaining
    _classPrivateFieldSet(_names2, _this, []);
    if (_classPrivateFieldGet(_names2, _this) == null) {
      void _classPrivateFieldGet(_names2, _this);
    }
    if (!wrap) {
      return _possibleConstructorReturn(_this);
    }
    // A wrapped Result is immutable
    Object.freeze(_this);
    // Proxy indices and names so we can trap deferred errors
    var proxy = new Proxy(_this, {
      get: function get(target, prop, receiver) {
        if (typeof prop === "string") {
          // Index accessor
          if (prop.match(/^[0-9]+$/)) {
            var index = (0, index_js_1.getNumber)(prop, "%index");
            if (index < 0 || index >= _this.length) {
              throw new RangeError("out of result range");
            }
            var item = target[index];
            if (item instanceof Error) {
              throwError("index ".concat(index), item);
            }
            return item;
          }
          // Pass important checks (like `then` for Promise) through
          if (passProperties.indexOf(prop) >= 0) {
            return Reflect.get(target, prop, receiver);
          }
          var value = target[prop];
          if (value instanceof Function) {
            // Make sure functions work with private variables
            // See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy#no_private_property_forwarding
            return function () {
              for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                args[_key2] = arguments[_key2];
              }
              return value.apply(this === receiver ? target : this, args);
            };
          } else if (!(prop in target)) {
            // Possible name accessor
            return target.getValue.apply(_this === receiver ? target : _this, [prop]);
          }
        }
        return Reflect.get(target, prop, receiver);
      }
    });
    setNames(proxy, getNames(_this));
    return _possibleConstructorReturn(_this, proxy);
  }
  /**
   *  Returns the Result as a normal Array. If %%deep%%, any children
   *  which are Result objects are also converted to a normal Array.
   *
   *  This will throw if there are any outstanding deferred
   *  errors.
   */
  _inherits(Result, _Array);
  return _createClass(Result, [{
    key: "toArray",
    value: function toArray(deep) {
      var result = [];
      this.forEach(function (item, index) {
        if (item instanceof Error) {
          throwError("index ".concat(index), item);
        }
        if (deep && item instanceof Result) {
          item = item.toArray(deep);
        }
        result.push(item);
      });
      return result;
    }
    /**
     *  Returns the Result as an Object with each name-value pair. If
     *  %%deep%%, any children which are Result objects are also
     *  converted to an Object.
     *
     *  This will throw if any value is unnamed, or if there are
     *  any outstanding deferred errors.
     */
  }, {
    key: "toObject",
    value: function toObject(deep) {
      var _this2 = this;
      var names = getNames(this);
      return names.reduce(function (accum, name, index) {
        (0, index_js_1.assert)(name != null, "value at index ".concat(index, " unnamed"), "UNSUPPORTED_OPERATION", {
          operation: "toObject()"
        });
        return _toObject(names, _this2, deep);
      }, {});
    }
    /**
     *  @_ignore
     */
  }, {
    key: "slice",
    value: function slice(start, end) {
      if (start == null) {
        start = 0;
      }
      if (start < 0) {
        start += this.length;
        if (start < 0) {
          start = 0;
        }
      }
      if (end == null) {
        end = this.length;
      }
      if (end < 0) {
        end += this.length;
        if (end < 0) {
          end = 0;
        }
      }
      if (end > this.length) {
        end = this.length;
      }
      var _names = getNames(this);
      var result = [],
        names = [];
      for (var i = start; i < end; i++) {
        result.push(this[i]);
        names.push(_names[i]);
      }
      return new Result(_guard, result, names);
    }
    /**
     *  @_ignore
     */
  }, {
    key: "filter",
    value: function filter(callback, thisArg) {
      var _names = getNames(this);
      var result = [],
        names = [];
      for (var i = 0; i < this.length; i++) {
        var item = this[i];
        if (item instanceof Error) {
          throwError("index ".concat(i), item);
        }
        if (callback.call(thisArg, item, i, this)) {
          result.push(item);
          names.push(_names[i]);
        }
      }
      return new Result(_guard, result, names);
    }
    /**
     *  @_ignore
     */
  }, {
    key: "map",
    value: function map(callback, thisArg) {
      var result = [];
      for (var i = 0; i < this.length; i++) {
        var item = this[i];
        if (item instanceof Error) {
          throwError("index ".concat(i), item);
        }
        result.push(callback.call(thisArg, item, i, this));
      }
      return result;
    }
    /**
     *  Returns the value for %%name%%.
     *
     *  Since it is possible to have a key whose name conflicts with
     *  a method on a [[Result]] or its superclass Array, or any
     *  JavaScript keyword, this ensures all named values are still
     *  accessible by name.
     */
  }, {
    key: "getValue",
    value: function getValue(name) {
      var index = getNames(this).indexOf(name);
      if (index === -1) {
        return undefined;
      }
      var value = this[index];
      if (value instanceof Error) {
        throwError("property ".concat(JSON.stringify(name)), value.error);
      }
      return value;
    }
    /**
     *  Creates a new [[Result]] for %%items%% with each entry
     *  also accessible by its corresponding name in %%keys%%.
     */
  }], [{
    key: "fromItems",
    value: function fromItems(items, keys) {
      return new Result(_guard, items, keys);
    }
  }]);
}( /*#__PURE__*/_wrapNativeSuper(Array));
exports.Result = Result;
/**
 *  Returns all errors found in a [[Result]].
 *
 *  Since certain errors encountered when creating a [[Result]] do
 *  not impact the ability to continue parsing data, they are
 *  deferred until they are actually accessed. Hence a faulty string
 *  in an Event that is never used does not impact the program flow.
 *
 *  However, sometimes it may be useful to access, identify or
 *  validate correctness of a [[Result]].
 *
 *  @_docloc api/abi
 */
function checkResultErrors(result) {
  // Find the first error (if any)
  var errors = [];
  var checkErrors = function checkErrors(path, object) {
    if (!Array.isArray(object)) {
      return;
    }
    for (var key in object) {
      var childPath = path.slice();
      childPath.push(key);
      try {
        checkErrors(childPath, object[key]);
      } catch (error) {
        errors.push({
          path: childPath,
          error: error
        });
      }
    }
  };
  checkErrors([], result);
  return errors;
}
exports.checkResultErrors = checkResultErrors;
function getValue(value) {
  var bytes = (0, index_js_1.toBeArray)(value);
  (0, index_js_1.assert)(bytes.length <= exports.WordSize, "value out-of-bounds", "BUFFER_OVERRUN", {
    buffer: bytes,
    length: exports.WordSize,
    offset: bytes.length
  });
  if (bytes.length !== exports.WordSize) {
    bytes = (0, index_js_1.getBytesCopy)((0, index_js_1.concat)([Padding.slice(bytes.length % exports.WordSize), bytes]));
  }
  return bytes;
}
/**
 *  @_ignore
 */
var Coder = /*#__PURE__*/function () {
  function Coder(name, type, localName, dynamic) {
    _classCallCheck(this, Coder);
    // The coder name:
    //   - address, uint256, tuple, array, etc.
    _defineProperty(this, "name", void 0);
    // The fully expanded type, including composite types:
    //   - address, uint256, tuple(address,bytes), uint256[3][4][],  etc.
    _defineProperty(this, "type", void 0);
    // The localName bound in the signature, in this example it is "baz":
    //   - tuple(address foo, uint bar) baz
    _defineProperty(this, "localName", void 0);
    // Whether this type is dynamic:
    //  - Dynamic: bytes, string, address[], tuple(boolean[]), etc.
    //  - Not Dynamic: address, uint256, boolean[3], tuple(address, uint8)
    _defineProperty(this, "dynamic", void 0);
    (0, index_js_1.defineProperties)(this, {
      name: name,
      type: type,
      localName: localName,
      dynamic: dynamic
    }, {
      name: "string",
      type: "string",
      localName: "string",
      dynamic: "boolean"
    });
  }
  return _createClass(Coder, [{
    key: "_throwError",
    value: function _throwError(message, value) {
      (0, index_js_1.assertArgument)(false, message, this.localName, value);
    }
  }]);
}();
exports.Coder = Coder;
/**
 *  @_ignore
 */
var _data = /*#__PURE__*/new WeakMap();
var _dataLength = /*#__PURE__*/new WeakMap();
var _Writer_brand = /*#__PURE__*/new WeakSet();
var Writer = /*#__PURE__*/function () {
  function Writer() {
    _classCallCheck(this, Writer);
    _classPrivateMethodInitSpec(this, _Writer_brand);
    // An array of WordSize lengthed objects to concatenation
    _classPrivateFieldInitSpec(this, _data, void 0);
    _classPrivateFieldInitSpec(this, _dataLength, void 0);
    _classPrivateFieldSet(_data, this, []);
    _classPrivateFieldSet(_dataLength, this, 0);
  }
  return _createClass(Writer, [{
    key: "data",
    get: function get() {
      return (0, index_js_1.concat)(_classPrivateFieldGet(_data, this));
    }
  }, {
    key: "length",
    get: function get() {
      return _classPrivateFieldGet(_dataLength, this);
    }
  }, {
    key: "appendWriter",
    value: function appendWriter(writer) {
      return _assertClassBrand(_Writer_brand, this, _writeData).call(this, (0, index_js_1.getBytesCopy)(writer.data));
    }
    // Arrayish item; pad on the right to *nearest* WordSize
  }, {
    key: "writeBytes",
    value: function writeBytes(value) {
      var bytes = (0, index_js_1.getBytesCopy)(value);
      var paddingOffset = bytes.length % exports.WordSize;
      if (paddingOffset) {
        bytes = (0, index_js_1.getBytesCopy)((0, index_js_1.concat)([bytes, Padding.slice(paddingOffset)]));
      }
      return _assertClassBrand(_Writer_brand, this, _writeData).call(this, bytes);
    }
    // Numeric item; pad on the left *to* WordSize
  }, {
    key: "writeValue",
    value: function writeValue(value) {
      return _assertClassBrand(_Writer_brand, this, _writeData).call(this, getValue(value));
    }
    // Inserts a numeric place-holder, returning a callback that can
    // be used to asjust the value later
  }, {
    key: "writeUpdatableValue",
    value: function writeUpdatableValue() {
      var _this3 = this;
      var offset = _classPrivateFieldGet(_data, this).length;
      _classPrivateFieldGet(_data, this).push(Padding);
      _classPrivateFieldSet(_dataLength, this, _classPrivateFieldGet(_dataLength, this) + exports.WordSize);
      return function (value) {
        _classPrivateFieldGet(_data, _this3)[offset] = getValue(value);
      };
    }
  }]);
}();
function _writeData(data) {
  _classPrivateFieldGet(_data, this).push(data);
  _classPrivateFieldSet(_dataLength, this, _classPrivateFieldGet(_dataLength, this) + data.length);
  return data.length;
}
exports.Writer = Writer;
/**
 *  @_ignore
 */
var _data2 = /*#__PURE__*/new WeakMap();
var _offset = /*#__PURE__*/new WeakMap();
var _bytesRead = /*#__PURE__*/new WeakMap();
var _parent = /*#__PURE__*/new WeakMap();
var _maxInflation = /*#__PURE__*/new WeakMap();
var _Reader_brand = /*#__PURE__*/new WeakSet();
var Reader = /*#__PURE__*/function () {
  function Reader(data, allowLoose, maxInflation) {
    _classCallCheck(this, Reader);
    _classPrivateMethodInitSpec(this, _Reader_brand);
    // Allows incomplete unpadded data to be read; otherwise an error
    // is raised if attempting to overrun the buffer. This is required
    // to deal with an old Solidity bug, in which event data for
    // external (not public thoguh) was tightly packed.
    _defineProperty(this, "allowLoose", void 0);
    _classPrivateFieldInitSpec(this, _data2, void 0);
    _classPrivateFieldInitSpec(this, _offset, void 0);
    _classPrivateFieldInitSpec(this, _bytesRead, void 0);
    _classPrivateFieldInitSpec(this, _parent, void 0);
    _classPrivateFieldInitSpec(this, _maxInflation, void 0);
    (0, index_js_1.defineProperties)(this, {
      allowLoose: !!allowLoose
    });
    _classPrivateFieldSet(_data2, this, (0, index_js_1.getBytesCopy)(data));
    _classPrivateFieldSet(_bytesRead, this, 0);
    _classPrivateFieldSet(_parent, this, null);
    _classPrivateFieldSet(_maxInflation, this, maxInflation != null ? maxInflation : 1024);
    _classPrivateFieldSet(_offset, this, 0);
  }
  return _createClass(Reader, [{
    key: "data",
    get: function get() {
      return (0, index_js_1.hexlify)(_classPrivateFieldGet(_data2, this));
    }
  }, {
    key: "dataLength",
    get: function get() {
      return _classPrivateFieldGet(_data2, this).length;
    }
  }, {
    key: "consumed",
    get: function get() {
      return _classPrivateFieldGet(_offset, this);
    }
  }, {
    key: "bytes",
    get: function get() {
      return new Uint8Array(_classPrivateFieldGet(_data2, this));
    }
  }, {
    key: "subReader",
    value:
    // Create a sub-reader with the same underlying data, but offset
    function subReader(offset) {
      var reader = new Reader(_classPrivateFieldGet(_data2, this).slice(_classPrivateFieldGet(_offset, this) + offset), this.allowLoose, _classPrivateFieldGet(_maxInflation, this));
      _classPrivateFieldSet(_parent, reader, this);
      return reader;
    }
    // Read bytes
  }, {
    key: "readBytes",
    value: function readBytes(length, loose) {
      var bytes = _assertClassBrand(_Reader_brand, this, _peekBytes).call(this, 0, length, !!loose);
      _assertClassBrand(_Reader_brand, this, _incrementBytesRead).call(this, length);
      _classPrivateFieldSet(_offset, this, _classPrivateFieldGet(_offset, this) + bytes.length);
      // @TODO: Make sure the length..end bytes are all 0?
      return bytes.slice(0, length);
    }
    // Read a numeric values
  }, {
    key: "readValue",
    value: function readValue() {
      return (0, index_js_1.toBigInt)(this.readBytes(exports.WordSize));
    }
  }, {
    key: "readIndex",
    value: function readIndex() {
      return (0, index_js_1.toNumber)(this.readBytes(exports.WordSize));
    }
  }]);
}();
function _incrementBytesRead(count) {
  if (_classPrivateFieldGet(_parent, this)) {
    var _classPrivateFieldGet2;
    return _assertClassBrand(_Reader_brand, _classPrivateFieldGet2 = _classPrivateFieldGet(_parent, this), _incrementBytesRead).call(_classPrivateFieldGet2, count);
  }
  _classPrivateFieldSet(_bytesRead, this, _classPrivateFieldGet(_bytesRead, this) + count);
  // Check for excessive inflation (see: #4537)
  (0, index_js_1.assert)(_classPrivateFieldGet(_maxInflation, this) < 1 || _classPrivateFieldGet(_bytesRead, this) <= _classPrivateFieldGet(_maxInflation, this) * this.dataLength, "compressed ABI data exceeds inflation ratio of ".concat(_classPrivateFieldGet(_maxInflation, this), " ( see: https://github.com/ethers-io/ethers.js/issues/4537 )"), "BUFFER_OVERRUN", {
    buffer: (0, index_js_1.getBytesCopy)(_classPrivateFieldGet(_data2, this)),
    offset: _classPrivateFieldGet(_offset, this),
    length: count,
    info: {
      bytesRead: _classPrivateFieldGet(_bytesRead, this),
      dataLength: this.dataLength
    }
  });
}
function _peekBytes(offset, length, loose) {
  var alignedLength = Math.ceil(length / exports.WordSize) * exports.WordSize;
  if (_classPrivateFieldGet(_offset, this) + alignedLength > _classPrivateFieldGet(_data2, this).length) {
    if (this.allowLoose && loose && _classPrivateFieldGet(_offset, this) + length <= _classPrivateFieldGet(_data2, this).length) {
      alignedLength = length;
    } else {
      (0, index_js_1.assert)(false, "data out-of-bounds", "BUFFER_OVERRUN", {
        buffer: (0, index_js_1.getBytesCopy)(_classPrivateFieldGet(_data2, this)),
        length: _classPrivateFieldGet(_data2, this).length,
        offset: _classPrivateFieldGet(_offset, this) + alignedLength
      });
    }
  }
  return _classPrivateFieldGet(_data2, this).slice(_classPrivateFieldGet(_offset, this), _classPrivateFieldGet(_offset, this) + alignedLength);
}
exports.Reader = Reader;

},{"../../utils/index.js":276}],190:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AddressCoder = void 0;
var index_js_1 = require("../../address/index.js");
var maths_js_1 = require("../../utils/maths.js");
var typed_js_1 = require("../typed.js");
var abstract_coder_js_1 = require("./abstract-coder.js");
/**
 *  @_ignore
 */
var AddressCoder = /*#__PURE__*/function (_abstract_coder_js_1$) {
  function AddressCoder(localName) {
    _classCallCheck(this, AddressCoder);
    return _callSuper(this, AddressCoder, ["address", "address", localName, false]);
  }
  _inherits(AddressCoder, _abstract_coder_js_1$);
  return _createClass(AddressCoder, [{
    key: "defaultValue",
    value: function defaultValue() {
      return "0x0000000000000000000000000000000000000000";
    }
  }, {
    key: "encode",
    value: function encode(writer, _value) {
      var value = typed_js_1.Typed.dereference(_value, "string");
      try {
        value = (0, index_js_1.getAddress)(value);
      } catch (error) {
        return this._throwError(error.message, _value);
      }
      return writer.writeValue(value);
    }
  }, {
    key: "decode",
    value: function decode(reader) {
      return (0, index_js_1.getAddress)((0, maths_js_1.toBeHex)(reader.readValue(), 20));
    }
  }]);
}(abstract_coder_js_1.Coder);
exports.AddressCoder = AddressCoder;

},{"../../address/index.js":207,"../../utils/maths.js":277,"../typed.js":203,"./abstract-coder.js":189}],191:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AnonymousCoder = void 0;
var abstract_coder_js_1 = require("./abstract-coder.js");
/**
 *  Clones the functionality of an existing Coder, but without a localName
 *
 *  @_ignore
 */
var AnonymousCoder = /*#__PURE__*/function (_abstract_coder_js_1$) {
  function AnonymousCoder(coder) {
    var _this;
    _classCallCheck(this, AnonymousCoder);
    _this = _callSuper(this, AnonymousCoder, [coder.name, coder.type, "_", coder.dynamic]);
    _defineProperty(_this, "coder", void 0);
    _this.coder = coder;
    return _this;
  }
  _inherits(AnonymousCoder, _abstract_coder_js_1$);
  return _createClass(AnonymousCoder, [{
    key: "defaultValue",
    value: function defaultValue() {
      return this.coder.defaultValue();
    }
  }, {
    key: "encode",
    value: function encode(writer, value) {
      return this.coder.encode(writer, value);
    }
  }, {
    key: "decode",
    value: function decode(reader) {
      return this.coder.decode(reader);
    }
  }]);
}(abstract_coder_js_1.Coder);
exports.AnonymousCoder = AnonymousCoder;

},{"./abstract-coder.js":189}],192:[function(require,module,exports){
"use strict";

function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ArrayCoder = exports.unpack = exports.pack = void 0;
var index_js_1 = require("../../utils/index.js");
var typed_js_1 = require("../typed.js");
var abstract_coder_js_1 = require("./abstract-coder.js");
var anonymous_js_1 = require("./anonymous.js");
/**
 *  @_ignore
 */
function pack(writer, coders, values) {
  var arrayValues = [];
  if (Array.isArray(values)) {
    arrayValues = values;
  } else if (values && _typeof(values) === "object") {
    var unique = {};
    arrayValues = coders.map(function (coder) {
      var name = coder.localName;
      (0, index_js_1.assert)(name, "cannot encode object for signature with missing names", "INVALID_ARGUMENT", {
        argument: "values",
        info: {
          coder: coder
        },
        value: values
      });
      (0, index_js_1.assert)(!unique[name], "cannot encode object for signature with duplicate names", "INVALID_ARGUMENT", {
        argument: "values",
        info: {
          coder: coder
        },
        value: values
      });
      unique[name] = true;
      return values[name];
    });
  } else {
    (0, index_js_1.assertArgument)(false, "invalid tuple value", "tuple", values);
  }
  (0, index_js_1.assertArgument)(coders.length === arrayValues.length, "types/value length mismatch", "tuple", values);
  var staticWriter = new abstract_coder_js_1.Writer();
  var dynamicWriter = new abstract_coder_js_1.Writer();
  var updateFuncs = [];
  coders.forEach(function (coder, index) {
    var value = arrayValues[index];
    if (coder.dynamic) {
      // Get current dynamic offset (for the future pointer)
      var dynamicOffset = dynamicWriter.length;
      // Encode the dynamic value into the dynamicWriter
      coder.encode(dynamicWriter, value);
      // Prepare to populate the correct offset once we are done
      var updateFunc = staticWriter.writeUpdatableValue();
      updateFuncs.push(function (baseOffset) {
        updateFunc(baseOffset + dynamicOffset);
      });
    } else {
      coder.encode(staticWriter, value);
    }
  });
  // Backfill all the dynamic offsets, now that we know the static length
  updateFuncs.forEach(function (func) {
    func(staticWriter.length);
  });
  var length = writer.appendWriter(staticWriter);
  length += writer.appendWriter(dynamicWriter);
  return length;
}
exports.pack = pack;
/**
 *  @_ignore
 */
function unpack(reader, coders) {
  var values = [];
  var keys = [];
  // A reader anchored to this base
  var baseReader = reader.subReader(0);
  coders.forEach(function (coder) {
    var value = null;
    if (coder.dynamic) {
      var offset = reader.readIndex();
      var offsetReader = baseReader.subReader(offset);
      try {
        value = coder.decode(offsetReader);
      } catch (error) {
        // Cannot recover from this
        if ((0, index_js_1.isError)(error, "BUFFER_OVERRUN")) {
          throw error;
        }
        value = error;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    } else {
      try {
        value = coder.decode(reader);
      } catch (error) {
        // Cannot recover from this
        if ((0, index_js_1.isError)(error, "BUFFER_OVERRUN")) {
          throw error;
        }
        value = error;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    }
    if (value == undefined) {
      throw new Error("investigate");
    }
    values.push(value);
    keys.push(coder.localName || null);
  });
  return abstract_coder_js_1.Result.fromItems(values, keys);
}
exports.unpack = unpack;
/**
 *  @_ignore
 */
var ArrayCoder = /*#__PURE__*/function (_abstract_coder_js_1$) {
  function ArrayCoder(coder, length, localName) {
    var _this;
    _classCallCheck(this, ArrayCoder);
    var type = coder.type + "[" + (length >= 0 ? length : "") + "]";
    var dynamic = length === -1 || coder.dynamic;
    _this = _callSuper(this, ArrayCoder, ["array", type, localName, dynamic]);
    _defineProperty(_this, "coder", void 0);
    _defineProperty(_this, "length", void 0);
    (0, index_js_1.defineProperties)(_this, {
      coder: coder,
      length: length
    });
    return _this;
  }
  _inherits(ArrayCoder, _abstract_coder_js_1$);
  return _createClass(ArrayCoder, [{
    key: "defaultValue",
    value: function defaultValue() {
      // Verifies the child coder is valid (even if the array is dynamic or 0-length)
      var defaultChild = this.coder.defaultValue();
      var result = [];
      for (var i = 0; i < this.length; i++) {
        result.push(defaultChild);
      }
      return result;
    }
  }, {
    key: "encode",
    value: function encode(writer, _value) {
      var value = typed_js_1.Typed.dereference(_value, "array");
      if (!Array.isArray(value)) {
        this._throwError("expected array value", value);
      }
      var count = this.length;
      if (count === -1) {
        count = value.length;
        writer.writeValue(value.length);
      }
      (0, index_js_1.assertArgumentCount)(value.length, count, "coder array" + (this.localName ? " " + this.localName : ""));
      var coders = [];
      for (var i = 0; i < value.length; i++) {
        coders.push(this.coder);
      }
      return pack(writer, coders, value);
    }
  }, {
    key: "decode",
    value: function decode(reader) {
      var count = this.length;
      if (count === -1) {
        count = reader.readIndex();
        // Check that there is *roughly* enough data to ensure
        // stray random data is not being read as a length. Each
        // slot requires at least 32 bytes for their value (or 32
        // bytes as a link to the data). This could use a much
        // tighter bound, but we are erroring on the side of safety.
        (0, index_js_1.assert)(count * abstract_coder_js_1.WordSize <= reader.dataLength, "insufficient data length", "BUFFER_OVERRUN", {
          buffer: reader.bytes,
          offset: count * abstract_coder_js_1.WordSize,
          length: reader.dataLength
        });
      }
      var coders = [];
      for (var i = 0; i < count; i++) {
        coders.push(new anonymous_js_1.AnonymousCoder(this.coder));
      }
      return unpack(reader, coders);
    }
  }]);
}(abstract_coder_js_1.Coder);
exports.ArrayCoder = ArrayCoder;

},{"../../utils/index.js":276,"../typed.js":203,"./abstract-coder.js":189,"./anonymous.js":191}],193:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BooleanCoder = void 0;
var typed_js_1 = require("../typed.js");
var abstract_coder_js_1 = require("./abstract-coder.js");
/**
 *  @_ignore
 */
var BooleanCoder = /*#__PURE__*/function (_abstract_coder_js_1$) {
  function BooleanCoder(localName) {
    _classCallCheck(this, BooleanCoder);
    return _callSuper(this, BooleanCoder, ["bool", "bool", localName, false]);
  }
  _inherits(BooleanCoder, _abstract_coder_js_1$);
  return _createClass(BooleanCoder, [{
    key: "defaultValue",
    value: function defaultValue() {
      return false;
    }
  }, {
    key: "encode",
    value: function encode(writer, _value) {
      var value = typed_js_1.Typed.dereference(_value, "bool");
      return writer.writeValue(value ? 1 : 0);
    }
  }, {
    key: "decode",
    value: function decode(reader) {
      return !!reader.readValue();
    }
  }]);
}(abstract_coder_js_1.Coder);
exports.BooleanCoder = BooleanCoder;

},{"../typed.js":203,"./abstract-coder.js":189}],194:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _get() { return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }
function _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BytesCoder = exports.DynamicBytesCoder = void 0;
var index_js_1 = require("../../utils/index.js");
var abstract_coder_js_1 = require("./abstract-coder.js");
/**
 *  @_ignore
 */
var DynamicBytesCoder = /*#__PURE__*/function (_abstract_coder_js_1$) {
  function DynamicBytesCoder(type, localName) {
    _classCallCheck(this, DynamicBytesCoder);
    return _callSuper(this, DynamicBytesCoder, [type, type, localName, true]);
  }
  _inherits(DynamicBytesCoder, _abstract_coder_js_1$);
  return _createClass(DynamicBytesCoder, [{
    key: "defaultValue",
    value: function defaultValue() {
      return "0x";
    }
  }, {
    key: "encode",
    value: function encode(writer, value) {
      value = (0, index_js_1.getBytesCopy)(value);
      var length = writer.writeValue(value.length);
      length += writer.writeBytes(value);
      return length;
    }
  }, {
    key: "decode",
    value: function decode(reader) {
      return reader.readBytes(reader.readIndex(), true);
    }
  }]);
}(abstract_coder_js_1.Coder);
exports.DynamicBytesCoder = DynamicBytesCoder;
/**
 *  @_ignore
 */
var BytesCoder = /*#__PURE__*/function (_DynamicBytesCoder) {
  function BytesCoder(localName) {
    _classCallCheck(this, BytesCoder);
    return _callSuper(this, BytesCoder, ["bytes", localName]);
  }
  _inherits(BytesCoder, _DynamicBytesCoder);
  return _createClass(BytesCoder, [{
    key: "decode",
    value: function decode(reader) {
      return (0, index_js_1.hexlify)(_get(_getPrototypeOf(BytesCoder.prototype), "decode", this).call(this, reader));
    }
  }]);
}(DynamicBytesCoder);
exports.BytesCoder = BytesCoder;

},{"../../utils/index.js":276,"./abstract-coder.js":189}],195:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FixedBytesCoder = void 0;
var index_js_1 = require("../../utils/index.js");
var typed_js_1 = require("../typed.js");
var abstract_coder_js_1 = require("./abstract-coder.js");
/**
 *  @_ignore
 */
var FixedBytesCoder = /*#__PURE__*/function (_abstract_coder_js_1$) {
  function FixedBytesCoder(size, localName) {
    var _this;
    _classCallCheck(this, FixedBytesCoder);
    var name = "bytes" + String(size);
    _this = _callSuper(this, FixedBytesCoder, [name, name, localName, false]);
    _defineProperty(_this, "size", void 0);
    (0, index_js_1.defineProperties)(_this, {
      size: size
    }, {
      size: "number"
    });
    return _this;
  }
  _inherits(FixedBytesCoder, _abstract_coder_js_1$);
  return _createClass(FixedBytesCoder, [{
    key: "defaultValue",
    value: function defaultValue() {
      return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2);
    }
  }, {
    key: "encode",
    value: function encode(writer, _value) {
      var data = (0, index_js_1.getBytesCopy)(typed_js_1.Typed.dereference(_value, this.type));
      if (data.length !== this.size) {
        this._throwError("incorrect data length", _value);
      }
      return writer.writeBytes(data);
    }
  }, {
    key: "decode",
    value: function decode(reader) {
      return (0, index_js_1.hexlify)(reader.readBytes(this.size));
    }
  }]);
}(abstract_coder_js_1.Coder);
exports.FixedBytesCoder = FixedBytesCoder;

},{"../../utils/index.js":276,"../typed.js":203,"./abstract-coder.js":189}],196:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NullCoder = void 0;
var abstract_coder_js_1 = require("./abstract-coder.js");
var Empty = new Uint8Array([]);
/**
 *  @_ignore
 */
var NullCoder = /*#__PURE__*/function (_abstract_coder_js_1$) {
  function NullCoder(localName) {
    _classCallCheck(this, NullCoder);
    return _callSuper(this, NullCoder, ["null", "", localName, false]);
  }
  _inherits(NullCoder, _abstract_coder_js_1$);
  return _createClass(NullCoder, [{
    key: "defaultValue",
    value: function defaultValue() {
      return null;
    }
  }, {
    key: "encode",
    value: function encode(writer, value) {
      if (value != null) {
        this._throwError("not null", value);
      }
      return writer.writeBytes(Empty);
    }
  }, {
    key: "decode",
    value: function decode(reader) {
      reader.readBytes(0);
      return null;
    }
  }]);
}(abstract_coder_js_1.Coder);
exports.NullCoder = NullCoder;

},{"./abstract-coder.js":189}],197:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NumberCoder = void 0;
var index_js_1 = require("../../utils/index.js");
var typed_js_1 = require("../typed.js");
var abstract_coder_js_1 = require("./abstract-coder.js");
var BN_0 = BigInt(0);
var BN_1 = BigInt(1);
var BN_MAX_UINT256 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
/**
 *  @_ignore
 */
var NumberCoder = /*#__PURE__*/function (_abstract_coder_js_1$) {
  function NumberCoder(size, signed, localName) {
    var _this;
    _classCallCheck(this, NumberCoder);
    var name = (signed ? "int" : "uint") + size * 8;
    _this = _callSuper(this, NumberCoder, [name, name, localName, false]);
    _defineProperty(_this, "size", void 0);
    _defineProperty(_this, "signed", void 0);
    (0, index_js_1.defineProperties)(_this, {
      size: size,
      signed: signed
    }, {
      size: "number",
      signed: "boolean"
    });
    return _this;
  }
  _inherits(NumberCoder, _abstract_coder_js_1$);
  return _createClass(NumberCoder, [{
    key: "defaultValue",
    value: function defaultValue() {
      return 0;
    }
  }, {
    key: "encode",
    value: function encode(writer, _value) {
      var value = (0, index_js_1.getBigInt)(typed_js_1.Typed.dereference(_value, this.type));
      // Check bounds are safe for encoding
      var maxUintValue = (0, index_js_1.mask)(BN_MAX_UINT256, abstract_coder_js_1.WordSize * 8);
      if (this.signed) {
        var bounds = (0, index_js_1.mask)(maxUintValue, this.size * 8 - 1);
        if (value > bounds || value < -(bounds + BN_1)) {
          this._throwError("value out-of-bounds", _value);
        }
        value = (0, index_js_1.toTwos)(value, 8 * abstract_coder_js_1.WordSize);
      } else if (value < BN_0 || value > (0, index_js_1.mask)(maxUintValue, this.size * 8)) {
        this._throwError("value out-of-bounds", _value);
      }
      return writer.writeValue(value);
    }
  }, {
    key: "decode",
    value: function decode(reader) {
      var value = (0, index_js_1.mask)(reader.readValue(), this.size * 8);
      if (this.signed) {
        value = (0, index_js_1.fromTwos)(value, this.size * 8);
      }
      return value;
    }
  }]);
}(abstract_coder_js_1.Coder);
exports.NumberCoder = NumberCoder;

},{"../../utils/index.js":276,"../typed.js":203,"./abstract-coder.js":189}],198:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _get() { return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }
function _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StringCoder = void 0;
var utf8_js_1 = require("../../utils/utf8.js");
var typed_js_1 = require("../typed.js");
var bytes_js_1 = require("./bytes.js");
/**
 *  @_ignore
 */
var StringCoder = /*#__PURE__*/function (_bytes_js_1$DynamicBy) {
  function StringCoder(localName) {
    _classCallCheck(this, StringCoder);
    return _callSuper(this, StringCoder, ["string", localName]);
  }
  _inherits(StringCoder, _bytes_js_1$DynamicBy);
  return _createClass(StringCoder, [{
    key: "defaultValue",
    value: function defaultValue() {
      return "";
    }
  }, {
    key: "encode",
    value: function encode(writer, _value) {
      return _get(_getPrototypeOf(StringCoder.prototype), "encode", this).call(this, writer, (0, utf8_js_1.toUtf8Bytes)(typed_js_1.Typed.dereference(_value, "string")));
    }
  }, {
    key: "decode",
    value: function decode(reader) {
      return (0, utf8_js_1.toUtf8String)(_get(_getPrototypeOf(StringCoder.prototype), "decode", this).call(this, reader));
    }
  }]);
}(bytes_js_1.DynamicBytesCoder);
exports.StringCoder = StringCoder;

},{"../../utils/utf8.js":282,"../typed.js":203,"./bytes.js":194}],199:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TupleCoder = void 0;
var properties_js_1 = require("../../utils/properties.js");
var typed_js_1 = require("../typed.js");
var abstract_coder_js_1 = require("./abstract-coder.js");
var array_js_1 = require("./array.js");
/**
 *  @_ignore
 */
var TupleCoder = /*#__PURE__*/function (_abstract_coder_js_1$) {
  function TupleCoder(coders, localName) {
    var _this;
    _classCallCheck(this, TupleCoder);
    var dynamic = false;
    var types = [];
    coders.forEach(function (coder) {
      if (coder.dynamic) {
        dynamic = true;
      }
      types.push(coder.type);
    });
    var type = "tuple(" + types.join(",") + ")";
    _this = _callSuper(this, TupleCoder, ["tuple", type, localName, dynamic]);
    _defineProperty(_this, "coders", void 0);
    (0, properties_js_1.defineProperties)(_this, {
      coders: Object.freeze(coders.slice())
    });
    return _this;
  }
  _inherits(TupleCoder, _abstract_coder_js_1$);
  return _createClass(TupleCoder, [{
    key: "defaultValue",
    value: function defaultValue() {
      var values = [];
      this.coders.forEach(function (coder) {
        values.push(coder.defaultValue());
      });
      // We only output named properties for uniquely named coders
      var uniqueNames = this.coders.reduce(function (accum, coder) {
        var name = coder.localName;
        if (name) {
          if (!accum[name]) {
            accum[name] = 0;
          }
          accum[name]++;
        }
        return accum;
      }, {});
      // Add named values
      this.coders.forEach(function (coder, index) {
        var name = coder.localName;
        if (!name || uniqueNames[name] !== 1) {
          return;
        }
        if (name === "length") {
          name = "_length";
        }
        if (values[name] != null) {
          return;
        }
        values[name] = values[index];
      });
      return Object.freeze(values);
    }
  }, {
    key: "encode",
    value: function encode(writer, _value) {
      var value = typed_js_1.Typed.dereference(_value, "tuple");
      return (0, array_js_1.pack)(writer, this.coders, value);
    }
  }, {
    key: "decode",
    value: function decode(reader) {
      return (0, array_js_1.unpack)(reader, this.coders);
    }
  }]);
}(abstract_coder_js_1.Coder);
exports.TupleCoder = TupleCoder;

},{"../../utils/properties.js":278,"../typed.js":203,"./abstract-coder.js":189,"./array.js":192}],200:[function(require,module,exports){
"use strict";

/**
 *  A fragment is a single item from an ABI, which may represent any of:
 *
 *  - [Functions](FunctionFragment)
 *  - [Events](EventFragment)
 *  - [Constructors](ConstructorFragment)
 *  - Custom [Errors](ErrorFragment)
 *  - [Fallback or Receive](FallbackFragment) functions
 *
 *  @_subsection api/abi/abi-coder:Fragments  [about-fragments]
 */
var _TokenString;
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StructFragment = exports.FunctionFragment = exports.FallbackFragment = exports.ConstructorFragment = exports.EventFragment = exports.ErrorFragment = exports.NamedFragment = exports.Fragment = exports.ParamType = void 0;
var index_js_1 = require("../utils/index.js");
var index_js_2 = require("../hash/index.js");
;
// [ "a", "b" ] => { "a": 1, "b": 1 }
function setify(items) {
  var result = new Set();
  items.forEach(function (k) {
    return result.add(k);
  });
  return Object.freeze(result);
}
var _kwVisibDeploy = "external public payable override";
var KwVisibDeploy = setify(_kwVisibDeploy.split(" "));
// Visibility Keywords
var _kwVisib = "constant external internal payable private public pure view override";
var KwVisib = setify(_kwVisib.split(" "));
var _kwTypes = "constructor error event fallback function receive struct";
var KwTypes = setify(_kwTypes.split(" "));
var _kwModifiers = "calldata memory storage payable indexed";
var KwModifiers = setify(_kwModifiers.split(" "));
var _kwOther = "tuple returns";
// All Keywords
var _keywords = [_kwTypes, _kwModifiers, _kwOther, _kwVisib].join(" ");
var Keywords = setify(_keywords.split(" "));
// Single character tokens
var SimpleTokens = {
  "(": "OPEN_PAREN",
  ")": "CLOSE_PAREN",
  "[": "OPEN_BRACKET",
  "]": "CLOSE_BRACKET",
  ",": "COMMA",
  "@": "AT"
};
// Parser regexes to consume the next token
var regexWhitespacePrefix = new RegExp("^(\\s*)");
var regexNumberPrefix = new RegExp("^([0-9]+)");
var regexIdPrefix = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)");
// Parser regexs to check validity
var regexId = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)$");
var regexType = new RegExp("^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$");
var _offset = /*#__PURE__*/new WeakMap();
var _tokens = /*#__PURE__*/new WeakMap();
var _TokenString_brand = /*#__PURE__*/new WeakSet();
var TokenString = /*#__PURE__*/function () {
  function TokenString(tokens) {
    _classCallCheck(this, TokenString);
    _classPrivateMethodInitSpec(this, _TokenString_brand);
    _classPrivateFieldInitSpec(this, _offset, void 0);
    _classPrivateFieldInitSpec(this, _tokens, void 0);
    _classPrivateFieldSet(_offset, this, 0);
    _classPrivateFieldSet(_tokens, this, tokens.slice());
  }
  return _createClass(TokenString, [{
    key: "offset",
    get: function get() {
      return _classPrivateFieldGet(_offset, this);
    }
  }, {
    key: "length",
    get: function get() {
      return _classPrivateFieldGet(_tokens, this).length - _classPrivateFieldGet(_offset, this);
    }
  }, {
    key: "clone",
    value: function clone() {
      return new TokenString(_classPrivateFieldGet(_tokens, this));
    }
  }, {
    key: "reset",
    value: function reset() {
      _classPrivateFieldSet(_offset, this, 0);
    }
  }, {
    key: "popKeyword",
    value:
    // Pops and returns the value of the next token, if it is a keyword in allowed; throws if out of tokens
    function popKeyword(allowed) {
      var top = this.peek();
      if (top.type !== "KEYWORD" || !allowed.has(top.text)) {
        throw new Error("expected keyword ".concat(top.text));
      }
      return this.pop().text;
    }
    // Pops and returns the value of the next token if it is `type`; throws if out of tokens
  }, {
    key: "popType",
    value: function popType(type) {
      if (this.peek().type !== type) {
        var top = this.peek();
        throw new Error("expected ".concat(type, "; got ").concat(top.type, " ").concat(JSON.stringify(top.text)));
      }
      return this.pop().text;
    }
    // Pops and returns a "(" TOKENS ")"
  }, {
    key: "popParen",
    value: function popParen() {
      var top = this.peek();
      if (top.type !== "OPEN_PAREN") {
        throw new Error("bad start");
      }
      var result = _assertClassBrand(_TokenString_brand, this, _subTokenString).call(this, _classPrivateFieldGet(_offset, this) + 1, top.match + 1);
      _classPrivateFieldSet(_offset, this, top.match + 1);
      return result;
    }
    // Pops and returns the items within "(" ITEM1 "," ITEM2 "," ... ")"
  }, {
    key: "popParams",
    value: function popParams() {
      var top = this.peek();
      if (top.type !== "OPEN_PAREN") {
        throw new Error("bad start");
      }
      var result = [];
      while (_classPrivateFieldGet(_offset, this) < top.match - 1) {
        var link = this.peek().linkNext;
        result.push(_assertClassBrand(_TokenString_brand, this, _subTokenString).call(this, _classPrivateFieldGet(_offset, this) + 1, link));
        _classPrivateFieldSet(_offset, this, link);
      }
      _classPrivateFieldSet(_offset, this, top.match + 1);
      return result;
    }
    // Returns the top Token, throwing if out of tokens
  }, {
    key: "peek",
    value: function peek() {
      if (_classPrivateFieldGet(_offset, this) >= _classPrivateFieldGet(_tokens, this).length) {
        throw new Error("out-of-bounds");
      }
      return _classPrivateFieldGet(_tokens, this)[_classPrivateFieldGet(_offset, this)];
    }
    // Returns the next value, if it is a keyword in `allowed`
  }, {
    key: "peekKeyword",
    value: function peekKeyword(allowed) {
      var top = this.peekType("KEYWORD");
      return top != null && allowed.has(top) ? top : null;
    }
    // Returns the value of the next token if it is `type`
  }, {
    key: "peekType",
    value: function peekType(type) {
      if (this.length === 0) {
        return null;
      }
      var top = this.peek();
      return top.type === type ? top.text : null;
    }
    // Returns the next token; throws if out of tokens
  }, {
    key: "pop",
    value: function pop() {
      var _this$offset, _this$offset2;
      var result = this.peek();
      _classPrivateFieldSet(_offset, this, (_this$offset = _classPrivateFieldGet(_offset, this), _this$offset2 = _this$offset++, _this$offset)), _this$offset2;
      return result;
    }
  }, {
    key: "toString",
    value: function toString() {
      var tokens = [];
      for (var i = _classPrivateFieldGet(_offset, this); i < _classPrivateFieldGet(_tokens, this).length; i++) {
        var token = _classPrivateFieldGet(_tokens, this)[i];
        tokens.push("".concat(token.type, ":").concat(token.text));
      }
      return "<TokenString ".concat(tokens.join(" "), ">");
    }
  }]);
}();
_TokenString = TokenString;
function _subTokenString() {
  var from = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  return new _TokenString(_classPrivateFieldGet(_tokens, this).slice(from, to).map(function (t) {
    return Object.freeze(Object.assign({}, t, {
      match: t.match - from,
      linkBack: t.linkBack - from,
      linkNext: t.linkNext - from
    }));
  }));
}
function lex(text) {
  var tokens = [];
  var throwError = function throwError(message) {
    var token = offset < text.length ? JSON.stringify(text[offset]) : "$EOI";
    throw new Error("invalid token ".concat(token, " at ").concat(offset, ": ").concat(message));
  };
  var brackets = [];
  var commas = [];
  var offset = 0;
  while (offset < text.length) {
    // Strip off any leading whitespace
    var cur = text.substring(offset);
    var match = cur.match(regexWhitespacePrefix);
    if (match) {
      offset += match[1].length;
      cur = text.substring(offset);
    }
    var token = {
      depth: brackets.length,
      linkBack: -1,
      linkNext: -1,
      match: -1,
      type: "",
      text: "",
      offset: offset,
      value: -1
    };
    tokens.push(token);
    var type = SimpleTokens[cur[0]] || "";
    if (type) {
      token.type = type;
      token.text = cur[0];
      offset++;
      if (type === "OPEN_PAREN") {
        brackets.push(tokens.length - 1);
        commas.push(tokens.length - 1);
      } else if (type == "CLOSE_PAREN") {
        if (brackets.length === 0) {
          throwError("no matching open bracket");
        }
        token.match = brackets.pop();
        tokens[token.match].match = tokens.length - 1;
        token.depth--;
        token.linkBack = commas.pop();
        tokens[token.linkBack].linkNext = tokens.length - 1;
      } else if (type === "COMMA") {
        token.linkBack = commas.pop();
        tokens[token.linkBack].linkNext = tokens.length - 1;
        commas.push(tokens.length - 1);
      } else if (type === "OPEN_BRACKET") {
        token.type = "BRACKET";
      } else if (type === "CLOSE_BRACKET") {
        // Remove the CLOSE_BRACKET
        var suffix = tokens.pop().text;
        if (tokens.length > 0 && tokens[tokens.length - 1].type === "NUMBER") {
          var value = tokens.pop().text;
          suffix = value + suffix;
          tokens[tokens.length - 1].value = (0, index_js_1.getNumber)(value);
        }
        if (tokens.length === 0 || tokens[tokens.length - 1].type !== "BRACKET") {
          throw new Error("missing opening bracket");
        }
        tokens[tokens.length - 1].text += suffix;
      }
      continue;
    }
    match = cur.match(regexIdPrefix);
    if (match) {
      token.text = match[1];
      offset += token.text.length;
      if (Keywords.has(token.text)) {
        token.type = "KEYWORD";
        continue;
      }
      if (token.text.match(regexType)) {
        token.type = "TYPE";
        continue;
      }
      token.type = "ID";
      continue;
    }
    match = cur.match(regexNumberPrefix);
    if (match) {
      token.text = match[1];
      token.type = "NUMBER";
      offset += token.text.length;
      continue;
    }
    throw new Error("unexpected token ".concat(JSON.stringify(cur[0]), " at position ").concat(offset));
  }
  return new TokenString(tokens.map(function (t) {
    return Object.freeze(t);
  }));
}
// Check only one of `allowed` is in `set`
function allowSingle(set, allowed) {
  var included = [];
  for (var key in allowed.keys()) {
    if (set.has(key)) {
      included.push(key);
    }
  }
  if (included.length > 1) {
    throw new Error("conflicting types: ".concat(included.join(", ")));
  }
}
// Functions to process a Solidity Signature TokenString from left-to-right for...
// ...the name with an optional type, returning the name
function consumeName(type, tokens) {
  if (tokens.peekKeyword(KwTypes)) {
    var keyword = tokens.pop().text;
    if (keyword !== type) {
      throw new Error("expected ".concat(type, ", got ").concat(keyword));
    }
  }
  return tokens.popType("ID");
}
// ...all keywords matching allowed, returning the keywords
function consumeKeywords(tokens, allowed) {
  var keywords = new Set();
  while (true) {
    var keyword = tokens.peekType("KEYWORD");
    if (keyword == null || allowed && !allowed.has(keyword)) {
      break;
    }
    tokens.pop();
    if (keywords.has(keyword)) {
      throw new Error("duplicate keywords: ".concat(JSON.stringify(keyword)));
    }
    keywords.add(keyword);
  }
  return Object.freeze(keywords);
}
// ...all visibility keywords, returning the coalesced mutability
function consumeMutability(tokens) {
  var modifiers = consumeKeywords(tokens, KwVisib);
  // Detect conflicting modifiers
  allowSingle(modifiers, setify("constant payable nonpayable".split(" ")));
  allowSingle(modifiers, setify("pure view payable nonpayable".split(" ")));
  // Process mutability states
  if (modifiers.has("view")) {
    return "view";
  }
  if (modifiers.has("pure")) {
    return "pure";
  }
  if (modifiers.has("payable")) {
    return "payable";
  }
  if (modifiers.has("nonpayable")) {
    return "nonpayable";
  }
  // Process legacy `constant` last
  if (modifiers.has("constant")) {
    return "view";
  }
  return "nonpayable";
}
// ...a parameter list, returning the ParamType list
function consumeParams(tokens, allowIndexed) {
  return tokens.popParams().map(function (t) {
    return ParamType.from(t, allowIndexed);
  });
}
// ...a gas limit, returning a BigNumber or null if none
function consumeGas(tokens) {
  if (tokens.peekType("AT")) {
    tokens.pop();
    if (tokens.peekType("NUMBER")) {
      return (0, index_js_1.getBigInt)(tokens.pop().text);
    }
    throw new Error("invalid gas");
  }
  return null;
}
function consumeEoi(tokens) {
  if (tokens.length) {
    throw new Error("unexpected tokens at offset ".concat(tokens.offset, ": ").concat(tokens.toString()));
  }
}
var regexArrayType = new RegExp(/^(.*)\[([0-9]*)\]$/);
function verifyBasicType(type) {
  var match = type.match(regexType);
  (0, index_js_1.assertArgument)(match, "invalid type", "type", type);
  if (type === "uint") {
    return "uint256";
  }
  if (type === "int") {
    return "int256";
  }
  if (match[2]) {
    // bytesXX
    var length = parseInt(match[2]);
    (0, index_js_1.assertArgument)(length !== 0 && length <= 32, "invalid bytes length", "type", type);
  } else if (match[3]) {
    // intXX or uintXX
    var size = parseInt(match[3]);
    (0, index_js_1.assertArgument)(size !== 0 && size <= 256 && size % 8 === 0, "invalid numeric width", "type", type);
  }
  return type;
}
// Make the Fragment constructors effectively private
var _guard = {};
var internal = Symbol["for"]("_ethers_internal");
var ParamTypeInternal = "_ParamTypeInternal";
var ErrorFragmentInternal = "_ErrorInternal";
var EventFragmentInternal = "_EventInternal";
var ConstructorFragmentInternal = "_ConstructorInternal";
var FallbackFragmentInternal = "_FallbackInternal";
var FunctionFragmentInternal = "_FunctionInternal";
var StructFragmentInternal = "_StructInternal";
/**
 *  Each input and output of a [[Fragment]] is an Array of **ParamType**.
 */
var _ParamType_brand = /*#__PURE__*/new WeakSet();
var ParamType = /*#__PURE__*/function () {
  /**
   *  @private
   */
  function ParamType(guard, name, type, baseType, indexed, _components, arrayLength, arrayChildren) {
    _classCallCheck(this, ParamType);
    _classPrivateMethodInitSpec(this, _ParamType_brand);
    /**
     *  The local name of the parameter (or ``""`` if unbound)
     */
    _defineProperty(this, "name", void 0);
    /**
     *  The fully qualified type (e.g. ``"address"``, ``"tuple(address)"``,
     *  ``"uint256[3][]"``)
     */
    _defineProperty(this, "type", void 0);
    /**
     *  The base type (e.g. ``"address"``, ``"tuple"``, ``"array"``)
     */
    _defineProperty(this, "baseType", void 0);
    /**
     *  True if the parameters is indexed.
     *
     *  For non-indexable types this is ``null``.
     */
    _defineProperty(this, "indexed", void 0);
    /**
     *  The components for the tuple.
     *
     *  For non-tuple types this is ``null``.
     */
    _defineProperty(this, "components", void 0);
    /**
     *  The array length, or ``-1`` for dynamic-lengthed arrays.
     *
     *  For non-array types this is ``null``.
     */
    _defineProperty(this, "arrayLength", void 0);
    /**
     *  The type of each child in the array.
     *
     *  For non-array types this is ``null``.
     */
    _defineProperty(this, "arrayChildren", void 0);
    (0, index_js_1.assertPrivate)(guard, _guard, "ParamType");
    Object.defineProperty(this, internal, {
      value: ParamTypeInternal
    });
    if (_components) {
      _components = Object.freeze(_components.slice());
    }
    if (baseType === "array") {
      if (arrayLength == null || arrayChildren == null) {
        throw new Error("");
      }
    } else if (arrayLength != null || arrayChildren != null) {
      throw new Error("");
    }
    if (baseType === "tuple") {
      if (_components == null) {
        throw new Error("");
      }
    } else if (_components != null) {
      throw new Error("");
    }
    (0, index_js_1.defineProperties)(this, {
      name: name,
      type: type,
      baseType: baseType,
      indexed: indexed,
      components: _components,
      arrayLength: arrayLength,
      arrayChildren: arrayChildren
    });
  }
  /**
   *  Return a string representation of this type.
   *
   *  For example,
   *
   *  ``sighash" => "(uint256,address)"``
   *
   *  ``"minimal" => "tuple(uint256,address) indexed"``
   *
   *  ``"full" => "tuple(uint256 foo, address bar) indexed baz"``
   */
  return _createClass(ParamType, [{
    key: "format",
    value: function format(_format) {
      if (_format == null) {
        _format = "sighash";
      }
      if (_format === "json") {
        var name = this.name || "";
        if (this.isArray()) {
          var _result = JSON.parse(this.arrayChildren.format("json"));
          _result.name = name;
          _result.type += "[".concat(this.arrayLength < 0 ? "" : String(this.arrayLength), "]");
          return JSON.stringify(_result);
        }
        var _result2 = {
          type: this.baseType === "tuple" ? "tuple" : this.type,
          name: name
        };
        if (typeof this.indexed === "boolean") {
          _result2.indexed = this.indexed;
        }
        if (this.isTuple()) {
          _result2.components = this.components.map(function (c) {
            return JSON.parse(c.format(_format));
          });
        }
        return JSON.stringify(_result2);
      }
      var result = "";
      // Array
      if (this.isArray()) {
        result += this.arrayChildren.format(_format);
        result += "[".concat(this.arrayLength < 0 ? "" : String(this.arrayLength), "]");
      } else {
        if (this.isTuple()) {
          result += "(" + this.components.map(function (comp) {
            return comp.format(_format);
          }).join(_format === "full" ? ", " : ",") + ")";
        } else {
          result += this.type;
        }
      }
      if (_format !== "sighash") {
        if (this.indexed === true) {
          result += " indexed";
        }
        if (_format === "full" && this.name) {
          result += " " + this.name;
        }
      }
      return result;
    }
    /**
     *  Returns true if %%this%% is an Array type.
     *
     *  This provides a type gaurd ensuring that [[arrayChildren]]
     *  and [[arrayLength]] are non-null.
     */
  }, {
    key: "isArray",
    value: function isArray() {
      return this.baseType === "array";
    }
    /**
     *  Returns true if %%this%% is a Tuple type.
     *
     *  This provides a type gaurd ensuring that [[components]]
     *  is non-null.
     */
  }, {
    key: "isTuple",
    value: function isTuple() {
      return this.baseType === "tuple";
    }
    /**
     *  Returns true if %%this%% is an Indexable type.
     *
     *  This provides a type gaurd ensuring that [[indexed]]
     *  is non-null.
     */
  }, {
    key: "isIndexable",
    value: function isIndexable() {
      return this.indexed != null;
    }
    /**
     *  Walks the **ParamType** with %%value%%, calling %%process%%
     *  on each type, destructing the %%value%% recursively.
     */
  }, {
    key: "walk",
    value: function walk(value, process) {
      if (this.isArray()) {
        if (!Array.isArray(value)) {
          throw new Error("invalid array value");
        }
        if (this.arrayLength !== -1 && value.length !== this.arrayLength) {
          throw new Error("array is wrong length");
        }
        var _this = this;
        return value.map(function (v) {
          return _this.arrayChildren.walk(v, process);
        });
      }
      if (this.isTuple()) {
        if (!Array.isArray(value)) {
          throw new Error("invalid tuple value");
        }
        if (value.length !== this.components.length) {
          throw new Error("array is wrong length");
        }
        var _this2 = this;
        return value.map(function (v, i) {
          return _this2.components[i].walk(v, process);
        });
      }
      return process(this.type, value);
    }
  }, {
    key: "walkAsync",
    value: (
    /**
     *  Walks the **ParamType** with %%value%%, asynchronously calling
     *  %%process%% on each type, destructing the %%value%% recursively.
     *
     *  This can be used to resolve ENS names by walking and resolving each
     *  ``"address"`` type.
     */
    function () {
      var _walkAsync2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(value, process) {
        var promises, result;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              promises = [];
              result = [value];
              _assertClassBrand(_ParamType_brand, this, _walkAsync).call(this, promises, value, process, function (value) {
                result[0] = value;
              });
              if (!promises.length) {
                _context.next = 6;
                break;
              }
              _context.next = 6;
              return Promise.all(promises);
            case 6:
              return _context.abrupt("return", result[0]);
            case 7:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function walkAsync(_x, _x2) {
        return _walkAsync2.apply(this, arguments);
      }
      return walkAsync;
    }()
    /**
     *  Creates a new **ParamType** for %%obj%%.
     *
     *  If %%allowIndexed%% then the ``indexed`` keyword is permitted,
     *  otherwise the ``indexed`` keyword will throw an error.
     */
    )
  }], [{
    key: "from",
    value: function from(obj, allowIndexed) {
      if (ParamType.isParamType(obj)) {
        return obj;
      }
      if (typeof obj === "string") {
        try {
          return ParamType.from(lex(obj), allowIndexed);
        } catch (error) {
          (0, index_js_1.assertArgument)(false, "invalid param type", "obj", obj);
        }
      } else if (obj instanceof TokenString) {
        var _type = "",
          baseType = "";
        var comps = null;
        if (consumeKeywords(obj, setify(["tuple"])).has("tuple") || obj.peekType("OPEN_PAREN")) {
          // Tuple
          baseType = "tuple";
          comps = obj.popParams().map(function (t) {
            return ParamType.from(t);
          });
          _type = "tuple(".concat(comps.map(function (c) {
            return c.format();
          }).join(","), ")");
        } else {
          // Normal
          _type = verifyBasicType(obj.popType("TYPE"));
          baseType = _type;
        }
        // Check for Array
        var arrayChildren = null;
        var arrayLength = null;
        while (obj.length && obj.peekType("BRACKET")) {
          var bracket = obj.pop(); //arrays[i];
          arrayChildren = new ParamType(_guard, "", _type, baseType, null, comps, arrayLength, arrayChildren);
          arrayLength = bracket.value;
          _type += bracket.text;
          baseType = "array";
          comps = null;
        }
        var _indexed = null;
        var keywords = consumeKeywords(obj, KwModifiers);
        if (keywords.has("indexed")) {
          if (!allowIndexed) {
            throw new Error("");
          }
          _indexed = true;
        }
        var _name = obj.peekType("ID") ? obj.pop().text : "";
        if (obj.length) {
          throw new Error("leftover tokens");
        }
        return new ParamType(_guard, _name, _type, baseType, _indexed, comps, arrayLength, arrayChildren);
      }
      var name = obj.name;
      (0, index_js_1.assertArgument)(!name || typeof name === "string" && name.match(regexId), "invalid name", "obj.name", name);
      var indexed = obj.indexed;
      if (indexed != null) {
        (0, index_js_1.assertArgument)(allowIndexed, "parameter cannot be indexed", "obj.indexed", obj.indexed);
        indexed = !!indexed;
      }
      var type = obj.type;
      var arrayMatch = type.match(regexArrayType);
      if (arrayMatch) {
        var _arrayLength = parseInt(arrayMatch[2] || "-1");
        var _arrayChildren = ParamType.from({
          type: arrayMatch[1],
          components: obj.components
        });
        return new ParamType(_guard, name || "", type, "array", indexed, null, _arrayLength, _arrayChildren);
      }
      if (type === "tuple" || type.startsWith("tuple(" /* fix: ) */) || type.startsWith("(" /* fix: ) */)) {
        var _comps = obj.components != null ? obj.components.map(function (c) {
          return ParamType.from(c);
        }) : null;
        var tuple = new ParamType(_guard, name || "", type, "tuple", indexed, _comps, null, null);
        // @TODO: use lexer to validate and normalize type
        return tuple;
      }
      type = verifyBasicType(obj.type);
      return new ParamType(_guard, name || "", type, type, indexed, null, null, null);
    }
    /**
     *  Returns true if %%value%% is a **ParamType**.
     */
  }, {
    key: "isParamType",
    value: function isParamType(value) {
      return value && value[internal] === ParamTypeInternal;
    }
  }]);
}();
function _walkAsync(promises, value, process, setValue) {
  if (this.isArray()) {
    if (!Array.isArray(value)) {
      throw new Error("invalid array value");
    }
    if (this.arrayLength !== -1 && value.length !== this.arrayLength) {
      throw new Error("array is wrong length");
    }
    var childType = this.arrayChildren;
    var _result3 = value.slice();
    _result3.forEach(function (value, index) {
      _assertClassBrand(_ParamType_brand, childType, _walkAsync).call(childType, promises, value, process, function (value) {
        _result3[index] = value;
      });
    });
    setValue(_result3);
    return;
  }
  if (this.isTuple()) {
    var components = this.components;
    // Convert the object into an array
    var _result4;
    if (Array.isArray(value)) {
      _result4 = value.slice();
    } else {
      if (value == null || _typeof(value) !== "object") {
        throw new Error("invalid tuple value");
      }
      _result4 = components.map(function (param) {
        if (!param.name) {
          throw new Error("cannot use object value with unnamed components");
        }
        if (!(param.name in value)) {
          throw new Error("missing value for component ".concat(param.name));
        }
        return value[param.name];
      });
    }
    if (_result4.length !== this.components.length) {
      throw new Error("array is wrong length");
    }
    _result4.forEach(function (value, index) {
      var _components$index;
      _assertClassBrand(_ParamType_brand, _components$index = components[index], _walkAsync).call(_components$index, promises, value, process, function (value) {
        _result4[index] = value;
      });
    });
    setValue(_result4);
    return;
  }
  var result = process(this.type, value);
  if (result.then) {
    promises.push(_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            _context2.t0 = setValue;
            _context2.next = 3;
            return result;
          case 3:
            _context2.t1 = _context2.sent;
            (0, _context2.t0)(_context2.t1);
          case 5:
          case "end":
            return _context2.stop();
        }
      }, _callee2);
    }))());
  } else {
    setValue(result);
  }
}
exports.ParamType = ParamType;
/**
 *  An abstract class to represent An individual fragment from a parse ABI.
 */
var Fragment = /*#__PURE__*/function () {
  /**
   *  @private
   */
  function Fragment(guard, type, inputs) {
    _classCallCheck(this, Fragment);
    /**
     *  The type of the fragment.
     */
    _defineProperty(this, "type", void 0);
    /**
     *  The inputs for the fragment.
     */
    _defineProperty(this, "inputs", void 0);
    (0, index_js_1.assertPrivate)(guard, _guard, "Fragment");
    inputs = Object.freeze(inputs.slice());
    (0, index_js_1.defineProperties)(this, {
      type: type,
      inputs: inputs
    });
  }
  /**
   *  Creates a new **Fragment** for %%obj%%, wich can be any supported
   *  ABI frgament type.
   */
  return _createClass(Fragment, null, [{
    key: "from",
    value: function from(obj) {
      if (typeof obj === "string") {
        // Try parsing JSON...
        try {
          Fragment.from(JSON.parse(obj));
        } catch (e) {}
        // ...otherwise, use the human-readable lexer
        return Fragment.from(lex(obj));
      }
      if (obj instanceof TokenString) {
        // Human-readable ABI (already lexed)
        var type = obj.peekKeyword(KwTypes);
        switch (type) {
          case "constructor":
            return ConstructorFragment.from(obj);
          case "error":
            return ErrorFragment.from(obj);
          case "event":
            return EventFragment.from(obj);
          case "fallback":
          case "receive":
            return FallbackFragment.from(obj);
          case "function":
            return FunctionFragment.from(obj);
          case "struct":
            return StructFragment.from(obj);
        }
      } else if (_typeof(obj) === "object") {
        // JSON ABI
        switch (obj.type) {
          case "constructor":
            return ConstructorFragment.from(obj);
          case "error":
            return ErrorFragment.from(obj);
          case "event":
            return EventFragment.from(obj);
          case "fallback":
          case "receive":
            return FallbackFragment.from(obj);
          case "function":
            return FunctionFragment.from(obj);
          case "struct":
            return StructFragment.from(obj);
        }
        (0, index_js_1.assert)(false, "unsupported type: ".concat(obj.type), "UNSUPPORTED_OPERATION", {
          operation: "Fragment.from"
        });
      }
      (0, index_js_1.assertArgument)(false, "unsupported frgament object", "obj", obj);
    }
    /**
     *  Returns true if %%value%% is a [[ConstructorFragment]].
     */
  }, {
    key: "isConstructor",
    value: function isConstructor(value) {
      return ConstructorFragment.isFragment(value);
    }
    /**
     *  Returns true if %%value%% is an [[ErrorFragment]].
     */
  }, {
    key: "isError",
    value: function isError(value) {
      return ErrorFragment.isFragment(value);
    }
    /**
     *  Returns true if %%value%% is an [[EventFragment]].
     */
  }, {
    key: "isEvent",
    value: function isEvent(value) {
      return EventFragment.isFragment(value);
    }
    /**
     *  Returns true if %%value%% is a [[FunctionFragment]].
     */
  }, {
    key: "isFunction",
    value: function isFunction(value) {
      return FunctionFragment.isFragment(value);
    }
    /**
     *  Returns true if %%value%% is a [[StructFragment]].
     */
  }, {
    key: "isStruct",
    value: function isStruct(value) {
      return StructFragment.isFragment(value);
    }
  }]);
}();
exports.Fragment = Fragment;
/**
 *  An abstract class to represent An individual fragment
 *  which has a name from a parse ABI.
 */
var NamedFragment = /*#__PURE__*/function (_Fragment2) {
  /**
   *  @private
   */
  function NamedFragment(guard, type, name, inputs) {
    var _this3;
    _classCallCheck(this, NamedFragment);
    _this3 = _callSuper(this, NamedFragment, [guard, type, inputs]);
    /**
     *  The name of the fragment.
     */
    _defineProperty(_this3, "name", void 0);
    (0, index_js_1.assertArgument)(typeof name === "string" && name.match(regexId), "invalid identifier", "name", name);
    inputs = Object.freeze(inputs.slice());
    (0, index_js_1.defineProperties)(_this3, {
      name: name
    });
    return _this3;
  }
  _inherits(NamedFragment, _Fragment2);
  return _createClass(NamedFragment);
}(Fragment);
exports.NamedFragment = NamedFragment;
function joinParams(format, params) {
  return "(" + params.map(function (p) {
    return p.format(format);
  }).join(format === "full" ? ", " : ",") + ")";
}
/**
 *  A Fragment which represents a //Custom Error//.
 */
var ErrorFragment = /*#__PURE__*/function (_NamedFragment2) {
  /**
   *  @private
   */
  function ErrorFragment(guard, name, inputs) {
    var _this4;
    _classCallCheck(this, ErrorFragment);
    _this4 = _callSuper(this, ErrorFragment, [guard, "error", name, inputs]);
    Object.defineProperty(_this4, internal, {
      value: ErrorFragmentInternal
    });
    return _this4;
  }
  /**
   *  The Custom Error selector.
   */
  _inherits(ErrorFragment, _NamedFragment2);
  return _createClass(ErrorFragment, [{
    key: "selector",
    get: function get() {
      return (0, index_js_2.id)(this.format("sighash")).substring(0, 10);
    }
    /**
     *  Returns a string representation of this fragment as %%format%%.
     */
  }, {
    key: "format",
    value: function format(_format2) {
      if (_format2 == null) {
        _format2 = "sighash";
      }
      if (_format2 === "json") {
        return JSON.stringify({
          type: "error",
          name: this.name,
          inputs: this.inputs.map(function (input) {
            return JSON.parse(input.format(_format2));
          })
        });
      }
      var result = [];
      if (_format2 !== "sighash") {
        result.push("error");
      }
      result.push(this.name + joinParams(_format2, this.inputs));
      return result.join(" ");
    }
    /**
     *  Returns a new **ErrorFragment** for %%obj%%.
     */
  }], [{
    key: "from",
    value: function from(obj) {
      if (ErrorFragment.isFragment(obj)) {
        return obj;
      }
      if (typeof obj === "string") {
        return ErrorFragment.from(lex(obj));
      } else if (obj instanceof TokenString) {
        var name = consumeName("error", obj);
        var inputs = consumeParams(obj);
        consumeEoi(obj);
        return new ErrorFragment(_guard, name, inputs);
      }
      return new ErrorFragment(_guard, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);
    }
    /**
     *  Returns ``true`` and provides a type guard if %%value%% is an
     *  **ErrorFragment**.
     */
  }, {
    key: "isFragment",
    value: function isFragment(value) {
      return value && value[internal] === ErrorFragmentInternal;
    }
  }]);
}(NamedFragment);
exports.ErrorFragment = ErrorFragment;
/**
 *  A Fragment which represents an Event.
 */
var EventFragment = /*#__PURE__*/function (_NamedFragment3) {
  /**
   *  @private
   */
  function EventFragment(guard, name, inputs, anonymous) {
    var _this5;
    _classCallCheck(this, EventFragment);
    _this5 = _callSuper(this, EventFragment, [guard, "event", name, inputs]);
    /**
     *  Whether this event is anonymous.
     */
    _defineProperty(_this5, "anonymous", void 0);
    Object.defineProperty(_this5, internal, {
      value: EventFragmentInternal
    });
    (0, index_js_1.defineProperties)(_this5, {
      anonymous: anonymous
    });
    return _this5;
  }
  /**
   *  The Event topic hash.
   */
  _inherits(EventFragment, _NamedFragment3);
  return _createClass(EventFragment, [{
    key: "topicHash",
    get: function get() {
      return (0, index_js_2.id)(this.format("sighash"));
    }
    /**
     *  Returns a string representation of this event as %%format%%.
     */
  }, {
    key: "format",
    value: function format(_format3) {
      if (_format3 == null) {
        _format3 = "sighash";
      }
      if (_format3 === "json") {
        return JSON.stringify({
          type: "event",
          anonymous: this.anonymous,
          name: this.name,
          inputs: this.inputs.map(function (i) {
            return JSON.parse(i.format(_format3));
          })
        });
      }
      var result = [];
      if (_format3 !== "sighash") {
        result.push("event");
      }
      result.push(this.name + joinParams(_format3, this.inputs));
      if (_format3 !== "sighash" && this.anonymous) {
        result.push("anonymous");
      }
      return result.join(" ");
    }
    /**
     *  Return the topic hash for an event with %%name%% and %%params%%.
     */
  }], [{
    key: "getTopicHash",
    value: function getTopicHash(name, params) {
      params = (params || []).map(function (p) {
        return ParamType.from(p);
      });
      var fragment = new EventFragment(_guard, name, params, false);
      return fragment.topicHash;
    }
    /**
     *  Returns a new **EventFragment** for %%obj%%.
     */
  }, {
    key: "from",
    value: function from(obj) {
      if (EventFragment.isFragment(obj)) {
        return obj;
      }
      if (typeof obj === "string") {
        try {
          return EventFragment.from(lex(obj));
        } catch (error) {
          (0, index_js_1.assertArgument)(false, "invalid event fragment", "obj", obj);
        }
      } else if (obj instanceof TokenString) {
        var name = consumeName("event", obj);
        var inputs = consumeParams(obj, true);
        var anonymous = !!consumeKeywords(obj, setify(["anonymous"])).has("anonymous");
        consumeEoi(obj);
        return new EventFragment(_guard, name, inputs, anonymous);
      }
      return new EventFragment(_guard, obj.name, obj.inputs ? obj.inputs.map(function (p) {
        return ParamType.from(p, true);
      }) : [], !!obj.anonymous);
    }
    /**
     *  Returns ``true`` and provides a type guard if %%value%% is an
     *  **EventFragment**.
     */
  }, {
    key: "isFragment",
    value: function isFragment(value) {
      return value && value[internal] === EventFragmentInternal;
    }
  }]);
}(NamedFragment);
exports.EventFragment = EventFragment;
/**
 *  A Fragment which represents a constructor.
 */
var ConstructorFragment = /*#__PURE__*/function (_Fragment3) {
  /**
   *  @private
   */
  function ConstructorFragment(guard, type, inputs, payable, gas) {
    var _this6;
    _classCallCheck(this, ConstructorFragment);
    _this6 = _callSuper(this, ConstructorFragment, [guard, type, inputs]);
    /**
     *  Whether the constructor can receive an endowment.
     */
    _defineProperty(_this6, "payable", void 0);
    /**
     *  The recommended gas limit for deployment or ``null``.
     */
    _defineProperty(_this6, "gas", void 0);
    Object.defineProperty(_this6, internal, {
      value: ConstructorFragmentInternal
    });
    (0, index_js_1.defineProperties)(_this6, {
      payable: payable,
      gas: gas
    });
    return _this6;
  }
  /**
   *  Returns a string representation of this constructor as %%format%%.
   */
  _inherits(ConstructorFragment, _Fragment3);
  return _createClass(ConstructorFragment, [{
    key: "format",
    value: function format(_format4) {
      (0, index_js_1.assert)(_format4 != null && _format4 !== "sighash", "cannot format a constructor for sighash", "UNSUPPORTED_OPERATION", {
        operation: "format(sighash)"
      });
      if (_format4 === "json") {
        return JSON.stringify({
          type: "constructor",
          stateMutability: this.payable ? "payable" : "undefined",
          payable: this.payable,
          gas: this.gas != null ? this.gas : undefined,
          inputs: this.inputs.map(function (i) {
            return JSON.parse(i.format(_format4));
          })
        });
      }
      var result = ["constructor".concat(joinParams(_format4, this.inputs))];
      if (this.payable) {
        result.push("payable");
      }
      if (this.gas != null) {
        result.push("@".concat(this.gas.toString()));
      }
      return result.join(" ");
    }
    /**
     *  Returns a new **ConstructorFragment** for %%obj%%.
     */
  }], [{
    key: "from",
    value: function from(obj) {
      if (ConstructorFragment.isFragment(obj)) {
        return obj;
      }
      if (typeof obj === "string") {
        try {
          return ConstructorFragment.from(lex(obj));
        } catch (error) {
          (0, index_js_1.assertArgument)(false, "invalid constuctor fragment", "obj", obj);
        }
      } else if (obj instanceof TokenString) {
        consumeKeywords(obj, setify(["constructor"]));
        var inputs = consumeParams(obj);
        var payable = !!consumeKeywords(obj, KwVisibDeploy).has("payable");
        var gas = consumeGas(obj);
        consumeEoi(obj);
        return new ConstructorFragment(_guard, "constructor", inputs, payable, gas);
      }
      return new ConstructorFragment(_guard, "constructor", obj.inputs ? obj.inputs.map(ParamType.from) : [], !!obj.payable, obj.gas != null ? obj.gas : null);
    }
    /**
     *  Returns ``true`` and provides a type guard if %%value%% is a
     *  **ConstructorFragment**.
     */
  }, {
    key: "isFragment",
    value: function isFragment(value) {
      return value && value[internal] === ConstructorFragmentInternal;
    }
  }]);
}(Fragment);
exports.ConstructorFragment = ConstructorFragment;
/**
 *  A Fragment which represents a method.
 */
var FallbackFragment = /*#__PURE__*/function (_Fragment4) {
  function FallbackFragment(guard, inputs, payable) {
    var _this7;
    _classCallCheck(this, FallbackFragment);
    _this7 = _callSuper(this, FallbackFragment, [guard, "fallback", inputs]);
    /**
     *  If the function can be sent value during invocation.
     */
    _defineProperty(_this7, "payable", void 0);
    Object.defineProperty(_this7, internal, {
      value: FallbackFragmentInternal
    });
    (0, index_js_1.defineProperties)(_this7, {
      payable: payable
    });
    return _this7;
  }
  /**
   *  Returns a string representation of this fallback as %%format%%.
   */
  _inherits(FallbackFragment, _Fragment4);
  return _createClass(FallbackFragment, [{
    key: "format",
    value: function format(_format5) {
      var type = this.inputs.length === 0 ? "receive" : "fallback";
      if (_format5 === "json") {
        var stateMutability = this.payable ? "payable" : "nonpayable";
        return JSON.stringify({
          type: type,
          stateMutability: stateMutability
        });
      }
      return "".concat(type, "()").concat(this.payable ? " payable" : "");
    }
    /**
     *  Returns a new **FallbackFragment** for %%obj%%.
     */
  }], [{
    key: "from",
    value: function from(obj) {
      if (FallbackFragment.isFragment(obj)) {
        return obj;
      }
      if (typeof obj === "string") {
        try {
          return FallbackFragment.from(lex(obj));
        } catch (error) {
          (0, index_js_1.assertArgument)(false, "invalid fallback fragment", "obj", obj);
        }
      } else if (obj instanceof TokenString) {
        var errorObj = obj.toString();
        var topIsValid = obj.peekKeyword(setify(["fallback", "receive"]));
        (0, index_js_1.assertArgument)(topIsValid, "type must be fallback or receive", "obj", errorObj);
        var type = obj.popKeyword(setify(["fallback", "receive"]));
        // receive()
        if (type === "receive") {
          var _inputs = consumeParams(obj);
          (0, index_js_1.assertArgument)(_inputs.length === 0, "receive cannot have arguments", "obj.inputs", _inputs);
          consumeKeywords(obj, setify(["payable"]));
          consumeEoi(obj);
          return new FallbackFragment(_guard, [], true);
        }
        // fallback() [payable]
        // fallback(bytes) [payable] returns (bytes)
        var inputs = consumeParams(obj);
        if (inputs.length) {
          (0, index_js_1.assertArgument)(inputs.length === 1 && inputs[0].type === "bytes", "invalid fallback inputs", "obj.inputs", inputs.map(function (i) {
            return i.format("minimal");
          }).join(", "));
        } else {
          inputs = [ParamType.from("bytes")];
        }
        var mutability = consumeMutability(obj);
        (0, index_js_1.assertArgument)(mutability === "nonpayable" || mutability === "payable", "fallback cannot be constants", "obj.stateMutability", mutability);
        if (consumeKeywords(obj, setify(["returns"])).has("returns")) {
          var outputs = consumeParams(obj);
          (0, index_js_1.assertArgument)(outputs.length === 1 && outputs[0].type === "bytes", "invalid fallback outputs", "obj.outputs", outputs.map(function (i) {
            return i.format("minimal");
          }).join(", "));
        }
        consumeEoi(obj);
        return new FallbackFragment(_guard, inputs, mutability === "payable");
      }
      if (obj.type === "receive") {
        return new FallbackFragment(_guard, [], true);
      }
      if (obj.type === "fallback") {
        var _inputs2 = [ParamType.from("bytes")];
        var payable = obj.stateMutability === "payable";
        return new FallbackFragment(_guard, _inputs2, payable);
      }
      (0, index_js_1.assertArgument)(false, "invalid fallback description", "obj", obj);
    }
    /**
     *  Returns ``true`` and provides a type guard if %%value%% is a
     *  **FallbackFragment**.
     */
  }, {
    key: "isFragment",
    value: function isFragment(value) {
      return value && value[internal] === FallbackFragmentInternal;
    }
  }]);
}(Fragment);
exports.FallbackFragment = FallbackFragment;
/**
 *  A Fragment which represents a method.
 */
var FunctionFragment = /*#__PURE__*/function (_NamedFragment4) {
  /**
   *  @private
   */
  function FunctionFragment(guard, name, stateMutability, inputs, outputs, gas) {
    var _this8;
    _classCallCheck(this, FunctionFragment);
    _this8 = _callSuper(this, FunctionFragment, [guard, "function", name, inputs]);
    /**
     *  If the function is constant (e.g. ``pure`` or ``view`` functions).
     */
    _defineProperty(_this8, "constant", void 0);
    /**
     *  The returned types for the result of calling this function.
     */
    _defineProperty(_this8, "outputs", void 0);
    /**
     *  The state mutability (e.g. ``payable``, ``nonpayable``, ``view``
     *  or ``pure``)
     */
    _defineProperty(_this8, "stateMutability", void 0);
    /**
     *  If the function can be sent value during invocation.
     */
    _defineProperty(_this8, "payable", void 0);
    /**
     *  The recommended gas limit to send when calling this function.
     */
    _defineProperty(_this8, "gas", void 0);
    Object.defineProperty(_this8, internal, {
      value: FunctionFragmentInternal
    });
    outputs = Object.freeze(outputs.slice());
    var constant = stateMutability === "view" || stateMutability === "pure";
    var payable = stateMutability === "payable";
    (0, index_js_1.defineProperties)(_this8, {
      constant: constant,
      gas: gas,
      outputs: outputs,
      payable: payable,
      stateMutability: stateMutability
    });
    return _this8;
  }
  /**
   *  The Function selector.
   */
  _inherits(FunctionFragment, _NamedFragment4);
  return _createClass(FunctionFragment, [{
    key: "selector",
    get: function get() {
      return (0, index_js_2.id)(this.format("sighash")).substring(0, 10);
    }
    /**
     *  Returns a string representation of this function as %%format%%.
     */
  }, {
    key: "format",
    value: function format(_format6) {
      if (_format6 == null) {
        _format6 = "sighash";
      }
      if (_format6 === "json") {
        return JSON.stringify({
          type: "function",
          name: this.name,
          constant: this.constant,
          stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : undefined,
          payable: this.payable,
          gas: this.gas != null ? this.gas : undefined,
          inputs: this.inputs.map(function (i) {
            return JSON.parse(i.format(_format6));
          }),
          outputs: this.outputs.map(function (o) {
            return JSON.parse(o.format(_format6));
          })
        });
      }
      var result = [];
      if (_format6 !== "sighash") {
        result.push("function");
      }
      result.push(this.name + joinParams(_format6, this.inputs));
      if (_format6 !== "sighash") {
        if (this.stateMutability !== "nonpayable") {
          result.push(this.stateMutability);
        }
        if (this.outputs && this.outputs.length) {
          result.push("returns");
          result.push(joinParams(_format6, this.outputs));
        }
        if (this.gas != null) {
          result.push("@".concat(this.gas.toString()));
        }
      }
      return result.join(" ");
    }
    /**
     *  Return the selector for a function with %%name%% and %%params%%.
     */
  }], [{
    key: "getSelector",
    value: function getSelector(name, params) {
      params = (params || []).map(function (p) {
        return ParamType.from(p);
      });
      var fragment = new FunctionFragment(_guard, name, "view", params, [], null);
      return fragment.selector;
    }
    /**
     *  Returns a new **FunctionFragment** for %%obj%%.
     */
  }, {
    key: "from",
    value: function from(obj) {
      if (FunctionFragment.isFragment(obj)) {
        return obj;
      }
      if (typeof obj === "string") {
        try {
          return FunctionFragment.from(lex(obj));
        } catch (error) {
          (0, index_js_1.assertArgument)(false, "invalid function fragment", "obj", obj);
        }
      } else if (obj instanceof TokenString) {
        var name = consumeName("function", obj);
        var inputs = consumeParams(obj);
        var mutability = consumeMutability(obj);
        var outputs = [];
        if (consumeKeywords(obj, setify(["returns"])).has("returns")) {
          outputs = consumeParams(obj);
        }
        var gas = consumeGas(obj);
        consumeEoi(obj);
        return new FunctionFragment(_guard, name, mutability, inputs, outputs, gas);
      }
      var stateMutability = obj.stateMutability;
      // Use legacy Solidity ABI logic if stateMutability is missing
      if (stateMutability == null) {
        stateMutability = "payable";
        if (typeof obj.constant === "boolean") {
          stateMutability = "view";
          if (!obj.constant) {
            stateMutability = "payable";
            if (typeof obj.payable === "boolean" && !obj.payable) {
              stateMutability = "nonpayable";
            }
          }
        } else if (typeof obj.payable === "boolean" && !obj.payable) {
          stateMutability = "nonpayable";
        }
      }
      // @TODO: verifyState for stateMutability (e.g. throw if
      //        payable: false but stateMutability is "nonpayable")
      return new FunctionFragment(_guard, obj.name, stateMutability, obj.inputs ? obj.inputs.map(ParamType.from) : [], obj.outputs ? obj.outputs.map(ParamType.from) : [], obj.gas != null ? obj.gas : null);
    }
    /**
     *  Returns ``true`` and provides a type guard if %%value%% is a
     *  **FunctionFragment**.
     */
  }, {
    key: "isFragment",
    value: function isFragment(value) {
      return value && value[internal] === FunctionFragmentInternal;
    }
  }]);
}(NamedFragment);
exports.FunctionFragment = FunctionFragment;
/**
 *  A Fragment which represents a structure.
 */
var StructFragment = /*#__PURE__*/function (_NamedFragment5) {
  /**
   *  @private
   */
  function StructFragment(guard, name, inputs) {
    var _this9;
    _classCallCheck(this, StructFragment);
    _this9 = _callSuper(this, StructFragment, [guard, "struct", name, inputs]);
    Object.defineProperty(_this9, internal, {
      value: StructFragmentInternal
    });
    return _this9;
  }
  /**
   *  Returns a string representation of this struct as %%format%%.
   */
  _inherits(StructFragment, _NamedFragment5);
  return _createClass(StructFragment, [{
    key: "format",
    value: function format() {
      throw new Error("@TODO");
    }
    /**
     *  Returns a new **StructFragment** for %%obj%%.
     */
  }], [{
    key: "from",
    value: function from(obj) {
      if (typeof obj === "string") {
        try {
          return StructFragment.from(lex(obj));
        } catch (error) {
          (0, index_js_1.assertArgument)(false, "invalid struct fragment", "obj", obj);
        }
      } else if (obj instanceof TokenString) {
        var name = consumeName("struct", obj);
        var inputs = consumeParams(obj);
        consumeEoi(obj);
        return new StructFragment(_guard, name, inputs);
      }
      return new StructFragment(_guard, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);
    }
    // @TODO: fix this return type
    /**
     *  Returns ``true`` and provides a type guard if %%value%% is a
     *  **StructFragment**.
     */
  }, {
    key: "isFragment",
    value: function isFragment(value) {
      return value && value[internal] === StructFragmentInternal;
    }
  }]);
}(NamedFragment);
exports.StructFragment = StructFragment;

},{"../hash/index.js":230,"../utils/index.js":276}],201:[function(require,module,exports){
"use strict";

/**
 *  The Application Binary Interface (ABI) describes how method input
 *  parameters should be encoded, their results decoded, and how to
 *  decode events and errors.
 *
 *  See [About ABIs](docs-abi) for more details how they are used.
 *
 *  @_section api/abi:Application Binary Interface  [about-abi]
 *  @_navTitle: ABI
 */
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Typed = exports.Result = exports.TransactionDescription = exports.LogDescription = exports.ErrorDescription = exports.Interface = exports.Indexed = exports.checkResultErrors = exports.StructFragment = exports.ParamType = exports.NamedFragment = exports.FunctionFragment = exports.Fragment = exports.FallbackFragment = exports.EventFragment = exports.ErrorFragment = exports.ConstructorFragment = exports.encodeBytes32String = exports.decodeBytes32String = exports.AbiCoder = void 0;
//////
var abi_coder_js_1 = require("./abi-coder.js");
Object.defineProperty(exports, "AbiCoder", {
  enumerable: true,
  get: function get() {
    return abi_coder_js_1.AbiCoder;
  }
});
var bytes32_js_1 = require("./bytes32.js");
Object.defineProperty(exports, "decodeBytes32String", {
  enumerable: true,
  get: function get() {
    return bytes32_js_1.decodeBytes32String;
  }
});
Object.defineProperty(exports, "encodeBytes32String", {
  enumerable: true,
  get: function get() {
    return bytes32_js_1.encodeBytes32String;
  }
});
var fragments_js_1 = require("./fragments.js");
Object.defineProperty(exports, "ConstructorFragment", {
  enumerable: true,
  get: function get() {
    return fragments_js_1.ConstructorFragment;
  }
});
Object.defineProperty(exports, "ErrorFragment", {
  enumerable: true,
  get: function get() {
    return fragments_js_1.ErrorFragment;
  }
});
Object.defineProperty(exports, "EventFragment", {
  enumerable: true,
  get: function get() {
    return fragments_js_1.EventFragment;
  }
});
Object.defineProperty(exports, "FallbackFragment", {
  enumerable: true,
  get: function get() {
    return fragments_js_1.FallbackFragment;
  }
});
Object.defineProperty(exports, "Fragment", {
  enumerable: true,
  get: function get() {
    return fragments_js_1.Fragment;
  }
});
Object.defineProperty(exports, "FunctionFragment", {
  enumerable: true,
  get: function get() {
    return fragments_js_1.FunctionFragment;
  }
});
Object.defineProperty(exports, "NamedFragment", {
  enumerable: true,
  get: function get() {
    return fragments_js_1.NamedFragment;
  }
});
Object.defineProperty(exports, "ParamType", {
  enumerable: true,
  get: function get() {
    return fragments_js_1.ParamType;
  }
});
Object.defineProperty(exports, "StructFragment", {
  enumerable: true,
  get: function get() {
    return fragments_js_1.StructFragment;
  }
});
var interface_js_1 = require("./interface.js");
Object.defineProperty(exports, "checkResultErrors", {
  enumerable: true,
  get: function get() {
    return interface_js_1.checkResultErrors;
  }
});
Object.defineProperty(exports, "Indexed", {
  enumerable: true,
  get: function get() {
    return interface_js_1.Indexed;
  }
});
Object.defineProperty(exports, "Interface", {
  enumerable: true,
  get: function get() {
    return interface_js_1.Interface;
  }
});
Object.defineProperty(exports, "ErrorDescription", {
  enumerable: true,
  get: function get() {
    return interface_js_1.ErrorDescription;
  }
});
Object.defineProperty(exports, "LogDescription", {
  enumerable: true,
  get: function get() {
    return interface_js_1.LogDescription;
  }
});
Object.defineProperty(exports, "TransactionDescription", {
  enumerable: true,
  get: function get() {
    return interface_js_1.TransactionDescription;
  }
});
Object.defineProperty(exports, "Result", {
  enumerable: true,
  get: function get() {
    return interface_js_1.Result;
  }
});
var typed_js_1 = require("./typed.js");
Object.defineProperty(exports, "Typed", {
  enumerable: true,
  get: function get() {
    return typed_js_1.Typed;
  }
});

},{"./abi-coder.js":187,"./bytes32.js":188,"./fragments.js":200,"./interface.js":202,"./typed.js":203}],202:[function(require,module,exports){
"use strict";

/**
 *  The Interface class is a low-level class that accepts an
 *  ABI and provides all the necessary functionality to encode
 *  and decode paramaters to and results from methods, events
 *  and errors.
 *
 *  It also provides several convenience methods to automatically
 *  search and find matching transactions and events to parse them.
 *
 *  @_subsection api/abi:Interfaces  [interfaces]
 */
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Interface = exports.Indexed = exports.ErrorDescription = exports.TransactionDescription = exports.LogDescription = exports.Result = exports.checkResultErrors = void 0;
var index_js_1 = require("../crypto/index.js");
var index_js_2 = require("../hash/index.js");
var index_js_3 = require("../utils/index.js");
var abi_coder_js_1 = require("./abi-coder.js");
var abstract_coder_js_1 = require("./coders/abstract-coder.js");
Object.defineProperty(exports, "checkResultErrors", {
  enumerable: true,
  get: function get() {
    return abstract_coder_js_1.checkResultErrors;
  }
});
Object.defineProperty(exports, "Result", {
  enumerable: true,
  get: function get() {
    return abstract_coder_js_1.Result;
  }
});
var fragments_js_1 = require("./fragments.js");
var typed_js_1 = require("./typed.js");
/**
 *  When using the [[Interface-parseLog]] to automatically match a Log to its event
 *  for parsing, a **LogDescription** is returned.
 */
var LogDescription = /*#__PURE__*/_createClass(
/**
 *  @_ignore:
 */
function LogDescription(fragment, topic, args) {
  _classCallCheck(this, LogDescription);
  /**
   *  The matching fragment for the ``topic0``.
   */
  _defineProperty(this, "fragment", void 0);
  /**
   *  The name of the Event.
   */
  _defineProperty(this, "name", void 0);
  /**
   *  The full Event signature.
   */
  _defineProperty(this, "signature", void 0);
  /**
   *  The topic hash for the Event.
   */
  _defineProperty(this, "topic", void 0);
  /**
   *  The arguments passed into the Event with ``emit``.
   */
  _defineProperty(this, "args", void 0);
  var name = fragment.name,
    signature = fragment.format();
  (0, index_js_3.defineProperties)(this, {
    fragment: fragment,
    name: name,
    signature: signature,
    topic: topic,
    args: args
  });
});
exports.LogDescription = LogDescription;
/**
 *  When using the [[Interface-parseTransaction]] to automatically match
 *  a transaction data to its function for parsing,
 *  a **TransactionDescription** is returned.
 */
var TransactionDescription = /*#__PURE__*/_createClass(
/**
 *  @_ignore:
 */
function TransactionDescription(fragment, selector, args, value) {
  _classCallCheck(this, TransactionDescription);
  /**
   *  The matching fragment from the transaction ``data``.
   */
  _defineProperty(this, "fragment", void 0);
  /**
   *  The name of the Function from the transaction ``data``.
   */
  _defineProperty(this, "name", void 0);
  /**
   *  The arguments passed to the Function from the transaction ``data``.
   */
  _defineProperty(this, "args", void 0);
  /**
   *  The full Function signature from the transaction ``data``.
   */
  _defineProperty(this, "signature", void 0);
  /**
   *  The selector for the Function from the transaction ``data``.
   */
  _defineProperty(this, "selector", void 0);
  /**
   *  The ``value`` (in wei) from the transaction.
   */
  _defineProperty(this, "value", void 0);
  var name = fragment.name,
    signature = fragment.format();
  (0, index_js_3.defineProperties)(this, {
    fragment: fragment,
    name: name,
    args: args,
    signature: signature,
    selector: selector,
    value: value
  });
});
exports.TransactionDescription = TransactionDescription;
/**
 *  When using the [[Interface-parseError]] to automatically match an
 *  error for a call result for parsing, an **ErrorDescription** is returned.
 */
var ErrorDescription = /*#__PURE__*/_createClass(
/**
 *  @_ignore:
 */
function ErrorDescription(fragment, selector, args) {
  _classCallCheck(this, ErrorDescription);
  /**
   *  The matching fragment.
   */
  _defineProperty(this, "fragment", void 0);
  /**
   *  The name of the Error.
   */
  _defineProperty(this, "name", void 0);
  /**
   *  The arguments passed to the Error with ``revert``.
   */
  _defineProperty(this, "args", void 0);
  /**
   *  The full Error signature.
   */
  _defineProperty(this, "signature", void 0);
  /**
   *  The selector for the Error.
   */
  _defineProperty(this, "selector", void 0);
  var name = fragment.name,
    signature = fragment.format();
  (0, index_js_3.defineProperties)(this, {
    fragment: fragment,
    name: name,
    args: args,
    signature: signature,
    selector: selector
  });
});
exports.ErrorDescription = ErrorDescription;
/**
 *  An **Indexed** is used as a value when a value that does not
 *  fit within a topic (i.e. not a fixed-length, 32-byte type). It
 *  is the ``keccak256`` of the value, and used for types such as
 *  arrays, tuples, bytes and strings.
 */
var Indexed = /*#__PURE__*/function () {
  /**
   *  @_ignore:
   */
  function Indexed(hash) {
    _classCallCheck(this, Indexed);
    /**
     *  The ``keccak256`` of the value logged.
     */
    _defineProperty(this, "hash", void 0);
    /**
     *  @_ignore:
     */
    _defineProperty(this, "_isIndexed", void 0);
    (0, index_js_3.defineProperties)(this, {
      hash: hash,
      _isIndexed: true
    });
  }
  return _createClass(Indexed, null, [{
    key: "isIndexed",
    value:
    /**
     *  Returns ``true`` if %%value%% is an **Indexed**.
     *
     *  This provides a Type Guard for property access.
     */
    function isIndexed(value) {
      return !!(value && value._isIndexed);
    }
  }]);
}();
exports.Indexed = Indexed;
// https://docs.soliditylang.org/en/v0.8.13/control-structures.html?highlight=panic#panic-via-assert-and-error-via-require
var PanicReasons = {
  "0": "generic panic",
  "1": "assert(false)",
  "17": "arithmetic overflow",
  "18": "division or modulo by zero",
  "33": "enum overflow",
  "34": "invalid encoded storage byte array accessed",
  "49": "out-of-bounds array access; popping on an empty array",
  "50": "out-of-bounds access of an array or bytesN",
  "65": "out of memory",
  "81": "uninitialized function"
};
var BuiltinErrors = {
  "0x08c379a0": {
    signature: "Error(string)",
    name: "Error",
    inputs: ["string"],
    reason: function reason(message) {
      return "reverted with reason string ".concat(JSON.stringify(message));
    }
  },
  "0x4e487b71": {
    signature: "Panic(uint256)",
    name: "Panic",
    inputs: ["uint256"],
    reason: function reason(code) {
      var reason = "unknown panic code";
      if (code >= 0 && code <= 0xff && PanicReasons[code.toString()]) {
        reason = PanicReasons[code.toString()];
      }
      return "reverted with panic code 0x".concat(code.toString(16), " (").concat(reason, ")");
    }
  }
};
/**
 *  An Interface abstracts many of the low-level details for
 *  encoding and decoding the data on the blockchain.
 *
 *  An ABI provides information on how to encode data to send to
 *  a Contract, how to decode the results and events and how to
 *  interpret revert errors.
 *
 *  The ABI can be specified by [any supported format](InterfaceAbi).
 */
var _errors = /*#__PURE__*/new WeakMap();
var _events = /*#__PURE__*/new WeakMap();
var _functions = /*#__PURE__*/new WeakMap();
var _abiCoder = /*#__PURE__*/new WeakMap();
var _Interface_brand = /*#__PURE__*/new WeakSet();
var Interface = /*#__PURE__*/function () {
  /**
   *  Create a new Interface for the %%fragments%%.
   */
  function Interface(fragments) {
    var _this = this;
    _classCallCheck(this, Interface);
    // Find a function definition by any means necessary (unless it is ambiguous)
    _classPrivateMethodInitSpec(this, _Interface_brand);
    /**
     *  All the Contract ABI members (i.e. methods, events, errors, etc).
     */
    _defineProperty(this, "fragments", void 0);
    /**
     *  The Contract constructor.
     */
    _defineProperty(this, "deploy", void 0);
    /**
     *  The Fallback method, if any.
     */
    _defineProperty(this, "fallback", void 0);
    /**
     *  If receiving ether is supported.
     */
    _defineProperty(this, "receive", void 0);
    _classPrivateFieldInitSpec(this, _errors, void 0);
    _classPrivateFieldInitSpec(this, _events, void 0);
    _classPrivateFieldInitSpec(this, _functions, void 0);
    //    #structs: Map<string, StructFragment>;
    _classPrivateFieldInitSpec(this, _abiCoder, void 0);
    var abi = [];
    if (typeof fragments === "string") {
      abi = JSON.parse(fragments);
    } else {
      abi = fragments;
    }
    _classPrivateFieldSet(_functions, this, new Map());
    _classPrivateFieldSet(_errors, this, new Map());
    _classPrivateFieldSet(_events, this, new Map());
    //        this.#structs = new Map();
    var frags = [];
    var _iterator = _createForOfIteratorHelper(abi),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var a = _step.value;
        try {
          frags.push(fragments_js_1.Fragment.from(a));
        } catch (error) {
          console.log("[Warning] Invalid Fragment ".concat(JSON.stringify(a), ":"), error.message);
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    (0, index_js_3.defineProperties)(this, {
      fragments: Object.freeze(frags)
    });
    var fallback = null;
    var receive = false;
    _classPrivateFieldSet(_abiCoder, this, this.getAbiCoder());
    // Add all fragments by their signature
    this.fragments.forEach(function (fragment, index) {
      var bucket;
      switch (fragment.type) {
        case "constructor":
          if (_this.deploy) {
            console.log("duplicate definition - constructor");
            return;
          }
          //checkNames(fragment, "input", fragment.inputs);
          (0, index_js_3.defineProperties)(_this, {
            deploy: fragment
          });
          return;
        case "fallback":
          if (fragment.inputs.length === 0) {
            receive = true;
          } else {
            (0, index_js_3.assertArgument)(!fallback || fragment.payable !== fallback.payable, "conflicting fallback fragments", "fragments[".concat(index, "]"), fragment);
            fallback = fragment;
            receive = fallback.payable;
          }
          return;
        case "function":
          //checkNames(fragment, "input", fragment.inputs);
          //checkNames(fragment, "output", (<FunctionFragment>fragment).outputs);
          bucket = _classPrivateFieldGet(_functions, _this);
          break;
        case "event":
          //checkNames(fragment, "input", fragment.inputs);
          bucket = _classPrivateFieldGet(_events, _this);
          break;
        case "error":
          bucket = _classPrivateFieldGet(_errors, _this);
          break;
        default:
          return;
      }
      // Two identical entries; ignore it
      var signature = fragment.format();
      if (bucket.has(signature)) {
        return;
      }
      bucket.set(signature, fragment);
    });
    // If we do not have a constructor add a default
    if (!this.deploy) {
      (0, index_js_3.defineProperties)(this, {
        deploy: fragments_js_1.ConstructorFragment.from("constructor()")
      });
    }
    (0, index_js_3.defineProperties)(this, {
      fallback: fallback,
      receive: receive
    });
  }
  /**
   *  Returns the entire Human-Readable ABI, as an array of
   *  signatures, optionally as %%minimal%% strings, which
   *  removes parameter names and unneceesary spaces.
   */
  return _createClass(Interface, [{
    key: "format",
    value: function format(minimal) {
      var format = minimal ? "minimal" : "full";
      var abi = this.fragments.map(function (f) {
        return f.format(format);
      });
      return abi;
    }
    /**
     *  Return the JSON-encoded ABI. This is the format Solidiy
     *  returns.
     */
  }, {
    key: "formatJson",
    value: function formatJson() {
      var abi = this.fragments.map(function (f) {
        return f.format("json");
      });
      // We need to re-bundle the JSON fragments a bit
      return JSON.stringify(abi.map(function (j) {
        return JSON.parse(j);
      }));
    }
    /**
     *  The ABI coder that will be used to encode and decode binary
     *  data.
     */
  }, {
    key: "getAbiCoder",
    value: function getAbiCoder() {
      return abi_coder_js_1.AbiCoder.defaultAbiCoder();
    }
  }, {
    key: "getFunctionName",
    value:
    /**
     *  Get the function name for %%key%%, which may be a function selector,
     *  function name or function signature that belongs to the ABI.
     */
    function getFunctionName(key) {
      var fragment = _assertClassBrand(_Interface_brand, this, _getFunction).call(this, key, null, false);
      (0, index_js_3.assertArgument)(fragment, "no matching function", "key", key);
      return fragment.name;
    }
    /**
     *  Returns true if %%key%% (a function selector, function name or
     *  function signature) is present in the ABI.
     *
     *  In the case of a function name, the name may be ambiguous, so
     *  accessing the [[FunctionFragment]] may require refinement.
     */
  }, {
    key: "hasFunction",
    value: function hasFunction(key) {
      return !!_assertClassBrand(_Interface_brand, this, _getFunction).call(this, key, null, false);
    }
    /**
     *  Get the [[FunctionFragment]] for %%key%%, which may be a function
     *  selector, function name or function signature that belongs to the ABI.
     *
     *  If %%values%% is provided, it will use the Typed API to handle
     *  ambiguous cases where multiple functions match by name.
     *
     *  If the %%key%% and %%values%% do not refine to a single function in
     *  the ABI, this will throw.
     */
  }, {
    key: "getFunction",
    value: function getFunction(key, values) {
      return _assertClassBrand(_Interface_brand, this, _getFunction).call(this, key, values || null, true);
    }
    /**
     *  Iterate over all functions, calling %%callback%%, sorted by their name.
     */
  }, {
    key: "forEachFunction",
    value: function forEachFunction(callback) {
      var names = Array.from(_classPrivateFieldGet(_functions, this).keys());
      names.sort(function (a, b) {
        return a.localeCompare(b);
      });
      for (var i = 0; i < names.length; i++) {
        var name = names[i];
        callback(_classPrivateFieldGet(_functions, this).get(name), i);
      }
    }
    // Find an event definition by any means necessary (unless it is ambiguous)
  }, {
    key: "getEventName",
    value:
    /**
     *  Get the event name for %%key%%, which may be a topic hash,
     *  event name or event signature that belongs to the ABI.
     */
    function getEventName(key) {
      var fragment = _assertClassBrand(_Interface_brand, this, _getEvent).call(this, key, null, false);
      (0, index_js_3.assertArgument)(fragment, "no matching event", "key", key);
      return fragment.name;
    }
    /**
     *  Returns true if %%key%% (an event topic hash, event name or
     *  event signature) is present in the ABI.
     *
     *  In the case of an event name, the name may be ambiguous, so
     *  accessing the [[EventFragment]] may require refinement.
     */
  }, {
    key: "hasEvent",
    value: function hasEvent(key) {
      return !!_assertClassBrand(_Interface_brand, this, _getEvent).call(this, key, null, false);
    }
    /**
     *  Get the [[EventFragment]] for %%key%%, which may be a topic hash,
     *  event name or event signature that belongs to the ABI.
     *
     *  If %%values%% is provided, it will use the Typed API to handle
     *  ambiguous cases where multiple events match by name.
     *
     *  If the %%key%% and %%values%% do not refine to a single event in
     *  the ABI, this will throw.
     */
  }, {
    key: "getEvent",
    value: function getEvent(key, values) {
      return _assertClassBrand(_Interface_brand, this, _getEvent).call(this, key, values || null, true);
    }
    /**
     *  Iterate over all events, calling %%callback%%, sorted by their name.
     */
  }, {
    key: "forEachEvent",
    value: function forEachEvent(callback) {
      var names = Array.from(_classPrivateFieldGet(_events, this).keys());
      names.sort(function (a, b) {
        return a.localeCompare(b);
      });
      for (var i = 0; i < names.length; i++) {
        var name = names[i];
        callback(_classPrivateFieldGet(_events, this).get(name), i);
      }
    }
    /**
     *  Get the [[ErrorFragment]] for %%key%%, which may be an error
     *  selector, error name or error signature that belongs to the ABI.
     *
     *  If %%values%% is provided, it will use the Typed API to handle
     *  ambiguous cases where multiple errors match by name.
     *
     *  If the %%key%% and %%values%% do not refine to a single error in
     *  the ABI, this will throw.
     */
  }, {
    key: "getError",
    value: function getError(key, values) {
      if ((0, index_js_3.isHexString)(key)) {
        var selector = key.toLowerCase();
        if (BuiltinErrors[selector]) {
          return fragments_js_1.ErrorFragment.from(BuiltinErrors[selector].signature);
        }
        var _iterator2 = _createForOfIteratorHelper(_classPrivateFieldGet(_errors, this).values()),
          _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var fragment = _step2.value;
            if (selector === fragment.selector) {
              return fragment;
            }
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
        return null;
      }
      // It is a bare name, look up the function (will return null if ambiguous)
      if (key.indexOf("(") === -1) {
        var matching = [];
        var _iterator3 = _createForOfIteratorHelper(_classPrivateFieldGet(_errors, this)),
          _step3;
        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var _step3$value = _slicedToArray(_step3.value, 2),
              name = _step3$value[0],
              _fragment = _step3$value[1];
            if (name.split("(" /* fix:) */)[0] === key) {
              matching.push(_fragment);
            }
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
        if (matching.length === 0) {
          if (key === "Error") {
            return fragments_js_1.ErrorFragment.from("error Error(string)");
          }
          if (key === "Panic") {
            return fragments_js_1.ErrorFragment.from("error Panic(uint256)");
          }
          return null;
        } else if (matching.length > 1) {
          var matchStr = matching.map(function (m) {
            return JSON.stringify(m.format());
          }).join(", ");
          (0, index_js_3.assertArgument)(false, "ambiguous error description (i.e. ".concat(matchStr, ")"), "name", key);
        }
        return matching[0];
      }
      // Normalize the signature and lookup the function
      key = fragments_js_1.ErrorFragment.from(key).format();
      if (key === "Error(string)") {
        return fragments_js_1.ErrorFragment.from("error Error(string)");
      }
      if (key === "Panic(uint256)") {
        return fragments_js_1.ErrorFragment.from("error Panic(uint256)");
      }
      var result = _classPrivateFieldGet(_errors, this).get(key);
      if (result) {
        return result;
      }
      return null;
    }
    /**
     *  Iterate over all errors, calling %%callback%%, sorted by their name.
     */
  }, {
    key: "forEachError",
    value: function forEachError(callback) {
      var names = Array.from(_classPrivateFieldGet(_errors, this).keys());
      names.sort(function (a, b) {
        return a.localeCompare(b);
      });
      for (var i = 0; i < names.length; i++) {
        var name = names[i];
        callback(_classPrivateFieldGet(_errors, this).get(name), i);
      }
    }
    // Get the 4-byte selector used by Solidity to identify a function
    /*
    getSelector(fragment: ErrorFragment | FunctionFragment): string {
    if (typeof(fragment) === "string") {
        const matches: Array<Fragment> = [ ];
         try { matches.push(this.getFunction(fragment)); } catch (error) { }
        try { matches.push(this.getError(<string>fragment)); } catch (_) { }
         if (matches.length === 0) {
            logger.throwArgumentError("unknown fragment", "key", fragment);
        } else if (matches.length > 1) {
            logger.throwArgumentError("ambiguous fragment matches function and error", "key", fragment);
        }
         fragment = matches[0];
    }
     return dataSlice(id(fragment.format()), 0, 4);
    }
    */
    // Get the 32-byte topic hash used by Solidity to identify an event
    /*
    getEventTopic(fragment: EventFragment): string {
        //if (typeof(fragment) === "string") { fragment = this.getEvent(eventFragment); }
        return id(fragment.format());
    }
    */
  }, {
    key: "_decodeParams",
    value: function _decodeParams(params, data) {
      return _classPrivateFieldGet(_abiCoder, this).decode(params, data);
    }
  }, {
    key: "_encodeParams",
    value: function _encodeParams(params, values) {
      return _classPrivateFieldGet(_abiCoder, this).encode(params, values);
    }
    /**
     *  Encodes a ``tx.data`` object for deploying the Contract with
     *  the %%values%% as the constructor arguments.
     */
  }, {
    key: "encodeDeploy",
    value: function encodeDeploy(values) {
      return this._encodeParams(this.deploy.inputs, values || []);
    }
    /**
     *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the
     *  specified error (see [[getError]] for valid values for
     *  %%key%%).
     *
     *  Most developers should prefer the [[parseCallResult]] method instead,
     *  which will automatically detect a ``CALL_EXCEPTION`` and throw the
     *  corresponding error.
     */
  }, {
    key: "decodeErrorResult",
    value: function decodeErrorResult(fragment, data) {
      if (typeof fragment === "string") {
        var f = this.getError(fragment);
        (0, index_js_3.assertArgument)(f, "unknown error", "fragment", fragment);
        fragment = f;
      }
      (0, index_js_3.assertArgument)((0, index_js_3.dataSlice)(data, 0, 4) === fragment.selector, "data signature does not match error ".concat(fragment.name, "."), "data", data);
      return this._decodeParams(fragment.inputs, (0, index_js_3.dataSlice)(data, 4));
    }
    /**
     *  Encodes the transaction revert data for a call result that
     *  reverted from the the Contract with the sepcified %%error%%
     *  (see [[getError]] for valid values for %%fragment%%) with the %%values%%.
     *
     *  This is generally not used by most developers, unless trying to mock
     *  a result from a Contract.
     */
  }, {
    key: "encodeErrorResult",
    value: function encodeErrorResult(fragment, values) {
      if (typeof fragment === "string") {
        var f = this.getError(fragment);
        (0, index_js_3.assertArgument)(f, "unknown error", "fragment", fragment);
        fragment = f;
      }
      return (0, index_js_3.concat)([fragment.selector, this._encodeParams(fragment.inputs, values || [])]);
    }
    /**
     *  Decodes the %%data%% from a transaction ``tx.data`` for
     *  the function specified (see [[getFunction]] for valid values
     *  for %%fragment%%).
     *
     *  Most developers should prefer the [[parseTransaction]] method
     *  instead, which will automatically detect the fragment.
     */
  }, {
    key: "decodeFunctionData",
    value: function decodeFunctionData(fragment, data) {
      if (typeof fragment === "string") {
        var f = this.getFunction(fragment);
        (0, index_js_3.assertArgument)(f, "unknown function", "fragment", fragment);
        fragment = f;
      }
      (0, index_js_3.assertArgument)((0, index_js_3.dataSlice)(data, 0, 4) === fragment.selector, "data signature does not match function ".concat(fragment.name, "."), "data", data);
      return this._decodeParams(fragment.inputs, (0, index_js_3.dataSlice)(data, 4));
    }
    /**
     *  Encodes the ``tx.data`` for a transaction that calls the function
     *  specified (see [[getFunction]] for valid values for %%fragment%%) with
     *  the %%values%%.
     */
  }, {
    key: "encodeFunctionData",
    value: function encodeFunctionData(fragment, values) {
      if (typeof fragment === "string") {
        var f = this.getFunction(fragment);
        (0, index_js_3.assertArgument)(f, "unknown function", "fragment", fragment);
        fragment = f;
      }
      return (0, index_js_3.concat)([fragment.selector, this._encodeParams(fragment.inputs, values || [])]);
    }
    /**
     *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the
     *  specified function (see [[getFunction]] for valid values for
     *  %%key%%).
     *
     *  Most developers should prefer the [[parseCallResult]] method instead,
     *  which will automatically detect a ``CALL_EXCEPTION`` and throw the
     *  corresponding error.
     */
  }, {
    key: "decodeFunctionResult",
    value: function decodeFunctionResult(fragment, data) {
      if (typeof fragment === "string") {
        var f = this.getFunction(fragment);
        (0, index_js_3.assertArgument)(f, "unknown function", "fragment", fragment);
        fragment = f;
      }
      var message = "invalid length for result data";
      var bytes = (0, index_js_3.getBytesCopy)(data);
      if (bytes.length % 32 === 0) {
        try {
          return _classPrivateFieldGet(_abiCoder, this).decode(fragment.outputs, bytes);
        } catch (error) {
          message = "could not decode result data";
        }
      }
      // Call returned data with no error, but the data is junk
      (0, index_js_3.assert)(false, message, "BAD_DATA", {
        value: (0, index_js_3.hexlify)(bytes),
        info: {
          method: fragment.name,
          signature: fragment.format()
        }
      });
    }
  }, {
    key: "makeError",
    value: function makeError(_data, tx) {
      var data = (0, index_js_3.getBytes)(_data, "data");
      var error = abi_coder_js_1.AbiCoder.getBuiltinCallException("call", tx, data);
      // Not a built-in error; try finding a custom error
      var customPrefix = "execution reverted (unknown custom error)";
      if (error.message.startsWith(customPrefix)) {
        var selector = (0, index_js_3.hexlify)(data.slice(0, 4));
        var ef = this.getError(selector);
        if (ef) {
          try {
            var args = _classPrivateFieldGet(_abiCoder, this).decode(ef.inputs, data.slice(4));
            error.revert = {
              name: ef.name,
              signature: ef.format(),
              args: args
            };
            error.reason = error.revert.signature;
            error.message = "execution reverted: ".concat(error.reason);
          } catch (e) {
            error.message = "execution reverted (coult not decode custom error)";
          }
        }
      }
      // Add the invocation, if available
      var parsed = this.parseTransaction(tx);
      if (parsed) {
        error.invocation = {
          method: parsed.name,
          signature: parsed.signature,
          args: parsed.args
        };
      }
      return error;
    }
    /**
     *  Encodes the result data (e.g. from an ``eth_call``) for the
     *  specified function (see [[getFunction]] for valid values
     *  for %%fragment%%) with %%values%%.
     *
     *  This is generally not used by most developers, unless trying to mock
     *  a result from a Contract.
     */
  }, {
    key: "encodeFunctionResult",
    value: function encodeFunctionResult(fragment, values) {
      if (typeof fragment === "string") {
        var f = this.getFunction(fragment);
        (0, index_js_3.assertArgument)(f, "unknown function", "fragment", fragment);
        fragment = f;
      }
      return (0, index_js_3.hexlify)(_classPrivateFieldGet(_abiCoder, this).encode(fragment.outputs, values || []));
    }
    /*
        spelunk(inputs: Array<ParamType>, values: ReadonlyArray<any>, processfunc: (type: string, value: any) => Promise<any>): Promise<Array<any>> {
            const promises: Array<Promise<>> = [ ];
            const process = function(type: ParamType, value: any): any {
                if (type.baseType === "array") {
                    return descend(type.child
                }
                if (type. === "address") {
                }
            };
    
            const descend = function (inputs: Array<ParamType>, values: ReadonlyArray<any>) {
                if (inputs.length !== values.length) { throw new Error("length mismatch"); }
                
            };
    
            const result: Array<any> = [ ];
            values.forEach((value, index) => {
                if (value == null) {
                    topics.push(null);
                } else if (param.baseType === "array" || param.baseType === "tuple") {
                    logger.throwArgumentError("filtering with tuples or arrays not supported", ("contract." + param.name), value);
                } else if (Array.isArray(value)) {
                    topics.push(value.map((value) => encodeTopic(param, value)));
                } else {
                    topics.push(encodeTopic(param, value));
                }
            });
        }
    */
    // Create the filter for the event with search criteria (e.g. for eth_filterLog)
  }, {
    key: "encodeFilterTopics",
    value: function encodeFilterTopics(fragment, values) {
      var _this2 = this;
      if (typeof fragment === "string") {
        var f = this.getEvent(fragment);
        (0, index_js_3.assertArgument)(f, "unknown event", "eventFragment", fragment);
        fragment = f;
      }
      (0, index_js_3.assert)(values.length <= fragment.inputs.length, "too many arguments for ".concat(fragment.format()), "UNEXPECTED_ARGUMENT", {
        count: values.length,
        expectedCount: fragment.inputs.length
      });
      var topics = [];
      if (!fragment.anonymous) {
        topics.push(fragment.topicHash);
      }
      // @TODO: Use the coders for this; to properly support tuples, etc.
      var encodeTopic = function encodeTopic(param, value) {
        if (param.type === "string") {
          return (0, index_js_2.id)(value);
        } else if (param.type === "bytes") {
          return (0, index_js_1.keccak256)((0, index_js_3.hexlify)(value));
        }
        if (param.type === "bool" && typeof value === "boolean") {
          value = value ? "0x01" : "0x00";
        } else if (param.type.match(/^u?int/)) {
          value = (0, index_js_3.toBeHex)(value); // @TODO: Should this toTwos??
        } else if (param.type.match(/^bytes/)) {
          value = (0, index_js_3.zeroPadBytes)(value, 32);
        } else if (param.type === "address") {
          // Check addresses are valid
          _classPrivateFieldGet(_abiCoder, _this2).encode(["address"], [value]);
        }
        return (0, index_js_3.zeroPadValue)((0, index_js_3.hexlify)(value), 32);
      };
      values.forEach(function (value, index) {
        var param = fragment.inputs[index];
        if (!param.indexed) {
          (0, index_js_3.assertArgument)(value == null, "cannot filter non-indexed parameters; must be null", "contract." + param.name, value);
          return;
        }
        if (value == null) {
          topics.push(null);
        } else if (param.baseType === "array" || param.baseType === "tuple") {
          (0, index_js_3.assertArgument)(false, "filtering with tuples or arrays not supported", "contract." + param.name, value);
        } else if (Array.isArray(value)) {
          topics.push(value.map(function (value) {
            return encodeTopic(param, value);
          }));
        } else {
          topics.push(encodeTopic(param, value));
        }
      });
      // Trim off trailing nulls
      while (topics.length && topics[topics.length - 1] === null) {
        topics.pop();
      }
      return topics;
    }
  }, {
    key: "encodeEventLog",
    value: function encodeEventLog(fragment, values) {
      var _this3 = this;
      if (typeof fragment === "string") {
        var f = this.getEvent(fragment);
        (0, index_js_3.assertArgument)(f, "unknown event", "eventFragment", fragment);
        fragment = f;
      }
      var topics = [];
      var dataTypes = [];
      var dataValues = [];
      if (!fragment.anonymous) {
        topics.push(fragment.topicHash);
      }
      (0, index_js_3.assertArgument)(values.length === fragment.inputs.length, "event arguments/values mismatch", "values", values);
      fragment.inputs.forEach(function (param, index) {
        var value = values[index];
        if (param.indexed) {
          if (param.type === "string") {
            topics.push((0, index_js_2.id)(value));
          } else if (param.type === "bytes") {
            topics.push((0, index_js_1.keccak256)(value));
          } else if (param.baseType === "tuple" || param.baseType === "array") {
            // @TODO
            throw new Error("not implemented");
          } else {
            topics.push(_classPrivateFieldGet(_abiCoder, _this3).encode([param.type], [value]));
          }
        } else {
          dataTypes.push(param);
          dataValues.push(value);
        }
      });
      return {
        data: _classPrivateFieldGet(_abiCoder, this).encode(dataTypes, dataValues),
        topics: topics
      };
    }
    // Decode a filter for the event and the search criteria
  }, {
    key: "decodeEventLog",
    value: function decodeEventLog(fragment, data, topics) {
      if (typeof fragment === "string") {
        var f = this.getEvent(fragment);
        (0, index_js_3.assertArgument)(f, "unknown event", "eventFragment", fragment);
        fragment = f;
      }
      if (topics != null && !fragment.anonymous) {
        var eventTopic = fragment.topicHash;
        (0, index_js_3.assertArgument)((0, index_js_3.isHexString)(topics[0], 32) && topics[0].toLowerCase() === eventTopic, "fragment/topic mismatch", "topics[0]", topics[0]);
        topics = topics.slice(1);
      }
      var indexed = [];
      var nonIndexed = [];
      var dynamic = [];
      fragment.inputs.forEach(function (param, index) {
        if (param.indexed) {
          if (param.type === "string" || param.type === "bytes" || param.baseType === "tuple" || param.baseType === "array") {
            indexed.push(fragments_js_1.ParamType.from({
              type: "bytes32",
              name: param.name
            }));
            dynamic.push(true);
          } else {
            indexed.push(param);
            dynamic.push(false);
          }
        } else {
          nonIndexed.push(param);
          dynamic.push(false);
        }
      });
      var resultIndexed = topics != null ? _classPrivateFieldGet(_abiCoder, this).decode(indexed, (0, index_js_3.concat)(topics)) : null;
      var resultNonIndexed = _classPrivateFieldGet(_abiCoder, this).decode(nonIndexed, data, true);
      //const result: (Array<any> & { [ key: string ]: any }) = [ ];
      var values = [];
      var keys = [];
      var nonIndexedIndex = 0,
        indexedIndex = 0;
      fragment.inputs.forEach(function (param, index) {
        var value = null;
        if (param.indexed) {
          if (resultIndexed == null) {
            value = new Indexed(null);
          } else if (dynamic[index]) {
            value = new Indexed(resultIndexed[indexedIndex++]);
          } else {
            try {
              value = resultIndexed[indexedIndex++];
            } catch (error) {
              value = error;
            }
          }
        } else {
          try {
            value = resultNonIndexed[nonIndexedIndex++];
          } catch (error) {
            value = error;
          }
        }
        values.push(value);
        keys.push(param.name || null);
      });
      return abstract_coder_js_1.Result.fromItems(values, keys);
    }
    /**
     *  Parses a transaction, finding the matching function and extracts
     *  the parameter values along with other useful function details.
     *
     *  If the matching function cannot be found, return null.
     */
  }, {
    key: "parseTransaction",
    value: function parseTransaction(tx) {
      var data = (0, index_js_3.getBytes)(tx.data, "tx.data");
      var value = (0, index_js_3.getBigInt)(tx.value != null ? tx.value : 0, "tx.value");
      var fragment = this.getFunction((0, index_js_3.hexlify)(data.slice(0, 4)));
      if (!fragment) {
        return null;
      }
      var args = _classPrivateFieldGet(_abiCoder, this).decode(fragment.inputs, data.slice(4));
      return new TransactionDescription(fragment, fragment.selector, args, value);
    }
  }, {
    key: "parseCallResult",
    value: function parseCallResult(data) {
      throw new Error("@TODO");
    }
    /**
     *  Parses a receipt log, finding the matching event and extracts
     *  the parameter values along with other useful event details.
     *
     *  If the matching event cannot be found, returns null.
     */
  }, {
    key: "parseLog",
    value: function parseLog(log) {
      var fragment = this.getEvent(log.topics[0]);
      if (!fragment || fragment.anonymous) {
        return null;
      }
      // @TODO: If anonymous, and the only method, and the input count matches, should we parse?
      //        Probably not, because just because it is the only event in the ABI does
      //        not mean we have the full ABI; maybe just a fragment?
      return new LogDescription(fragment, fragment.topicHash, this.decodeEventLog(fragment, log.data, log.topics));
    }
    /**
     *  Parses a revert data, finding the matching error and extracts
     *  the parameter values along with other useful error details.
     *
     *  If the matching error cannot be found, returns null.
     */
  }, {
    key: "parseError",
    value: function parseError(data) {
      var hexData = (0, index_js_3.hexlify)(data);
      var fragment = this.getError((0, index_js_3.dataSlice)(hexData, 0, 4));
      if (!fragment) {
        return null;
      }
      var args = _classPrivateFieldGet(_abiCoder, this).decode(fragment.inputs, (0, index_js_3.dataSlice)(hexData, 4));
      return new ErrorDescription(fragment, fragment.selector, args);
    }
    /**
     *  Creates a new [[Interface]] from the ABI %%value%%.
     *
     *  The %%value%% may be provided as an existing [[Interface]] object,
     *  a JSON-encoded ABI or any Human-Readable ABI format.
     */
  }], [{
    key: "from",
    value: function from(value) {
      // Already an Interface, which is immutable
      if (value instanceof Interface) {
        return value;
      }
      // JSON
      if (typeof value === "string") {
        return new Interface(JSON.parse(value));
      }
      // An Interface; possibly from another v6 instance
      if (typeof value.formatJson === "function") {
        return new Interface(value.formatJson());
      }
      // A legacy Interface; from an older version
      if (typeof value.format === "function") {
        return new Interface(value.format("json"));
      }
      // Array of fragments
      return new Interface(value);
    }
  }]);
}();
function _getFunction(key, values, forceUnique) {
  // Selector
  if ((0, index_js_3.isHexString)(key)) {
    var selector = key.toLowerCase();
    var _iterator4 = _createForOfIteratorHelper(_classPrivateFieldGet(_functions, this).values()),
      _step4;
    try {
      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
        var fragment = _step4.value;
        if (selector === fragment.selector) {
          return fragment;
        }
      }
    } catch (err) {
      _iterator4.e(err);
    } finally {
      _iterator4.f();
    }
    return null;
  }
  // It is a bare name, look up the function (will return null if ambiguous)
  if (key.indexOf("(") === -1) {
    var matching = [];
    var _iterator5 = _createForOfIteratorHelper(_classPrivateFieldGet(_functions, this)),
      _step5;
    try {
      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
        var _step5$value = _slicedToArray(_step5.value, 2),
          name = _step5$value[0],
          _fragment2 = _step5$value[1];
        if (name.split("(" /* fix:) */)[0] === key) {
          matching.push(_fragment2);
        }
      }
    } catch (err) {
      _iterator5.e(err);
    } finally {
      _iterator5.f();
    }
    if (values) {
      var lastValue = values.length > 0 ? values[values.length - 1] : null;
      var valueLength = values.length;
      var allowOptions = true;
      if (typed_js_1.Typed.isTyped(lastValue) && lastValue.type === "overrides") {
        allowOptions = false;
        valueLength--;
      }
      // Remove all matches that don't have a compatible length. The args
      // may contain an overrides, so the match may have n or n - 1 parameters
      for (var i = matching.length - 1; i >= 0; i--) {
        var inputs = matching[i].inputs.length;
        if (inputs !== valueLength && (!allowOptions || inputs !== valueLength - 1)) {
          matching.splice(i, 1);
        }
      }
      // Remove all matches that don't match the Typed signature
      for (var _i = matching.length - 1; _i >= 0; _i--) {
        var _inputs = matching[_i].inputs;
        for (var j = 0; j < values.length; j++) {
          // Not a typed value
          if (!typed_js_1.Typed.isTyped(values[j])) {
            continue;
          }
          // We are past the inputs
          if (j >= _inputs.length) {
            if (values[j].type === "overrides") {
              continue;
            }
            matching.splice(_i, 1);
            break;
          }
          // Make sure the value type matches the input type
          if (values[j].type !== _inputs[j].baseType) {
            matching.splice(_i, 1);
            break;
          }
        }
      }
    }
    // We found a single matching signature with an overrides, but the
    // last value is something that cannot possibly be an options
    if (matching.length === 1 && values && values.length !== matching[0].inputs.length) {
      var lastArg = values[values.length - 1];
      if (lastArg == null || Array.isArray(lastArg) || _typeof(lastArg) !== "object") {
        matching.splice(0, 1);
      }
    }
    if (matching.length === 0) {
      return null;
    }
    if (matching.length > 1 && forceUnique) {
      var matchStr = matching.map(function (m) {
        return JSON.stringify(m.format());
      }).join(", ");
      (0, index_js_3.assertArgument)(false, "ambiguous function description (i.e. matches ".concat(matchStr, ")"), "key", key);
    }
    return matching[0];
  }
  // Normalize the signature and lookup the function
  var result = _classPrivateFieldGet(_functions, this).get(fragments_js_1.FunctionFragment.from(key).format());
  if (result) {
    return result;
  }
  return null;
}
function _getEvent(key, values, forceUnique) {
  // EventTopic
  if ((0, index_js_3.isHexString)(key)) {
    var eventTopic = key.toLowerCase();
    var _iterator6 = _createForOfIteratorHelper(_classPrivateFieldGet(_events, this).values()),
      _step6;
    try {
      for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
        var fragment = _step6.value;
        if (eventTopic === fragment.topicHash) {
          return fragment;
        }
      }
    } catch (err) {
      _iterator6.e(err);
    } finally {
      _iterator6.f();
    }
    return null;
  }
  // It is a bare name, look up the function (will return null if ambiguous)
  if (key.indexOf("(") === -1) {
    var matching = [];
    var _iterator7 = _createForOfIteratorHelper(_classPrivateFieldGet(_events, this)),
      _step7;
    try {
      for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
        var _step7$value = _slicedToArray(_step7.value, 2),
          name = _step7$value[0],
          _fragment3 = _step7$value[1];
        if (name.split("(" /* fix:) */)[0] === key) {
          matching.push(_fragment3);
        }
      }
    } catch (err) {
      _iterator7.e(err);
    } finally {
      _iterator7.f();
    }
    if (values) {
      // Remove all matches that don't have a compatible length.
      for (var i = matching.length - 1; i >= 0; i--) {
        if (matching[i].inputs.length < values.length) {
          matching.splice(i, 1);
        }
      }
      // Remove all matches that don't match the Typed signature
      for (var _i2 = matching.length - 1; _i2 >= 0; _i2--) {
        var inputs = matching[_i2].inputs;
        for (var j = 0; j < values.length; j++) {
          // Not a typed value
          if (!typed_js_1.Typed.isTyped(values[j])) {
            continue;
          }
          // Make sure the value type matches the input type
          if (values[j].type !== inputs[j].baseType) {
            matching.splice(_i2, 1);
            break;
          }
        }
      }
    }
    if (matching.length === 0) {
      return null;
    }
    if (matching.length > 1 && forceUnique) {
      var matchStr = matching.map(function (m) {
        return JSON.stringify(m.format());
      }).join(", ");
      (0, index_js_3.assertArgument)(false, "ambiguous event description (i.e. matches ".concat(matchStr, ")"), "key", key);
    }
    return matching[0];
  }
  // Normalize the signature and lookup the function
  var result = _classPrivateFieldGet(_events, this).get(fragments_js_1.EventFragment.from(key).format());
  if (result) {
    return result;
  }
  return null;
}
exports.Interface = Interface;

},{"../crypto/index.js":219,"../hash/index.js":230,"../utils/index.js":276,"./abi-coder.js":187,"./coders/abstract-coder.js":189,"./fragments.js":200,"./typed.js":203}],203:[function(require,module,exports){
"use strict";

/**
 *  A Typed object allows a value to have its type explicitly
 *  specified.
 *
 *  For example, in Solidity, the value ``45`` could represent a
 *  ``uint8`` or a ``uint256``. The value ``0x1234`` could represent
 *  a ``bytes2`` or ``bytes``.
 *
 *  Since JavaScript has no meaningful way to explicitly inform any
 *  APIs which what the type is, this allows transparent interoperation
 *  with Soldity.
 *
 *  @_subsection: api/abi:Typed Values
 */
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Typed = void 0;
var index_js_1 = require("../utils/index.js");
var _gaurd = {};
function n(value, width) {
  var signed = false;
  if (width < 0) {
    signed = true;
    width *= -1;
  }
  // @TODO: Check range is valid for value
  return new Typed(_gaurd, "".concat(signed ? "" : "u", "int").concat(width), value, {
    signed: signed,
    width: width
  });
}
function b(value, size) {
  // @TODO: Check range is valid for value
  return new Typed(_gaurd, "bytes".concat(size ? size : ""), value, {
    size: size
  });
}
var _typedSymbol = Symbol["for"]("_ethers_typed");
/**
 *  The **Typed** class to wrap values providing explicit type information.
 */
var _options = /*#__PURE__*/new WeakMap();
var Typed = /*#__PURE__*/function () {
  /**
   *  @_ignore:
   */
  function Typed(gaurd, type, value, options) {
    _classCallCheck(this, Typed);
    /**
     *  The type, as a Solidity-compatible type.
     */
    _defineProperty(this, "type", void 0);
    /**
     *  The actual value.
     */
    _defineProperty(this, "value", void 0);
    _classPrivateFieldInitSpec(this, _options, void 0);
    /**
     *  @_ignore:
     */
    _defineProperty(this, "_typedSymbol", void 0);
    if (options == null) {
      options = null;
    }
    (0, index_js_1.assertPrivate)(_gaurd, gaurd, "Typed");
    (0, index_js_1.defineProperties)(this, {
      _typedSymbol: _typedSymbol,
      type: type,
      value: value
    });
    _classPrivateFieldSet(_options, this, options);
    // Check the value is valid
    this.format();
  }
  /**
   *  Format the type as a Human-Readable type.
   */
  return _createClass(Typed, [{
    key: "format",
    value: function format() {
      if (this.type === "array") {
        throw new Error("");
      } else if (this.type === "dynamicArray") {
        throw new Error("");
      } else if (this.type === "tuple") {
        return "tuple(".concat(this.value.map(function (v) {
          return v.format();
        }).join(","), ")");
      }
      return this.type;
    }
    /**
     *  The default value returned by this type.
     */
  }, {
    key: "defaultValue",
    value: function defaultValue() {
      return 0;
    }
    /**
     *  The minimum value for numeric types.
     */
  }, {
    key: "minValue",
    value: function minValue() {
      return 0;
    }
    /**
     *  The maximum value for numeric types.
     */
  }, {
    key: "maxValue",
    value: function maxValue() {
      return 0;
    }
    /**
     *  Returns ``true`` and provides a type guard is this is a [[TypedBigInt]].
     */
  }, {
    key: "isBigInt",
    value: function isBigInt() {
      return !!this.type.match(/^u?int[0-9]+$/);
    }
    /**
     *  Returns ``true`` and provides a type guard is this is a [[TypedData]].
     */
  }, {
    key: "isData",
    value: function isData() {
      return this.type.startsWith("bytes");
    }
    /**
     *  Returns ``true`` and provides a type guard is this is a [[TypedString]].
     */
  }, {
    key: "isString",
    value: function isString() {
      return this.type === "string";
    }
    /**
     *  Returns the tuple name, if this is a tuple. Throws otherwise.
     */
  }, {
    key: "tupleName",
    get: function get() {
      if (this.type !== "tuple") {
        throw TypeError("not a tuple");
      }
      return _classPrivateFieldGet(_options, this);
    }
    // Returns the length of this type as an array
    // - `null` indicates the length is unforced, it could be dynamic
    // - `-1` indicates the length is dynamic
    // - any other value indicates it is a static array and is its length
    /**
     *  Returns the length of the array type or ``-1`` if it is dynamic.
     *
     *  Throws if the type is not an array.
     */
  }, {
    key: "arrayLength",
    get: function get() {
      if (this.type !== "array") {
        throw TypeError("not an array");
      }
      if (_classPrivateFieldGet(_options, this) === true) {
        return -1;
      }
      if (_classPrivateFieldGet(_options, this) === false) {
        return this.value.length;
      }
      return null;
    }
    /**
     *  Returns a new **Typed** of %%type%% with the %%value%%.
     */
  }], [{
    key: "from",
    value: function from(type, value) {
      return new Typed(_gaurd, type, value);
    }
    /**
     *  Return a new ``uint8`` type for %%v%%.
     */
  }, {
    key: "uint8",
    value: function uint8(v) {
      return n(v, 8);
    }
    /**
     *  Return a new ``uint16`` type for %%v%%.
     */
  }, {
    key: "uint16",
    value: function uint16(v) {
      return n(v, 16);
    }
    /**
     *  Return a new ``uint24`` type for %%v%%.
     */
  }, {
    key: "uint24",
    value: function uint24(v) {
      return n(v, 24);
    }
    /**
     *  Return a new ``uint32`` type for %%v%%.
     */
  }, {
    key: "uint32",
    value: function uint32(v) {
      return n(v, 32);
    }
    /**
     *  Return a new ``uint40`` type for %%v%%.
     */
  }, {
    key: "uint40",
    value: function uint40(v) {
      return n(v, 40);
    }
    /**
     *  Return a new ``uint48`` type for %%v%%.
     */
  }, {
    key: "uint48",
    value: function uint48(v) {
      return n(v, 48);
    }
    /**
     *  Return a new ``uint56`` type for %%v%%.
     */
  }, {
    key: "uint56",
    value: function uint56(v) {
      return n(v, 56);
    }
    /**
     *  Return a new ``uint64`` type for %%v%%.
     */
  }, {
    key: "uint64",
    value: function uint64(v) {
      return n(v, 64);
    }
    /**
     *  Return a new ``uint72`` type for %%v%%.
     */
  }, {
    key: "uint72",
    value: function uint72(v) {
      return n(v, 72);
    }
    /**
     *  Return a new ``uint80`` type for %%v%%.
     */
  }, {
    key: "uint80",
    value: function uint80(v) {
      return n(v, 80);
    }
    /**
     *  Return a new ``uint88`` type for %%v%%.
     */
  }, {
    key: "uint88",
    value: function uint88(v) {
      return n(v, 88);
    }
    /**
     *  Return a new ``uint96`` type for %%v%%.
     */
  }, {
    key: "uint96",
    value: function uint96(v) {
      return n(v, 96);
    }
    /**
     *  Return a new ``uint104`` type for %%v%%.
     */
  }, {
    key: "uint104",
    value: function uint104(v) {
      return n(v, 104);
    }
    /**
     *  Return a new ``uint112`` type for %%v%%.
     */
  }, {
    key: "uint112",
    value: function uint112(v) {
      return n(v, 112);
    }
    /**
     *  Return a new ``uint120`` type for %%v%%.
     */
  }, {
    key: "uint120",
    value: function uint120(v) {
      return n(v, 120);
    }
    /**
     *  Return a new ``uint128`` type for %%v%%.
     */
  }, {
    key: "uint128",
    value: function uint128(v) {
      return n(v, 128);
    }
    /**
     *  Return a new ``uint136`` type for %%v%%.
     */
  }, {
    key: "uint136",
    value: function uint136(v) {
      return n(v, 136);
    }
    /**
     *  Return a new ``uint144`` type for %%v%%.
     */
  }, {
    key: "uint144",
    value: function uint144(v) {
      return n(v, 144);
    }
    /**
     *  Return a new ``uint152`` type for %%v%%.
     */
  }, {
    key: "uint152",
    value: function uint152(v) {
      return n(v, 152);
    }
    /**
     *  Return a new ``uint160`` type for %%v%%.
     */
  }, {
    key: "uint160",
    value: function uint160(v) {
      return n(v, 160);
    }
    /**
     *  Return a new ``uint168`` type for %%v%%.
     */
  }, {
    key: "uint168",
    value: function uint168(v) {
      return n(v, 168);
    }
    /**
     *  Return a new ``uint176`` type for %%v%%.
     */
  }, {
    key: "uint176",
    value: function uint176(v) {
      return n(v, 176);
    }
    /**
     *  Return a new ``uint184`` type for %%v%%.
     */
  }, {
    key: "uint184",
    value: function uint184(v) {
      return n(v, 184);
    }
    /**
     *  Return a new ``uint192`` type for %%v%%.
     */
  }, {
    key: "uint192",
    value: function uint192(v) {
      return n(v, 192);
    }
    /**
     *  Return a new ``uint200`` type for %%v%%.
     */
  }, {
    key: "uint200",
    value: function uint200(v) {
      return n(v, 200);
    }
    /**
     *  Return a new ``uint208`` type for %%v%%.
     */
  }, {
    key: "uint208",
    value: function uint208(v) {
      return n(v, 208);
    }
    /**
     *  Return a new ``uint216`` type for %%v%%.
     */
  }, {
    key: "uint216",
    value: function uint216(v) {
      return n(v, 216);
    }
    /**
     *  Return a new ``uint224`` type for %%v%%.
     */
  }, {
    key: "uint224",
    value: function uint224(v) {
      return n(v, 224);
    }
    /**
     *  Return a new ``uint232`` type for %%v%%.
     */
  }, {
    key: "uint232",
    value: function uint232(v) {
      return n(v, 232);
    }
    /**
     *  Return a new ``uint240`` type for %%v%%.
     */
  }, {
    key: "uint240",
    value: function uint240(v) {
      return n(v, 240);
    }
    /**
     *  Return a new ``uint248`` type for %%v%%.
     */
  }, {
    key: "uint248",
    value: function uint248(v) {
      return n(v, 248);
    }
    /**
     *  Return a new ``uint256`` type for %%v%%.
     */
  }, {
    key: "uint256",
    value: function uint256(v) {
      return n(v, 256);
    }
    /**
     *  Return a new ``uint256`` type for %%v%%.
     */
  }, {
    key: "uint",
    value: function uint(v) {
      return n(v, 256);
    }
    /**
     *  Return a new ``int8`` type for %%v%%.
     */
  }, {
    key: "int8",
    value: function int8(v) {
      return n(v, -8);
    }
    /**
     *  Return a new ``int16`` type for %%v%%.
     */
  }, {
    key: "int16",
    value: function int16(v) {
      return n(v, -16);
    }
    /**
     *  Return a new ``int24`` type for %%v%%.
     */
  }, {
    key: "int24",
    value: function int24(v) {
      return n(v, -24);
    }
    /**
     *  Return a new ``int32`` type for %%v%%.
     */
  }, {
    key: "int32",
    value: function int32(v) {
      return n(v, -32);
    }
    /**
     *  Return a new ``int40`` type for %%v%%.
     */
  }, {
    key: "int40",
    value: function int40(v) {
      return n(v, -40);
    }
    /**
     *  Return a new ``int48`` type for %%v%%.
     */
  }, {
    key: "int48",
    value: function int48(v) {
      return n(v, -48);
    }
    /**
     *  Return a new ``int56`` type for %%v%%.
     */
  }, {
    key: "int56",
    value: function int56(v) {
      return n(v, -56);
    }
    /**
     *  Return a new ``int64`` type for %%v%%.
     */
  }, {
    key: "int64",
    value: function int64(v) {
      return n(v, -64);
    }
    /**
     *  Return a new ``int72`` type for %%v%%.
     */
  }, {
    key: "int72",
    value: function int72(v) {
      return n(v, -72);
    }
    /**
     *  Return a new ``int80`` type for %%v%%.
     */
  }, {
    key: "int80",
    value: function int80(v) {
      return n(v, -80);
    }
    /**
     *  Return a new ``int88`` type for %%v%%.
     */
  }, {
    key: "int88",
    value: function int88(v) {
      return n(v, -88);
    }
    /**
     *  Return a new ``int96`` type for %%v%%.
     */
  }, {
    key: "int96",
    value: function int96(v) {
      return n(v, -96);
    }
    /**
     *  Return a new ``int104`` type for %%v%%.
     */
  }, {
    key: "int104",
    value: function int104(v) {
      return n(v, -104);
    }
    /**
     *  Return a new ``int112`` type for %%v%%.
     */
  }, {
    key: "int112",
    value: function int112(v) {
      return n(v, -112);
    }
    /**
     *  Return a new ``int120`` type for %%v%%.
     */
  }, {
    key: "int120",
    value: function int120(v) {
      return n(v, -120);
    }
    /**
     *  Return a new ``int128`` type for %%v%%.
     */
  }, {
    key: "int128",
    value: function int128(v) {
      return n(v, -128);
    }
    /**
     *  Return a new ``int136`` type for %%v%%.
     */
  }, {
    key: "int136",
    value: function int136(v) {
      return n(v, -136);
    }
    /**
     *  Return a new ``int144`` type for %%v%%.
     */
  }, {
    key: "int144",
    value: function int144(v) {
      return n(v, -144);
    }
    /**
     *  Return a new ``int52`` type for %%v%%.
     */
  }, {
    key: "int152",
    value: function int152(v) {
      return n(v, -152);
    }
    /**
     *  Return a new ``int160`` type for %%v%%.
     */
  }, {
    key: "int160",
    value: function int160(v) {
      return n(v, -160);
    }
    /**
     *  Return a new ``int168`` type for %%v%%.
     */
  }, {
    key: "int168",
    value: function int168(v) {
      return n(v, -168);
    }
    /**
     *  Return a new ``int176`` type for %%v%%.
     */
  }, {
    key: "int176",
    value: function int176(v) {
      return n(v, -176);
    }
    /**
     *  Return a new ``int184`` type for %%v%%.
     */
  }, {
    key: "int184",
    value: function int184(v) {
      return n(v, -184);
    }
    /**
     *  Return a new ``int92`` type for %%v%%.
     */
  }, {
    key: "int192",
    value: function int192(v) {
      return n(v, -192);
    }
    /**
     *  Return a new ``int200`` type for %%v%%.
     */
  }, {
    key: "int200",
    value: function int200(v) {
      return n(v, -200);
    }
    /**
     *  Return a new ``int208`` type for %%v%%.
     */
  }, {
    key: "int208",
    value: function int208(v) {
      return n(v, -208);
    }
    /**
     *  Return a new ``int216`` type for %%v%%.
     */
  }, {
    key: "int216",
    value: function int216(v) {
      return n(v, -216);
    }
    /**
     *  Return a new ``int224`` type for %%v%%.
     */
  }, {
    key: "int224",
    value: function int224(v) {
      return n(v, -224);
    }
    /**
     *  Return a new ``int232`` type for %%v%%.
     */
  }, {
    key: "int232",
    value: function int232(v) {
      return n(v, -232);
    }
    /**
     *  Return a new ``int240`` type for %%v%%.
     */
  }, {
    key: "int240",
    value: function int240(v) {
      return n(v, -240);
    }
    /**
     *  Return a new ``int248`` type for %%v%%.
     */
  }, {
    key: "int248",
    value: function int248(v) {
      return n(v, -248);
    }
    /**
     *  Return a new ``int256`` type for %%v%%.
     */
  }, {
    key: "int256",
    value: function int256(v) {
      return n(v, -256);
    }
    /**
     *  Return a new ``int256`` type for %%v%%.
     */
  }, {
    key: "int",
    value: function int(v) {
      return n(v, -256);
    }
    /**
     *  Return a new ``bytes1`` type for %%v%%.
     */
  }, {
    key: "bytes1",
    value: function bytes1(v) {
      return b(v, 1);
    }
    /**
     *  Return a new ``bytes2`` type for %%v%%.
     */
  }, {
    key: "bytes2",
    value: function bytes2(v) {
      return b(v, 2);
    }
    /**
     *  Return a new ``bytes3`` type for %%v%%.
     */
  }, {
    key: "bytes3",
    value: function bytes3(v) {
      return b(v, 3);
    }
    /**
     *  Return a new ``bytes4`` type for %%v%%.
     */
  }, {
    key: "bytes4",
    value: function bytes4(v) {
      return b(v, 4);
    }
    /**
     *  Return a new ``bytes5`` type for %%v%%.
     */
  }, {
    key: "bytes5",
    value: function bytes5(v) {
      return b(v, 5);
    }
    /**
     *  Return a new ``bytes6`` type for %%v%%.
     */
  }, {
    key: "bytes6",
    value: function bytes6(v) {
      return b(v, 6);
    }
    /**
     *  Return a new ``bytes7`` type for %%v%%.
     */
  }, {
    key: "bytes7",
    value: function bytes7(v) {
      return b(v, 7);
    }
    /**
     *  Return a new ``bytes8`` type for %%v%%.
     */
  }, {
    key: "bytes8",
    value: function bytes8(v) {
      return b(v, 8);
    }
    /**
     *  Return a new ``bytes9`` type for %%v%%.
     */
  }, {
    key: "bytes9",
    value: function bytes9(v) {
      return b(v, 9);
    }
    /**
     *  Return a new ``bytes10`` type for %%v%%.
     */
  }, {
    key: "bytes10",
    value: function bytes10(v) {
      return b(v, 10);
    }
    /**
     *  Return a new ``bytes11`` type for %%v%%.
     */
  }, {
    key: "bytes11",
    value: function bytes11(v) {
      return b(v, 11);
    }
    /**
     *  Return a new ``bytes12`` type for %%v%%.
     */
  }, {
    key: "bytes12",
    value: function bytes12(v) {
      return b(v, 12);
    }
    /**
     *  Return a new ``bytes13`` type for %%v%%.
     */
  }, {
    key: "bytes13",
    value: function bytes13(v) {
      return b(v, 13);
    }
    /**
     *  Return a new ``bytes14`` type for %%v%%.
     */
  }, {
    key: "bytes14",
    value: function bytes14(v) {
      return b(v, 14);
    }
    /**
     *  Return a new ``bytes15`` type for %%v%%.
     */
  }, {
    key: "bytes15",
    value: function bytes15(v) {
      return b(v, 15);
    }
    /**
     *  Return a new ``bytes16`` type for %%v%%.
     */
  }, {
    key: "bytes16",
    value: function bytes16(v) {
      return b(v, 16);
    }
    /**
     *  Return a new ``bytes17`` type for %%v%%.
     */
  }, {
    key: "bytes17",
    value: function bytes17(v) {
      return b(v, 17);
    }
    /**
     *  Return a new ``bytes18`` type for %%v%%.
     */
  }, {
    key: "bytes18",
    value: function bytes18(v) {
      return b(v, 18);
    }
    /**
     *  Return a new ``bytes19`` type for %%v%%.
     */
  }, {
    key: "bytes19",
    value: function bytes19(v) {
      return b(v, 19);
    }
    /**
     *  Return a new ``bytes20`` type for %%v%%.
     */
  }, {
    key: "bytes20",
    value: function bytes20(v) {
      return b(v, 20);
    }
    /**
     *  Return a new ``bytes21`` type for %%v%%.
     */
  }, {
    key: "bytes21",
    value: function bytes21(v) {
      return b(v, 21);
    }
    /**
     *  Return a new ``bytes22`` type for %%v%%.
     */
  }, {
    key: "bytes22",
    value: function bytes22(v) {
      return b(v, 22);
    }
    /**
     *  Return a new ``bytes23`` type for %%v%%.
     */
  }, {
    key: "bytes23",
    value: function bytes23(v) {
      return b(v, 23);
    }
    /**
     *  Return a new ``bytes24`` type for %%v%%.
     */
  }, {
    key: "bytes24",
    value: function bytes24(v) {
      return b(v, 24);
    }
    /**
     *  Return a new ``bytes25`` type for %%v%%.
     */
  }, {
    key: "bytes25",
    value: function bytes25(v) {
      return b(v, 25);
    }
    /**
     *  Return a new ``bytes26`` type for %%v%%.
     */
  }, {
    key: "bytes26",
    value: function bytes26(v) {
      return b(v, 26);
    }
    /**
     *  Return a new ``bytes27`` type for %%v%%.
     */
  }, {
    key: "bytes27",
    value: function bytes27(v) {
      return b(v, 27);
    }
    /**
     *  Return a new ``bytes28`` type for %%v%%.
     */
  }, {
    key: "bytes28",
    value: function bytes28(v) {
      return b(v, 28);
    }
    /**
     *  Return a new ``bytes29`` type for %%v%%.
     */
  }, {
    key: "bytes29",
    value: function bytes29(v) {
      return b(v, 29);
    }
    /**
     *  Return a new ``bytes30`` type for %%v%%.
     */
  }, {
    key: "bytes30",
    value: function bytes30(v) {
      return b(v, 30);
    }
    /**
     *  Return a new ``bytes31`` type for %%v%%.
     */
  }, {
    key: "bytes31",
    value: function bytes31(v) {
      return b(v, 31);
    }
    /**
     *  Return a new ``bytes32`` type for %%v%%.
     */
  }, {
    key: "bytes32",
    value: function bytes32(v) {
      return b(v, 32);
    }
    /**
     *  Return a new ``address`` type for %%v%%.
     */
  }, {
    key: "address",
    value: function address(v) {
      return new Typed(_gaurd, "address", v);
    }
    /**
     *  Return a new ``bool`` type for %%v%%.
     */
  }, {
    key: "bool",
    value: function bool(v) {
      return new Typed(_gaurd, "bool", !!v);
    }
    /**
     *  Return a new ``bytes`` type for %%v%%.
     */
  }, {
    key: "bytes",
    value: function bytes(v) {
      return new Typed(_gaurd, "bytes", v);
    }
    /**
     *  Return a new ``string`` type for %%v%%.
     */
  }, {
    key: "string",
    value: function string(v) {
      return new Typed(_gaurd, "string", v);
    }
    /**
     *  Return a new ``array`` type for %%v%%, allowing %%dynamic%% length.
     */
  }, {
    key: "array",
    value: function array(v, dynamic) {
      throw new Error("not implemented yet");
      return new Typed(_gaurd, "array", v, dynamic);
    }
    /**
     *  Return a new ``tuple`` type for %%v%%, with the optional %%name%%.
     */
  }, {
    key: "tuple",
    value: function tuple(v, name) {
      throw new Error("not implemented yet");
      return new Typed(_gaurd, "tuple", v, name);
    }
    /**
     *  Return a new ``uint8`` type for %%v%%.
     */
  }, {
    key: "overrides",
    value: function overrides(v) {
      return new Typed(_gaurd, "overrides", Object.assign({}, v));
    }
    /**
     *  Returns true only if %%value%% is a [[Typed]] instance.
     */
  }, {
    key: "isTyped",
    value: function isTyped(value) {
      return value && _typeof(value) === "object" && "_typedSymbol" in value && value._typedSymbol === _typedSymbol;
    }
    /**
     *  If the value is a [[Typed]] instance, validates the underlying value
     *  and returns it, otherwise returns value directly.
     *
     *  This is useful for functions that with to accept either a [[Typed]]
     *  object or values.
     */
  }, {
    key: "dereference",
    value: function dereference(value, type) {
      if (Typed.isTyped(value)) {
        if (value.type !== type) {
          throw new Error("invalid type: expecetd ".concat(type, ", got ").concat(value.type));
        }
        return value.value;
      }
      return value;
    }
  }]);
}();
exports.Typed = Typed;

},{"../utils/index.js":276}],204:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getIcapAddress = exports.getAddress = void 0;
var index_js_1 = require("../crypto/index.js");
var index_js_2 = require("../utils/index.js");
var BN_0 = BigInt(0);
var BN_36 = BigInt(36);
function getChecksumAddress(address) {
  //    if (!isHexString(address, 20)) {
  //        logger.throwArgumentError("invalid address", "address", address);
  //    }
  address = address.toLowerCase();
  var chars = address.substring(2).split("");
  var expanded = new Uint8Array(40);
  for (var i = 0; i < 40; i++) {
    expanded[i] = chars[i].charCodeAt(0);
  }
  var hashed = (0, index_js_2.getBytes)((0, index_js_1.keccak256)(expanded));
  for (var _i = 0; _i < 40; _i += 2) {
    if (hashed[_i >> 1] >> 4 >= 8) {
      chars[_i] = chars[_i].toUpperCase();
    }
    if ((hashed[_i >> 1] & 0x0f) >= 8) {
      chars[_i + 1] = chars[_i + 1].toUpperCase();
    }
  }
  return "0x" + chars.join("");
}
// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number
// Create lookup table
var ibanLookup = {};
for (var i = 0; i < 10; i++) {
  ibanLookup[String(i)] = String(i);
}
for (var _i2 = 0; _i2 < 26; _i2++) {
  ibanLookup[String.fromCharCode(65 + _i2)] = String(10 + _i2);
}
// How many decimal digits can we process? (for 64-bit float, this is 15)
// i.e. Math.floor(Math.log10(Number.MAX_SAFE_INTEGER));
var safeDigits = 15;
function ibanChecksum(address) {
  address = address.toUpperCase();
  address = address.substring(4) + address.substring(0, 2) + "00";
  var expanded = address.split("").map(function (c) {
    return ibanLookup[c];
  }).join("");
  // Javascript can handle integers safely up to 15 (decimal) digits
  while (expanded.length >= safeDigits) {
    var block = expanded.substring(0, safeDigits);
    expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
  }
  var checksum = String(98 - parseInt(expanded, 10) % 97);
  while (checksum.length < 2) {
    checksum = "0" + checksum;
  }
  return checksum;
}
;
var Base36 = function () {
  ;
  var result = {};
  for (var _i3 = 0; _i3 < 36; _i3++) {
    var key = "0123456789abcdefghijklmnopqrstuvwxyz"[_i3];
    result[key] = BigInt(_i3);
  }
  return result;
}();
function fromBase36(value) {
  value = value.toLowerCase();
  var result = BN_0;
  for (var _i4 = 0; _i4 < value.length; _i4++) {
    result = result * BN_36 + Base36[value[_i4]];
  }
  return result;
}
/**
 *  Returns a normalized and checksumed address for %%address%%.
 *  This accepts non-checksum addresses, checksum addresses and
 *  [[getIcapAddress]] formats.
 *
 *  The checksum in Ethereum uses the capitalization (upper-case
 *  vs lower-case) of the characters within an address to encode
 *  its checksum, which offers, on average, a checksum of 15-bits.
 *
 *  If %%address%% contains both upper-case and lower-case, it is
 *  assumed to already be a checksum address and its checksum is
 *  validated, and if the address fails its expected checksum an
 *  error is thrown.
 *
 *  If you wish the checksum of %%address%% to be ignore, it should
 *  be converted to lower-case (i.e. ``.toLowercase()``) before
 *  being passed in. This should be a very rare situation though,
 *  that you wish to bypass the safegaurds in place to protect
 *  against an address that has been incorrectly copied from another
 *  source.
 *
 *  @example:
 *    // Adds the checksum (via upper-casing specific letters)
 *    getAddress("0x8ba1f109551bd432803012645ac136ddd64dba72")
 *    //_result:
 *
 *    // Converts ICAP address and adds checksum
 *    getAddress("XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36");
 *    //_result:
 *
 *    // Throws an error if an address contains mixed case,
 *    // but the checksum fails
 *    getAddress("0x8Ba1f109551bD432803012645Ac136ddd64DBA72")
 *    //_error:
 */
function getAddress(address) {
  (0, index_js_2.assertArgument)(typeof address === "string", "invalid address", "address", address);
  if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
    // Missing the 0x prefix
    if (!address.startsWith("0x")) {
      address = "0x" + address;
    }
    var result = getChecksumAddress(address);
    // It is a checksummed address with a bad checksum
    (0, index_js_2.assertArgument)(!address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || result === address, "bad address checksum", "address", address);
    return result;
  }
  // Maybe ICAP? (we only support direct mode)
  if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    // It is an ICAP address with a bad checksum
    (0, index_js_2.assertArgument)(address.substring(2, 4) === ibanChecksum(address), "bad icap checksum", "address", address);
    var _result = fromBase36(address.substring(4)).toString(16);
    while (_result.length < 40) {
      _result = "0" + _result;
    }
    return getChecksumAddress("0x" + _result);
  }
  (0, index_js_2.assertArgument)(false, "invalid address", "address", address);
}
exports.getAddress = getAddress;
/**
 *  The [ICAP Address format](link-icap) format is an early checksum
 *  format which attempts to be compatible with the banking
 *  industry [IBAN format](link-wiki-iban) for bank accounts.
 *
 *  It is no longer common or a recommended format.
 *
 *  @example:
 *    getIcapAddress("0x8ba1f109551bd432803012645ac136ddd64dba72");
 *    //_result:
 *
 *    getIcapAddress("XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36");
 *    //_result:
 *
 *    // Throws an error if the ICAP checksum is wrong
 *    getIcapAddress("XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK37");
 *    //_error:
 */
function getIcapAddress(address) {
  //let base36 = _base16To36(getAddress(address).substring(2)).toUpperCase();
  var base36 = BigInt(getAddress(address)).toString(36).toUpperCase();
  while (base36.length < 30) {
    base36 = "0" + base36;
  }
  return "XE" + ibanChecksum("XE00" + base36) + base36;
}
exports.getIcapAddress = getIcapAddress;

},{"../crypto/index.js":219,"../utils/index.js":276}],205:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.resolveAddress = exports.isAddress = exports.isAddressable = void 0;
var index_js_1 = require("../utils/index.js");
var address_js_1 = require("./address.js");
/**
 *  Returns true if %%value%% is an object which implements the
 *  [[Addressable]] interface.
 *
 *  @example:
 *    // Wallets and AbstractSigner sub-classes
 *    isAddressable(Wallet.createRandom())
 *    //_result:
 *
 *    // Contracts
 *    contract = new Contract("dai.tokens.ethers.eth", [ ], provider)
 *    isAddressable(contract)
 *    //_result:
 */
function isAddressable(value) {
  return value && typeof value.getAddress === "function";
}
exports.isAddressable = isAddressable;
/**
 *  Returns true if %%value%% is a valid address.
 *
 *  @example:
 *    // Valid address
 *    isAddress("0x8ba1f109551bD432803012645Ac136ddd64DBA72")
 *    //_result:
 *
 *    // Valid ICAP address
 *    isAddress("XE65GB6LDNXYOFTX0NSV3FUWKOWIXAMJK36")
 *    //_result:
 *
 *    // Invalid checksum
 *    isAddress("0x8Ba1f109551bD432803012645Ac136ddd64DBa72")
 *    //_result:
 *
 *    // Invalid ICAP checksum
 *    isAddress("0x8Ba1f109551bD432803012645Ac136ddd64DBA72")
 *    //_result:
 *
 *    // Not an address (an ENS name requires a provided and an
 *    // asynchronous API to access)
 *    isAddress("ricmoo.eth")
 *    //_result:
 */
function isAddress(value) {
  try {
    (0, address_js_1.getAddress)(value);
    return true;
  } catch (error) {}
  return false;
}
exports.isAddress = isAddress;
function checkAddress(_x, _x2) {
  return _checkAddress.apply(this, arguments);
}
/**
 *  Resolves to an address for the %%target%%, which may be any
 *  supported address type, an [[Addressable]] or a Promise which
 *  resolves to an address.
 *
 *  If an ENS name is provided, but that name has not been correctly
 *  configured a [[UnconfiguredNameError]] is thrown.
 *
 *  @example:
 *    addr = "0x6B175474E89094C44Da98b954EedeAC495271d0F"
 *
 *    // Addresses are return synchronously
 *    resolveAddress(addr, provider)
 *    //_result:
 *
 *    // Address promises are resolved asynchronously
 *    resolveAddress(Promise.resolve(addr))
 *    //_result:
 *
 *    // ENS names are resolved asynchronously
 *    resolveAddress("dai.tokens.ethers.eth", provider)
 *    //_result:
 *
 *    // Addressable objects are resolved asynchronously
 *    contract = new Contract(addr, [ ])
 *    resolveAddress(contract, provider)
 *    //_result:
 *
 *    // Unconfigured ENS names reject
 *    resolveAddress("nothing-here.ricmoo.eth", provider)
 *    //_error:
 *
 *    // ENS names require a NameResolver object passed in
 *    // (notice the provider was omitted)
 *    resolveAddress("nothing-here.ricmoo.eth")
 *    //_error:
 */
function _checkAddress() {
  _checkAddress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(target, promise) {
    var result;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return promise;
        case 2:
          result = _context.sent;
          if (result == null || result === "0x0000000000000000000000000000000000000000") {
            (0, index_js_1.assert)(typeof target !== "string", "unconfigured name", "UNCONFIGURED_NAME", {
              value: target
            });
            (0, index_js_1.assertArgument)(false, "invalid AddressLike value; did not resolve to a value address", "target", target);
          }
          return _context.abrupt("return", (0, address_js_1.getAddress)(result));
        case 5:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return _checkAddress.apply(this, arguments);
}
function resolveAddress(target, resolver) {
  if (typeof target === "string") {
    if (target.match(/^0x[0-9a-f]{40}$/i)) {
      return (0, address_js_1.getAddress)(target);
    }
    (0, index_js_1.assert)(resolver != null, "ENS resolution requires a provider", "UNSUPPORTED_OPERATION", {
      operation: "resolveName"
    });
    return checkAddress(target, resolver.resolveName(target));
  } else if (isAddressable(target)) {
    return checkAddress(target, target.getAddress());
  } else if (target && typeof target.then === "function") {
    return checkAddress(target, target);
  }
  (0, index_js_1.assertArgument)(false, "unsupported addressable value", "target", target);
}
exports.resolveAddress = resolveAddress;

},{"../utils/index.js":276,"./address.js":204}],206:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getCreate2Address = exports.getCreateAddress = void 0;
var index_js_1 = require("../crypto/index.js");
var index_js_2 = require("../utils/index.js");
var address_js_1 = require("./address.js");
// http://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed
/**
 *  Returns the address that would result from a ``CREATE`` for %%tx%%.
 *
 *  This can be used to compute the address a contract will be
 *  deployed to by an EOA when sending a deployment transaction (i.e.
 *  when the ``to`` address is ``null``).
 *
 *  This can also be used to compute the address a contract will be
 *  deployed to by a contract, by using the contract's address as the
 *  ``to`` and the contract's nonce.
 *
 *  @example
 *    from = "0x8ba1f109551bD432803012645Ac136ddd64DBA72";
 *    nonce = 5;
 *
 *    getCreateAddress({ from, nonce });
 *    //_result:
 */
function getCreateAddress(tx) {
  var from = (0, address_js_1.getAddress)(tx.from);
  var nonce = (0, index_js_2.getBigInt)(tx.nonce, "tx.nonce");
  var nonceHex = nonce.toString(16);
  if (nonceHex === "0") {
    nonceHex = "0x";
  } else if (nonceHex.length % 2) {
    nonceHex = "0x0" + nonceHex;
  } else {
    nonceHex = "0x" + nonceHex;
  }
  return (0, address_js_1.getAddress)((0, index_js_2.dataSlice)((0, index_js_1.keccak256)((0, index_js_2.encodeRlp)([from, nonceHex])), 12));
}
exports.getCreateAddress = getCreateAddress;
/**
 *  Returns the address that would result from a ``CREATE2`` operation
 *  with the given %%from%%, %%salt%% and %%initCodeHash%%.
 *
 *  To compute the %%initCodeHash%% from a contract's init code, use
 *  the [[keccak256]] function.
 *
 *  For a quick overview and example of ``CREATE2``, see [[link-ricmoo-wisps]].
 *
 *  @example
 *    // The address of the contract
 *    from = "0x8ba1f109551bD432803012645Ac136ddd64DBA72"
 *
 *    // The salt
 *    salt = id("HelloWorld")
 *
 *    // The hash of the initCode
 *    initCode = "0x6394198df16000526103ff60206004601c335afa6040516060f3";
 *    initCodeHash = keccak256(initCode)
 *
 *    getCreate2Address(from, salt, initCodeHash)
 *    //_result:
 */
function getCreate2Address(_from, _salt, _initCodeHash) {
  var from = (0, address_js_1.getAddress)(_from);
  var salt = (0, index_js_2.getBytes)(_salt, "salt");
  var initCodeHash = (0, index_js_2.getBytes)(_initCodeHash, "initCodeHash");
  (0, index_js_2.assertArgument)(salt.length === 32, "salt must be 32 bytes", "salt", _salt);
  (0, index_js_2.assertArgument)(initCodeHash.length === 32, "initCodeHash must be 32 bytes", "initCodeHash", _initCodeHash);
  return (0, address_js_1.getAddress)((0, index_js_2.dataSlice)((0, index_js_1.keccak256)((0, index_js_2.concat)(["0xff", from, salt, initCodeHash])), 12));
}
exports.getCreate2Address = getCreate2Address;

},{"../crypto/index.js":219,"../utils/index.js":276,"./address.js":204}],207:[function(require,module,exports){
"use strict";

/**
 *  Addresses are a fundamental part of interacting with Ethereum. They
 *  represent the gloabal identity of Externally Owned Accounts (accounts
 *  backed by a private key) and contracts.
 *
 *  The Ethereum Naming Service (ENS) provides an interconnected ecosystem
 *  of contracts, standards and libraries which enable looking up an
 *  address for an ENS name.
 *
 *  These functions help convert between various formats, validate
 *  addresses and safely resolve ENS names.
 *
 *  @_section: api/address:Addresses  [about-addresses]
 */
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.resolveAddress = exports.isAddress = exports.isAddressable = exports.getCreate2Address = exports.getCreateAddress = exports.getIcapAddress = exports.getAddress = void 0;
null;
var address_js_1 = require("./address.js");
Object.defineProperty(exports, "getAddress", {
  enumerable: true,
  get: function get() {
    return address_js_1.getAddress;
  }
});
Object.defineProperty(exports, "getIcapAddress", {
  enumerable: true,
  get: function get() {
    return address_js_1.getIcapAddress;
  }
});
var contract_address_js_1 = require("./contract-address.js");
Object.defineProperty(exports, "getCreateAddress", {
  enumerable: true,
  get: function get() {
    return contract_address_js_1.getCreateAddress;
  }
});
Object.defineProperty(exports, "getCreate2Address", {
  enumerable: true,
  get: function get() {
    return contract_address_js_1.getCreate2Address;
  }
});
var checks_js_1 = require("./checks.js");
Object.defineProperty(exports, "isAddressable", {
  enumerable: true,
  get: function get() {
    return checks_js_1.isAddressable;
  }
});
Object.defineProperty(exports, "isAddress", {
  enumerable: true,
  get: function get() {
    return checks_js_1.isAddress;
  }
});
Object.defineProperty(exports, "resolveAddress", {
  enumerable: true,
  get: function get() {
    return checks_js_1.resolveAddress;
  }
});

},{"./address.js":204,"./checks.js":205,"./contract-address.js":206}],208:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ZeroAddress = void 0;
/**
 *  A constant for the zero address.
 *
 *  (**i.e.** ``"0x0000000000000000000000000000000000000000"``)
 */
exports.ZeroAddress = "0x0000000000000000000000000000000000000000";

},{}],209:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ZeroHash = void 0;
/**
 *  A constant for the zero hash.
 *
 *  (**i.e.** ``"0x0000000000000000000000000000000000000000000000000000000000000000"``)
 */
exports.ZeroHash = "0x0000000000000000000000000000000000000000000000000000000000000000";

},{}],210:[function(require,module,exports){
"use strict";

/**
 *  Some common constants useful for Ethereum.
 *
 *  @_section: api/constants: Constants  [about-constants]
 */
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MessagePrefix = exports.EtherSymbol = exports.MaxInt256 = exports.MinInt256 = exports.MaxUint256 = exports.WeiPerEther = exports.N = exports.ZeroHash = exports.ZeroAddress = void 0;
var addresses_js_1 = require("./addresses.js");
Object.defineProperty(exports, "ZeroAddress", {
  enumerable: true,
  get: function get() {
    return addresses_js_1.ZeroAddress;
  }
});
var hashes_js_1 = require("./hashes.js");
Object.defineProperty(exports, "ZeroHash", {
  enumerable: true,
  get: function get() {
    return hashes_js_1.ZeroHash;
  }
});
var numbers_js_1 = require("./numbers.js");
Object.defineProperty(exports, "N", {
  enumerable: true,
  get: function get() {
    return numbers_js_1.N;
  }
});
Object.defineProperty(exports, "WeiPerEther", {
  enumerable: true,
  get: function get() {
    return numbers_js_1.WeiPerEther;
  }
});
Object.defineProperty(exports, "MaxUint256", {
  enumerable: true,
  get: function get() {
    return numbers_js_1.MaxUint256;
  }
});
Object.defineProperty(exports, "MinInt256", {
  enumerable: true,
  get: function get() {
    return numbers_js_1.MinInt256;
  }
});
Object.defineProperty(exports, "MaxInt256", {
  enumerable: true,
  get: function get() {
    return numbers_js_1.MaxInt256;
  }
});
var strings_js_1 = require("./strings.js");
Object.defineProperty(exports, "EtherSymbol", {
  enumerable: true,
  get: function get() {
    return strings_js_1.EtherSymbol;
  }
});
Object.defineProperty(exports, "MessagePrefix", {
  enumerable: true,
  get: function get() {
    return strings_js_1.MessagePrefix;
  }
});

},{"./addresses.js":208,"./hashes.js":209,"./numbers.js":211,"./strings.js":212}],211:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MaxInt256 = exports.MinInt256 = exports.MaxUint256 = exports.WeiPerEther = exports.N = void 0;
/**
 *  A constant for the order N for the secp256k1 curve.
 *
 *  (**i.e.** ``0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141n``)
 */
exports.N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
/**
 *  A constant for the number of wei in a single ether.
 *
 *  (**i.e.** ``1000000000000000000n``)
 */
exports.WeiPerEther = BigInt("1000000000000000000");
/**
 *  A constant for the maximum value for a ``uint256``.
 *
 *  (**i.e.** ``0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffn``)
 */
exports.MaxUint256 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
/**
 *  A constant for the minimum value for an ``int256``.
 *
 *  (**i.e.** ``-8000000000000000000000000000000000000000000000000000000000000000n``)
 */
exports.MinInt256 = BigInt("0x8000000000000000000000000000000000000000000000000000000000000000") * BigInt(-1);
/**
 *  A constant for the maximum value for an ``int256``.
 *
 *  (**i.e.** ``0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffn``)
 */
exports.MaxInt256 = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");

},{}],212:[function(require,module,exports){
"use strict";

// NFKC (composed)             // (decomposed)
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MessagePrefix = exports.EtherSymbol = void 0;
/**
 *  A constant for the ether symbol (normalized using NFKC).
 *
 *  (**i.e.** ``"\\u039e"``)
 */
exports.EtherSymbol = "\u039E"; // "\uD835\uDF63";
/**
 *  A constant for the [[link-eip-191]] personal message prefix.
 *
 *  (**i.e.** ``"\\x19Ethereum Signed Message:\\n"``)
 */
exports.MessagePrefix = "\x19Ethereum Signed Message:\n";

},{}],213:[function(require,module,exports){
"use strict";

function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Contract = exports.BaseContract = exports.resolveArgs = exports.copyOverrides = void 0;
var index_js_1 = require("../abi/index.js");
var index_js_2 = require("../address/index.js");
// import from provider.ts instead of index.ts to prevent circular dep
// from EtherscanProvider
var provider_js_1 = require("../providers/provider.js");
var index_js_3 = require("../utils/index.js");
var wrappers_js_1 = require("./wrappers.js");
var BN_0 = BigInt(0);
function canCall(value) {
  return value && typeof value.call === "function";
}
function canEstimate(value) {
  return value && typeof value.estimateGas === "function";
}
function canResolve(value) {
  return value && typeof value.resolveName === "function";
}
function canSend(value) {
  return value && typeof value.sendTransaction === "function";
}
function getResolver(value) {
  if (value != null) {
    if (canResolve(value)) {
      return value;
    }
    if (value.provider) {
      return value.provider;
    }
  }
  return undefined;
}
var _filter = /*#__PURE__*/new WeakMap();
var PreparedTopicFilter = /*#__PURE__*/function () {
  function PreparedTopicFilter(contract, fragment, args) {
    _classCallCheck(this, PreparedTopicFilter);
    _classPrivateFieldInitSpec(this, _filter, void 0);
    _defineProperty(this, "fragment", void 0);
    (0, index_js_3.defineProperties)(this, {
      fragment: fragment
    });
    if (fragment.inputs.length < args.length) {
      throw new Error("too many arguments");
    }
    // Recursively descend into args and resolve any addresses
    var runner = getRunner(contract.runner, "resolveName");
    var resolver = canResolve(runner) ? runner : null;
    _classPrivateFieldSet(_filter, this, _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      var resolvedArgs;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return Promise.all(fragment.inputs.map(function (param, index) {
              var arg = args[index];
              if (arg == null) {
                return null;
              }
              return param.walkAsync(args[index], function (type, value) {
                if (type === "address") {
                  if (Array.isArray(value)) {
                    return Promise.all(value.map(function (v) {
                      return (0, index_js_2.resolveAddress)(v, resolver);
                    }));
                  }
                  return (0, index_js_2.resolveAddress)(value, resolver);
                }
                return value;
              });
            }));
          case 2:
            resolvedArgs = _context.sent;
            return _context.abrupt("return", contract["interface"].encodeFilterTopics(fragment, resolvedArgs));
          case 4:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }))());
  }
  return _createClass(PreparedTopicFilter, [{
    key: "getTopicFilter",
    value: function getTopicFilter() {
      return _classPrivateFieldGet(_filter, this);
    }
  }]);
}(); // A = Arguments passed in as a tuple
// R = The result type of the call (i.e. if only one return type,
//     the qualified type, otherwise Result)
// D = The type the default call will return (i.e. R for view/pure,
//     TransactionResponse otherwise)
//export interface ContractMethod<A extends Array<any> = Array<any>, R = any, D extends R | ContractTransactionResponse = ContractTransactionResponse> {
function getRunner(value, feature) {
  if (value == null) {
    return null;
  }
  if (typeof value[feature] === "function") {
    return value;
  }
  if (value.provider && typeof value.provider[feature] === "function") {
    return value.provider;
  }
  return null;
}
function getProvider(value) {
  if (value == null) {
    return null;
  }
  return value.provider || null;
}
/**
 *  @_ignore:
 */
function copyOverrides(_x, _x2) {
  return _copyOverrides.apply(this, arguments);
}
function _copyOverrides() {
  _copyOverrides = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee28(arg, allowed) {
    var _overrides, overrides;
    return _regeneratorRuntime().wrap(function _callee28$(_context28) {
      while (1) switch (_context28.prev = _context28.next) {
        case 0:
          // Make sure the overrides passed in are a valid overrides object
          _overrides = index_js_1.Typed.dereference(arg, "overrides");
          (0, index_js_3.assertArgument)(_typeof(_overrides) === "object", "invalid overrides parameter", "overrides", arg);
          // Create a shallow copy (we'll deep-ify anything needed during normalizing)
          overrides = (0, provider_js_1.copyRequest)(_overrides);
          (0, index_js_3.assertArgument)(overrides.to == null || (allowed || []).indexOf("to") >= 0, "cannot override to", "overrides.to", overrides.to);
          (0, index_js_3.assertArgument)(overrides.data == null || (allowed || []).indexOf("data") >= 0, "cannot override data", "overrides.data", overrides.data);
          // Resolve any from
          if (overrides.from) {
            overrides.from = overrides.from;
          }
          return _context28.abrupt("return", overrides);
        case 7:
        case "end":
          return _context28.stop();
      }
    }, _callee28);
  }));
  return _copyOverrides.apply(this, arguments);
}
exports.copyOverrides = copyOverrides;
/**
 *  @_ignore:
 */
function resolveArgs(_x3, _x4, _x5) {
  return _resolveArgs.apply(this, arguments);
}
function _resolveArgs() {
  _resolveArgs = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee29(_runner, inputs, args) {
    var runner, resolver;
    return _regeneratorRuntime().wrap(function _callee29$(_context29) {
      while (1) switch (_context29.prev = _context29.next) {
        case 0:
          // Recursively descend into args and resolve any addresses
          runner = getRunner(_runner, "resolveName");
          resolver = canResolve(runner) ? runner : null;
          _context29.next = 4;
          return Promise.all(inputs.map(function (param, index) {
            return param.walkAsync(args[index], function (type, value) {
              value = index_js_1.Typed.dereference(value, type);
              if (type === "address") {
                return (0, index_js_2.resolveAddress)(value, resolver);
              }
              return value;
            });
          }));
        case 4:
          return _context29.abrupt("return", _context29.sent);
        case 5:
        case "end":
          return _context29.stop();
      }
    }, _callee29);
  }));
  return _resolveArgs.apply(this, arguments);
}
exports.resolveArgs = resolveArgs;
function buildWrappedFallback(contract) {
  var populateTransaction = /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(overrides) {
      var tx, iface, noValue, noData, payable;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return copyOverrides(overrides, ["data"]);
          case 2:
            tx = _context2.sent;
            _context2.next = 5;
            return contract.getAddress();
          case 5:
            tx.to = _context2.sent;
            if (!tx.from) {
              _context2.next = 10;
              break;
            }
            _context2.next = 9;
            return (0, index_js_2.resolveAddress)(tx.from, getResolver(contract.runner));
          case 9:
            tx.from = _context2.sent;
          case 10:
            iface = contract["interface"];
            noValue = (0, index_js_3.getBigInt)(tx.value || BN_0, "overrides.value") === BN_0;
            noData = (tx.data || "0x") === "0x";
            if (iface.fallback && !iface.fallback.payable && iface.receive && !noData && !noValue) {
              (0, index_js_3.assertArgument)(false, "cannot send data to receive or send value to non-payable fallback", "overrides", overrides);
            }
            (0, index_js_3.assertArgument)(iface.fallback || noData, "cannot send data to receive-only contract", "overrides.data", tx.data);
            // Only allow payable contracts to set non-zero value
            payable = iface.receive || iface.fallback && iface.fallback.payable;
            (0, index_js_3.assertArgument)(payable || noValue, "cannot send value to non-payable fallback", "overrides.value", tx.value);
            // Only allow fallback contracts to set non-empty data
            (0, index_js_3.assertArgument)(iface.fallback || noData, "cannot send data to receive-only contract", "overrides.data", tx.data);
            return _context2.abrupt("return", tx);
          case 19:
          case "end":
            return _context2.stop();
        }
      }, _callee2);
    }));
    return function populateTransaction(_x6) {
      return _ref2.apply(this, arguments);
    };
  }();
  var staticCall = /*#__PURE__*/function () {
    var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(overrides) {
      var runner, tx;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            runner = getRunner(contract.runner, "call");
            (0, index_js_3.assert)(canCall(runner), "contract runner does not support calling", "UNSUPPORTED_OPERATION", {
              operation: "call"
            });
            _context3.next = 4;
            return populateTransaction(overrides);
          case 4:
            tx = _context3.sent;
            _context3.prev = 5;
            _context3.next = 8;
            return runner.call(tx);
          case 8:
            return _context3.abrupt("return", _context3.sent);
          case 11:
            _context3.prev = 11;
            _context3.t0 = _context3["catch"](5);
            if (!((0, index_js_3.isCallException)(_context3.t0) && _context3.t0.data)) {
              _context3.next = 15;
              break;
            }
            throw contract["interface"].makeError(_context3.t0.data, tx);
          case 15:
            throw _context3.t0;
          case 16:
          case "end":
            return _context3.stop();
        }
      }, _callee3, null, [[5, 11]]);
    }));
    return function staticCall(_x7) {
      return _ref3.apply(this, arguments);
    };
  }();
  var send = /*#__PURE__*/function () {
    var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(overrides) {
      var runner, tx, provider;
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            runner = contract.runner;
            (0, index_js_3.assert)(canSend(runner), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", {
              operation: "sendTransaction"
            });
            _context4.t0 = runner;
            _context4.next = 5;
            return populateTransaction(overrides);
          case 5:
            _context4.t1 = _context4.sent;
            _context4.next = 8;
            return _context4.t0.sendTransaction.call(_context4.t0, _context4.t1);
          case 8:
            tx = _context4.sent;
            provider = getProvider(contract.runner); // @TODO: the provider can be null; make a custom dummy provider that will throw a
            // meaningful error
            return _context4.abrupt("return", new wrappers_js_1.ContractTransactionResponse(contract["interface"], provider, tx));
          case 11:
          case "end":
            return _context4.stop();
        }
      }, _callee4);
    }));
    return function send(_x8) {
      return _ref4.apply(this, arguments);
    };
  }();
  var estimateGas = /*#__PURE__*/function () {
    var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(overrides) {
      var runner;
      return _regeneratorRuntime().wrap(function _callee5$(_context5) {
        while (1) switch (_context5.prev = _context5.next) {
          case 0:
            runner = getRunner(contract.runner, "estimateGas");
            (0, index_js_3.assert)(canEstimate(runner), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", {
              operation: "estimateGas"
            });
            _context5.t0 = runner;
            _context5.next = 5;
            return populateTransaction(overrides);
          case 5:
            _context5.t1 = _context5.sent;
            _context5.next = 8;
            return _context5.t0.estimateGas.call(_context5.t0, _context5.t1);
          case 8:
            return _context5.abrupt("return", _context5.sent);
          case 9:
          case "end":
            return _context5.stop();
        }
      }, _callee5);
    }));
    return function estimateGas(_x9) {
      return _ref5.apply(this, arguments);
    };
  }();
  var method = /*#__PURE__*/function () {
    var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(overrides) {
      return _regeneratorRuntime().wrap(function _callee6$(_context6) {
        while (1) switch (_context6.prev = _context6.next) {
          case 0:
            _context6.next = 2;
            return send(overrides);
          case 2:
            return _context6.abrupt("return", _context6.sent);
          case 3:
          case "end":
            return _context6.stop();
        }
      }, _callee6);
    }));
    return function method(_x10) {
      return _ref6.apply(this, arguments);
    };
  }();
  (0, index_js_3.defineProperties)(method, {
    _contract: contract,
    estimateGas: estimateGas,
    populateTransaction: populateTransaction,
    send: send,
    staticCall: staticCall
  });
  return method;
}
function buildWrappedMethod(contract, key) {
  var getFragment = function getFragment() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    var fragment = contract["interface"].getFunction(key, args);
    (0, index_js_3.assert)(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
      operation: "fragment",
      info: {
        key: key,
        args: args
      }
    });
    return fragment;
  };
  var populateTransaction = /*#__PURE__*/function () {
    var _ref7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {
      var _len2,
        args,
        _key2,
        fragment,
        overrides,
        resolvedArgs,
        _args7 = arguments;
      return _regeneratorRuntime().wrap(function _callee7$(_context7) {
        while (1) switch (_context7.prev = _context7.next) {
          case 0:
            for (_len2 = _args7.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
              args[_key2] = _args7[_key2];
            }
            fragment = getFragment.apply(void 0, args); // If an overrides was passed in, copy it and normalize the values
            overrides = {};
            if (!(fragment.inputs.length + 1 === args.length)) {
              _context7.next = 11;
              break;
            }
            _context7.next = 6;
            return copyOverrides(args.pop());
          case 6:
            overrides = _context7.sent;
            if (!overrides.from) {
              _context7.next = 11;
              break;
            }
            _context7.next = 10;
            return (0, index_js_2.resolveAddress)(overrides.from, getResolver(contract.runner));
          case 10:
            overrides.from = _context7.sent;
          case 11:
            if (!(fragment.inputs.length !== args.length)) {
              _context7.next = 13;
              break;
            }
            throw new Error("internal error: fragment inputs doesn't match arguments; should not happen");
          case 13:
            _context7.next = 15;
            return resolveArgs(contract.runner, fragment.inputs, args);
          case 15:
            resolvedArgs = _context7.sent;
            _context7.t0 = Object;
            _context7.t1 = {};
            _context7.t2 = overrides;
            _context7.next = 21;
            return (0, index_js_3.resolveProperties)({
              to: contract.getAddress(),
              data: contract["interface"].encodeFunctionData(fragment, resolvedArgs)
            });
          case 21:
            _context7.t3 = _context7.sent;
            return _context7.abrupt("return", _context7.t0.assign.call(_context7.t0, _context7.t1, _context7.t2, _context7.t3));
          case 23:
          case "end":
            return _context7.stop();
        }
      }, _callee7);
    }));
    return function populateTransaction() {
      return _ref7.apply(this, arguments);
    };
  }();
  var staticCall = /*#__PURE__*/function () {
    var _ref8 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {
      var result,
        _args8 = arguments;
      return _regeneratorRuntime().wrap(function _callee8$(_context8) {
        while (1) switch (_context8.prev = _context8.next) {
          case 0:
            _context8.next = 2;
            return staticCallResult.apply(void 0, _args8);
          case 2:
            result = _context8.sent;
            if (!(result.length === 1)) {
              _context8.next = 5;
              break;
            }
            return _context8.abrupt("return", result[0]);
          case 5:
            return _context8.abrupt("return", result);
          case 6:
          case "end":
            return _context8.stop();
        }
      }, _callee8);
    }));
    return function staticCall() {
      return _ref8.apply(this, arguments);
    };
  }();
  var send = /*#__PURE__*/function () {
    var _ref9 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {
      var runner,
        tx,
        provider,
        _args9 = arguments;
      return _regeneratorRuntime().wrap(function _callee9$(_context9) {
        while (1) switch (_context9.prev = _context9.next) {
          case 0:
            runner = contract.runner;
            (0, index_js_3.assert)(canSend(runner), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", {
              operation: "sendTransaction"
            });
            _context9.t0 = runner;
            _context9.next = 5;
            return populateTransaction.apply(void 0, _args9);
          case 5:
            _context9.t1 = _context9.sent;
            _context9.next = 8;
            return _context9.t0.sendTransaction.call(_context9.t0, _context9.t1);
          case 8:
            tx = _context9.sent;
            provider = getProvider(contract.runner); // @TODO: the provider can be null; make a custom dummy provider that will throw a
            // meaningful error
            return _context9.abrupt("return", new wrappers_js_1.ContractTransactionResponse(contract["interface"], provider, tx));
          case 11:
          case "end":
            return _context9.stop();
        }
      }, _callee9);
    }));
    return function send() {
      return _ref9.apply(this, arguments);
    };
  }();
  var estimateGas = /*#__PURE__*/function () {
    var _ref10 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {
      var runner,
        _args10 = arguments;
      return _regeneratorRuntime().wrap(function _callee10$(_context10) {
        while (1) switch (_context10.prev = _context10.next) {
          case 0:
            runner = getRunner(contract.runner, "estimateGas");
            (0, index_js_3.assert)(canEstimate(runner), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", {
              operation: "estimateGas"
            });
            _context10.t0 = runner;
            _context10.next = 5;
            return populateTransaction.apply(void 0, _args10);
          case 5:
            _context10.t1 = _context10.sent;
            _context10.next = 8;
            return _context10.t0.estimateGas.call(_context10.t0, _context10.t1);
          case 8:
            return _context10.abrupt("return", _context10.sent);
          case 9:
          case "end":
            return _context10.stop();
        }
      }, _callee10);
    }));
    return function estimateGas() {
      return _ref10.apply(this, arguments);
    };
  }();
  var staticCallResult = /*#__PURE__*/function () {
    var _ref11 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {
      var runner,
        tx,
        result,
        fragment,
        _args11 = arguments;
      return _regeneratorRuntime().wrap(function _callee11$(_context11) {
        while (1) switch (_context11.prev = _context11.next) {
          case 0:
            runner = getRunner(contract.runner, "call");
            (0, index_js_3.assert)(canCall(runner), "contract runner does not support calling", "UNSUPPORTED_OPERATION", {
              operation: "call"
            });
            _context11.next = 4;
            return populateTransaction.apply(void 0, _args11);
          case 4:
            tx = _context11.sent;
            result = "0x";
            _context11.prev = 6;
            _context11.next = 9;
            return runner.call(tx);
          case 9:
            result = _context11.sent;
            _context11.next = 17;
            break;
          case 12:
            _context11.prev = 12;
            _context11.t0 = _context11["catch"](6);
            if (!((0, index_js_3.isCallException)(_context11.t0) && _context11.t0.data)) {
              _context11.next = 16;
              break;
            }
            throw contract["interface"].makeError(_context11.t0.data, tx);
          case 16:
            throw _context11.t0;
          case 17:
            fragment = getFragment.apply(void 0, _args11);
            return _context11.abrupt("return", contract["interface"].decodeFunctionResult(fragment, result));
          case 19:
          case "end":
            return _context11.stop();
        }
      }, _callee11, null, [[6, 12]]);
    }));
    return function staticCallResult() {
      return _ref11.apply(this, arguments);
    };
  }();
  var method = /*#__PURE__*/function () {
    var _ref12 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {
      var fragment,
        _args12 = arguments;
      return _regeneratorRuntime().wrap(function _callee12$(_context12) {
        while (1) switch (_context12.prev = _context12.next) {
          case 0:
            fragment = getFragment.apply(void 0, _args12);
            if (!fragment.constant) {
              _context12.next = 5;
              break;
            }
            _context12.next = 4;
            return staticCall.apply(void 0, _args12);
          case 4:
            return _context12.abrupt("return", _context12.sent);
          case 5:
            _context12.next = 7;
            return send.apply(void 0, _args12);
          case 7:
            return _context12.abrupt("return", _context12.sent);
          case 8:
          case "end":
            return _context12.stop();
        }
      }, _callee12);
    }));
    return function method() {
      return _ref12.apply(this, arguments);
    };
  }();
  (0, index_js_3.defineProperties)(method, {
    name: contract["interface"].getFunctionName(key),
    _contract: contract,
    _key: key,
    getFragment: getFragment,
    estimateGas: estimateGas,
    populateTransaction: populateTransaction,
    send: send,
    staticCall: staticCall,
    staticCallResult: staticCallResult
  });
  // Only works on non-ambiguous keys (refined fragment is always non-ambiguous)
  Object.defineProperty(method, "fragment", {
    configurable: false,
    enumerable: true,
    get: function get() {
      var fragment = contract["interface"].getFunction(key);
      (0, index_js_3.assert)(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
        operation: "fragment",
        info: {
          key: key
        }
      });
      return fragment;
    }
  });
  return method;
}
function buildWrappedEvent(contract, key) {
  var getFragment = function getFragment() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }
    var fragment = contract["interface"].getEvent(key, args);
    (0, index_js_3.assert)(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
      operation: "fragment",
      info: {
        key: key,
        args: args
      }
    });
    return fragment;
  };
  var method = function method() {
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }
    return new PreparedTopicFilter(contract, getFragment.apply(void 0, args), args);
  };
  (0, index_js_3.defineProperties)(method, {
    name: contract["interface"].getEventName(key),
    _contract: contract,
    _key: key,
    getFragment: getFragment
  });
  // Only works on non-ambiguous keys (refined fragment is always non-ambiguous)
  Object.defineProperty(method, "fragment", {
    configurable: false,
    enumerable: true,
    get: function get() {
      var fragment = contract["interface"].getEvent(key);
      (0, index_js_3.assert)(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
        operation: "fragment",
        info: {
          key: key
        }
      });
      return fragment;
    }
  });
  return method;
}
// The combination of TypeScrype, Private Fields and Proxies makes
// the world go boom; so we hide variables with some trickery keeping
// a symbol attached to each BaseContract which its sub-class (even
// via a Proxy) can reach and use to look up its internal values.
var internal = Symbol["for"]("_ethersInternal_contract");
var internalValues = new WeakMap();
function setInternal(contract, values) {
  internalValues.set(contract[internal], values);
}
function getInternal(contract) {
  return internalValues.get(contract[internal]);
}
function isDeferred(value) {
  return value && _typeof(value) === "object" && "getTopicFilter" in value && typeof value.getTopicFilter === "function" && value.fragment;
}
function getSubInfo(_x11, _x12) {
  return _getSubInfo.apply(this, arguments);
}
function _getSubInfo() {
  _getSubInfo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee30(contract, event) {
    var topics, fragment, topicHashify, tag;
    return _regeneratorRuntime().wrap(function _callee30$(_context30) {
      while (1) switch (_context30.prev = _context30.next) {
        case 0:
          fragment = null; // Convert named events to topicHash and get the fragment for
          // events which need deconstructing.
          if (!Array.isArray(event)) {
            _context30.next = 6;
            break;
          }
          topicHashify = function topicHashify(name) {
            if ((0, index_js_3.isHexString)(name, 32)) {
              return name;
            }
            var fragment = contract["interface"].getEvent(name);
            (0, index_js_3.assertArgument)(fragment, "unknown fragment", "name", name);
            return fragment.topicHash;
          }; // Array of Topics and Names; e.g. `[ "0x1234...89ab", "Transfer(address)" ]`
          topics = event.map(function (e) {
            if (e == null) {
              return null;
            }
            if (Array.isArray(e)) {
              return e.map(topicHashify);
            }
            return topicHashify(e);
          });
          _context30.next = 21;
          break;
        case 6:
          if (!(event === "*")) {
            _context30.next = 10;
            break;
          }
          topics = [null];
          _context30.next = 21;
          break;
        case 10:
          if (!(typeof event === "string")) {
            _context30.next = 14;
            break;
          }
          if ((0, index_js_3.isHexString)(event, 32)) {
            // Topic Hash
            topics = [event];
          } else {
            // Name or Signature; e.g. `"Transfer", `"Transfer(address)"`
            fragment = contract["interface"].getEvent(event);
            (0, index_js_3.assertArgument)(fragment, "unknown fragment", "event", event);
            topics = [fragment.topicHash];
          }
          _context30.next = 21;
          break;
        case 14:
          if (!isDeferred(event)) {
            _context30.next = 20;
            break;
          }
          _context30.next = 17;
          return event.getTopicFilter();
        case 17:
          topics = _context30.sent;
          _context30.next = 21;
          break;
        case 20:
          if ("fragment" in event) {
            // ContractEvent; e.g. `contract.filter.Transfer`
            fragment = event.fragment;
            topics = [fragment.topicHash];
          } else {
            (0, index_js_3.assertArgument)(false, "unknown event name", "event", event);
          }
        case 21:
          // Normalize topics and sort TopicSets
          topics = topics.map(function (t) {
            if (t == null) {
              return null;
            }
            if (Array.isArray(t)) {
              var items = Array.from(new Set(t.map(function (t) {
                return t.toLowerCase();
              })).values());
              if (items.length === 1) {
                return items[0];
              }
              items.sort();
              return items;
            }
            return t.toLowerCase();
          });
          tag = topics.map(function (t) {
            if (t == null) {
              return "null";
            }
            if (Array.isArray(t)) {
              return t.join("|");
            }
            return t;
          }).join("&");
          return _context30.abrupt("return", {
            fragment: fragment,
            tag: tag,
            topics: topics
          });
        case 24:
        case "end":
          return _context30.stop();
      }
    }, _callee30);
  }));
  return _getSubInfo.apply(this, arguments);
}
function hasSub(_x13, _x14) {
  return _hasSub.apply(this, arguments);
}
function _hasSub() {
  _hasSub = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee31(contract, event) {
    var _getInternal5, subs;
    return _regeneratorRuntime().wrap(function _callee31$(_context31) {
      while (1) switch (_context31.prev = _context31.next) {
        case 0:
          _getInternal5 = getInternal(contract), subs = _getInternal5.subs;
          _context31.t1 = subs;
          _context31.next = 4;
          return getSubInfo(contract, event);
        case 4:
          _context31.t2 = _context31.sent.tag;
          _context31.t0 = _context31.t1.get.call(_context31.t1, _context31.t2);
          if (_context31.t0) {
            _context31.next = 8;
            break;
          }
          _context31.t0 = null;
        case 8:
          return _context31.abrupt("return", _context31.t0);
        case 9:
        case "end":
          return _context31.stop();
      }
    }, _callee31);
  }));
  return _hasSub.apply(this, arguments);
}
function getSub(_x15, _x16, _x17) {
  return _getSub.apply(this, arguments);
} // We use this to ensure one emit resolves before firing the next to
// ensure correct ordering (note this cannot throw and just adds the
// notice to the event queu using setTimeout).
function _getSub() {
  _getSub = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee33(contract, operation, event) {
    var provider, _yield$getSubInfo2, fragment, tag, topics, _getInternal6, addr, subs, sub, address, filter, listener, starting, start, stop;
    return _regeneratorRuntime().wrap(function _callee33$(_context33) {
      while (1) switch (_context33.prev = _context33.next) {
        case 0:
          // Make sure our runner can actually subscribe to events
          provider = getProvider(contract.runner);
          (0, index_js_3.assert)(provider, "contract runner does not support subscribing", "UNSUPPORTED_OPERATION", {
            operation: operation
          });
          _context33.next = 4;
          return getSubInfo(contract, event);
        case 4:
          _yield$getSubInfo2 = _context33.sent;
          fragment = _yield$getSubInfo2.fragment;
          tag = _yield$getSubInfo2.tag;
          topics = _yield$getSubInfo2.topics;
          _getInternal6 = getInternal(contract), addr = _getInternal6.addr, subs = _getInternal6.subs;
          sub = subs.get(tag);
          if (!sub) {
            address = addr ? addr : contract;
            filter = {
              address: address,
              topics: topics
            };
            listener = function listener(log) {
              var foundFragment = fragment;
              if (foundFragment == null) {
                try {
                  foundFragment = contract["interface"].getEvent(log.topics[0]);
                } catch (error) {}
              }
              // If fragment is null, we do not deconstruct the args to emit
              if (foundFragment) {
                var _foundFragment = foundFragment;
                var _args32 = fragment ? contract["interface"].decodeEventLog(fragment, log.data, log.topics) : [];
                _emit4(contract, event, _args32, function (listener) {
                  return new wrappers_js_1.ContractEventPayload(contract, listener, event, _foundFragment, log);
                });
              } else {
                _emit4(contract, event, [], function (listener) {
                  return new wrappers_js_1.ContractUnknownEventPayload(contract, listener, event, log);
                });
              }
            };
            starting = [];
            start = function start() {
              if (starting.length) {
                return;
              }
              starting.push(provider.on(filter, listener));
            };
            stop = /*#__PURE__*/function () {
              var _ref17 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee32() {
                var started;
                return _regeneratorRuntime().wrap(function _callee32$(_context32) {
                  while (1) switch (_context32.prev = _context32.next) {
                    case 0:
                      if (!(starting.length == 0)) {
                        _context32.next = 2;
                        break;
                      }
                      return _context32.abrupt("return");
                    case 2:
                      started = starting;
                      starting = [];
                      _context32.next = 6;
                      return Promise.all(started);
                    case 6:
                      provider.off(filter, listener);
                    case 7:
                    case "end":
                      return _context32.stop();
                  }
                }, _callee32);
              }));
              return function stop() {
                return _ref17.apply(this, arguments);
              };
            }();
            sub = {
              tag: tag,
              listeners: [],
              start: start,
              stop: stop
            };
            subs.set(tag, sub);
          }
          return _context33.abrupt("return", sub);
        case 12:
        case "end":
          return _context33.stop();
      }
    }, _callee33);
  }));
  return _getSub.apply(this, arguments);
}
var lastEmit = Promise.resolve();
function _emit(_x18, _x19, _x20, _x21) {
  return _emit2.apply(this, arguments);
}
function _emit2() {
  _emit2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee34(contract, event, args, payloadFunc) {
    var sub, count;
    return _regeneratorRuntime().wrap(function _callee34$(_context34) {
      while (1) switch (_context34.prev = _context34.next) {
        case 0:
          _context34.next = 2;
          return lastEmit;
        case 2:
          _context34.next = 4;
          return hasSub(contract, event);
        case 4:
          sub = _context34.sent;
          if (sub) {
            _context34.next = 7;
            break;
          }
          return _context34.abrupt("return", false);
        case 7:
          count = sub.listeners.length;
          sub.listeners = sub.listeners.filter(function (_ref18) {
            var listener = _ref18.listener,
              once = _ref18.once;
            var passArgs = Array.from(args);
            if (payloadFunc) {
              passArgs.push(payloadFunc(once ? null : listener));
            }
            try {
              listener.call.apply(listener, [contract].concat(passArgs));
            } catch (error) {}
            return !once;
          });
          if (sub.listeners.length === 0) {
            sub.stop();
            getInternal(contract).subs["delete"](sub.tag);
          }
          return _context34.abrupt("return", count > 0);
        case 11:
        case "end":
          return _context34.stop();
      }
    }, _callee34);
  }));
  return _emit2.apply(this, arguments);
}
function _emit4(_x22, _x23, _x24, _x25) {
  return _emit3.apply(this, arguments);
}
function _emit3() {
  _emit3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee35(contract, event, args, payloadFunc) {
    var resultPromise;
    return _regeneratorRuntime().wrap(function _callee35$(_context35) {
      while (1) switch (_context35.prev = _context35.next) {
        case 0:
          _context35.prev = 0;
          _context35.next = 3;
          return lastEmit;
        case 3:
          _context35.next = 7;
          break;
        case 5:
          _context35.prev = 5;
          _context35.t0 = _context35["catch"](0);
        case 7:
          resultPromise = _emit(contract, event, args, payloadFunc);
          lastEmit = resultPromise;
          _context35.next = 11;
          return resultPromise;
        case 11:
          return _context35.abrupt("return", _context35.sent);
        case 12:
        case "end":
          return _context35.stop();
      }
    }, _callee35, null, [[0, 5]]);
  }));
  return _emit3.apply(this, arguments);
}
var passProperties = ["then"];
var BaseContract = /*#__PURE__*/function () {
  /**
   *  Creates a new contract connected to %%target%% with the %%abi%% and
   *  optionally connected to a %%runner%% to perform operations on behalf
   *  of.
   */
  function BaseContract(target, abi, runner, _deployTx) {
    var _this = this;
    _classCallCheck(this, BaseContract);
    /**
     *  The target to connect to.
     *
     *  This can be an address, ENS name or any [[Addressable]], such as
     *  another contract. To get the resovled address, use the ``getAddress``
     *  method.
     */
    _defineProperty(this, "target", void 0);
    /**
     *  The contract Interface.
     */
    _defineProperty(this, "interface", void 0);
    /**
     *  The connected runner. This is generally a [[Provider]] or a
     *  [[Signer]], which dictates what operations are supported.
     *
     *  For example, a **Contract** connected to a [[Provider]] may
     *  only execute read-only operations.
     */
    _defineProperty(this, "runner", void 0);
    /**
     *  All the Events available on this contract.
     */
    _defineProperty(this, "filters", void 0);
    /**
     *  @_ignore:
     */
    _defineProperty(this, internal, void 0);
    /**
     *  The fallback or receive function if any.
     */
    _defineProperty(this, "fallback", void 0);
    (0, index_js_3.assertArgument)(typeof target === "string" || (0, index_js_2.isAddressable)(target), "invalid value for Contract target", "target", target);
    if (runner == null) {
      runner = null;
    }
    var iface = index_js_1.Interface.from(abi);
    (0, index_js_3.defineProperties)(this, {
      target: target,
      runner: runner,
      "interface": iface
    });
    Object.defineProperty(this, internal, {
      value: {}
    });
    var addrPromise;
    var addr = null;
    var deployTx = null;
    if (_deployTx) {
      var provider = getProvider(runner);
      // @TODO: the provider can be null; make a custom dummy provider that will throw a
      // meaningful error
      deployTx = new wrappers_js_1.ContractTransactionResponse(this["interface"], provider, _deployTx);
    }
    var subs = new Map();
    // Resolve the target as the address
    if (typeof target === "string") {
      if ((0, index_js_3.isHexString)(target)) {
        addr = target;
        addrPromise = Promise.resolve(target);
      } else {
        var resolver = getRunner(runner, "resolveName");
        if (!canResolve(resolver)) {
          throw (0, index_js_3.makeError)("contract runner does not support name resolution", "UNSUPPORTED_OPERATION", {
            operation: "resolveName"
          });
        }
        addrPromise = resolver.resolveName(target).then(function (addr) {
          if (addr == null) {
            throw (0, index_js_3.makeError)("an ENS name used for a contract target must be correctly configured", "UNCONFIGURED_NAME", {
              value: target
            });
          }
          getInternal(_this).addr = addr;
          return addr;
        });
      }
    } else {
      addrPromise = target.getAddress().then(function (addr) {
        if (addr == null) {
          throw new Error("TODO");
        }
        getInternal(_this).addr = addr;
        return addr;
      });
    }
    // Set our private values
    setInternal(this, {
      addrPromise: addrPromise,
      addr: addr,
      deployTx: deployTx,
      subs: subs
    });
    // Add the event filters
    var filters = new Proxy({}, {
      get: function get(target, prop, receiver) {
        // Pass important checks (like `then` for Promise) through
        if (_typeof(prop) === "symbol" || passProperties.indexOf(prop) >= 0) {
          return Reflect.get(target, prop, receiver);
        }
        try {
          return _this.getEvent(prop);
        } catch (error) {
          if (!(0, index_js_3.isError)(error, "INVALID_ARGUMENT") || error.argument !== "key") {
            throw error;
          }
        }
        return undefined;
      },
      has: function has(target, prop) {
        // Pass important checks (like `then` for Promise) through
        if (passProperties.indexOf(prop) >= 0) {
          return Reflect.has(target, prop);
        }
        return Reflect.has(target, prop) || _this["interface"].hasEvent(String(prop));
      }
    });
    (0, index_js_3.defineProperties)(this, {
      filters: filters
    });
    (0, index_js_3.defineProperties)(this, {
      fallback: iface.receive || iface.fallback ? buildWrappedFallback(this) : null
    });
    // Return a Proxy that will respond to functions
    return new Proxy(this, {
      get: function get(target, prop, receiver) {
        if (_typeof(prop) === "symbol" || prop in target || passProperties.indexOf(prop) >= 0) {
          return Reflect.get(target, prop, receiver);
        }
        // Undefined properties should return undefined
        try {
          return target.getFunction(prop);
        } catch (error) {
          if (!(0, index_js_3.isError)(error, "INVALID_ARGUMENT") || error.argument !== "key") {
            throw error;
          }
        }
        return undefined;
      },
      has: function has(target, prop) {
        if (_typeof(prop) === "symbol" || prop in target || passProperties.indexOf(prop) >= 0) {
          return Reflect.has(target, prop);
        }
        return target["interface"].hasFunction(prop);
      }
    });
  }
  /**
   *  Return a new Contract instance with the same target and ABI, but
   *  a different %%runner%%.
   */
  return _createClass(BaseContract, [{
    key: "connect",
    value: function connect(runner) {
      return new BaseContract(this.target, this["interface"], runner);
    }
    /**
     *  Return a new Contract instance with the same ABI and runner, but
     *  a different %%target%%.
     */
  }, {
    key: "attach",
    value: function attach(target) {
      return new BaseContract(target, this["interface"], this.runner);
    }
    /**
     *  Return the resolved address of this Contract.
     */
  }, {
    key: "getAddress",
    value: (function () {
      var _getAddress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13() {
        return _regeneratorRuntime().wrap(function _callee13$(_context13) {
          while (1) switch (_context13.prev = _context13.next) {
            case 0:
              _context13.next = 2;
              return getInternal(this).addrPromise;
            case 2:
              return _context13.abrupt("return", _context13.sent);
            case 3:
            case "end":
              return _context13.stop();
          }
        }, _callee13, this);
      }));
      function getAddress() {
        return _getAddress.apply(this, arguments);
      }
      return getAddress;
    }()
    /**
     *  Return the deployed bytecode or null if no bytecode is found.
     */
    )
  }, {
    key: "getDeployedCode",
    value: (function () {
      var _getDeployedCode = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14() {
        var provider, code;
        return _regeneratorRuntime().wrap(function _callee14$(_context14) {
          while (1) switch (_context14.prev = _context14.next) {
            case 0:
              provider = getProvider(this.runner);
              (0, index_js_3.assert)(provider, "runner does not support .provider", "UNSUPPORTED_OPERATION", {
                operation: "getDeployedCode"
              });
              _context14.t0 = provider;
              _context14.next = 5;
              return this.getAddress();
            case 5:
              _context14.t1 = _context14.sent;
              _context14.next = 8;
              return _context14.t0.getCode.call(_context14.t0, _context14.t1);
            case 8:
              code = _context14.sent;
              if (!(code === "0x")) {
                _context14.next = 11;
                break;
              }
              return _context14.abrupt("return", null);
            case 11:
              return _context14.abrupt("return", code);
            case 12:
            case "end":
              return _context14.stop();
          }
        }, _callee14, this);
      }));
      function getDeployedCode() {
        return _getDeployedCode.apply(this, arguments);
      }
      return getDeployedCode;
    }()
    /**
     *  Resolve to this Contract once the bytecode has been deployed, or
     *  resolve immediately if already deployed.
     */
    )
  }, {
    key: "waitForDeployment",
    value: (function () {
      var _waitForDeployment = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16() {
        var _this2 = this;
        var deployTx, code, provider;
        return _regeneratorRuntime().wrap(function _callee16$(_context16) {
          while (1) switch (_context16.prev = _context16.next) {
            case 0:
              // We have the deployement transaction; just use that (throws if deployement fails)
              deployTx = this.deploymentTransaction();
              if (!deployTx) {
                _context16.next = 5;
                break;
              }
              _context16.next = 4;
              return deployTx.wait();
            case 4:
              return _context16.abrupt("return", this);
            case 5:
              _context16.next = 7;
              return this.getDeployedCode();
            case 7:
              code = _context16.sent;
              if (!(code != null)) {
                _context16.next = 10;
                break;
              }
              return _context16.abrupt("return", this);
            case 10:
              // Make sure we can subscribe to a provider event
              provider = getProvider(this.runner);
              (0, index_js_3.assert)(provider != null, "contract runner does not support .provider", "UNSUPPORTED_OPERATION", {
                operation: "waitForDeployment"
              });
              return _context16.abrupt("return", new Promise(function (resolve, reject) {
                var checkCode = /*#__PURE__*/function () {
                  var _ref13 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15() {
                    var _code;
                    return _regeneratorRuntime().wrap(function _callee15$(_context15) {
                      while (1) switch (_context15.prev = _context15.next) {
                        case 0:
                          _context15.prev = 0;
                          _context15.next = 3;
                          return _this2.getDeployedCode();
                        case 3:
                          _code = _context15.sent;
                          if (!(_code != null)) {
                            _context15.next = 6;
                            break;
                          }
                          return _context15.abrupt("return", resolve(_this2));
                        case 6:
                          provider.once("block", checkCode);
                          _context15.next = 12;
                          break;
                        case 9:
                          _context15.prev = 9;
                          _context15.t0 = _context15["catch"](0);
                          reject(_context15.t0);
                        case 12:
                        case "end":
                          return _context15.stop();
                      }
                    }, _callee15, null, [[0, 9]]);
                  }));
                  return function checkCode() {
                    return _ref13.apply(this, arguments);
                  };
                }();
                checkCode();
              }));
            case 13:
            case "end":
              return _context16.stop();
          }
        }, _callee16, this);
      }));
      function waitForDeployment() {
        return _waitForDeployment.apply(this, arguments);
      }
      return waitForDeployment;
    }()
    /**
     *  Return the transaction used to deploy this contract.
     *
     *  This is only available if this instance was returned from a
     *  [[ContractFactory]].
     */
    )
  }, {
    key: "deploymentTransaction",
    value: function deploymentTransaction() {
      return getInternal(this).deployTx;
    }
    /**
     *  Return the function for a given name. This is useful when a contract
     *  method name conflicts with a JavaScript name such as ``prototype`` or
     *  when using a Contract programatically.
     */
  }, {
    key: "getFunction",
    value: function getFunction(key) {
      if (typeof key !== "string") {
        key = key.format();
      }
      var func = buildWrappedMethod(this, key);
      return func;
    }
    /**
     *  Return the event for a given name. This is useful when a contract
     *  event name conflicts with a JavaScript name such as ``prototype`` or
     *  when using a Contract programatically.
     */
  }, {
    key: "getEvent",
    value: function getEvent(key) {
      if (typeof key !== "string") {
        key = key.format();
      }
      return buildWrappedEvent(this, key);
    }
    /**
     *  @_ignore:
     */
  }, {
    key: "queryTransaction",
    value: (function () {
      var _queryTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17(hash) {
        return _regeneratorRuntime().wrap(function _callee17$(_context17) {
          while (1) switch (_context17.prev = _context17.next) {
            case 0:
              throw new Error("@TODO");
            case 1:
            case "end":
              return _context17.stop();
          }
        }, _callee17);
      }));
      function queryTransaction(_x26) {
        return _queryTransaction.apply(this, arguments);
      }
      return queryTransaction;
    }()
    /*
    // @TODO: this is a non-backwards compatible change, but will be added
    //        in v7 and in a potential SmartContract class in an upcoming
    //        v6 release
    async getTransactionReceipt(hash: string): Promise<null | ContractTransactionReceipt> {
        const provider = getProvider(this.runner);
        assert(provider, "contract runner does not have a provider",
            "UNSUPPORTED_OPERATION", { operation: "queryTransaction" });
         const receipt = await provider.getTransactionReceipt(hash);
        if (receipt == null) { return null; }
         return new ContractTransactionReceipt(this.interface, provider, receipt);
    }
    */
    /**
     *  Provide historic access to event data for %%event%% in the range
     *  %%fromBlock%% (default: ``0``) to %%toBlock%% (default: ``"latest"``)
     *  inclusive.
     */
    )
  }, {
    key: "queryFilter",
    value: (function () {
      var _queryFilter = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee18(event, fromBlock, toBlock) {
        var _this3 = this;
        var _getInternal, addr, addrPromise, address, _yield$getSubInfo, fragment, topics, filter, provider;
        return _regeneratorRuntime().wrap(function _callee18$(_context18) {
          while (1) switch (_context18.prev = _context18.next) {
            case 0:
              if (fromBlock == null) {
                fromBlock = 0;
              }
              if (toBlock == null) {
                toBlock = "latest";
              }
              _getInternal = getInternal(this), addr = _getInternal.addr, addrPromise = _getInternal.addrPromise;
              if (!addr) {
                _context18.next = 7;
                break;
              }
              _context18.t0 = addr;
              _context18.next = 10;
              break;
            case 7:
              _context18.next = 9;
              return addrPromise;
            case 9:
              _context18.t0 = _context18.sent;
            case 10:
              address = _context18.t0;
              _context18.next = 13;
              return getSubInfo(this, event);
            case 13:
              _yield$getSubInfo = _context18.sent;
              fragment = _yield$getSubInfo.fragment;
              topics = _yield$getSubInfo.topics;
              filter = {
                address: address,
                topics: topics,
                fromBlock: fromBlock,
                toBlock: toBlock
              };
              provider = getProvider(this.runner);
              (0, index_js_3.assert)(provider, "contract runner does not have a provider", "UNSUPPORTED_OPERATION", {
                operation: "queryFilter"
              });
              _context18.next = 21;
              return provider.getLogs(filter);
            case 21:
              return _context18.abrupt("return", _context18.sent.map(function (log) {
                var foundFragment = fragment;
                if (foundFragment == null) {
                  try {
                    foundFragment = _this3["interface"].getEvent(log.topics[0]);
                  } catch (error) {}
                }
                if (foundFragment) {
                  try {
                    return new wrappers_js_1.EventLog(log, _this3["interface"], foundFragment);
                  } catch (error) {
                    return new wrappers_js_1.UndecodedEventLog(log, error);
                  }
                }
                return new provider_js_1.Log(log, provider);
              }));
            case 22:
            case "end":
              return _context18.stop();
          }
        }, _callee18, this);
      }));
      function queryFilter(_x27, _x28, _x29) {
        return _queryFilter.apply(this, arguments);
      }
      return queryFilter;
    }()
    /**
     *  Add an event %%listener%% for the %%event%%.
     */
    )
  }, {
    key: "on",
    value: (function () {
      var _on = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee19(event, listener) {
        var sub;
        return _regeneratorRuntime().wrap(function _callee19$(_context19) {
          while (1) switch (_context19.prev = _context19.next) {
            case 0:
              _context19.next = 2;
              return getSub(this, "on", event);
            case 2:
              sub = _context19.sent;
              sub.listeners.push({
                listener: listener,
                once: false
              });
              sub.start();
              return _context19.abrupt("return", this);
            case 6:
            case "end":
              return _context19.stop();
          }
        }, _callee19, this);
      }));
      function on(_x30, _x31) {
        return _on.apply(this, arguments);
      }
      return on;
    }()
    /**
     *  Add an event %%listener%% for the %%event%%, but remove the listener
     *  after it is fired once.
     */
    )
  }, {
    key: "once",
    value: (function () {
      var _once = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee20(event, listener) {
        var sub;
        return _regeneratorRuntime().wrap(function _callee20$(_context20) {
          while (1) switch (_context20.prev = _context20.next) {
            case 0:
              _context20.next = 2;
              return getSub(this, "once", event);
            case 2:
              sub = _context20.sent;
              sub.listeners.push({
                listener: listener,
                once: true
              });
              sub.start();
              return _context20.abrupt("return", this);
            case 6:
            case "end":
              return _context20.stop();
          }
        }, _callee20, this);
      }));
      function once(_x32, _x33) {
        return _once.apply(this, arguments);
      }
      return once;
    }()
    /**
     *  Emit an %%event%% calling all listeners with %%args%%.
     *
     *  Resolves to ``true`` if any listeners were called.
     */
    )
  }, {
    key: "emit",
    value: (function () {
      var _emit5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee21(event) {
        var _len5,
          args,
          _key5,
          _args21 = arguments;
        return _regeneratorRuntime().wrap(function _callee21$(_context21) {
          while (1) switch (_context21.prev = _context21.next) {
            case 0:
              for (_len5 = _args21.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
                args[_key5 - 1] = _args21[_key5];
              }
              _context21.next = 3;
              return _emit4(this, event, args, null);
            case 3:
              return _context21.abrupt("return", _context21.sent);
            case 4:
            case "end":
              return _context21.stop();
          }
        }, _callee21, this);
      }));
      function emit(_x34) {
        return _emit5.apply(this, arguments);
      }
      return emit;
    }()
    /**
     *  Resolves to the number of listeners of %%event%% or the total number
     *  of listeners if unspecified.
     */
    )
  }, {
    key: "listenerCount",
    value: (function () {
      var _listenerCount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee22(event) {
        var sub, _getInternal2, subs, total, _iterator, _step, listeners;
        return _regeneratorRuntime().wrap(function _callee22$(_context22) {
          while (1) switch (_context22.prev = _context22.next) {
            case 0:
              if (!event) {
                _context22.next = 7;
                break;
              }
              _context22.next = 3;
              return hasSub(this, event);
            case 3:
              sub = _context22.sent;
              if (sub) {
                _context22.next = 6;
                break;
              }
              return _context22.abrupt("return", 0);
            case 6:
              return _context22.abrupt("return", sub.listeners.length);
            case 7:
              _getInternal2 = getInternal(this), subs = _getInternal2.subs;
              total = 0;
              _iterator = _createForOfIteratorHelper(subs.values());
              try {
                for (_iterator.s(); !(_step = _iterator.n()).done;) {
                  listeners = _step.value.listeners;
                  total += listeners.length;
                }
              } catch (err) {
                _iterator.e(err);
              } finally {
                _iterator.f();
              }
              return _context22.abrupt("return", total);
            case 12:
            case "end":
              return _context22.stop();
          }
        }, _callee22, this);
      }));
      function listenerCount(_x35) {
        return _listenerCount.apply(this, arguments);
      }
      return listenerCount;
    }()
    /**
     *  Resolves to the listeners subscribed to %%event%% or all listeners
     *  if unspecified.
     */
    )
  }, {
    key: "listeners",
    value: (function () {
      var _listeners = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee23(event) {
        var sub, _getInternal3, subs, result, _iterator2, _step2, _listeners2;
        return _regeneratorRuntime().wrap(function _callee23$(_context23) {
          while (1) switch (_context23.prev = _context23.next) {
            case 0:
              if (!event) {
                _context23.next = 7;
                break;
              }
              _context23.next = 3;
              return hasSub(this, event);
            case 3:
              sub = _context23.sent;
              if (sub) {
                _context23.next = 6;
                break;
              }
              return _context23.abrupt("return", []);
            case 6:
              return _context23.abrupt("return", sub.listeners.map(function (_ref14) {
                var listener = _ref14.listener;
                return listener;
              }));
            case 7:
              _getInternal3 = getInternal(this), subs = _getInternal3.subs;
              result = [];
              _iterator2 = _createForOfIteratorHelper(subs.values());
              try {
                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                  _listeners2 = _step2.value.listeners;
                  result = result.concat(_listeners2.map(function (_ref15) {
                    var listener = _ref15.listener;
                    return listener;
                  }));
                }
              } catch (err) {
                _iterator2.e(err);
              } finally {
                _iterator2.f();
              }
              return _context23.abrupt("return", result);
            case 12:
            case "end":
              return _context23.stop();
          }
        }, _callee23, this);
      }));
      function listeners(_x36) {
        return _listeners.apply(this, arguments);
      }
      return listeners;
    }()
    /**
     *  Remove the %%listener%% from the listeners for %%event%% or remove
     *  all listeners if unspecified.
     */
    )
  }, {
    key: "off",
    value: (function () {
      var _off = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee24(event, listener) {
        var sub, index;
        return _regeneratorRuntime().wrap(function _callee24$(_context24) {
          while (1) switch (_context24.prev = _context24.next) {
            case 0:
              _context24.next = 2;
              return hasSub(this, event);
            case 2:
              sub = _context24.sent;
              if (sub) {
                _context24.next = 5;
                break;
              }
              return _context24.abrupt("return", this);
            case 5:
              if (listener) {
                index = sub.listeners.map(function (_ref16) {
                  var listener = _ref16.listener;
                  return listener;
                }).indexOf(listener);
                if (index >= 0) {
                  sub.listeners.splice(index, 1);
                }
              }
              if (listener == null || sub.listeners.length === 0) {
                sub.stop();
                getInternal(this).subs["delete"](sub.tag);
              }
              return _context24.abrupt("return", this);
            case 8:
            case "end":
              return _context24.stop();
          }
        }, _callee24, this);
      }));
      function off(_x37, _x38) {
        return _off.apply(this, arguments);
      }
      return off;
    }()
    /**
     *  Remove all the listeners for %%event%% or remove all listeners if
     *  unspecified.
     */
    )
  }, {
    key: "removeAllListeners",
    value: (function () {
      var _removeAllListeners = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee25(event) {
        var sub, _getInternal4, subs, _iterator3, _step3, _step3$value, tag, stop;
        return _regeneratorRuntime().wrap(function _callee25$(_context25) {
          while (1) switch (_context25.prev = _context25.next) {
            case 0:
              if (!event) {
                _context25.next = 10;
                break;
              }
              _context25.next = 3;
              return hasSub(this, event);
            case 3:
              sub = _context25.sent;
              if (sub) {
                _context25.next = 6;
                break;
              }
              return _context25.abrupt("return", this);
            case 6:
              sub.stop();
              getInternal(this).subs["delete"](sub.tag);
              _context25.next = 13;
              break;
            case 10:
              _getInternal4 = getInternal(this), subs = _getInternal4.subs;
              _iterator3 = _createForOfIteratorHelper(subs.values());
              try {
                for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                  _step3$value = _step3.value, tag = _step3$value.tag, stop = _step3$value.stop;
                  stop();
                  subs["delete"](tag);
                }
              } catch (err) {
                _iterator3.e(err);
              } finally {
                _iterator3.f();
              }
            case 13:
              return _context25.abrupt("return", this);
            case 14:
            case "end":
              return _context25.stop();
          }
        }, _callee25, this);
      }));
      function removeAllListeners(_x39) {
        return _removeAllListeners.apply(this, arguments);
      }
      return removeAllListeners;
    }()
    /**
     *  Alias for [on].
     */
    )
  }, {
    key: "addListener",
    value: (function () {
      var _addListener = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee26(event, listener) {
        return _regeneratorRuntime().wrap(function _callee26$(_context26) {
          while (1) switch (_context26.prev = _context26.next) {
            case 0:
              _context26.next = 2;
              return this.on(event, listener);
            case 2:
              return _context26.abrupt("return", _context26.sent);
            case 3:
            case "end":
              return _context26.stop();
          }
        }, _callee26, this);
      }));
      function addListener(_x40, _x41) {
        return _addListener.apply(this, arguments);
      }
      return addListener;
    }()
    /**
     *  Alias for [off].
     */
    )
  }, {
    key: "removeListener",
    value: (function () {
      var _removeListener = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee27(event, listener) {
        return _regeneratorRuntime().wrap(function _callee27$(_context27) {
          while (1) switch (_context27.prev = _context27.next) {
            case 0:
              _context27.next = 2;
              return this.off(event, listener);
            case 2:
              return _context27.abrupt("return", _context27.sent);
            case 3:
            case "end":
              return _context27.stop();
          }
        }, _callee27, this);
      }));
      function removeListener(_x42, _x43) {
        return _removeListener.apply(this, arguments);
      }
      return removeListener;
    }()
    /**
     *  Create a new Class for the %%abi%%.
     */
    )
  }], [{
    key: "buildClass",
    value: function buildClass(abi) {
      var CustomContract = /*#__PURE__*/function (_BaseContract2) {
        function CustomContract(address) {
          var runner = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          _classCallCheck(this, CustomContract);
          return _callSuper(this, CustomContract, [address, abi, runner]);
        }
        _inherits(CustomContract, _BaseContract2);
        return _createClass(CustomContract);
      }(BaseContract);
      return CustomContract;
    }
  }, {
    key: "from",
    value:
    /**
     *  Create a new BaseContract with a specified Interface.
     */
    function from(target, abi, runner) {
      if (runner == null) {
        runner = null;
      }
      var contract = new this(target, abi, runner);
      return contract;
    }
  }]);
}();
exports.BaseContract = BaseContract;
function _ContractBase() {
  return BaseContract;
}
/**
 *  A [[BaseContract]] with no type guards on its methods or events.
 */
var Contract = /*#__PURE__*/function (_ContractBase2) {
  function Contract() {
    _classCallCheck(this, Contract);
    return _callSuper(this, Contract, arguments);
  }
  _inherits(Contract, _ContractBase2);
  return _createClass(Contract);
}(_ContractBase());
exports.Contract = Contract;

},{"../abi/index.js":201,"../address/index.js":207,"../providers/provider.js":259,"../utils/index.js":276,"./wrappers.js":216}],214:[function(require,module,exports){
"use strict";

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ContractFactory = void 0;
var index_js_1 = require("../abi/index.js");
var index_js_2 = require("../address/index.js");
var index_js_3 = require("../utils/index.js");
var contract_js_1 = require("./contract.js");
// A = Arguments to the constructor
// I = Interface of deployed contracts
/**
 *  A **ContractFactory** is used to deploy a Contract to the blockchain.
 */
var ContractFactory = /*#__PURE__*/function () {
  /**
   *  Create a new **ContractFactory** with %%abi%% and %%bytecode%%,
   *  optionally connected to %%runner%%.
   *
   *  The %%bytecode%% may be the ``bytecode`` property within the
   *  standard Solidity JSON output.
   */
  function ContractFactory(abi, bytecode, runner) {
    _classCallCheck(this, ContractFactory);
    /**
     *  The Contract Interface.
     */
    _defineProperty(this, "interface", void 0);
    /**
     *  The Contract deployment bytecode. Often called the initcode.
     */
    _defineProperty(this, "bytecode", void 0);
    /**
     *  The ContractRunner to deploy the Contract as.
     */
    _defineProperty(this, "runner", void 0);
    var iface = index_js_1.Interface.from(abi);
    // Dereference Solidity bytecode objects and allow a missing `0x`-prefix
    if (bytecode instanceof Uint8Array) {
      bytecode = (0, index_js_3.hexlify)((0, index_js_3.getBytes)(bytecode));
    } else {
      if (_typeof(bytecode) === "object") {
        bytecode = bytecode.object;
      }
      if (!bytecode.startsWith("0x")) {
        bytecode = "0x" + bytecode;
      }
      bytecode = (0, index_js_3.hexlify)((0, index_js_3.getBytes)(bytecode));
    }
    (0, index_js_3.defineProperties)(this, {
      bytecode: bytecode,
      "interface": iface,
      runner: runner || null
    });
  }
  return _createClass(ContractFactory, [{
    key: "attach",
    value: function attach(target) {
      return new contract_js_1.BaseContract(target, this["interface"], this.runner);
    }
    /**
     *  Resolves to the transaction to deploy the contract, passing %%args%%
     *  into the constructor.
     */
  }, {
    key: "getDeployTransaction",
    value: (function () {
      var _getDeployTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var overrides,
          fragment,
          _len,
          args,
          _key,
          resolvedArgs,
          data,
          _args = arguments;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              overrides = {};
              fragment = this["interface"].deploy;
              for (_len = _args.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = _args[_key];
              }
              if (!(fragment.inputs.length + 1 === args.length)) {
                _context.next = 7;
                break;
              }
              _context.next = 6;
              return (0, contract_js_1.copyOverrides)(args.pop());
            case 6:
              overrides = _context.sent;
            case 7:
              if (!(fragment.inputs.length !== args.length)) {
                _context.next = 9;
                break;
              }
              throw new Error("incorrect number of arguments to constructor");
            case 9:
              _context.next = 11;
              return (0, contract_js_1.resolveArgs)(this.runner, fragment.inputs, args);
            case 11:
              resolvedArgs = _context.sent;
              data = (0, index_js_3.concat)([this.bytecode, this["interface"].encodeDeploy(resolvedArgs)]);
              return _context.abrupt("return", Object.assign({}, overrides, {
                data: data
              }));
            case 14:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function getDeployTransaction() {
        return _getDeployTransaction.apply(this, arguments);
      }
      return getDeployTransaction;
    }()
    /**
     *  Resolves to the Contract deployed by passing %%args%% into the
     *  constructor.
     *
     *  This will resolve to the Contract before it has been deployed to the
     *  network, so the [[BaseContract-waitForDeployment]] should be used before
     *  sending any transactions to it.
     */
    )
  }, {
    key: "deploy",
    value: (function () {
      var _deploy = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        var tx,
          sentTx,
          address,
          _args2 = arguments;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return this.getDeployTransaction.apply(this, _args2);
            case 2:
              tx = _context2.sent;
              (0, index_js_3.assert)(this.runner && typeof this.runner.sendTransaction === "function", "factory runner does not support sending transactions", "UNSUPPORTED_OPERATION", {
                operation: "sendTransaction"
              });
              _context2.next = 6;
              return this.runner.sendTransaction(tx);
            case 6:
              sentTx = _context2.sent;
              address = (0, index_js_2.getCreateAddress)(sentTx);
              return _context2.abrupt("return", new contract_js_1.BaseContract(address, this["interface"], this.runner, sentTx));
            case 9:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function deploy() {
        return _deploy.apply(this, arguments);
      }
      return deploy;
    }()
    /**
     *  Return a new **ContractFactory** with the same ABI and bytecode,
     *  but connected to %%runner%%.
     */
    )
  }, {
    key: "connect",
    value: function connect(runner) {
      return new ContractFactory(this["interface"], this.bytecode, runner);
    }
    /**
     *  Create a new **ContractFactory** from the standard Solidity JSON output.
     */
  }], [{
    key: "fromSolidity",
    value: function fromSolidity(output, runner) {
      (0, index_js_3.assertArgument)(output != null, "bad compiler output", "output", output);
      if (typeof output === "string") {
        output = JSON.parse(output);
      }
      var abi = output.abi;
      var bytecode = "";
      if (output.bytecode) {
        bytecode = output.bytecode;
      } else if (output.evm && output.evm.bytecode) {
        bytecode = output.evm.bytecode;
      }
      return new this(abi, bytecode, runner);
    }
  }]);
}();
exports.ContractFactory = ContractFactory;

},{"../abi/index.js":201,"../address/index.js":207,"../utils/index.js":276,"./contract.js":213}],215:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.UndecodedEventLog = exports.EventLog = exports.ContractTransactionResponse = exports.ContractTransactionReceipt = exports.ContractUnknownEventPayload = exports.ContractEventPayload = exports.ContractFactory = exports.Contract = exports.BaseContract = void 0;
/**
 *  A **Contract** object is a meta-class (a class whose definition is
 *  defined at runtime), which communicates with a deployed smart contract
 *  on the blockchain and provides a simple JavaScript interface to call
 *  methods, send transaction, query historic logs and listen for its events.
 *
 *  @_section: api/contract:Contracts  [about-contracts]
 */
var contract_js_1 = require("./contract.js");
Object.defineProperty(exports, "BaseContract", {
  enumerable: true,
  get: function get() {
    return contract_js_1.BaseContract;
  }
});
Object.defineProperty(exports, "Contract", {
  enumerable: true,
  get: function get() {
    return contract_js_1.Contract;
  }
});
var factory_js_1 = require("./factory.js");
Object.defineProperty(exports, "ContractFactory", {
  enumerable: true,
  get: function get() {
    return factory_js_1.ContractFactory;
  }
});
var wrappers_js_1 = require("./wrappers.js");
Object.defineProperty(exports, "ContractEventPayload", {
  enumerable: true,
  get: function get() {
    return wrappers_js_1.ContractEventPayload;
  }
});
Object.defineProperty(exports, "ContractUnknownEventPayload", {
  enumerable: true,
  get: function get() {
    return wrappers_js_1.ContractUnknownEventPayload;
  }
});
Object.defineProperty(exports, "ContractTransactionReceipt", {
  enumerable: true,
  get: function get() {
    return wrappers_js_1.ContractTransactionReceipt;
  }
});
Object.defineProperty(exports, "ContractTransactionResponse", {
  enumerable: true,
  get: function get() {
    return wrappers_js_1.ContractTransactionResponse;
  }
});
Object.defineProperty(exports, "EventLog", {
  enumerable: true,
  get: function get() {
    return wrappers_js_1.EventLog;
  }
});
Object.defineProperty(exports, "UndecodedEventLog", {
  enumerable: true,
  get: function get() {
    return wrappers_js_1.UndecodedEventLog;
  }
});

},{"./contract.js":213,"./factory.js":214,"./wrappers.js":216}],216:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _get() { return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }
function _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ContractEventPayload = exports.ContractUnknownEventPayload = exports.ContractTransactionResponse = exports.ContractTransactionReceipt = exports.UndecodedEventLog = exports.EventLog = void 0;
// import from provider.ts instead of index.ts to prevent circular dep
// from EtherscanProvider
var provider_js_1 = require("../providers/provider.js");
var index_js_1 = require("../utils/index.js");
/**
 *  An **EventLog** contains additional properties parsed from the [[Log]].
 */
var EventLog = /*#__PURE__*/function (_provider_js_1$Log) {
  /**
   * @_ignore:
   */
  function EventLog(log, iface, fragment) {
    var _this;
    _classCallCheck(this, EventLog);
    _this = _callSuper(this, EventLog, [log, log.provider]);
    /**
     *  The Contract Interface.
     */
    _defineProperty(_this, "interface", void 0);
    /**
     *  The matching event.
     */
    _defineProperty(_this, "fragment", void 0);
    /**
     *  The parsed arguments passed to the event by ``emit``.
     */
    _defineProperty(_this, "args", void 0);
    var args = iface.decodeEventLog(fragment, log.data, log.topics);
    (0, index_js_1.defineProperties)(_this, {
      args: args,
      fragment: fragment,
      "interface": iface
    });
    return _this;
  }
  /**
   *  The name of the event.
   */
  _inherits(EventLog, _provider_js_1$Log);
  return _createClass(EventLog, [{
    key: "eventName",
    get: function get() {
      return this.fragment.name;
    }
    /**
     *  The signature of the event.
     */
  }, {
    key: "eventSignature",
    get: function get() {
      return this.fragment.format();
    }
  }]);
}(provider_js_1.Log);
exports.EventLog = EventLog;
/**
 *  An **EventLog** contains additional properties parsed from the [[Log]].
 */
var UndecodedEventLog = /*#__PURE__*/function (_provider_js_1$Log2) {
  /**
   * @_ignore:
   */
  function UndecodedEventLog(log, error) {
    var _this2;
    _classCallCheck(this, UndecodedEventLog);
    _this2 = _callSuper(this, UndecodedEventLog, [log, log.provider]);
    /**
     *  The error encounted when trying to decode the log.
     */
    _defineProperty(_this2, "error", void 0);
    (0, index_js_1.defineProperties)(_this2, {
      error: error
    });
    return _this2;
  }
  _inherits(UndecodedEventLog, _provider_js_1$Log2);
  return _createClass(UndecodedEventLog);
}(provider_js_1.Log);
exports.UndecodedEventLog = UndecodedEventLog;
/**
 *  A **ContractTransactionReceipt** includes the parsed logs from a
 *  [[TransactionReceipt]].
 */
var _iface = /*#__PURE__*/new WeakMap();
var ContractTransactionReceipt = /*#__PURE__*/function (_provider_js_1$Transa) {
  /**
   *  @_ignore:
   */
  function ContractTransactionReceipt(iface, provider, tx) {
    var _this3;
    _classCallCheck(this, ContractTransactionReceipt);
    _this3 = _callSuper(this, ContractTransactionReceipt, [tx, provider]);
    _classPrivateFieldInitSpec(_this3, _iface, void 0);
    _classPrivateFieldSet(_iface, _this3, iface);
    return _this3;
  }
  /**
   *  The parsed logs for any [[Log]] which has a matching event in the
   *  Contract ABI.
   */
  _inherits(ContractTransactionReceipt, _provider_js_1$Transa);
  return _createClass(ContractTransactionReceipt, [{
    key: "logs",
    get: function get() {
      var _this4 = this;
      return _get(_getPrototypeOf(ContractTransactionReceipt.prototype), "logs", this).map(function (log) {
        var fragment = log.topics.length ? _classPrivateFieldGet(_iface, _this4).getEvent(log.topics[0]) : null;
        if (fragment) {
          try {
            return new EventLog(log, _classPrivateFieldGet(_iface, _this4), fragment);
          } catch (error) {
            return new UndecodedEventLog(log, error);
          }
        }
        return log;
      });
    }
  }]);
}(provider_js_1.TransactionReceipt);
exports.ContractTransactionReceipt = ContractTransactionReceipt;
/**
 *  A **ContractTransactionResponse** will return a
 *  [[ContractTransactionReceipt]] when waited on.
 */
var _iface2 = /*#__PURE__*/new WeakMap();
var ContractTransactionResponse = /*#__PURE__*/function (_provider_js_1$Transa2) {
  /**
   *  @_ignore:
   */
  function ContractTransactionResponse(iface, provider, tx) {
    var _this5;
    _classCallCheck(this, ContractTransactionResponse);
    _this5 = _callSuper(this, ContractTransactionResponse, [tx, provider]);
    _classPrivateFieldInitSpec(_this5, _iface2, void 0);
    _classPrivateFieldSet(_iface2, _this5, iface);
    return _this5;
  }
  /**
   *  Resolves once this transaction has been mined and has
   *  %%confirms%% blocks including it (default: ``1``) with an
   *  optional %%timeout%%.
   *
   *  This can resolve to ``null`` only if %%confirms%% is ``0``
   *  and the transaction has not been mined, otherwise this will
   *  wait until enough confirmations have completed.
   */
  _inherits(ContractTransactionResponse, _provider_js_1$Transa2);
  return _createClass(ContractTransactionResponse, [{
    key: "wait",
    value: (function () {
      var _wait = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(confirms, timeout) {
        var receipt;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return _get(_getPrototypeOf(ContractTransactionResponse.prototype), "wait", this).call(this, confirms, timeout);
            case 2:
              receipt = _context.sent;
              if (!(receipt == null)) {
                _context.next = 5;
                break;
              }
              return _context.abrupt("return", null);
            case 5:
              return _context.abrupt("return", new ContractTransactionReceipt(_classPrivateFieldGet(_iface2, this), this.provider, receipt));
            case 6:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function wait(_x, _x2) {
        return _wait.apply(this, arguments);
      }
      return wait;
    }())
  }]);
}(provider_js_1.TransactionResponse);
exports.ContractTransactionResponse = ContractTransactionResponse;
/**
 *  A **ContractUnknownEventPayload** is included as the last parameter to
 *  Contract Events when the event does not match any events in the ABI.
 */
var ContractUnknownEventPayload = /*#__PURE__*/function (_index_js_1$EventPayl) {
  /**
   *  @_event:
   */
  function ContractUnknownEventPayload(contract, listener, filter, log) {
    var _this6;
    _classCallCheck(this, ContractUnknownEventPayload);
    _this6 = _callSuper(this, ContractUnknownEventPayload, [contract, listener, filter]);
    /**
     *  The log with no matching events.
     */
    _defineProperty(_this6, "log", void 0);
    (0, index_js_1.defineProperties)(_this6, {
      log: log
    });
    return _this6;
  }
  /**
   *  Resolves to the block the event occured in.
   */
  _inherits(ContractUnknownEventPayload, _index_js_1$EventPayl);
  return _createClass(ContractUnknownEventPayload, [{
    key: "getBlock",
    value: (function () {
      var _getBlock = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return this.log.getBlock();
            case 2:
              return _context2.abrupt("return", _context2.sent);
            case 3:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function getBlock() {
        return _getBlock.apply(this, arguments);
      }
      return getBlock;
    }()
    /**
     *  Resolves to the transaction the event occured in.
     */
    )
  }, {
    key: "getTransaction",
    value: (function () {
      var _getTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _context3.next = 2;
              return this.log.getTransaction();
            case 2:
              return _context3.abrupt("return", _context3.sent);
            case 3:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function getTransaction() {
        return _getTransaction.apply(this, arguments);
      }
      return getTransaction;
    }()
    /**
     *  Resolves to the transaction receipt the event occured in.
     */
    )
  }, {
    key: "getTransactionReceipt",
    value: (function () {
      var _getTransactionReceipt = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              _context4.next = 2;
              return this.log.getTransactionReceipt();
            case 2:
              return _context4.abrupt("return", _context4.sent);
            case 3:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));
      function getTransactionReceipt() {
        return _getTransactionReceipt.apply(this, arguments);
      }
      return getTransactionReceipt;
    }())
  }]);
}(index_js_1.EventPayload);
exports.ContractUnknownEventPayload = ContractUnknownEventPayload;
/**
 *  A **ContractEventPayload** is included as the last parameter to
 *  Contract Events when the event is known.
 */
var ContractEventPayload = /*#__PURE__*/function (_ContractUnknownEvent) {
  /**
   *  @_ignore:
   */
  function ContractEventPayload(contract, listener, filter, fragment, _log) {
    var _this7;
    _classCallCheck(this, ContractEventPayload);
    _this7 = _callSuper(this, ContractEventPayload, [contract, listener, filter, new EventLog(_log, contract["interface"], fragment)]);
    var args = contract["interface"].decodeEventLog(fragment, _this7.log.data, _this7.log.topics);
    (0, index_js_1.defineProperties)(_this7, {
      args: args,
      fragment: fragment
    });
    return _this7;
  }
  /**
   *  The event name.
   */
  _inherits(ContractEventPayload, _ContractUnknownEvent);
  return _createClass(ContractEventPayload, [{
    key: "eventName",
    get: function get() {
      return this.fragment.name;
    }
    /**
     *  The event signature.
     */
  }, {
    key: "eventSignature",
    get: function get() {
      return this.fragment.format();
    }
  }]);
}(ContractUnknownEventPayload);
exports.ContractEventPayload = ContractEventPayload;

},{"../providers/provider.js":259,"../utils/index.js":276}],217:[function(require,module,exports){
(function (global){(function (){
"use strict";

/* Browser Crypto Shims */
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.randomBytes = exports.pbkdf2Sync = exports.createHmac = exports.createHash = void 0;
var hmac_1 = require("@noble/hashes/hmac");
var pbkdf2_1 = require("@noble/hashes/pbkdf2");
var sha256_1 = require("@noble/hashes/sha256");
var sha512_1 = require("@noble/hashes/sha512");
var index_js_1 = require("../utils/index.js");
function getGlobal() {
  if (typeof self !== 'undefined') {
    return self;
  }
  if (typeof window !== 'undefined') {
    return window;
  }
  if (typeof global !== 'undefined') {
    return global;
  }
  throw new Error('unable to locate global object');
}
;
var anyGlobal = getGlobal();
var crypto = anyGlobal.crypto || anyGlobal.msCrypto;
function createHash(algo) {
  switch (algo) {
    case "sha256":
      return sha256_1.sha256.create();
    case "sha512":
      return sha512_1.sha512.create();
  }
  (0, index_js_1.assertArgument)(false, "invalid hashing algorithm name", "algorithm", algo);
}
exports.createHash = createHash;
function createHmac(_algo, key) {
  var algo = {
    sha256: sha256_1.sha256,
    sha512: sha512_1.sha512
  }[_algo];
  (0, index_js_1.assertArgument)(algo != null, "invalid hmac algorithm", "algorithm", _algo);
  return hmac_1.hmac.create(algo, key);
}
exports.createHmac = createHmac;
function pbkdf2Sync(password, salt, iterations, keylen, _algo) {
  var algo = {
    sha256: sha256_1.sha256,
    sha512: sha512_1.sha512
  }[_algo];
  (0, index_js_1.assertArgument)(algo != null, "invalid pbkdf2 algorithm", "algorithm", _algo);
  return (0, pbkdf2_1.pbkdf2)(algo, password, salt, {
    c: iterations,
    dkLen: keylen
  });
}
exports.pbkdf2Sync = pbkdf2Sync;
function randomBytes(length) {
  (0, index_js_1.assert)(crypto != null, "platform does not support secure random numbers", "UNSUPPORTED_OPERATION", {
    operation: "randomBytes"
  });
  (0, index_js_1.assertArgument)(Number.isInteger(length) && length > 0 && length <= 1024, "invalid length", "length", length);
  var result = new Uint8Array(length);
  crypto.getRandomValues(result);
  return result;
}
exports.randomBytes = randomBytes;

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../utils/index.js":276,"@noble/hashes/hmac":66,"@noble/hashes/pbkdf2":67,"@noble/hashes/sha256":70,"@noble/hashes/sha512":72}],218:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.computeHmac = void 0;
/**
 *  An **HMAC** enables verification that a given key was used
 *  to authenticate a payload.
 *
 *  See: [[link-wiki-hmac]]
 *
 *  @_subsection: api/crypto:HMAC  [about-hmac]
 */
var crypto_js_1 = require("./crypto.js");
var index_js_1 = require("../utils/index.js");
var locked = false;
var _computeHmac = function _computeHmac(algorithm, key, data) {
  return (0, crypto_js_1.createHmac)(algorithm, key).update(data).digest();
};
var __computeHmac = _computeHmac;
/**
 *  Return the HMAC for %%data%% using the %%key%% key with the underlying
 *  %%algo%% used for compression.
 *
 *  @example:
 *    key = id("some-secret")
 *
 *    // Compute the HMAC
 *    computeHmac("sha256", key, "0x1337")
 *    //_result:
 *
 *    // To compute the HMAC of UTF-8 data, the data must be
 *    // converted to UTF-8 bytes
 *    computeHmac("sha256", key, toUtf8Bytes("Hello World"))
 *    //_result:
 *
 */
function computeHmac(algorithm, _key, _data) {
  var key = (0, index_js_1.getBytes)(_key, "key");
  var data = (0, index_js_1.getBytes)(_data, "data");
  return (0, index_js_1.hexlify)(__computeHmac(algorithm, key, data));
}
exports.computeHmac = computeHmac;
computeHmac._ = _computeHmac;
computeHmac.lock = function () {
  locked = true;
};
computeHmac.register = function (func) {
  if (locked) {
    throw new Error("computeHmac is locked");
  }
  __computeHmac = func;
};
Object.freeze(computeHmac);

},{"../utils/index.js":276,"./crypto.js":217}],219:[function(require,module,exports){
"use strict";

/**
 *  A fundamental building block of Ethereum is the underlying
 *  cryptographic primitives.
 *
 *  @_section: api/crypto:Cryptographic Functions   [about-crypto]
 */
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.lock = exports.Signature = exports.SigningKey = exports.scryptSync = exports.scrypt = exports.pbkdf2 = exports.sha512 = exports.sha256 = exports.ripemd160 = exports.keccak256 = exports.randomBytes = exports.computeHmac = void 0;
null;
// We import all these so we can export lock()
var hmac_js_1 = require("./hmac.js");
Object.defineProperty(exports, "computeHmac", {
  enumerable: true,
  get: function get() {
    return hmac_js_1.computeHmac;
  }
});
var keccak_js_1 = require("./keccak.js");
Object.defineProperty(exports, "keccak256", {
  enumerable: true,
  get: function get() {
    return keccak_js_1.keccak256;
  }
});
var ripemd160_js_1 = require("./ripemd160.js");
Object.defineProperty(exports, "ripemd160", {
  enumerable: true,
  get: function get() {
    return ripemd160_js_1.ripemd160;
  }
});
var pbkdf2_js_1 = require("./pbkdf2.js");
Object.defineProperty(exports, "pbkdf2", {
  enumerable: true,
  get: function get() {
    return pbkdf2_js_1.pbkdf2;
  }
});
var random_js_1 = require("./random.js");
Object.defineProperty(exports, "randomBytes", {
  enumerable: true,
  get: function get() {
    return random_js_1.randomBytes;
  }
});
var scrypt_js_1 = require("./scrypt.js");
Object.defineProperty(exports, "scrypt", {
  enumerable: true,
  get: function get() {
    return scrypt_js_1.scrypt;
  }
});
Object.defineProperty(exports, "scryptSync", {
  enumerable: true,
  get: function get() {
    return scrypt_js_1.scryptSync;
  }
});
var sha2_js_1 = require("./sha2.js");
Object.defineProperty(exports, "sha256", {
  enumerable: true,
  get: function get() {
    return sha2_js_1.sha256;
  }
});
Object.defineProperty(exports, "sha512", {
  enumerable: true,
  get: function get() {
    return sha2_js_1.sha512;
  }
});
var signing_key_js_1 = require("./signing-key.js");
Object.defineProperty(exports, "SigningKey", {
  enumerable: true,
  get: function get() {
    return signing_key_js_1.SigningKey;
  }
});
var signature_js_1 = require("./signature.js");
Object.defineProperty(exports, "Signature", {
  enumerable: true,
  get: function get() {
    return signature_js_1.Signature;
  }
});
/**
 *  Once called, prevents any future change to the underlying cryptographic
 *  primitives using the ``.register`` feature for hooks.
 */
function lock() {
  hmac_js_1.computeHmac.lock();
  keccak_js_1.keccak256.lock();
  pbkdf2_js_1.pbkdf2.lock();
  random_js_1.randomBytes.lock();
  ripemd160_js_1.ripemd160.lock();
  scrypt_js_1.scrypt.lock();
  scrypt_js_1.scryptSync.lock();
  sha2_js_1.sha256.lock();
  sha2_js_1.sha512.lock();
  random_js_1.randomBytes.lock();
}
exports.lock = lock;

},{"./hmac.js":218,"./keccak.js":220,"./pbkdf2.js":221,"./random.js":222,"./ripemd160.js":223,"./scrypt.js":224,"./sha2.js":225,"./signature.js":226,"./signing-key.js":227}],220:[function(require,module,exports){
"use strict";

/**
 *  Cryptographic hashing functions
 *
 *  @_subsection: api/crypto:Hash Functions [about-crypto-hashing]
 */
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.keccak256 = void 0;
var sha3_1 = require("@noble/hashes/sha3");
var index_js_1 = require("../utils/index.js");
var locked = false;
var _keccak256 = function _keccak256(data) {
  return (0, sha3_1.keccak_256)(data);
};
var __keccak256 = _keccak256;
/**
 *  Compute the cryptographic KECCAK256 hash of %%data%%.
 *
 *  The %%data%% **must** be a data representation, to compute the
 *  hash of UTF-8 data use the [[id]] function.
 *
 *  @returns DataHexstring
 *  @example:
 *    keccak256("0x")
 *    //_result:
 *
 *    keccak256("0x1337")
 *    //_result:
 *
 *    keccak256(new Uint8Array([ 0x13, 0x37 ]))
 *    //_result:
 *
 *    // Strings are assumed to be DataHexString, otherwise it will
 *    // throw. To hash UTF-8 data, see the note above.
 *    keccak256("Hello World")
 *    //_error:
 */
function keccak256(_data) {
  var data = (0, index_js_1.getBytes)(_data, "data");
  return (0, index_js_1.hexlify)(__keccak256(data));
}
exports.keccak256 = keccak256;
keccak256._ = _keccak256;
keccak256.lock = function () {
  locked = true;
};
keccak256.register = function (func) {
  if (locked) {
    throw new TypeError("keccak256 is locked");
  }
  __keccak256 = func;
};
Object.freeze(keccak256);

},{"../utils/index.js":276,"@noble/hashes/sha3":71}],221:[function(require,module,exports){
"use strict";

/**
 *  A **Password-Based Key-Derivation Function** is designed to create
 *  a sequence of bytes suitible as a **key** from a human-rememberable
 *  password.
 *
 *  @_subsection: api/crypto:Passwords  [about-pbkdf]
 */
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pbkdf2 = void 0;
var crypto_js_1 = require("./crypto.js");
var index_js_1 = require("../utils/index.js");
var locked = false;
var _pbkdf2 = function _pbkdf2(password, salt, iterations, keylen, algo) {
  return (0, crypto_js_1.pbkdf2Sync)(password, salt, iterations, keylen, algo);
};
var __pbkdf2 = _pbkdf2;
/**
 *  Return the [[link-pbkdf2]] for %%keylen%% bytes for %%password%% using
 *  the %%salt%% and using %%iterations%% of %%algo%%.
 *
 *  This PBKDF is outdated and should not be used in new projects, but is
 *  required to decrypt older files.
 *
 *  @example:
 *    // The password must be converted to bytes, and it is generally
 *    // best practices to ensure the string has been normalized. Many
 *    // formats explicitly indicate the normalization form to use.
 *    password = "hello"
 *    passwordBytes = toUtf8Bytes(password, "NFKC")
 *
 *    salt = id("some-salt")
 *
 *    // Compute the PBKDF2
 *    pbkdf2(passwordBytes, salt, 1024, 16, "sha256")
 *    //_result:
 */
function pbkdf2(_password, _salt, iterations, keylen, algo) {
  var password = (0, index_js_1.getBytes)(_password, "password");
  var salt = (0, index_js_1.getBytes)(_salt, "salt");
  return (0, index_js_1.hexlify)(__pbkdf2(password, salt, iterations, keylen, algo));
}
exports.pbkdf2 = pbkdf2;
pbkdf2._ = _pbkdf2;
pbkdf2.lock = function () {
  locked = true;
};
pbkdf2.register = function (func) {
  if (locked) {
    throw new Error("pbkdf2 is locked");
  }
  __pbkdf2 = func;
};
Object.freeze(pbkdf2);

},{"../utils/index.js":276,"./crypto.js":217}],222:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.randomBytes = void 0;
/**
 *  A **Cryptographically Secure Random Value** is one that has been
 *  generated with additional care take to prevent side-channels
 *  from allowing others to detect it and prevent others from through
 *  coincidence generate the same values.
 *
 *  @_subsection: api/crypto:Random Values  [about-crypto-random]
 */
var crypto_js_1 = require("./crypto.js");
var locked = false;
var _randomBytes = function _randomBytes(length) {
  return new Uint8Array((0, crypto_js_1.randomBytes)(length));
};
var __randomBytes = _randomBytes;
/**
 *  Return %%length%% bytes of cryptographically secure random data.
 *
 *  @example:
 *    randomBytes(8)
 *    //_result:
 */
function randomBytes(length) {
  return __randomBytes(length);
}
exports.randomBytes = randomBytes;
randomBytes._ = _randomBytes;
randomBytes.lock = function () {
  locked = true;
};
randomBytes.register = function (func) {
  if (locked) {
    throw new Error("randomBytes is locked");
  }
  __randomBytes = func;
};
Object.freeze(randomBytes);

},{"./crypto.js":217}],223:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ripemd160 = void 0;
var ripemd160_1 = require("@noble/hashes/ripemd160");
var index_js_1 = require("../utils/index.js");
var locked = false;
var _ripemd160 = function _ripemd160(data) {
  return (0, ripemd160_1.ripemd160)(data);
};
var __ripemd160 = _ripemd160;
/**
 *  Compute the cryptographic RIPEMD-160 hash of %%data%%.
 *
 *  @_docloc: api/crypto:Hash Functions
 *  @returns DataHexstring
 *
 *  @example:
 *    ripemd160("0x")
 *    //_result:
 *
 *    ripemd160("0x1337")
 *    //_result:
 *
 *    ripemd160(new Uint8Array([ 0x13, 0x37 ]))
 *    //_result:
 *
 */
function ripemd160(_data) {
  var data = (0, index_js_1.getBytes)(_data, "data");
  return (0, index_js_1.hexlify)(__ripemd160(data));
}
exports.ripemd160 = ripemd160;
ripemd160._ = _ripemd160;
ripemd160.lock = function () {
  locked = true;
};
ripemd160.register = function (func) {
  if (locked) {
    throw new TypeError("ripemd160 is locked");
  }
  __ripemd160 = func;
};
Object.freeze(ripemd160);

},{"../utils/index.js":276,"@noble/hashes/ripemd160":68}],224:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.scryptSync = exports.scrypt = void 0;
var scrypt_1 = require("@noble/hashes/scrypt");
var index_js_1 = require("../utils/index.js");
var lockedSync = false,
  lockedAsync = false;
var _scryptAsync = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(passwd, salt, N, r, p, dkLen, onProgress) {
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return (0, scrypt_1.scryptAsync)(passwd, salt, {
            N: N,
            r: r,
            p: p,
            dkLen: dkLen,
            onProgress: onProgress
          });
        case 2:
          return _context.abrupt("return", _context.sent);
        case 3:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return function _scryptAsync(_x, _x2, _x3, _x4, _x5, _x6, _x7) {
    return _ref.apply(this, arguments);
  };
}();
var _scryptSync = function _scryptSync(passwd, salt, N, r, p, dkLen) {
  return (0, scrypt_1.scrypt)(passwd, salt, {
    N: N,
    r: r,
    p: p,
    dkLen: dkLen
  });
};
var __scryptAsync = _scryptAsync;
var __scryptSync = _scryptSync;
/**
 *  The [[link-wiki-scrypt]] uses a memory and cpu hard method of
 *  derivation to increase the resource cost to brute-force a password
 *  for a given key.
 *
 *  This means this algorithm is intentionally slow, and can be tuned to
 *  become slower. As computation and memory speed improve over time,
 *  increasing the difficulty maintains the cost of an attacker.
 *
 *  For example, if a target time of 5 seconds is used, a legitimate user
 *  which knows their password requires only 5 seconds to unlock their
 *  account. A 6 character password has 68 billion possibilities, which
 *  would require an attacker to invest over 10,000 years of CPU time. This
 *  is of course a crude example (as password generally aren't random),
 *  but demonstrates to value of imposing large costs to decryption.
 *
 *  For this reason, if building a UI which involved decrypting or
 *  encrypting datsa using scrypt, it is recommended to use a
 *  [[ProgressCallback]] (as event short periods can seem lik an eternity
 *  if the UI freezes). Including the phrase //"decrypting"// in the UI
 *  can also help, assuring the user their waiting is for a good reason.
 *
 *  @_docloc: api/crypto:Passwords
 *
 *  @example:
 *    // The password must be converted to bytes, and it is generally
 *    // best practices to ensure the string has been normalized. Many
 *    // formats explicitly indicate the normalization form to use.
 *    password = "hello"
 *    passwordBytes = toUtf8Bytes(password, "NFKC")
 *
 *    salt = id("some-salt")
 *
 *    // Compute the scrypt
 *    scrypt(passwordBytes, salt, 1024, 8, 1, 16)
 *    //_result:
 */
function scrypt(_x8, _x9, _x10, _x11, _x12, _x13, _x14) {
  return _scrypt.apply(this, arguments);
}
function _scrypt() {
  _scrypt = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(_passwd, _salt, N, r, p, dkLen, progress) {
    var passwd, salt;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          passwd = (0, index_js_1.getBytes)(_passwd, "passwd");
          salt = (0, index_js_1.getBytes)(_salt, "salt");
          _context2.t0 = (0, index_js_1.hexlify);
          _context2.next = 5;
          return __scryptAsync(passwd, salt, N, r, p, dkLen, progress);
        case 5:
          _context2.t1 = _context2.sent;
          return _context2.abrupt("return", (0, _context2.t0)(_context2.t1));
        case 7:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
  return _scrypt.apply(this, arguments);
}
exports.scrypt = scrypt;
scrypt._ = _scryptAsync;
scrypt.lock = function () {
  lockedAsync = true;
};
scrypt.register = function (func) {
  if (lockedAsync) {
    throw new Error("scrypt is locked");
  }
  __scryptAsync = func;
};
Object.freeze(scrypt);
/**
 *  Provides a synchronous variant of [[scrypt]].
 *
 *  This will completely lock up and freeze the UI in a browser and will
 *  prevent any event loop from progressing. For this reason, it is
 *  preferred to use the [async variant](scrypt).
 *
 *  @_docloc: api/crypto:Passwords
 *
 *  @example:
 *    // The password must be converted to bytes, and it is generally
 *    // best practices to ensure the string has been normalized. Many
 *    // formats explicitly indicate the normalization form to use.
 *    password = "hello"
 *    passwordBytes = toUtf8Bytes(password, "NFKC")
 *
 *    salt = id("some-salt")
 *
 *    // Compute the scrypt
 *    scryptSync(passwordBytes, salt, 1024, 8, 1, 16)
 *    //_result:
 */
function scryptSync(_passwd, _salt, N, r, p, dkLen) {
  var passwd = (0, index_js_1.getBytes)(_passwd, "passwd");
  var salt = (0, index_js_1.getBytes)(_salt, "salt");
  return (0, index_js_1.hexlify)(__scryptSync(passwd, salt, N, r, p, dkLen));
}
exports.scryptSync = scryptSync;
scryptSync._ = _scryptSync;
scryptSync.lock = function () {
  lockedSync = true;
};
scryptSync.register = function (func) {
  if (lockedSync) {
    throw new Error("scryptSync is locked");
  }
  __scryptSync = func;
};
Object.freeze(scryptSync);

},{"../utils/index.js":276,"@noble/hashes/scrypt":69}],225:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sha512 = exports.sha256 = void 0;
var crypto_js_1 = require("./crypto.js");
var index_js_1 = require("../utils/index.js");
var _sha256 = function _sha256(data) {
  return (0, crypto_js_1.createHash)("sha256").update(data).digest();
};
var _sha512 = function _sha512(data) {
  return (0, crypto_js_1.createHash)("sha512").update(data).digest();
};
var __sha256 = _sha256;
var __sha512 = _sha512;
var locked256 = false,
  locked512 = false;
/**
 *  Compute the cryptographic SHA2-256 hash of %%data%%.
 *
 *  @_docloc: api/crypto:Hash Functions
 *  @returns DataHexstring
 *
 *  @example:
 *    sha256("0x")
 *    //_result:
 *
 *    sha256("0x1337")
 *    //_result:
 *
 *    sha256(new Uint8Array([ 0x13, 0x37 ]))
 *    //_result:
 *
 */
function sha256(_data) {
  var data = (0, index_js_1.getBytes)(_data, "data");
  return (0, index_js_1.hexlify)(__sha256(data));
}
exports.sha256 = sha256;
sha256._ = _sha256;
sha256.lock = function () {
  locked256 = true;
};
sha256.register = function (func) {
  if (locked256) {
    throw new Error("sha256 is locked");
  }
  __sha256 = func;
};
Object.freeze(sha256);
/**
 *  Compute the cryptographic SHA2-512 hash of %%data%%.
 *
 *  @_docloc: api/crypto:Hash Functions
 *  @returns DataHexstring
 *
 *  @example:
 *    sha512("0x")
 *    //_result:
 *
 *    sha512("0x1337")
 *    //_result:
 *
 *    sha512(new Uint8Array([ 0x13, 0x37 ]))
 *    //_result:
 */
function sha512(_data) {
  var data = (0, index_js_1.getBytes)(_data, "data");
  return (0, index_js_1.hexlify)(__sha512(data));
}
exports.sha512 = sha512;
sha512._ = _sha512;
sha512.lock = function () {
  locked512 = true;
};
sha512.register = function (func) {
  if (locked512) {
    throw new Error("sha512 is locked");
  }
  __sha512 = func;
};
Object.freeze(sha256);

},{"../utils/index.js":276,"./crypto.js":217}],226:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Signature = void 0;
var index_js_1 = require("../constants/index.js");
var index_js_2 = require("../utils/index.js");
// Constants
var BN_0 = BigInt(0);
var BN_1 = BigInt(1);
var BN_2 = BigInt(2);
var BN_27 = BigInt(27);
var BN_28 = BigInt(28);
var BN_35 = BigInt(35);
var _guard = {};
function toUint256(value) {
  return (0, index_js_2.zeroPadValue)((0, index_js_2.toBeArray)(value), 32);
}
/**
 *  A Signature  @TODO
 *
 *
 *  @_docloc: api/crypto:Signing
 */
var _r2 = /*#__PURE__*/new WeakMap();
var _s = /*#__PURE__*/new WeakMap();
var _v2 = /*#__PURE__*/new WeakMap();
var _networkV = /*#__PURE__*/new WeakMap();
var Signature = /*#__PURE__*/function () {
  /**
   *  @private
   */
  function Signature(guard, r, s, v) {
    _classCallCheck(this, Signature);
    _classPrivateFieldInitSpec(this, _r2, void 0);
    _classPrivateFieldInitSpec(this, _s, void 0);
    _classPrivateFieldInitSpec(this, _v2, void 0);
    _classPrivateFieldInitSpec(this, _networkV, void 0);
    (0, index_js_2.assertPrivate)(guard, _guard, "Signature");
    _classPrivateFieldSet(_r2, this, r);
    _classPrivateFieldSet(_s, this, s);
    _classPrivateFieldSet(_v2, this, v);
    _classPrivateFieldSet(_networkV, this, null);
  }
  return _createClass(Signature, [{
    key: "r",
    get:
    /**
     *  The ``r`` value for a signautre.
     *
     *  This represents the ``x`` coordinate of a "reference" or
     *  challenge point, from which the ``y`` can be computed.
     */
    function get() {
      return _classPrivateFieldGet(_r2, this);
    },
    set: function set(value) {
      (0, index_js_2.assertArgument)((0, index_js_2.dataLength)(value) === 32, "invalid r", "value", value);
      _classPrivateFieldSet(_r2, this, (0, index_js_2.hexlify)(value));
    }
    /**
     *  The ``s`` value for a signature.
     */
  }, {
    key: "s",
    get: function get() {
      return _classPrivateFieldGet(_s, this);
    },
    set: function set(_value) {
      (0, index_js_2.assertArgument)((0, index_js_2.dataLength)(_value) === 32, "invalid s", "value", _value);
      var value = (0, index_js_2.hexlify)(_value);
      (0, index_js_2.assertArgument)(parseInt(value.substring(0, 3)) < 8, "non-canonical s", "value", value);
      _classPrivateFieldSet(_s, this, value);
    }
    /**
     *  The ``v`` value for a signature.
     *
     *  Since a given ``x`` value for ``r`` has two possible values for
     *  its correspondin ``y``, the ``v`` indicates which of the two ``y``
     *  values to use.
     *
     *  It is normalized to the values ``27`` or ``28`` for legacy
     *  purposes.
     */
  }, {
    key: "v",
    get: function get() {
      return _classPrivateFieldGet(_v2, this);
    },
    set: function set(value) {
      var v = (0, index_js_2.getNumber)(value, "value");
      (0, index_js_2.assertArgument)(v === 27 || v === 28, "invalid v", "v", value);
      _classPrivateFieldSet(_v2, this, v);
    }
    /**
     *  The EIP-155 ``v`` for legacy transactions. For non-legacy
     *  transactions, this value is ``null``.
     */
  }, {
    key: "networkV",
    get: function get() {
      return _classPrivateFieldGet(_networkV, this);
    }
    /**
     *  The chain ID for EIP-155 legacy transactions. For non-legacy
     *  transactions, this value is ``null``.
     */
  }, {
    key: "legacyChainId",
    get: function get() {
      var v = this.networkV;
      if (v == null) {
        return null;
      }
      return Signature.getChainId(v);
    }
    /**
     *  The ``yParity`` for the signature.
     *
     *  See ``v`` for more details on how this value is used.
     */
  }, {
    key: "yParity",
    get: function get() {
      return this.v === 27 ? 0 : 1;
    }
    /**
     *  The [[link-eip-2098]] compact representation of the ``yParity``
     *  and ``s`` compacted into a single ``bytes32``.
     */
  }, {
    key: "yParityAndS",
    get: function get() {
      // The EIP-2098 compact representation
      var yParityAndS = (0, index_js_2.getBytes)(this.s);
      if (this.yParity) {
        yParityAndS[0] |= 0x80;
      }
      return (0, index_js_2.hexlify)(yParityAndS);
    }
    /**
     *  The [[link-eip-2098]] compact representation.
     */
  }, {
    key: "compactSerialized",
    get: function get() {
      return (0, index_js_2.concat)([this.r, this.yParityAndS]);
    }
    /**
     *  The serialized representation.
     */
  }, {
    key: "serialized",
    get: function get() {
      return (0, index_js_2.concat)([this.r, this.s, this.yParity ? "0x1c" : "0x1b"]);
    }
  }, {
    key: Symbol["for"]('nodejs.util.inspect.custom'),
    value: function value() {
      return "Signature { r: \"".concat(this.r, "\", s: \"").concat(this.s, "\", yParity: ").concat(this.yParity, ", networkV: ").concat(this.networkV, " }");
    }
    /**
     *  Returns a new identical [[Signature]].
     */
  }, {
    key: "clone",
    value: function clone() {
      var clone = new Signature(_guard, this.r, this.s, this.v);
      if (this.networkV) {
        _classPrivateFieldSet(_networkV, clone, this.networkV);
      }
      return clone;
    }
    /**
     *  Returns a representation that is compatible with ``JSON.stringify``.
     */
  }, {
    key: "toJSON",
    value: function toJSON() {
      var networkV = this.networkV;
      return {
        _type: "signature",
        networkV: networkV != null ? networkV.toString() : null,
        r: this.r,
        s: this.s,
        v: this.v
      };
    }
    /**
     *  Compute the chain ID from the ``v`` in a legacy EIP-155 transactions.
     *
     *  @example:
     *    Signature.getChainId(45)
     *    //_result:
     *
     *    Signature.getChainId(46)
     *    //_result:
     */
  }], [{
    key: "getChainId",
    value: function getChainId(v) {
      var bv = (0, index_js_2.getBigInt)(v, "v");
      // The v is not an EIP-155 v, so it is the unspecified chain ID
      if (bv == BN_27 || bv == BN_28) {
        return BN_0;
      }
      // Bad value for an EIP-155 v
      (0, index_js_2.assertArgument)(bv >= BN_35, "invalid EIP-155 v", "v", v);
      return (bv - BN_35) / BN_2;
    }
    /**
     *  Compute the ``v`` for a chain ID for a legacy EIP-155 transactions.
     *
     *  Legacy transactions which use [[link-eip-155]] hijack the ``v``
     *  property to include the chain ID.
     *
     *  @example:
     *    Signature.getChainIdV(5, 27)
     *    //_result:
     *
     *    Signature.getChainIdV(5, 28)
     *    //_result:
     *
     */
  }, {
    key: "getChainIdV",
    value: function getChainIdV(chainId, v) {
      return (0, index_js_2.getBigInt)(chainId) * BN_2 + BigInt(35 + v - 27);
    }
    /**
     *  Compute the normalized legacy transaction ``v`` from a ``yParirty``,
     *  a legacy transaction ``v`` or a legacy [[link-eip-155]] transaction.
     *
     *  @example:
     *    // The values 0 and 1 imply v is actually yParity
     *    Signature.getNormalizedV(0)
     *    //_result:
     *
     *    // Legacy non-EIP-1559 transaction (i.e. 27 or 28)
     *    Signature.getNormalizedV(27)
     *    //_result:
     *
     *    // Legacy EIP-155 transaction (i.e. >= 35)
     *    Signature.getNormalizedV(46)
     *    //_result:
     *
     *    // Invalid values throw
     *    Signature.getNormalizedV(5)
     *    //_error:
     */
  }, {
    key: "getNormalizedV",
    value: function getNormalizedV(v) {
      var bv = (0, index_js_2.getBigInt)(v);
      if (bv === BN_0 || bv === BN_27) {
        return 27;
      }
      if (bv === BN_1 || bv === BN_28) {
        return 28;
      }
      (0, index_js_2.assertArgument)(bv >= BN_35, "invalid v", "v", v);
      // Otherwise, EIP-155 v means odd is 27 and even is 28
      return bv & BN_1 ? 27 : 28;
    }
    /**
     *  Creates a new [[Signature]].
     *
     *  If no %%sig%% is provided, a new [[Signature]] is created
     *  with default values.
     *
     *  If %%sig%% is a string, it is parsed.
     */
  }, {
    key: "from",
    value: function from(sig) {
      function assertError(check, message) {
        (0, index_js_2.assertArgument)(check, message, "signature", sig);
      }
      ;
      if (sig == null) {
        return new Signature(_guard, index_js_1.ZeroHash, index_js_1.ZeroHash, 27);
      }
      if (typeof sig === "string") {
        var bytes = (0, index_js_2.getBytes)(sig, "signature");
        if (bytes.length === 64) {
          var _r3 = (0, index_js_2.hexlify)(bytes.slice(0, 32));
          var _s2 = bytes.slice(32, 64);
          var _v3 = _s2[0] & 0x80 ? 28 : 27;
          _s2[0] &= 0x7f;
          return new Signature(_guard, _r3, (0, index_js_2.hexlify)(_s2), _v3);
        }
        if (bytes.length === 65) {
          var _r4 = (0, index_js_2.hexlify)(bytes.slice(0, 32));
          var _s3 = bytes.slice(32, 64);
          assertError((_s3[0] & 0x80) === 0, "non-canonical s");
          var _v4 = Signature.getNormalizedV(bytes[64]);
          return new Signature(_guard, _r4, (0, index_js_2.hexlify)(_s3), _v4);
        }
        assertError(false, "invalid raw signature length");
      }
      if (sig instanceof Signature) {
        return sig.clone();
      }
      // Get r
      var _r = sig.r;
      assertError(_r != null, "missing r");
      var r = toUint256(_r);
      // Get s; by any means necessary (we check consistency below)
      var s = function (s, yParityAndS) {
        if (s != null) {
          return toUint256(s);
        }
        if (yParityAndS != null) {
          assertError((0, index_js_2.isHexString)(yParityAndS, 32), "invalid yParityAndS");
          var _bytes = (0, index_js_2.getBytes)(yParityAndS);
          _bytes[0] &= 0x7f;
          return (0, index_js_2.hexlify)(_bytes);
        }
        assertError(false, "missing s");
      }(sig.s, sig.yParityAndS);
      assertError(((0, index_js_2.getBytes)(s)[0] & 0x80) == 0, "non-canonical s");
      // Get v; by any means necessary (we check consistency below)
      var _ref = function (_v, yParityAndS, yParity) {
          if (_v != null) {
            var _v5 = (0, index_js_2.getBigInt)(_v);
            return {
              networkV: _v5 >= BN_35 ? _v5 : undefined,
              v: Signature.getNormalizedV(_v5)
            };
          }
          if (yParityAndS != null) {
            assertError((0, index_js_2.isHexString)(yParityAndS, 32), "invalid yParityAndS");
            return {
              v: (0, index_js_2.getBytes)(yParityAndS)[0] & 0x80 ? 28 : 27
            };
          }
          if (yParity != null) {
            switch ((0, index_js_2.getNumber)(yParity, "sig.yParity")) {
              case 0:
                return {
                  v: 27
                };
              case 1:
                return {
                  v: 28
                };
            }
            assertError(false, "invalid yParity");
          }
          assertError(false, "missing v");
        }(sig.v, sig.yParityAndS, sig.yParity),
        networkV = _ref.networkV,
        v = _ref.v;
      var result = new Signature(_guard, r, s, v);
      if (networkV) {
        _classPrivateFieldSet(_networkV, result, networkV);
      }
      // If multiple of v, yParity, yParityAndS we given, check they match
      assertError(sig.yParity == null || (0, index_js_2.getNumber)(sig.yParity, "sig.yParity") === result.yParity, "yParity mismatch");
      assertError(sig.yParityAndS == null || sig.yParityAndS === result.yParityAndS, "yParityAndS mismatch");
      return result;
    }
  }]);
}();
exports.Signature = Signature;

},{"../constants/index.js":210,"../utils/index.js":276}],227:[function(require,module,exports){
"use strict";

/**
 *  Add details about signing here.
 *
 *  @_subsection: api/crypto:Signing  [about-signing]
 */
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SigningKey = void 0;
var secp256k1_1 = require("@noble/curves/secp256k1");
var index_js_1 = require("../utils/index.js");
var signature_js_1 = require("./signature.js");
/**
 *  A **SigningKey** provides high-level access to the elliptic curve
 *  cryptography (ECC) operations and key management.
 */
var _privateKey = /*#__PURE__*/new WeakMap();
var SigningKey = /*#__PURE__*/function () {
  /**
   *  Creates a new **SigningKey** for %%privateKey%%.
   */
  function SigningKey(privateKey) {
    _classCallCheck(this, SigningKey);
    _classPrivateFieldInitSpec(this, _privateKey, void 0);
    (0, index_js_1.assertArgument)((0, index_js_1.dataLength)(privateKey) === 32, "invalid private key", "privateKey", "[REDACTED]");
    _classPrivateFieldSet(_privateKey, this, (0, index_js_1.hexlify)(privateKey));
  }
  /**
   *  The private key.
   */
  return _createClass(SigningKey, [{
    key: "privateKey",
    get: function get() {
      return _classPrivateFieldGet(_privateKey, this);
    }
    /**
     *  The uncompressed public key.
     *
     * This will always begin with the prefix ``0x04`` and be 132
     * characters long (the ``0x`` prefix and 130 hexadecimal nibbles).
     */
  }, {
    key: "publicKey",
    get: function get() {
      return SigningKey.computePublicKey(_classPrivateFieldGet(_privateKey, this));
    }
    /**
     *  The compressed public key.
     *
     *  This will always begin with either the prefix ``0x02`` or ``0x03``
     *  and be 68 characters long (the ``0x`` prefix and 33 hexadecimal
     *  nibbles)
     */
  }, {
    key: "compressedPublicKey",
    get: function get() {
      return SigningKey.computePublicKey(_classPrivateFieldGet(_privateKey, this), true);
    }
    /**
     *  Return the signature of the signed %%digest%%.
     */
  }, {
    key: "sign",
    value: function sign(digest) {
      (0, index_js_1.assertArgument)((0, index_js_1.dataLength)(digest) === 32, "invalid digest length", "digest", digest);
      var sig = secp256k1_1.secp256k1.sign((0, index_js_1.getBytesCopy)(digest), (0, index_js_1.getBytesCopy)(_classPrivateFieldGet(_privateKey, this)), {
        lowS: true
      });
      return signature_js_1.Signature.from({
        r: (0, index_js_1.toBeHex)(sig.r, 32),
        s: (0, index_js_1.toBeHex)(sig.s, 32),
        v: sig.recovery ? 0x1c : 0x1b
      });
    }
    /**
     *  Returns the [[link-wiki-ecdh]] shared secret between this
     *  private key and the %%other%% key.
     *
     *  The %%other%% key may be any type of key, a raw public key,
     *  a compressed/uncompressed pubic key or aprivate key.
     *
     *  Best practice is usually to use a cryptographic hash on the
     *  returned value before using it as a symetric secret.
     *
     *  @example:
     *    sign1 = new SigningKey(id("some-secret-1"))
     *    sign2 = new SigningKey(id("some-secret-2"))
     *
     *    // Notice that privA.computeSharedSecret(pubB)...
     *    sign1.computeSharedSecret(sign2.publicKey)
     *    //_result:
     *
     *    // ...is equal to privB.computeSharedSecret(pubA).
     *    sign2.computeSharedSecret(sign1.publicKey)
     *    //_result:
     */
  }, {
    key: "computeSharedSecret",
    value: function computeSharedSecret(other) {
      var pubKey = SigningKey.computePublicKey(other);
      return (0, index_js_1.hexlify)(secp256k1_1.secp256k1.getSharedSecret((0, index_js_1.getBytesCopy)(_classPrivateFieldGet(_privateKey, this)), (0, index_js_1.getBytes)(pubKey), false));
    }
    /**
     *  Compute the public key for %%key%%, optionally %%compressed%%.
     *
     *  The %%key%% may be any type of key, a raw public key, a
     *  compressed/uncompressed public key or private key.
     *
     *  @example:
     *    sign = new SigningKey(id("some-secret"));
     *
     *    // Compute the uncompressed public key for a private key
     *    SigningKey.computePublicKey(sign.privateKey)
     *    //_result:
     *
     *    // Compute the compressed public key for a private key
     *    SigningKey.computePublicKey(sign.privateKey, true)
     *    //_result:
     *
     *    // Compute the uncompressed public key
     *    SigningKey.computePublicKey(sign.publicKey, false);
     *    //_result:
     *
     *    // Compute the Compressed a public key
     *    SigningKey.computePublicKey(sign.publicKey, true);
     *    //_result:
     */
  }], [{
    key: "computePublicKey",
    value: function computePublicKey(key, compressed) {
      var bytes = (0, index_js_1.getBytes)(key, "key");
      // private key
      if (bytes.length === 32) {
        var pubKey = secp256k1_1.secp256k1.getPublicKey(bytes, !!compressed);
        return (0, index_js_1.hexlify)(pubKey);
      }
      // raw public key; use uncompressed key with 0x04 prefix
      if (bytes.length === 64) {
        var pub = new Uint8Array(65);
        pub[0] = 0x04;
        pub.set(bytes, 1);
        bytes = pub;
      }
      var point = secp256k1_1.secp256k1.ProjectivePoint.fromHex(bytes);
      return (0, index_js_1.hexlify)(point.toRawBytes(compressed));
    }
    /**
     *  Returns the public key for the private key which produced the
     *  %%signature%% for the given %%digest%%.
     *
     *  @example:
     *    key = new SigningKey(id("some-secret"))
     *    digest = id("hello world")
     *    sig = key.sign(digest)
     *
     *    // Notice the signer public key...
     *    key.publicKey
     *    //_result:
     *
     *    // ...is equal to the recovered public key
     *    SigningKey.recoverPublicKey(digest, sig)
     *    //_result:
     *
     */
  }, {
    key: "recoverPublicKey",
    value: function recoverPublicKey(digest, signature) {
      (0, index_js_1.assertArgument)((0, index_js_1.dataLength)(digest) === 32, "invalid digest length", "digest", digest);
      var sig = signature_js_1.Signature.from(signature);
      var secpSig = secp256k1_1.secp256k1.Signature.fromCompact((0, index_js_1.getBytesCopy)((0, index_js_1.concat)([sig.r, sig.s])));
      secpSig = secpSig.addRecoveryBit(sig.yParity);
      var pubKey = secpSig.recoverPublicKey((0, index_js_1.getBytesCopy)(digest));
      (0, index_js_1.assertArgument)(pubKey != null, "invalid signautre for digest", "signature", signature);
      return "0x" + pubKey.toHex(false);
    }
    /**
     *  Returns the point resulting from adding the ellipic curve points
     *  %%p0%% and %%p1%%.
     *
     *  This is not a common function most developers should require, but
     *  can be useful for certain privacy-specific techniques.
     *
     *  For example, it is used by [[HDNodeWallet]] to compute child
     *  addresses from parent public keys and chain codes.
     */
  }, {
    key: "addPoints",
    value: function addPoints(p0, p1, compressed) {
      var pub0 = secp256k1_1.secp256k1.ProjectivePoint.fromHex(SigningKey.computePublicKey(p0).substring(2));
      var pub1 = secp256k1_1.secp256k1.ProjectivePoint.fromHex(SigningKey.computePublicKey(p1).substring(2));
      return "0x" + pub0.add(pub1).toHex(!!compressed);
    }
  }]);
}();
exports.SigningKey = SigningKey;

},{"../utils/index.js":276,"./signature.js":226,"@noble/curves/secp256k1":61}],228:[function(require,module,exports){
"use strict";

/////////////////////////////
//
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ripemd160 = exports.keccak256 = exports.randomBytes = exports.computeHmac = exports.UndecodedEventLog = exports.EventLog = exports.ContractUnknownEventPayload = exports.ContractTransactionResponse = exports.ContractTransactionReceipt = exports.ContractEventPayload = exports.ContractFactory = exports.Contract = exports.BaseContract = exports.MessagePrefix = exports.EtherSymbol = exports.ZeroHash = exports.N = exports.MaxInt256 = exports.MinInt256 = exports.MaxUint256 = exports.WeiPerEther = exports.ZeroAddress = exports.resolveAddress = exports.isAddress = exports.isAddressable = exports.getCreate2Address = exports.getCreateAddress = exports.getIcapAddress = exports.getAddress = exports.Typed = exports.TransactionDescription = exports.Result = exports.LogDescription = exports.Interface = exports.Indexed = exports.ErrorDescription = exports.checkResultErrors = exports.StructFragment = exports.ParamType = exports.NamedFragment = exports.FunctionFragment = exports.FallbackFragment = exports.Fragment = exports.EventFragment = exports.ErrorFragment = exports.ConstructorFragment = exports.AbiCoder = exports.encodeBytes32String = exports.decodeBytes32String = exports.version = void 0;
exports.EnsPlugin = exports.Network = exports.EnsResolver = exports.WebSocketProvider = exports.SocketProvider = exports.IpcSocketProvider = exports.QuickNodeProvider = exports.PocketProvider = exports.InfuraWebSocketProvider = exports.InfuraProvider = exports.EtherscanProvider = exports.CloudflareProvider = exports.ChainstackProvider = exports.AnkrProvider = exports.AlchemyProvider = exports.BrowserProvider = exports.JsonRpcSigner = exports.JsonRpcProvider = exports.JsonRpcApiProvider = exports.FallbackProvider = exports.AbstractProvider = exports.VoidSigner = exports.NonceManager = exports.AbstractSigner = exports.TransactionResponse = exports.TransactionReceipt = exports.Log = exports.FeeData = exports.Block = exports.getDefaultProvider = exports.verifyTypedData = exports.TypedDataEncoder = exports.solidityPackedSha256 = exports.solidityPackedKeccak256 = exports.solidityPacked = exports.verifyMessage = exports.hashMessage = exports.dnsEncode = exports.namehash = exports.isValidName = exports.ensNormalize = exports.id = exports.SigningKey = exports.Signature = exports.lock = exports.scryptSync = exports.scrypt = exports.pbkdf2 = exports.sha512 = exports.sha256 = void 0;
exports.getUint = exports.getNumber = exports.getBigInt = exports.FixedNumber = exports.FetchCancelSignal = exports.FetchResponse = exports.FetchRequest = exports.EventPayload = exports.isError = exports.isCallException = exports.makeError = exports.assertPrivate = exports.assertNormalize = exports.assertArgumentCount = exports.assertArgument = exports.assert = exports.resolveProperties = exports.defineProperties = exports.zeroPadValue = exports.zeroPadBytes = exports.stripZerosLeft = exports.isBytesLike = exports.isHexString = exports.hexlify = exports.getBytesCopy = exports.getBytes = exports.dataSlice = exports.dataLength = exports.concat = exports.encodeBase64 = exports.decodeBase64 = exports.encodeBase58 = exports.decodeBase58 = exports.Transaction = exports.recoverAddress = exports.computeAddress = exports.accessListify = exports.showThrottleMessage = exports.copyRequest = exports.UnmanagedSubscriber = exports.SocketSubscriber = exports.SocketPendingSubscriber = exports.SocketEventSubscriber = exports.SocketBlockSubscriber = exports.MulticoinProviderPlugin = exports.NetworkPlugin = exports.GasCostPlugin = exports.FetchUrlFeeDataNetworkPlugin = exports.FeeDataNetworkPlugin = exports.EtherscanPlugin = void 0;
exports.wordlists = exports.WordlistOwlA = exports.WordlistOwl = exports.LangEn = exports.Wordlist = exports.encryptKeystoreJsonSync = exports.encryptKeystoreJson = exports.decryptKeystoreJson = exports.decryptKeystoreJsonSync = exports.decryptCrowdsaleJson = exports.isKeystoreJson = exports.isCrowdsaleJson = exports.getIndexedAccountPath = exports.getAccountPath = exports.defaultPath = exports.Wallet = exports.HDNodeVoidWallet = exports.HDNodeWallet = exports.BaseWallet = exports.Mnemonic = exports.uuidV4 = exports.encodeRlp = exports.decodeRlp = exports.Utf8ErrorFuncs = exports.toUtf8String = exports.toUtf8CodePoints = exports.toUtf8Bytes = exports.parseUnits = exports.formatUnits = exports.parseEther = exports.formatEther = exports.mask = exports.toTwos = exports.fromTwos = exports.toQuantity = exports.toNumber = exports.toBeHex = exports.toBigInt = exports.toBeArray = void 0;
var _version_js_1 = require("./_version.js");
Object.defineProperty(exports, "version", {
  enumerable: true,
  get: function get() {
    return _version_js_1.version;
  }
});
var index_js_1 = require("./abi/index.js");
Object.defineProperty(exports, "decodeBytes32String", {
  enumerable: true,
  get: function get() {
    return index_js_1.decodeBytes32String;
  }
});
Object.defineProperty(exports, "encodeBytes32String", {
  enumerable: true,
  get: function get() {
    return index_js_1.encodeBytes32String;
  }
});
Object.defineProperty(exports, "AbiCoder", {
  enumerable: true,
  get: function get() {
    return index_js_1.AbiCoder;
  }
});
Object.defineProperty(exports, "ConstructorFragment", {
  enumerable: true,
  get: function get() {
    return index_js_1.ConstructorFragment;
  }
});
Object.defineProperty(exports, "ErrorFragment", {
  enumerable: true,
  get: function get() {
    return index_js_1.ErrorFragment;
  }
});
Object.defineProperty(exports, "EventFragment", {
  enumerable: true,
  get: function get() {
    return index_js_1.EventFragment;
  }
});
Object.defineProperty(exports, "Fragment", {
  enumerable: true,
  get: function get() {
    return index_js_1.Fragment;
  }
});
Object.defineProperty(exports, "FallbackFragment", {
  enumerable: true,
  get: function get() {
    return index_js_1.FallbackFragment;
  }
});
Object.defineProperty(exports, "FunctionFragment", {
  enumerable: true,
  get: function get() {
    return index_js_1.FunctionFragment;
  }
});
Object.defineProperty(exports, "NamedFragment", {
  enumerable: true,
  get: function get() {
    return index_js_1.NamedFragment;
  }
});
Object.defineProperty(exports, "ParamType", {
  enumerable: true,
  get: function get() {
    return index_js_1.ParamType;
  }
});
Object.defineProperty(exports, "StructFragment", {
  enumerable: true,
  get: function get() {
    return index_js_1.StructFragment;
  }
});
Object.defineProperty(exports, "checkResultErrors", {
  enumerable: true,
  get: function get() {
    return index_js_1.checkResultErrors;
  }
});
Object.defineProperty(exports, "ErrorDescription", {
  enumerable: true,
  get: function get() {
    return index_js_1.ErrorDescription;
  }
});
Object.defineProperty(exports, "Indexed", {
  enumerable: true,
  get: function get() {
    return index_js_1.Indexed;
  }
});
Object.defineProperty(exports, "Interface", {
  enumerable: true,
  get: function get() {
    return index_js_1.Interface;
  }
});
Object.defineProperty(exports, "LogDescription", {
  enumerable: true,
  get: function get() {
    return index_js_1.LogDescription;
  }
});
Object.defineProperty(exports, "Result", {
  enumerable: true,
  get: function get() {
    return index_js_1.Result;
  }
});
Object.defineProperty(exports, "TransactionDescription", {
  enumerable: true,
  get: function get() {
    return index_js_1.TransactionDescription;
  }
});
Object.defineProperty(exports, "Typed", {
  enumerable: true,
  get: function get() {
    return index_js_1.Typed;
  }
});
var index_js_2 = require("./address/index.js");
Object.defineProperty(exports, "getAddress", {
  enumerable: true,
  get: function get() {
    return index_js_2.getAddress;
  }
});
Object.defineProperty(exports, "getIcapAddress", {
  enumerable: true,
  get: function get() {
    return index_js_2.getIcapAddress;
  }
});
Object.defineProperty(exports, "getCreateAddress", {
  enumerable: true,
  get: function get() {
    return index_js_2.getCreateAddress;
  }
});
Object.defineProperty(exports, "getCreate2Address", {
  enumerable: true,
  get: function get() {
    return index_js_2.getCreate2Address;
  }
});
Object.defineProperty(exports, "isAddressable", {
  enumerable: true,
  get: function get() {
    return index_js_2.isAddressable;
  }
});
Object.defineProperty(exports, "isAddress", {
  enumerable: true,
  get: function get() {
    return index_js_2.isAddress;
  }
});
Object.defineProperty(exports, "resolveAddress", {
  enumerable: true,
  get: function get() {
    return index_js_2.resolveAddress;
  }
});
var index_js_3 = require("./constants/index.js");
Object.defineProperty(exports, "ZeroAddress", {
  enumerable: true,
  get: function get() {
    return index_js_3.ZeroAddress;
  }
});
Object.defineProperty(exports, "WeiPerEther", {
  enumerable: true,
  get: function get() {
    return index_js_3.WeiPerEther;
  }
});
Object.defineProperty(exports, "MaxUint256", {
  enumerable: true,
  get: function get() {
    return index_js_3.MaxUint256;
  }
});
Object.defineProperty(exports, "MinInt256", {
  enumerable: true,
  get: function get() {
    return index_js_3.MinInt256;
  }
});
Object.defineProperty(exports, "MaxInt256", {
  enumerable: true,
  get: function get() {
    return index_js_3.MaxInt256;
  }
});
Object.defineProperty(exports, "N", {
  enumerable: true,
  get: function get() {
    return index_js_3.N;
  }
});
Object.defineProperty(exports, "ZeroHash", {
  enumerable: true,
  get: function get() {
    return index_js_3.ZeroHash;
  }
});
Object.defineProperty(exports, "EtherSymbol", {
  enumerable: true,
  get: function get() {
    return index_js_3.EtherSymbol;
  }
});
Object.defineProperty(exports, "MessagePrefix", {
  enumerable: true,
  get: function get() {
    return index_js_3.MessagePrefix;
  }
});
var index_js_4 = require("./contract/index.js");
Object.defineProperty(exports, "BaseContract", {
  enumerable: true,
  get: function get() {
    return index_js_4.BaseContract;
  }
});
Object.defineProperty(exports, "Contract", {
  enumerable: true,
  get: function get() {
    return index_js_4.Contract;
  }
});
Object.defineProperty(exports, "ContractFactory", {
  enumerable: true,
  get: function get() {
    return index_js_4.ContractFactory;
  }
});
Object.defineProperty(exports, "ContractEventPayload", {
  enumerable: true,
  get: function get() {
    return index_js_4.ContractEventPayload;
  }
});
Object.defineProperty(exports, "ContractTransactionReceipt", {
  enumerable: true,
  get: function get() {
    return index_js_4.ContractTransactionReceipt;
  }
});
Object.defineProperty(exports, "ContractTransactionResponse", {
  enumerable: true,
  get: function get() {
    return index_js_4.ContractTransactionResponse;
  }
});
Object.defineProperty(exports, "ContractUnknownEventPayload", {
  enumerable: true,
  get: function get() {
    return index_js_4.ContractUnknownEventPayload;
  }
});
Object.defineProperty(exports, "EventLog", {
  enumerable: true,
  get: function get() {
    return index_js_4.EventLog;
  }
});
Object.defineProperty(exports, "UndecodedEventLog", {
  enumerable: true,
  get: function get() {
    return index_js_4.UndecodedEventLog;
  }
});
var index_js_5 = require("./crypto/index.js");
Object.defineProperty(exports, "computeHmac", {
  enumerable: true,
  get: function get() {
    return index_js_5.computeHmac;
  }
});
Object.defineProperty(exports, "randomBytes", {
  enumerable: true,
  get: function get() {
    return index_js_5.randomBytes;
  }
});
Object.defineProperty(exports, "keccak256", {
  enumerable: true,
  get: function get() {
    return index_js_5.keccak256;
  }
});
Object.defineProperty(exports, "ripemd160", {
  enumerable: true,
  get: function get() {
    return index_js_5.ripemd160;
  }
});
Object.defineProperty(exports, "sha256", {
  enumerable: true,
  get: function get() {
    return index_js_5.sha256;
  }
});
Object.defineProperty(exports, "sha512", {
  enumerable: true,
  get: function get() {
    return index_js_5.sha512;
  }
});
Object.defineProperty(exports, "pbkdf2", {
  enumerable: true,
  get: function get() {
    return index_js_5.pbkdf2;
  }
});
Object.defineProperty(exports, "scrypt", {
  enumerable: true,
  get: function get() {
    return index_js_5.scrypt;
  }
});
Object.defineProperty(exports, "scryptSync", {
  enumerable: true,
  get: function get() {
    return index_js_5.scryptSync;
  }
});
Object.defineProperty(exports, "lock", {
  enumerable: true,
  get: function get() {
    return index_js_5.lock;
  }
});
Object.defineProperty(exports, "Signature", {
  enumerable: true,
  get: function get() {
    return index_js_5.Signature;
  }
});
Object.defineProperty(exports, "SigningKey", {
  enumerable: true,
  get: function get() {
    return index_js_5.SigningKey;
  }
});
var index_js_6 = require("./hash/index.js");
Object.defineProperty(exports, "id", {
  enumerable: true,
  get: function get() {
    return index_js_6.id;
  }
});
Object.defineProperty(exports, "ensNormalize", {
  enumerable: true,
  get: function get() {
    return index_js_6.ensNormalize;
  }
});
Object.defineProperty(exports, "isValidName", {
  enumerable: true,
  get: function get() {
    return index_js_6.isValidName;
  }
});
Object.defineProperty(exports, "namehash", {
  enumerable: true,
  get: function get() {
    return index_js_6.namehash;
  }
});
Object.defineProperty(exports, "dnsEncode", {
  enumerable: true,
  get: function get() {
    return index_js_6.dnsEncode;
  }
});
Object.defineProperty(exports, "hashMessage", {
  enumerable: true,
  get: function get() {
    return index_js_6.hashMessage;
  }
});
Object.defineProperty(exports, "verifyMessage", {
  enumerable: true,
  get: function get() {
    return index_js_6.verifyMessage;
  }
});
Object.defineProperty(exports, "solidityPacked", {
  enumerable: true,
  get: function get() {
    return index_js_6.solidityPacked;
  }
});
Object.defineProperty(exports, "solidityPackedKeccak256", {
  enumerable: true,
  get: function get() {
    return index_js_6.solidityPackedKeccak256;
  }
});
Object.defineProperty(exports, "solidityPackedSha256", {
  enumerable: true,
  get: function get() {
    return index_js_6.solidityPackedSha256;
  }
});
Object.defineProperty(exports, "TypedDataEncoder", {
  enumerable: true,
  get: function get() {
    return index_js_6.TypedDataEncoder;
  }
});
Object.defineProperty(exports, "verifyTypedData", {
  enumerable: true,
  get: function get() {
    return index_js_6.verifyTypedData;
  }
});
var index_js_7 = require("./providers/index.js");
Object.defineProperty(exports, "getDefaultProvider", {
  enumerable: true,
  get: function get() {
    return index_js_7.getDefaultProvider;
  }
});
Object.defineProperty(exports, "Block", {
  enumerable: true,
  get: function get() {
    return index_js_7.Block;
  }
});
Object.defineProperty(exports, "FeeData", {
  enumerable: true,
  get: function get() {
    return index_js_7.FeeData;
  }
});
Object.defineProperty(exports, "Log", {
  enumerable: true,
  get: function get() {
    return index_js_7.Log;
  }
});
Object.defineProperty(exports, "TransactionReceipt", {
  enumerable: true,
  get: function get() {
    return index_js_7.TransactionReceipt;
  }
});
Object.defineProperty(exports, "TransactionResponse", {
  enumerable: true,
  get: function get() {
    return index_js_7.TransactionResponse;
  }
});
Object.defineProperty(exports, "AbstractSigner", {
  enumerable: true,
  get: function get() {
    return index_js_7.AbstractSigner;
  }
});
Object.defineProperty(exports, "NonceManager", {
  enumerable: true,
  get: function get() {
    return index_js_7.NonceManager;
  }
});
Object.defineProperty(exports, "VoidSigner", {
  enumerable: true,
  get: function get() {
    return index_js_7.VoidSigner;
  }
});
Object.defineProperty(exports, "AbstractProvider", {
  enumerable: true,
  get: function get() {
    return index_js_7.AbstractProvider;
  }
});
Object.defineProperty(exports, "FallbackProvider", {
  enumerable: true,
  get: function get() {
    return index_js_7.FallbackProvider;
  }
});
Object.defineProperty(exports, "JsonRpcApiProvider", {
  enumerable: true,
  get: function get() {
    return index_js_7.JsonRpcApiProvider;
  }
});
Object.defineProperty(exports, "JsonRpcProvider", {
  enumerable: true,
  get: function get() {
    return index_js_7.JsonRpcProvider;
  }
});
Object.defineProperty(exports, "JsonRpcSigner", {
  enumerable: true,
  get: function get() {
    return index_js_7.JsonRpcSigner;
  }
});
Object.defineProperty(exports, "BrowserProvider", {
  enumerable: true,
  get: function get() {
    return index_js_7.BrowserProvider;
  }
});
Object.defineProperty(exports, "AlchemyProvider", {
  enumerable: true,
  get: function get() {
    return index_js_7.AlchemyProvider;
  }
});
Object.defineProperty(exports, "AnkrProvider", {
  enumerable: true,
  get: function get() {
    return index_js_7.AnkrProvider;
  }
});
Object.defineProperty(exports, "ChainstackProvider", {
  enumerable: true,
  get: function get() {
    return index_js_7.ChainstackProvider;
  }
});
Object.defineProperty(exports, "CloudflareProvider", {
  enumerable: true,
  get: function get() {
    return index_js_7.CloudflareProvider;
  }
});
Object.defineProperty(exports, "EtherscanProvider", {
  enumerable: true,
  get: function get() {
    return index_js_7.EtherscanProvider;
  }
});
Object.defineProperty(exports, "InfuraProvider", {
  enumerable: true,
  get: function get() {
    return index_js_7.InfuraProvider;
  }
});
Object.defineProperty(exports, "InfuraWebSocketProvider", {
  enumerable: true,
  get: function get() {
    return index_js_7.InfuraWebSocketProvider;
  }
});
Object.defineProperty(exports, "PocketProvider", {
  enumerable: true,
  get: function get() {
    return index_js_7.PocketProvider;
  }
});
Object.defineProperty(exports, "QuickNodeProvider", {
  enumerable: true,
  get: function get() {
    return index_js_7.QuickNodeProvider;
  }
});
Object.defineProperty(exports, "IpcSocketProvider", {
  enumerable: true,
  get: function get() {
    return index_js_7.IpcSocketProvider;
  }
});
Object.defineProperty(exports, "SocketProvider", {
  enumerable: true,
  get: function get() {
    return index_js_7.SocketProvider;
  }
});
Object.defineProperty(exports, "WebSocketProvider", {
  enumerable: true,
  get: function get() {
    return index_js_7.WebSocketProvider;
  }
});
Object.defineProperty(exports, "EnsResolver", {
  enumerable: true,
  get: function get() {
    return index_js_7.EnsResolver;
  }
});
Object.defineProperty(exports, "Network", {
  enumerable: true,
  get: function get() {
    return index_js_7.Network;
  }
});
Object.defineProperty(exports, "EnsPlugin", {
  enumerable: true,
  get: function get() {
    return index_js_7.EnsPlugin;
  }
});
Object.defineProperty(exports, "EtherscanPlugin", {
  enumerable: true,
  get: function get() {
    return index_js_7.EtherscanPlugin;
  }
});
Object.defineProperty(exports, "FeeDataNetworkPlugin", {
  enumerable: true,
  get: function get() {
    return index_js_7.FeeDataNetworkPlugin;
  }
});
Object.defineProperty(exports, "FetchUrlFeeDataNetworkPlugin", {
  enumerable: true,
  get: function get() {
    return index_js_7.FetchUrlFeeDataNetworkPlugin;
  }
});
Object.defineProperty(exports, "GasCostPlugin", {
  enumerable: true,
  get: function get() {
    return index_js_7.GasCostPlugin;
  }
});
Object.defineProperty(exports, "NetworkPlugin", {
  enumerable: true,
  get: function get() {
    return index_js_7.NetworkPlugin;
  }
});
Object.defineProperty(exports, "MulticoinProviderPlugin", {
  enumerable: true,
  get: function get() {
    return index_js_7.MulticoinProviderPlugin;
  }
});
Object.defineProperty(exports, "SocketBlockSubscriber", {
  enumerable: true,
  get: function get() {
    return index_js_7.SocketBlockSubscriber;
  }
});
Object.defineProperty(exports, "SocketEventSubscriber", {
  enumerable: true,
  get: function get() {
    return index_js_7.SocketEventSubscriber;
  }
});
Object.defineProperty(exports, "SocketPendingSubscriber", {
  enumerable: true,
  get: function get() {
    return index_js_7.SocketPendingSubscriber;
  }
});
Object.defineProperty(exports, "SocketSubscriber", {
  enumerable: true,
  get: function get() {
    return index_js_7.SocketSubscriber;
  }
});
Object.defineProperty(exports, "UnmanagedSubscriber", {
  enumerable: true,
  get: function get() {
    return index_js_7.UnmanagedSubscriber;
  }
});
Object.defineProperty(exports, "copyRequest", {
  enumerable: true,
  get: function get() {
    return index_js_7.copyRequest;
  }
});
Object.defineProperty(exports, "showThrottleMessage", {
  enumerable: true,
  get: function get() {
    return index_js_7.showThrottleMessage;
  }
});
var index_js_8 = require("./transaction/index.js");
Object.defineProperty(exports, "accessListify", {
  enumerable: true,
  get: function get() {
    return index_js_8.accessListify;
  }
});
Object.defineProperty(exports, "computeAddress", {
  enumerable: true,
  get: function get() {
    return index_js_8.computeAddress;
  }
});
Object.defineProperty(exports, "recoverAddress", {
  enumerable: true,
  get: function get() {
    return index_js_8.recoverAddress;
  }
});
Object.defineProperty(exports, "Transaction", {
  enumerable: true,
  get: function get() {
    return index_js_8.Transaction;
  }
});
var index_js_9 = require("./utils/index.js");
Object.defineProperty(exports, "decodeBase58", {
  enumerable: true,
  get: function get() {
    return index_js_9.decodeBase58;
  }
});
Object.defineProperty(exports, "encodeBase58", {
  enumerable: true,
  get: function get() {
    return index_js_9.encodeBase58;
  }
});
Object.defineProperty(exports, "decodeBase64", {
  enumerable: true,
  get: function get() {
    return index_js_9.decodeBase64;
  }
});
Object.defineProperty(exports, "encodeBase64", {
  enumerable: true,
  get: function get() {
    return index_js_9.encodeBase64;
  }
});
Object.defineProperty(exports, "concat", {
  enumerable: true,
  get: function get() {
    return index_js_9.concat;
  }
});
Object.defineProperty(exports, "dataLength", {
  enumerable: true,
  get: function get() {
    return index_js_9.dataLength;
  }
});
Object.defineProperty(exports, "dataSlice", {
  enumerable: true,
  get: function get() {
    return index_js_9.dataSlice;
  }
});
Object.defineProperty(exports, "getBytes", {
  enumerable: true,
  get: function get() {
    return index_js_9.getBytes;
  }
});
Object.defineProperty(exports, "getBytesCopy", {
  enumerable: true,
  get: function get() {
    return index_js_9.getBytesCopy;
  }
});
Object.defineProperty(exports, "hexlify", {
  enumerable: true,
  get: function get() {
    return index_js_9.hexlify;
  }
});
Object.defineProperty(exports, "isHexString", {
  enumerable: true,
  get: function get() {
    return index_js_9.isHexString;
  }
});
Object.defineProperty(exports, "isBytesLike", {
  enumerable: true,
  get: function get() {
    return index_js_9.isBytesLike;
  }
});
Object.defineProperty(exports, "stripZerosLeft", {
  enumerable: true,
  get: function get() {
    return index_js_9.stripZerosLeft;
  }
});
Object.defineProperty(exports, "zeroPadBytes", {
  enumerable: true,
  get: function get() {
    return index_js_9.zeroPadBytes;
  }
});
Object.defineProperty(exports, "zeroPadValue", {
  enumerable: true,
  get: function get() {
    return index_js_9.zeroPadValue;
  }
});
Object.defineProperty(exports, "defineProperties", {
  enumerable: true,
  get: function get() {
    return index_js_9.defineProperties;
  }
});
Object.defineProperty(exports, "resolveProperties", {
  enumerable: true,
  get: function get() {
    return index_js_9.resolveProperties;
  }
});
Object.defineProperty(exports, "assert", {
  enumerable: true,
  get: function get() {
    return index_js_9.assert;
  }
});
Object.defineProperty(exports, "assertArgument", {
  enumerable: true,
  get: function get() {
    return index_js_9.assertArgument;
  }
});
Object.defineProperty(exports, "assertArgumentCount", {
  enumerable: true,
  get: function get() {
    return index_js_9.assertArgumentCount;
  }
});
Object.defineProperty(exports, "assertNormalize", {
  enumerable: true,
  get: function get() {
    return index_js_9.assertNormalize;
  }
});
Object.defineProperty(exports, "assertPrivate", {
  enumerable: true,
  get: function get() {
    return index_js_9.assertPrivate;
  }
});
Object.defineProperty(exports, "makeError", {
  enumerable: true,
  get: function get() {
    return index_js_9.makeError;
  }
});
Object.defineProperty(exports, "isCallException", {
  enumerable: true,
  get: function get() {
    return index_js_9.isCallException;
  }
});
Object.defineProperty(exports, "isError", {
  enumerable: true,
  get: function get() {
    return index_js_9.isError;
  }
});
Object.defineProperty(exports, "EventPayload", {
  enumerable: true,
  get: function get() {
    return index_js_9.EventPayload;
  }
});
Object.defineProperty(exports, "FetchRequest", {
  enumerable: true,
  get: function get() {
    return index_js_9.FetchRequest;
  }
});
Object.defineProperty(exports, "FetchResponse", {
  enumerable: true,
  get: function get() {
    return index_js_9.FetchResponse;
  }
});
Object.defineProperty(exports, "FetchCancelSignal", {
  enumerable: true,
  get: function get() {
    return index_js_9.FetchCancelSignal;
  }
});
Object.defineProperty(exports, "FixedNumber", {
  enumerable: true,
  get: function get() {
    return index_js_9.FixedNumber;
  }
});
Object.defineProperty(exports, "getBigInt", {
  enumerable: true,
  get: function get() {
    return index_js_9.getBigInt;
  }
});
Object.defineProperty(exports, "getNumber", {
  enumerable: true,
  get: function get() {
    return index_js_9.getNumber;
  }
});
Object.defineProperty(exports, "getUint", {
  enumerable: true,
  get: function get() {
    return index_js_9.getUint;
  }
});
Object.defineProperty(exports, "toBeArray", {
  enumerable: true,
  get: function get() {
    return index_js_9.toBeArray;
  }
});
Object.defineProperty(exports, "toBigInt", {
  enumerable: true,
  get: function get() {
    return index_js_9.toBigInt;
  }
});
Object.defineProperty(exports, "toBeHex", {
  enumerable: true,
  get: function get() {
    return index_js_9.toBeHex;
  }
});
Object.defineProperty(exports, "toNumber", {
  enumerable: true,
  get: function get() {
    return index_js_9.toNumber;
  }
});
Object.defineProperty(exports, "toQuantity", {
  enumerable: true,
  get: function get() {
    return index_js_9.toQuantity;
  }
});
Object.defineProperty(exports, "fromTwos", {
  enumerable: true,
  get: function get() {
    return index_js_9.fromTwos;
  }
});
Object.defineProperty(exports, "toTwos", {
  enumerable: true,
  get: function get() {
    return index_js_9.toTwos;
  }
});
Object.defineProperty(exports, "mask", {
  enumerable: true,
  get: function get() {
    return index_js_9.mask;
  }
});
Object.defineProperty(exports, "formatEther", {
  enumerable: true,
  get: function get() {
    return index_js_9.formatEther;
  }
});
Object.defineProperty(exports, "parseEther", {
  enumerable: true,
  get: function get() {
    return index_js_9.parseEther;
  }
});
Object.defineProperty(exports, "formatUnits", {
  enumerable: true,
  get: function get() {
    return index_js_9.formatUnits;
  }
});
Object.defineProperty(exports, "parseUnits", {
  enumerable: true,
  get: function get() {
    return index_js_9.parseUnits;
  }
});
Object.defineProperty(exports, "toUtf8Bytes", {
  enumerable: true,
  get: function get() {
    return index_js_9.toUtf8Bytes;
  }
});
Object.defineProperty(exports, "toUtf8CodePoints", {
  enumerable: true,
  get: function get() {
    return index_js_9.toUtf8CodePoints;
  }
});
Object.defineProperty(exports, "toUtf8String", {
  enumerable: true,
  get: function get() {
    return index_js_9.toUtf8String;
  }
});
Object.defineProperty(exports, "Utf8ErrorFuncs", {
  enumerable: true,
  get: function get() {
    return index_js_9.Utf8ErrorFuncs;
  }
});
Object.defineProperty(exports, "decodeRlp", {
  enumerable: true,
  get: function get() {
    return index_js_9.decodeRlp;
  }
});
Object.defineProperty(exports, "encodeRlp", {
  enumerable: true,
  get: function get() {
    return index_js_9.encodeRlp;
  }
});
Object.defineProperty(exports, "uuidV4", {
  enumerable: true,
  get: function get() {
    return index_js_9.uuidV4;
  }
});
var index_js_10 = require("./wallet/index.js");
Object.defineProperty(exports, "Mnemonic", {
  enumerable: true,
  get: function get() {
    return index_js_10.Mnemonic;
  }
});
Object.defineProperty(exports, "BaseWallet", {
  enumerable: true,
  get: function get() {
    return index_js_10.BaseWallet;
  }
});
Object.defineProperty(exports, "HDNodeWallet", {
  enumerable: true,
  get: function get() {
    return index_js_10.HDNodeWallet;
  }
});
Object.defineProperty(exports, "HDNodeVoidWallet", {
  enumerable: true,
  get: function get() {
    return index_js_10.HDNodeVoidWallet;
  }
});
Object.defineProperty(exports, "Wallet", {
  enumerable: true,
  get: function get() {
    return index_js_10.Wallet;
  }
});
Object.defineProperty(exports, "defaultPath", {
  enumerable: true,
  get: function get() {
    return index_js_10.defaultPath;
  }
});
Object.defineProperty(exports, "getAccountPath", {
  enumerable: true,
  get: function get() {
    return index_js_10.getAccountPath;
  }
});
Object.defineProperty(exports, "getIndexedAccountPath", {
  enumerable: true,
  get: function get() {
    return index_js_10.getIndexedAccountPath;
  }
});
Object.defineProperty(exports, "isCrowdsaleJson", {
  enumerable: true,
  get: function get() {
    return index_js_10.isCrowdsaleJson;
  }
});
Object.defineProperty(exports, "isKeystoreJson", {
  enumerable: true,
  get: function get() {
    return index_js_10.isKeystoreJson;
  }
});
Object.defineProperty(exports, "decryptCrowdsaleJson", {
  enumerable: true,
  get: function get() {
    return index_js_10.decryptCrowdsaleJson;
  }
});
Object.defineProperty(exports, "decryptKeystoreJsonSync", {
  enumerable: true,
  get: function get() {
    return index_js_10.decryptKeystoreJsonSync;
  }
});
Object.defineProperty(exports, "decryptKeystoreJson", {
  enumerable: true,
  get: function get() {
    return index_js_10.decryptKeystoreJson;
  }
});
Object.defineProperty(exports, "encryptKeystoreJson", {
  enumerable: true,
  get: function get() {
    return index_js_10.encryptKeystoreJson;
  }
});
Object.defineProperty(exports, "encryptKeystoreJsonSync", {
  enumerable: true,
  get: function get() {
    return index_js_10.encryptKeystoreJsonSync;
  }
});
var index_js_11 = require("./wordlists/index.js");
Object.defineProperty(exports, "Wordlist", {
  enumerable: true,
  get: function get() {
    return index_js_11.Wordlist;
  }
});
Object.defineProperty(exports, "LangEn", {
  enumerable: true,
  get: function get() {
    return index_js_11.LangEn;
  }
});
Object.defineProperty(exports, "WordlistOwl", {
  enumerable: true,
  get: function get() {
    return index_js_11.WordlistOwl;
  }
});
Object.defineProperty(exports, "WordlistOwlA", {
  enumerable: true,
  get: function get() {
    return index_js_11.WordlistOwlA;
  }
});
Object.defineProperty(exports, "wordlists", {
  enumerable: true,
  get: function get() {
    return index_js_11.wordlists;
  }
});
// dummy change; to pick-up ws security issue changes

},{"./_version.js":186,"./abi/index.js":201,"./address/index.js":207,"./constants/index.js":210,"./contract/index.js":215,"./crypto/index.js":219,"./hash/index.js":230,"./providers/index.js":242,"./transaction/index.js":266,"./utils/index.js":276,"./wallet/index.js":286,"./wordlists/index.js":295}],229:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.id = void 0;
var index_js_1 = require("../crypto/index.js");
var index_js_2 = require("../utils/index.js");
/**
 *  A simple hashing function which operates on UTF-8 strings to
 *  compute an 32-byte identifier.
 *
 *  This simply computes the [UTF-8 bytes](toUtf8Bytes) and computes
 *  the [[keccak256]].
 *
 *  @example:
 *    id("hello world")
 *    //_result:
 */
function id(value) {
  return (0, index_js_1.keccak256)((0, index_js_2.toUtf8Bytes)(value));
}
exports.id = id;

},{"../crypto/index.js":219,"../utils/index.js":276}],230:[function(require,module,exports){
"use strict";

/**
 *  Utilities for common tasks involving hashing. Also see
 *  [cryptographic hashing](about-crypto-hashing).
 *
 *  @_section: api/hashing:Hashing Utilities  [about-hashing]
 */
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.verifyTypedData = exports.TypedDataEncoder = exports.solidityPackedSha256 = exports.solidityPackedKeccak256 = exports.solidityPacked = exports.verifyMessage = exports.hashMessage = exports.dnsEncode = exports.namehash = exports.isValidName = exports.ensNormalize = exports.id = void 0;
var id_js_1 = require("./id.js");
Object.defineProperty(exports, "id", {
  enumerable: true,
  get: function get() {
    return id_js_1.id;
  }
});
var namehash_js_1 = require("./namehash.js");
Object.defineProperty(exports, "ensNormalize", {
  enumerable: true,
  get: function get() {
    return namehash_js_1.ensNormalize;
  }
});
Object.defineProperty(exports, "isValidName", {
  enumerable: true,
  get: function get() {
    return namehash_js_1.isValidName;
  }
});
Object.defineProperty(exports, "namehash", {
  enumerable: true,
  get: function get() {
    return namehash_js_1.namehash;
  }
});
Object.defineProperty(exports, "dnsEncode", {
  enumerable: true,
  get: function get() {
    return namehash_js_1.dnsEncode;
  }
});
var message_js_1 = require("./message.js");
Object.defineProperty(exports, "hashMessage", {
  enumerable: true,
  get: function get() {
    return message_js_1.hashMessage;
  }
});
Object.defineProperty(exports, "verifyMessage", {
  enumerable: true,
  get: function get() {
    return message_js_1.verifyMessage;
  }
});
var solidity_js_1 = require("./solidity.js");
Object.defineProperty(exports, "solidityPacked", {
  enumerable: true,
  get: function get() {
    return solidity_js_1.solidityPacked;
  }
});
Object.defineProperty(exports, "solidityPackedKeccak256", {
  enumerable: true,
  get: function get() {
    return solidity_js_1.solidityPackedKeccak256;
  }
});
Object.defineProperty(exports, "solidityPackedSha256", {
  enumerable: true,
  get: function get() {
    return solidity_js_1.solidityPackedSha256;
  }
});
var typed_data_js_1 = require("./typed-data.js");
Object.defineProperty(exports, "TypedDataEncoder", {
  enumerable: true,
  get: function get() {
    return typed_data_js_1.TypedDataEncoder;
  }
});
Object.defineProperty(exports, "verifyTypedData", {
  enumerable: true,
  get: function get() {
    return typed_data_js_1.verifyTypedData;
  }
});

},{"./id.js":229,"./message.js":231,"./namehash.js":232,"./solidity.js":233,"./typed-data.js":234}],231:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.verifyMessage = exports.hashMessage = void 0;
var index_js_1 = require("../crypto/index.js");
var index_js_2 = require("../constants/index.js");
var index_js_3 = require("../transaction/index.js");
var index_js_4 = require("../utils/index.js");
/**
 *  Computes the [[link-eip-191]] personal-sign message digest to sign.
 *
 *  This prefixes the message with [[MessagePrefix]] and the decimal length
 *  of %%message%% and computes the [[keccak256]] digest.
 *
 *  If %%message%% is a string, it is converted to its UTF-8 bytes
 *  first. To compute the digest of a [[DataHexString]], it must be converted
 *  to [bytes](getBytes).
 *
 *  @example:
 *    hashMessage("Hello World")
 *    //_result:
 *
 *    // Hashes the SIX (6) string characters, i.e.
 *    // [ "0", "x", "4", "2", "4", "3" ]
 *    hashMessage("0x4243")
 *    //_result:
 *
 *    // Hashes the TWO (2) bytes [ 0x42, 0x43 ]...
 *    hashMessage(getBytes("0x4243"))
 *    //_result:
 *
 *    // ...which is equal to using data
 *    hashMessage(new Uint8Array([ 0x42, 0x43 ]))
 *    //_result:
 *
 */
function hashMessage(message) {
  if (typeof message === "string") {
    message = (0, index_js_4.toUtf8Bytes)(message);
  }
  return (0, index_js_1.keccak256)((0, index_js_4.concat)([(0, index_js_4.toUtf8Bytes)(index_js_2.MessagePrefix), (0, index_js_4.toUtf8Bytes)(String(message.length)), message]));
}
exports.hashMessage = hashMessage;
/**
 *  Return the address of the private key that produced
 *  the signature %%sig%% during signing for %%message%%.
 */
function verifyMessage(message, sig) {
  var digest = hashMessage(message);
  return (0, index_js_3.recoverAddress)(digest, sig);
}
exports.verifyMessage = verifyMessage;

},{"../constants/index.js":210,"../crypto/index.js":219,"../transaction/index.js":266,"../utils/index.js":276}],232:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.dnsEncode = exports.namehash = exports.isValidName = exports.ensNormalize = void 0;
var index_js_1 = require("../crypto/index.js");
var index_js_2 = require("../utils/index.js");
var ens_normalize_1 = require("@adraffy/ens-normalize");
var Zeros = new Uint8Array(32);
Zeros.fill(0);
function checkComponent(comp) {
  (0, index_js_2.assertArgument)(comp.length !== 0, "invalid ENS name; empty component", "comp", comp);
  return comp;
}
function ensNameSplit(name) {
  var bytes = (0, index_js_2.toUtf8Bytes)(ensNormalize(name));
  var comps = [];
  if (name.length === 0) {
    return comps;
  }
  var last = 0;
  for (var i = 0; i < bytes.length; i++) {
    var d = bytes[i];
    // A separator (i.e. "."); copy this component
    if (d === 0x2e) {
      comps.push(checkComponent(bytes.slice(last, i)));
      last = i + 1;
    }
  }
  // There was a stray separator at the end of the name
  (0, index_js_2.assertArgument)(last < bytes.length, "invalid ENS name; empty component", "name", name);
  comps.push(checkComponent(bytes.slice(last)));
  return comps;
}
/**
 *  Returns the ENS %%name%% normalized.
 */
function ensNormalize(name) {
  try {
    if (name.length === 0) {
      throw new Error("empty label");
    }
    return (0, ens_normalize_1.ens_normalize)(name);
  } catch (error) {
    (0, index_js_2.assertArgument)(false, "invalid ENS name (".concat(error.message, ")"), "name", name);
  }
}
exports.ensNormalize = ensNormalize;
/**
 *  Returns ``true`` if %%name%% is a valid ENS name.
 */
function isValidName(name) {
  try {
    return ensNameSplit(name).length !== 0;
  } catch (error) {}
  return false;
}
exports.isValidName = isValidName;
/**
 *  Returns the [[link-namehash]] for %%name%%.
 */
function namehash(name) {
  (0, index_js_2.assertArgument)(typeof name === "string", "invalid ENS name; not a string", "name", name);
  (0, index_js_2.assertArgument)(name.length, "invalid ENS name (empty label)", "name", name);
  var result = Zeros;
  var comps = ensNameSplit(name);
  while (comps.length) {
    result = (0, index_js_1.keccak256)((0, index_js_2.concat)([result, (0, index_js_1.keccak256)(comps.pop())]));
  }
  return (0, index_js_2.hexlify)(result);
}
exports.namehash = namehash;
/**
 *  Returns the DNS encoded %%name%%.
 *
 *  This is used for various parts of ENS name resolution, such
 *  as the wildcard resolution.
 */
function dnsEncode(name, _maxLength) {
  var length = _maxLength != null ? _maxLength : 63;
  (0, index_js_2.assertArgument)(length <= 255, "DNS encoded label cannot exceed 255", "length", length);
  return (0, index_js_2.hexlify)((0, index_js_2.concat)(ensNameSplit(name).map(function (comp) {
    (0, index_js_2.assertArgument)(comp.length <= length, "label ".concat(JSON.stringify(name), " exceeds ").concat(length, " bytes"), "name", name);
    var bytes = new Uint8Array(comp.length + 1);
    bytes.set(comp, 1);
    bytes[0] = bytes.length - 1;
    return bytes;
  }))) + "00";
}
exports.dnsEncode = dnsEncode;

},{"../crypto/index.js":219,"../utils/index.js":276,"@adraffy/ens-normalize":1}],233:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.solidityPackedSha256 = exports.solidityPackedKeccak256 = exports.solidityPacked = void 0;
var index_js_1 = require("../address/index.js");
var index_js_2 = require("../crypto/index.js");
var index_js_3 = require("../utils/index.js");
var regexBytes = new RegExp("^bytes([0-9]+)$");
var regexNumber = new RegExp("^(u?int)([0-9]*)$");
var regexArray = new RegExp("^(.*)\\[([0-9]*)\\]$");
function _pack(type, value, isArray) {
  switch (type) {
    case "address":
      if (isArray) {
        return (0, index_js_3.getBytes)((0, index_js_3.zeroPadValue)(value, 32));
      }
      return (0, index_js_3.getBytes)((0, index_js_1.getAddress)(value));
    case "string":
      return (0, index_js_3.toUtf8Bytes)(value);
    case "bytes":
      return (0, index_js_3.getBytes)(value);
    case "bool":
      value = !!value ? "0x01" : "0x00";
      if (isArray) {
        return (0, index_js_3.getBytes)((0, index_js_3.zeroPadValue)(value, 32));
      }
      return (0, index_js_3.getBytes)(value);
  }
  var match = type.match(regexNumber);
  if (match) {
    var signed = match[1] === "int";
    var size = parseInt(match[2] || "256");
    (0, index_js_3.assertArgument)((!match[2] || match[2] === String(size)) && size % 8 === 0 && size !== 0 && size <= 256, "invalid number type", "type", type);
    if (isArray) {
      size = 256;
    }
    if (signed) {
      value = (0, index_js_3.toTwos)(value, size);
    }
    return (0, index_js_3.getBytes)((0, index_js_3.zeroPadValue)((0, index_js_3.toBeArray)(value), size / 8));
  }
  match = type.match(regexBytes);
  if (match) {
    var _size = parseInt(match[1]);
    (0, index_js_3.assertArgument)(String(_size) === match[1] && _size !== 0 && _size <= 32, "invalid bytes type", "type", type);
    (0, index_js_3.assertArgument)((0, index_js_3.dataLength)(value) === _size, "invalid value for ".concat(type), "value", value);
    if (isArray) {
      return (0, index_js_3.getBytes)((0, index_js_3.zeroPadBytes)(value, 32));
    }
    return value;
  }
  match = type.match(regexArray);
  if (match && Array.isArray(value)) {
    var baseType = match[1];
    var count = parseInt(match[2] || String(value.length));
    (0, index_js_3.assertArgument)(count === value.length, "invalid array length for ".concat(type), "value", value);
    var result = [];
    value.forEach(function (value) {
      result.push(_pack(baseType, value, true));
    });
    return (0, index_js_3.getBytes)((0, index_js_3.concat)(result));
  }
  (0, index_js_3.assertArgument)(false, "invalid type", "type", type);
}
// @TODO: Array Enum
/**
 *   Computes the [[link-solc-packed]] representation of %%values%%
 *   respectively to their %%types%%.
 *
 *   @example:
 *       addr = "0x8ba1f109551bd432803012645ac136ddd64dba72"
 *       solidityPacked([ "address", "uint" ], [ addr, 45 ]);
 *       //_result:
 */
function solidityPacked(types, values) {
  (0, index_js_3.assertArgument)(types.length === values.length, "wrong number of values; expected ${ types.length }", "values", values);
  var tight = [];
  types.forEach(function (type, index) {
    tight.push(_pack(type, values[index]));
  });
  return (0, index_js_3.hexlify)((0, index_js_3.concat)(tight));
}
exports.solidityPacked = solidityPacked;
/**
 *   Computes the [[link-solc-packed]] [[keccak256]] hash of %%values%%
 *   respectively to their %%types%%.
 *
 *   @example:
 *       addr = "0x8ba1f109551bd432803012645ac136ddd64dba72"
 *       solidityPackedKeccak256([ "address", "uint" ], [ addr, 45 ]);
 *       //_result:
 */
function solidityPackedKeccak256(types, values) {
  return (0, index_js_2.keccak256)(solidityPacked(types, values));
}
exports.solidityPackedKeccak256 = solidityPackedKeccak256;
/**
 *   Computes the [[link-solc-packed]] [[sha256]] hash of %%values%%
 *   respectively to their %%types%%.
 *
 *   @example:
 *       addr = "0x8ba1f109551bd432803012645ac136ddd64dba72"
 *       solidityPackedSha256([ "address", "uint" ], [ addr, 45 ]);
 *       //_result:
 */
function solidityPackedSha256(types, values) {
  return (0, index_js_2.sha256)(solidityPacked(types, values));
}
exports.solidityPackedSha256 = solidityPackedSha256;

},{"../address/index.js":207,"../crypto/index.js":219,"../utils/index.js":276}],234:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.verifyTypedData = exports.TypedDataEncoder = void 0;
//import { TypedDataDomain, TypedDataField } from "@ethersproject/providerabstract-signer";
var index_js_1 = require("../address/index.js");
var index_js_2 = require("../crypto/index.js");
var index_js_3 = require("../transaction/index.js");
var index_js_4 = require("../utils/index.js");
var id_js_1 = require("./id.js");
var padding = new Uint8Array(32);
padding.fill(0);
var BN__1 = BigInt(-1);
var BN_0 = BigInt(0);
var BN_1 = BigInt(1);
var BN_MAX_UINT256 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
;
;
function hexPadRight(value) {
  var bytes = (0, index_js_4.getBytes)(value);
  var padOffset = bytes.length % 32;
  if (padOffset) {
    return (0, index_js_4.concat)([bytes, padding.slice(padOffset)]);
  }
  return (0, index_js_4.hexlify)(bytes);
}
var hexTrue = (0, index_js_4.toBeHex)(BN_1, 32);
var hexFalse = (0, index_js_4.toBeHex)(BN_0, 32);
var domainFieldTypes = {
  name: "string",
  version: "string",
  chainId: "uint256",
  verifyingContract: "address",
  salt: "bytes32"
};
var domainFieldNames = ["name", "version", "chainId", "verifyingContract", "salt"];
function checkString(key) {
  return function (value) {
    (0, index_js_4.assertArgument)(typeof value === "string", "invalid domain value for ".concat(JSON.stringify(key)), "domain.".concat(key), value);
    return value;
  };
}
var domainChecks = {
  name: checkString("name"),
  version: checkString("version"),
  chainId: function chainId(_value) {
    var value = (0, index_js_4.getBigInt)(_value, "domain.chainId");
    (0, index_js_4.assertArgument)(value >= 0, "invalid chain ID", "domain.chainId", _value);
    if (Number.isSafeInteger(value)) {
      return Number(value);
    }
    return (0, index_js_4.toQuantity)(value);
  },
  verifyingContract: function verifyingContract(value) {
    try {
      return (0, index_js_1.getAddress)(value).toLowerCase();
    } catch (error) {}
    (0, index_js_4.assertArgument)(false, "invalid domain value \"verifyingContract\"", "domain.verifyingContract", value);
  },
  salt: function salt(value) {
    var bytes = (0, index_js_4.getBytes)(value, "domain.salt");
    (0, index_js_4.assertArgument)(bytes.length === 32, "invalid domain value \"salt\"", "domain.salt", value);
    return (0, index_js_4.hexlify)(bytes);
  }
};
function getBaseEncoder(type) {
  // intXX and uintXX
  {
    var match = type.match(/^(u?)int(\d+)$/);
    if (match) {
      var signed = match[1] === "";
      var width = parseInt(match[2]);
      (0, index_js_4.assertArgument)(width % 8 === 0 && width !== 0 && width <= 256 && match[2] === String(width), "invalid numeric width", "type", type);
      var boundsUpper = (0, index_js_4.mask)(BN_MAX_UINT256, signed ? width - 1 : width);
      var boundsLower = signed ? (boundsUpper + BN_1) * BN__1 : BN_0;
      return function (_value) {
        var value = (0, index_js_4.getBigInt)(_value, "value");
        (0, index_js_4.assertArgument)(value >= boundsLower && value <= boundsUpper, "value out-of-bounds for ".concat(type), "value", value);
        return (0, index_js_4.toBeHex)(signed ? (0, index_js_4.toTwos)(value, 256) : value, 32);
      };
    }
  }
  // bytesXX
  {
    var _match = type.match(/^bytes(\d+)$/);
    if (_match) {
      var _width = parseInt(_match[1]);
      (0, index_js_4.assertArgument)(_width !== 0 && _width <= 32 && _match[1] === String(_width), "invalid bytes width", "type", type);
      return function (value) {
        var bytes = (0, index_js_4.getBytes)(value);
        (0, index_js_4.assertArgument)(bytes.length === _width, "invalid length for ".concat(type), "value", value);
        return hexPadRight(value);
      };
    }
  }
  switch (type) {
    case "address":
      return function (value) {
        return (0, index_js_4.zeroPadValue)((0, index_js_1.getAddress)(value), 32);
      };
    case "bool":
      return function (value) {
        return !value ? hexFalse : hexTrue;
      };
    case "bytes":
      return function (value) {
        return (0, index_js_2.keccak256)(value);
      };
    case "string":
      return function (value) {
        return (0, id_js_1.id)(value);
      };
  }
  return null;
}
function encodeType(name, fields) {
  return "".concat(name, "(").concat(fields.map(function (_ref) {
    var name = _ref.name,
      type = _ref.type;
    return type + " " + name;
  }).join(","), ")");
}
// foo[][3] => { base: "foo", index: "[][3]", array: {
//     base: "foo", prefix: "foo[]", count: 3 } }
function splitArray(type) {
  var match = type.match(/^([^\x5b]*)((\x5b\d*\x5d)*)(\x5b(\d*)\x5d)$/);
  if (match) {
    return {
      base: match[1],
      index: match[2] + match[4],
      array: {
        base: match[1],
        prefix: match[1] + match[2],
        count: match[5] ? parseInt(match[5]) : -1
      }
    };
  }
  return {
    base: type
  };
}
/**
 *  A **TypedDataEncode** prepares and encodes [[link-eip-712]] payloads
 *  for signed typed data.
 *
 *  This is useful for those that wish to compute various components of a
 *  typed data hash, primary types, or sub-components, but generally the
 *  higher level [[Signer-signTypedData]] is more useful.
 */
var _types2 = /*#__PURE__*/new WeakMap();
var _fullTypes = /*#__PURE__*/new WeakMap();
var _encoderCache = /*#__PURE__*/new WeakMap();
var _TypedDataEncoder_brand = /*#__PURE__*/new WeakSet();
var TypedDataEncoder = /*#__PURE__*/function () {
  /**
   *  Create a new **TypedDataEncoder** for %%types%%.
   *
   *  This performs all necessary checking that types are valid and
   *  do not violate the [[link-eip-712]] structural constraints as
   *  well as computes the [[primaryType]].
   */
  function TypedDataEncoder(_types) {
    _classCallCheck(this, TypedDataEncoder);
    _classPrivateMethodInitSpec(this, _TypedDataEncoder_brand);
    /**
     *  The primary type for the structured [[types]].
     *
     *  This is derived automatically from the [[types]], since no
     *  recursion is possible, once the DAG for the types is consturcted
     *  internally, the primary type must be the only remaining type with
     *  no parent nodes.
     */
    _defineProperty(this, "primaryType", void 0);
    _classPrivateFieldInitSpec(this, _types2, void 0);
    _classPrivateFieldInitSpec(this, _fullTypes, void 0);
    _classPrivateFieldInitSpec(this, _encoderCache, void 0);
    _classPrivateFieldSet(_fullTypes, this, new Map());
    _classPrivateFieldSet(_encoderCache, this, new Map());
    // Link struct types to their direct child structs
    var links = new Map();
    // Link structs to structs which contain them as a child
    var parents = new Map();
    // Link all subtypes within a given struct
    var subtypes = new Map();
    var types = {};
    Object.keys(_types).forEach(function (type) {
      types[type] = _types[type].map(function (_ref2) {
        var name = _ref2.name,
          type = _ref2.type;
        // Normalize the base type (unless name conflict)
        var _splitArray = splitArray(type),
          base = _splitArray.base,
          index = _splitArray.index;
        if (base === "int" && !_types["int"]) {
          base = "int256";
        }
        if (base === "uint" && !_types["uint"]) {
          base = "uint256";
        }
        return {
          name: name,
          type: base + (index || "")
        };
      });
      links.set(type, new Set());
      parents.set(type, []);
      subtypes.set(type, new Set());
    });
    _classPrivateFieldSet(_types2, this, JSON.stringify(types));
    for (var name in types) {
      var uniqueNames = new Set();
      var _iterator = _createForOfIteratorHelper(types[name]),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var field = _step.value;
          // Check each field has a unique name
          (0, index_js_4.assertArgument)(!uniqueNames.has(field.name), "duplicate variable name ".concat(JSON.stringify(field.name), " in ").concat(JSON.stringify(name)), "types", _types);
          uniqueNames.add(field.name);
          // Get the base type (drop any array specifiers)
          var baseType = splitArray(field.type).base;
          (0, index_js_4.assertArgument)(baseType !== name, "circular type reference to ".concat(JSON.stringify(baseType)), "types", _types);
          // Is this a base encoding type?
          var encoder = getBaseEncoder(baseType);
          if (encoder) {
            continue;
          }
          (0, index_js_4.assertArgument)(parents.has(baseType), "unknown type ".concat(JSON.stringify(baseType)), "types", _types);
          // Add linkage
          parents.get(baseType).push(name);
          links.get(name).add(baseType);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
    // Deduce the primary type
    var primaryTypes = Array.from(parents.keys()).filter(function (n) {
      return parents.get(n).length === 0;
    });
    (0, index_js_4.assertArgument)(primaryTypes.length !== 0, "missing primary type", "types", _types);
    (0, index_js_4.assertArgument)(primaryTypes.length === 1, "ambiguous primary types or unused types: ".concat(primaryTypes.map(function (t) {
      return JSON.stringify(t);
    }).join(", ")), "types", _types);
    (0, index_js_4.defineProperties)(this, {
      primaryType: primaryTypes[0]
    });
    // Check for circular type references
    function checkCircular(type, found) {
      (0, index_js_4.assertArgument)(!found.has(type), "circular type reference to ".concat(JSON.stringify(type)), "types", _types);
      found.add(type);
      var _iterator2 = _createForOfIteratorHelper(links.get(type)),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var child = _step2.value;
          if (!parents.has(child)) {
            continue;
          }
          // Recursively check children
          checkCircular(child, found);
          // Mark all ancestors as having this decendant
          var _iterator3 = _createForOfIteratorHelper(found),
            _step3;
          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
              var subtype = _step3.value;
              subtypes.get(subtype).add(child);
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      found["delete"](type);
    }
    checkCircular(this.primaryType, new Set());
    // Compute each fully describe type
    var _iterator4 = _createForOfIteratorHelper(subtypes),
      _step4;
    try {
      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
        var _step4$value = _slicedToArray(_step4.value, 2),
          _name = _step4$value[0],
          set = _step4$value[1];
        var st = Array.from(set);
        st.sort();
        _classPrivateFieldGet(_fullTypes, this).set(_name, encodeType(_name, types[_name]) + st.map(function (t) {
          return encodeType(t, types[t]);
        }).join(""));
      }
    } catch (err) {
      _iterator4.e(err);
    } finally {
      _iterator4.f();
    }
  }
  /**
   *  Returnthe encoder for the specific %%type%%.
   */
  return _createClass(TypedDataEncoder, [{
    key: "types",
    get:
    /**
     *  The types.
     */
    function get() {
      return JSON.parse(_classPrivateFieldGet(_types2, this));
    }
  }, {
    key: "getEncoder",
    value: function getEncoder(type) {
      var encoder = _classPrivateFieldGet(_encoderCache, this).get(type);
      if (!encoder) {
        encoder = _assertClassBrand(_TypedDataEncoder_brand, this, _getEncoder).call(this, type);
        _classPrivateFieldGet(_encoderCache, this).set(type, encoder);
      }
      return encoder;
    }
  }, {
    key: "encodeType",
    value:
    /**
     *  Return the full type for %%name%%.
     */
    function encodeType(name) {
      var result = _classPrivateFieldGet(_fullTypes, this).get(name);
      (0, index_js_4.assertArgument)(result, "unknown type: ".concat(JSON.stringify(name)), "name", name);
      return result;
    }
    /**
     *  Return the encoded %%value%% for the %%type%%.
     */
  }, {
    key: "encodeData",
    value: function encodeData(type, value) {
      return this.getEncoder(type)(value);
    }
    /**
     *  Returns the hash of %%value%% for the type of %%name%%.
     */
  }, {
    key: "hashStruct",
    value: function hashStruct(name, value) {
      return (0, index_js_2.keccak256)(this.encodeData(name, value));
    }
    /**
     *  Return the fulled encoded %%value%% for the [[types]].
     */
  }, {
    key: "encode",
    value: function encode(value) {
      return this.encodeData(this.primaryType, value);
    }
    /**
     *  Return the hash of the fully encoded %%value%% for the [[types]].
     */
  }, {
    key: "hash",
    value: function hash(value) {
      return this.hashStruct(this.primaryType, value);
    }
    /**
     *  @_ignore:
     */
  }, {
    key: "_visit",
    value: function _visit(type, value, callback) {
      var _this = this;
      // Basic encoder type (address, bool, uint256, etc)
      {
        var encoder = getBaseEncoder(type);
        if (encoder) {
          return callback(type, value);
        }
      }
      // Array
      var array = splitArray(type).array;
      if (array) {
        (0, index_js_4.assertArgument)(array.count === -1 || array.count === value.length, "array length mismatch; expected length ".concat(array.count), "value", value);
        return value.map(function (v) {
          return _this._visit(array.prefix, v, callback);
        });
      }
      // Struct
      var fields = this.types[type];
      if (fields) {
        return fields.reduce(function (accum, _ref3) {
          var name = _ref3.name,
            type = _ref3.type;
          accum[name] = _this._visit(type, value[name], callback);
          return accum;
        }, {});
      }
      (0, index_js_4.assertArgument)(false, "unknown type: ".concat(type), "type", type);
    }
    /**
     *  Call %%calback%% for each value in %%value%%, passing the type and
     *  component within %%value%%.
     *
     *  This is useful for replacing addresses or other transformation that
     *  may be desired on each component, based on its type.
     */
  }, {
    key: "visit",
    value: function visit(value, callback) {
      return this._visit(this.primaryType, value, callback);
    }
    /**
     *  Create a new **TypedDataEncoder** for %%types%%.
     */
  }], [{
    key: "from",
    value: function from(types) {
      return new TypedDataEncoder(types);
    }
    /**
     *  Return the primary type for %%types%%.
     */
  }, {
    key: "getPrimaryType",
    value: function getPrimaryType(types) {
      return TypedDataEncoder.from(types).primaryType;
    }
    /**
     *  Return the hashed struct for %%value%% using %%types%% and %%name%%.
     */
  }, {
    key: "hashStruct",
    value: function hashStruct(name, types, value) {
      return TypedDataEncoder.from(types).hashStruct(name, value);
    }
    /**
     *  Return the domain hash for %%domain%%.
     */
  }, {
    key: "hashDomain",
    value: function hashDomain(domain) {
      var domainFields = [];
      for (var name in domain) {
        if (domain[name] == null) {
          continue;
        }
        var type = domainFieldTypes[name];
        (0, index_js_4.assertArgument)(type, "invalid typed-data domain key: ".concat(JSON.stringify(name)), "domain", domain);
        domainFields.push({
          name: name,
          type: type
        });
      }
      domainFields.sort(function (a, b) {
        return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b.name);
      });
      return TypedDataEncoder.hashStruct("EIP712Domain", {
        EIP712Domain: domainFields
      }, domain);
    }
    /**
     *  Return the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.
     */
  }, {
    key: "encode",
    value: function encode(domain, types, value) {
      return (0, index_js_4.concat)(["0x1901", TypedDataEncoder.hashDomain(domain), TypedDataEncoder.from(types).hash(value)]);
    }
    /**
     *  Return the hash of the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.
     */
  }, {
    key: "hash",
    value: function hash(domain, types, value) {
      return (0, index_js_2.keccak256)(TypedDataEncoder.encode(domain, types, value));
    }
    // Replaces all address types with ENS names with their looked up address
    /**
     * Resolves to the value from resolving all addresses in %%value%% for
     * %%types%% and the %%domain%%.
     */
  }, {
    key: "resolveNames",
    value: function () {
      var _resolveNames = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(domain, types, value, resolveName) {
        var key, ensCache, encoder, name;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              // Make a copy to isolate it from the object passed in
              domain = Object.assign({}, domain);
              // Allow passing null to ignore value
              for (key in domain) {
                if (domain[key] == null) {
                  delete domain[key];
                }
              }
              // Look up all ENS names
              ensCache = {}; // Do we need to look up the domain's verifyingContract?
              if (domain.verifyingContract && !(0, index_js_4.isHexString)(domain.verifyingContract, 20)) {
                ensCache[domain.verifyingContract] = "0x";
              }
              // We are going to use the encoder to visit all the base values
              encoder = TypedDataEncoder.from(types); // Get a list of all the addresses
              encoder.visit(value, function (type, value) {
                if (type === "address" && !(0, index_js_4.isHexString)(value, 20)) {
                  ensCache[value] = "0x";
                }
                return value;
              });
              // Lookup each name
              _context.t0 = _regeneratorRuntime().keys(ensCache);
            case 7:
              if ((_context.t1 = _context.t0()).done) {
                _context.next = 14;
                break;
              }
              name = _context.t1.value;
              _context.next = 11;
              return resolveName(name);
            case 11:
              ensCache[name] = _context.sent;
              _context.next = 7;
              break;
            case 14:
              // Replace the domain verifyingContract if needed
              if (domain.verifyingContract && ensCache[domain.verifyingContract]) {
                domain.verifyingContract = ensCache[domain.verifyingContract];
              }
              // Replace all ENS names with their address
              value = encoder.visit(value, function (type, value) {
                if (type === "address" && ensCache[value]) {
                  return ensCache[value];
                }
                return value;
              });
              return _context.abrupt("return", {
                domain: domain,
                value: value
              });
            case 17:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));
      function resolveNames(_x, _x2, _x3, _x4) {
        return _resolveNames.apply(this, arguments);
      }
      return resolveNames;
    }()
    /**
     *  Returns the JSON-encoded payload expected by nodes which implement
     *  the JSON-RPC [[link-eip-712]] method.
     */
  }, {
    key: "getPayload",
    value: function getPayload(domain, types, value) {
      // Validate the domain fields
      TypedDataEncoder.hashDomain(domain);
      // Derive the EIP712Domain Struct reference type
      var domainValues = {};
      var domainTypes = [];
      domainFieldNames.forEach(function (name) {
        var value = domain[name];
        if (value == null) {
          return;
        }
        domainValues[name] = domainChecks[name](value);
        domainTypes.push({
          name: name,
          type: domainFieldTypes[name]
        });
      });
      var encoder = TypedDataEncoder.from(types);
      // Get the normalized types
      types = encoder.types;
      var typesWithDomain = Object.assign({}, types);
      (0, index_js_4.assertArgument)(typesWithDomain.EIP712Domain == null, "types must not contain EIP712Domain type", "types.EIP712Domain", types);
      typesWithDomain.EIP712Domain = domainTypes;
      // Validate the data structures and types
      encoder.encode(value);
      return {
        types: typesWithDomain,
        domain: domainValues,
        primaryType: encoder.primaryType,
        message: encoder.visit(value, function (type, value) {
          // bytes
          if (type.match(/^bytes(\d*)/)) {
            return (0, index_js_4.hexlify)((0, index_js_4.getBytes)(value));
          }
          // uint or int
          if (type.match(/^u?int/)) {
            return (0, index_js_4.getBigInt)(value).toString();
          }
          switch (type) {
            case "address":
              return value.toLowerCase();
            case "bool":
              return !!value;
            case "string":
              (0, index_js_4.assertArgument)(typeof value === "string", "invalid string", "value", value);
              return value;
          }
          (0, index_js_4.assertArgument)(false, "unsupported type", "type", type);
        })
      };
    }
  }]);
}();
function _getEncoder(type) {
  var _this2 = this;
  // Basic encoder type (address, bool, uint256, etc)
  {
    var encoder = getBaseEncoder(type);
    if (encoder) {
      return encoder;
    }
  }
  // Array
  var array = splitArray(type).array;
  if (array) {
    var subtype = array.prefix;
    var subEncoder = this.getEncoder(subtype);
    return function (value) {
      (0, index_js_4.assertArgument)(array.count === -1 || array.count === value.length, "array length mismatch; expected length ".concat(array.count), "value", value);
      var result = value.map(subEncoder);
      if (_classPrivateFieldGet(_fullTypes, _this2).has(subtype)) {
        result = result.map(index_js_2.keccak256);
      }
      return (0, index_js_2.keccak256)((0, index_js_4.concat)(result));
    };
  }
  // Struct
  var fields = this.types[type];
  if (fields) {
    var encodedType = (0, id_js_1.id)(_classPrivateFieldGet(_fullTypes, this).get(type));
    return function (value) {
      var values = fields.map(function (_ref4) {
        var name = _ref4.name,
          type = _ref4.type;
        var result = _this2.getEncoder(type)(value[name]);
        if (_classPrivateFieldGet(_fullTypes, _this2).has(type)) {
          return (0, index_js_2.keccak256)(result);
        }
        return result;
      });
      values.unshift(encodedType);
      return (0, index_js_4.concat)(values);
    };
  }
  (0, index_js_4.assertArgument)(false, "unknown type: ".concat(type), "type", type);
}
exports.TypedDataEncoder = TypedDataEncoder;
/**
 *  Compute the address used to sign the typed data for the %%signature%%.
 */
function verifyTypedData(domain, types, value, signature) {
  return (0, index_js_3.recoverAddress)(TypedDataEncoder.hash(domain, types, value), signature);
}
exports.verifyTypedData = verifyTypedData;

},{"../address/index.js":207,"../crypto/index.js":219,"../transaction/index.js":266,"../utils/index.js":276,"./id.js":229}],235:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ethers = void 0;
var tslib_1 = require("tslib");
/**
 *  The Application Programming Interface (API) is the collection of
 *  functions, classes and types offered by the Ethers library.
 *
 *  @_section: api:Application Programming Interface  [about-api]
 *  @_navTitle: API
 */
var ethers = tslib_1.__importStar(require("./ethers.js"));
exports.ethers = ethers;
tslib_1.__exportStar(require("./ethers.js"), exports);

},{"./ethers.js":228,"tslib":420}],236:[function(require,module,exports){
"use strict";

/**
 *  The available providers should suffice for most developers purposes,
 *  but the [[AbstractProvider]] class has many features which enable
 *  sub-classing it for specific purposes.
 *
 *  @_section: api/providers/abstract-provider: Subclassing Provider  [abstract-provider]
 */
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AbstractProvider = exports.UnmanagedSubscriber = void 0;
// @TODO
// Event coalescence
//   When we register an event with an async value (e.g. address is a Signer
//   or ENS name), we need to add it immeidately for the Event API, but also
//   need time to resolve the address. Upon resolving the address, we need to
//   migrate the listener to the static event. We also need to maintain a map
//   of Signer/ENS name to address so we can sync respond to listenerCount.
var index_js_1 = require("../address/index.js");
var index_js_2 = require("../constants/index.js");
var index_js_3 = require("../contract/index.js");
var index_js_4 = require("../hash/index.js");
var index_js_5 = require("../transaction/index.js");
var index_js_6 = require("../utils/index.js");
var ens_resolver_js_1 = require("./ens-resolver.js");
var format_js_1 = require("./format.js");
var network_js_1 = require("./network.js");
var provider_js_1 = require("./provider.js");
var subscriber_polling_js_1 = require("./subscriber-polling.js");
// Constants
var BN_2 = BigInt(2);
var MAX_CCIP_REDIRECTS = 10;
function isPromise(value) {
  return value && typeof value.then === "function";
}
function getTag(prefix, value) {
  return prefix + ":" + JSON.stringify(value, function (k, v) {
    if (v == null) {
      return "null";
    }
    if (typeof v === "bigint") {
      return "bigint:".concat(v.toString());
    }
    if (typeof v === "string") {
      return v.toLowerCase();
    }
    // Sort object keys
    if (_typeof(v) === "object" && !Array.isArray(v)) {
      var keys = Object.keys(v);
      keys.sort();
      return keys.reduce(function (accum, key) {
        accum[key] = v[key];
        return accum;
      }, {});
    }
    return v;
  });
}
/**
 *  An **UnmanagedSubscriber** is useful for events which do not require
 *  any additional management, such as ``"debug"`` which only requires
 *  emit in synchronous event loop triggered calls.
 */
var UnmanagedSubscriber = /*#__PURE__*/function () {
  /**
   *  Create a new UnmanagedSubscriber with %%name%%.
   */
  function UnmanagedSubscriber(name) {
    _classCallCheck(this, UnmanagedSubscriber);
    /**
     *  The name fof the event.
     */
    _defineProperty(this, "name", void 0);
    (0, index_js_6.defineProperties)(this, {
      name: name
    });
  }
  return _createClass(UnmanagedSubscriber, [{
    key: "start",
    value: function start() {}
  }, {
    key: "stop",
    value: function stop() {}
  }, {
    key: "pause",
    value: function pause(dropWhilePaused) {}
  }, {
    key: "resume",
    value: function resume() {}
  }]);
}();
exports.UnmanagedSubscriber = UnmanagedSubscriber;
function copy(value) {
  return JSON.parse(JSON.stringify(value));
}
function concisify(items) {
  items = Array.from(new Set(items).values());
  items.sort();
  return items;
}
function getSubscription(_x, _x2) {
  return _getSubscription.apply(this, arguments);
}
function _getSubscription() {
  _getSubscription = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee43(_event, provider) {
    var hash, event, _event2, filter, addresses, promises, addAddress;
    return _regeneratorRuntime().wrap(function _callee43$(_context43) {
      while (1) switch (_context43.prev = _context43.next) {
        case 0:
          if (!(_event == null)) {
            _context43.next = 2;
            break;
          }
          throw new Error("invalid event");
        case 2:
          // Normalize topic array info an EventFilter
          if (Array.isArray(_event)) {
            _event = {
              topics: _event
            };
          }
          if (!(typeof _event === "string")) {
            _context43.next = 8;
            break;
          }
          _context43.t0 = _event;
          _context43.next = _context43.t0 === "block" ? 7 : _context43.t0 === "debug" ? 7 : _context43.t0 === "error" ? 7 : _context43.t0 === "finalized" ? 7 : _context43.t0 === "network" ? 7 : _context43.t0 === "pending" ? 7 : _context43.t0 === "safe" ? 7 : 8;
          break;
        case 7:
          return _context43.abrupt("return", {
            type: _event,
            tag: _event
          });
        case 8:
          if (!(0, index_js_6.isHexString)(_event, 32)) {
            _context43.next = 11;
            break;
          }
          hash = _event.toLowerCase();
          return _context43.abrupt("return", {
            type: "transaction",
            tag: getTag("tx", {
              hash: hash
            }),
            hash: hash
          });
        case 11:
          if (!_event.orphan) {
            _context43.next = 14;
            break;
          }
          event = _event; // @TODO: Should lowercase and whatnot things here instead of copy...
          return _context43.abrupt("return", {
            type: "orphan",
            tag: getTag("orphan", event),
            filter: copy(event)
          });
        case 14:
          if (!(_event.address || _event.topics)) {
            _context43.next = 27;
            break;
          }
          _event2 = _event;
          filter = {
            topics: (_event2.topics || []).map(function (t) {
              if (t == null) {
                return null;
              }
              if (Array.isArray(t)) {
                return concisify(t.map(function (t) {
                  return t.toLowerCase();
                }));
              }
              return t.toLowerCase();
            })
          };
          if (!_event2.address) {
            _context43.next = 26;
            break;
          }
          addresses = [];
          promises = [];
          addAddress = function addAddress(addr) {
            if ((0, index_js_6.isHexString)(addr)) {
              addresses.push(addr);
            } else {
              promises.push(_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee42() {
                return _regeneratorRuntime().wrap(function _callee42$(_context42) {
                  while (1) switch (_context42.prev = _context42.next) {
                    case 0:
                      _context42.t0 = addresses;
                      _context42.next = 3;
                      return (0, index_js_1.resolveAddress)(addr, provider);
                    case 3:
                      _context42.t1 = _context42.sent;
                      _context42.t0.push.call(_context42.t0, _context42.t1);
                    case 5:
                    case "end":
                      return _context42.stop();
                  }
                }, _callee42);
              }))());
            }
          };
          if (Array.isArray(_event2.address)) {
            _event2.address.forEach(addAddress);
          } else {
            addAddress(_event2.address);
          }
          if (!promises.length) {
            _context43.next = 25;
            break;
          }
          _context43.next = 25;
          return Promise.all(promises);
        case 25:
          filter.address = concisify(addresses.map(function (a) {
            return a.toLowerCase();
          }));
        case 26:
          return _context43.abrupt("return", {
            filter: filter,
            tag: getTag("event", filter),
            type: "event"
          });
        case 27:
          (0, index_js_6.assertArgument)(false, "unknown ProviderEvent", "event", _event);
        case 28:
        case "end":
          return _context43.stop();
      }
    }, _callee43);
  }));
  return _getSubscription.apply(this, arguments);
}
function getTime() {
  return new Date().getTime();
}
var defaultOptions = {
  cacheTimeout: 250,
  pollingInterval: 4000
};
/**
 *  An **AbstractProvider** provides a base class for other sub-classes to
 *  implement the [[Provider]] API by normalizing input arguments and
 *  formatting output results as well as tracking events for consistent
 *  behaviour on an eventually-consistent network.
 */
var _subs = /*#__PURE__*/new WeakMap();
var _plugins = /*#__PURE__*/new WeakMap();
var _pausedState = /*#__PURE__*/new WeakMap();
var _destroyed = /*#__PURE__*/new WeakMap();
var _networkPromise = /*#__PURE__*/new WeakMap();
var _anyNetwork = /*#__PURE__*/new WeakMap();
var _performCache = /*#__PURE__*/new WeakMap();
var _lastBlockNumber = /*#__PURE__*/new WeakMap();
var _nextTimer = /*#__PURE__*/new WeakMap();
var _timers = /*#__PURE__*/new WeakMap();
var _disableCcipRead = /*#__PURE__*/new WeakMap();
var _options = /*#__PURE__*/new WeakMap();
var _AbstractProvider_brand = /*#__PURE__*/new WeakSet();
var AbstractProvider = /*#__PURE__*/function () {
  /**
   *  Create a new **AbstractProvider** connected to %%network%%, or
   *  use the various network detection capabilities to discover the
   *  [[Network]] if necessary.
   */
  function AbstractProvider(_network, options) {
    var _this = this;
    _classCallCheck(this, AbstractProvider);
    // Shares multiple identical requests made during the same 250ms
    _classPrivateMethodInitSpec(this, _AbstractProvider_brand);
    _classPrivateFieldInitSpec(this, _subs, void 0);
    _classPrivateFieldInitSpec(this, _plugins, void 0);
    // null=unpaused, true=paused+dropWhilePaused, false=paused
    _classPrivateFieldInitSpec(this, _pausedState, void 0);
    _classPrivateFieldInitSpec(this, _destroyed, void 0);
    _classPrivateFieldInitSpec(this, _networkPromise, void 0);
    _classPrivateFieldInitSpec(this, _anyNetwork, void 0);
    _classPrivateFieldInitSpec(this, _performCache, void 0);
    // The most recent block number if running an event or -1 if no "block" event
    _classPrivateFieldInitSpec(this, _lastBlockNumber, void 0);
    _classPrivateFieldInitSpec(this, _nextTimer, void 0);
    _classPrivateFieldInitSpec(this, _timers, void 0);
    _classPrivateFieldInitSpec(this, _disableCcipRead, void 0);
    _classPrivateFieldInitSpec(this, _options, void 0);
    _classPrivateFieldSet(_options, this, Object.assign({}, defaultOptions, options || {}));
    if (_network === "any") {
      _classPrivateFieldSet(_anyNetwork, this, true);
      _classPrivateFieldSet(_networkPromise, this, null);
    } else if (_network) {
      var network = network_js_1.Network.from(_network);
      _classPrivateFieldSet(_anyNetwork, this, false);
      _classPrivateFieldSet(_networkPromise, this, Promise.resolve(network));
      setTimeout(function () {
        _this.emit("network", network, null);
      }, 0);
    } else {
      _classPrivateFieldSet(_anyNetwork, this, false);
      _classPrivateFieldSet(_networkPromise, this, null);
    }
    _classPrivateFieldSet(_lastBlockNumber, this, -1);
    _classPrivateFieldSet(_performCache, this, new Map());
    _classPrivateFieldSet(_subs, this, new Map());
    _classPrivateFieldSet(_plugins, this, new Map());
    _classPrivateFieldSet(_pausedState, this, null);
    _classPrivateFieldSet(_destroyed, this, false);
    _classPrivateFieldSet(_nextTimer, this, 1);
    _classPrivateFieldSet(_timers, this, new Map());
    _classPrivateFieldSet(_disableCcipRead, this, false);
  }
  return _createClass(AbstractProvider, [{
    key: "pollingInterval",
    get: function get() {
      return _classPrivateFieldGet(_options, this).pollingInterval;
    }
    /**
     *  Returns ``this``, to allow an **AbstractProvider** to implement
     *  the [[ContractRunner]] interface.
     */
  }, {
    key: "provider",
    get: function get() {
      return this;
    }
    /**
     *  Returns all the registered plug-ins.
     */
  }, {
    key: "plugins",
    get: function get() {
      return Array.from(_classPrivateFieldGet(_plugins, this).values());
    }
    /**
     *  Attach a new plug-in.
     */
  }, {
    key: "attachPlugin",
    value: function attachPlugin(plugin) {
      if (_classPrivateFieldGet(_plugins, this).get(plugin.name)) {
        throw new Error("cannot replace existing plugin: ".concat(plugin.name, " "));
      }
      _classPrivateFieldGet(_plugins, this).set(plugin.name, plugin.connect(this));
      return this;
    }
    /**
     *  Get a plugin by name.
     */
  }, {
    key: "getPlugin",
    value: function getPlugin(name) {
      return _classPrivateFieldGet(_plugins, this).get(name) || null;
    }
    /**
     *  Prevent any CCIP-read operation, regardless of whether requested
     *  in a [[call]] using ``enableCcipRead``.
     */
  }, {
    key: "disableCcipRead",
    get: function get() {
      return _classPrivateFieldGet(_disableCcipRead, this);
    },
    set: function set(value) {
      _classPrivateFieldSet(_disableCcipRead, this, !!value);
    }
  }, {
    key: "ccipReadFetch",
    value: (
    /**
     *  Resolves to the data for executing the CCIP-read operations.
     */
    function () {
      var _ccipReadFetch = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(tx, calldata, urls) {
        var sender, data, errorMessages, i, url, href, request, errorMessage, resp, result;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              if (!(this.disableCcipRead || urls.length === 0 || tx.to == null)) {
                _context.next = 2;
                break;
              }
              return _context.abrupt("return", null);
            case 2:
              sender = tx.to.toLowerCase();
              data = calldata.toLowerCase();
              errorMessages = [];
              i = 0;
            case 6:
              if (!(i < urls.length)) {
                _context.next = 32;
                break;
              }
              url = urls[i]; // URL expansion
              href = url.replace("{sender}", sender).replace("{data}", data); // If no {data} is present, use POST; otherwise GET
              //const json: string | null = (url.indexOf("{data}") >= 0) ? null: JSON.stringify({ data, sender });
              //const result = await fetchJson({ url: href, errorPassThrough: true }, json, (value, response) => {
              //    value.status = response.statusCode;
              //    return value;
              //});
              request = new index_js_6.FetchRequest(href);
              if (url.indexOf("{data}") === -1) {
                request.body = {
                  data: data,
                  sender: sender
                };
              }
              this.emit("debug", {
                action: "sendCcipReadFetchRequest",
                request: request,
                index: i,
                urls: urls
              });
              errorMessage = "unknown error";
              _context.next = 15;
              return request.send();
            case 15:
              resp = _context.sent;
              _context.prev = 16;
              result = resp.bodyJson;
              if (!result.data) {
                _context.next = 21;
                break;
              }
              this.emit("debug", {
                action: "receiveCcipReadFetchResult",
                request: request,
                result: result
              });
              return _context.abrupt("return", result.data);
            case 21:
              if (result.message) {
                errorMessage = result.message;
              }
              this.emit("debug", {
                action: "receiveCcipReadFetchError",
                request: request,
                result: result
              });
              _context.next = 27;
              break;
            case 25:
              _context.prev = 25;
              _context.t0 = _context["catch"](16);
            case 27:
              // 4xx indicates the result is not present; stop
              (0, index_js_6.assert)(resp.statusCode < 400 || resp.statusCode >= 500, "response not found during CCIP fetch: ".concat(errorMessage), "OFFCHAIN_FAULT", {
                reason: "404_MISSING_RESOURCE",
                transaction: tx,
                info: {
                  url: url,
                  errorMessage: errorMessage
                }
              });
              // 5xx indicates server issue; try the next url
              errorMessages.push(errorMessage);
            case 29:
              i++;
              _context.next = 6;
              break;
            case 32:
              (0, index_js_6.assert)(false, "error encountered during CCIP fetch: ".concat(errorMessages.map(function (m) {
                return JSON.stringify(m);
              }).join(", ")), "OFFCHAIN_FAULT", {
                reason: "500_SERVER_ERROR",
                transaction: tx,
                info: {
                  urls: urls,
                  errorMessages: errorMessages
                }
              });
            case 33:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[16, 25]]);
      }));
      function ccipReadFetch(_x3, _x4, _x5) {
        return _ccipReadFetch.apply(this, arguments);
      }
      return ccipReadFetch;
    }()
    /**
     *  Provides the opportunity for a sub-class to wrap a block before
     *  returning it, to add additional properties or an alternate
     *  sub-class of [[Block]].
     */
    )
  }, {
    key: "_wrapBlock",
    value: function _wrapBlock(value, network) {
      return new provider_js_1.Block((0, format_js_1.formatBlock)(value), this);
    }
    /**
     *  Provides the opportunity for a sub-class to wrap a log before
     *  returning it, to add additional properties or an alternate
     *  sub-class of [[Log]].
     */
  }, {
    key: "_wrapLog",
    value: function _wrapLog(value, network) {
      return new provider_js_1.Log((0, format_js_1.formatLog)(value), this);
    }
    /**
     *  Provides the opportunity for a sub-class to wrap a transaction
     *  receipt before returning it, to add additional properties or an
     *  alternate sub-class of [[TransactionReceipt]].
     */
  }, {
    key: "_wrapTransactionReceipt",
    value: function _wrapTransactionReceipt(value, network) {
      return new provider_js_1.TransactionReceipt((0, format_js_1.formatTransactionReceipt)(value), this);
    }
    /**
     *  Provides the opportunity for a sub-class to wrap a transaction
     *  response before returning it, to add additional properties or an
     *  alternate sub-class of [[TransactionResponse]].
     */
  }, {
    key: "_wrapTransactionResponse",
    value: function _wrapTransactionResponse(tx, network) {
      return new provider_js_1.TransactionResponse((0, format_js_1.formatTransactionResponse)(tx), this);
    }
    /**
     *  Resolves to the Network, forcing a network detection using whatever
     *  technique the sub-class requires.
     *
     *  Sub-classes **must** override this.
     */
  }, {
    key: "_detectNetwork",
    value: function _detectNetwork() {
      (0, index_js_6.assert)(false, "sub-classes must implement this", "UNSUPPORTED_OPERATION", {
        operation: "_detectNetwork"
      });
    }
    /**
     *  Sub-classes should use this to perform all built-in operations. All
     *  methods sanitizes and normalizes the values passed into this.
     *
     *  Sub-classes **must** override this.
     */
  }, {
    key: "_perform",
    value: (function () {
      var _perform2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(req) {
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              (0, index_js_6.assert)(false, "unsupported method: ".concat(req.method), "UNSUPPORTED_OPERATION", {
                operation: req.method,
                info: req
              });
            case 1:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      }));
      function _perform(_x6) {
        return _perform2.apply(this, arguments);
      }
      return _perform;
    }() // State
    )
  }, {
    key: "getBlockNumber",
    value: function () {
      var _getBlockNumber = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
        var blockNumber;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _context3.t0 = (0, index_js_6.getNumber);
              _context3.next = 3;
              return _assertClassBrand(_AbstractProvider_brand, this, _perform).call(this, {
                method: "getBlockNumber"
              });
            case 3:
              _context3.t1 = _context3.sent;
              blockNumber = (0, _context3.t0)(_context3.t1, "%response");
              if (_classPrivateFieldGet(_lastBlockNumber, this) >= 0) {
                _classPrivateFieldSet(_lastBlockNumber, this, blockNumber);
              }
              return _context3.abrupt("return", blockNumber);
            case 7:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function getBlockNumber() {
        return _getBlockNumber.apply(this, arguments);
      }
      return getBlockNumber;
    }()
    /**
     *  Returns or resolves to the address for %%address%%, resolving ENS
     *  names and [[Addressable]] objects and returning if already an
     *  address.
     */
  }, {
    key: "_getAddress",
    value: function _getAddress(address) {
      return (0, index_js_1.resolveAddress)(address, this);
    }
    /**
     *  Returns or resolves to a valid block tag for %%blockTag%%, resolving
     *  negative values and returning if already a valid block tag.
     */
  }, {
    key: "_getBlockTag",
    value: function _getBlockTag(blockTag) {
      if (blockTag == null) {
        return "latest";
      }
      switch (blockTag) {
        case "earliest":
          return "0x0";
        case "finalized":
        case "latest":
        case "pending":
        case "safe":
          return blockTag;
      }
      if ((0, index_js_6.isHexString)(blockTag)) {
        if ((0, index_js_6.isHexString)(blockTag, 32)) {
          return blockTag;
        }
        return (0, index_js_6.toQuantity)(blockTag);
      }
      if (typeof blockTag === "bigint") {
        blockTag = (0, index_js_6.getNumber)(blockTag, "blockTag");
      }
      if (typeof blockTag === "number") {
        if (blockTag >= 0) {
          return (0, index_js_6.toQuantity)(blockTag);
        }
        if (_classPrivateFieldGet(_lastBlockNumber, this) >= 0) {
          return (0, index_js_6.toQuantity)(_classPrivateFieldGet(_lastBlockNumber, this) + blockTag);
        }
        return this.getBlockNumber().then(function (b) {
          return (0, index_js_6.toQuantity)(b + blockTag);
        });
      }
      (0, index_js_6.assertArgument)(false, "invalid blockTag", "blockTag", blockTag);
    }
    /**
     *  Returns or resolves to a filter for %%filter%%, resolving any ENS
     *  names or [[Addressable]] object and returning if already a valid
     *  filter.
     */
  }, {
    key: "_getFilter",
    value: function _getFilter(filter) {
      // Create a canonical representation of the topics
      var topics = (filter.topics || []).map(function (t) {
        if (t == null) {
          return null;
        }
        if (Array.isArray(t)) {
          return concisify(t.map(function (t) {
            return t.toLowerCase();
          }));
        }
        return t.toLowerCase();
      });
      var blockHash = "blockHash" in filter ? filter.blockHash : undefined;
      var resolve = function resolve(_address, fromBlock, toBlock) {
        var address = undefined;
        switch (_address.length) {
          case 0:
            break;
          case 1:
            address = _address[0];
            break;
          default:
            _address.sort();
            address = _address;
        }
        if (blockHash) {
          if (fromBlock != null || toBlock != null) {
            throw new Error("invalid filter");
          }
        }
        var filter = {};
        if (address) {
          filter.address = address;
        }
        if (topics.length) {
          filter.topics = topics;
        }
        if (fromBlock) {
          filter.fromBlock = fromBlock;
        }
        if (toBlock) {
          filter.toBlock = toBlock;
        }
        if (blockHash) {
          filter.blockHash = blockHash;
        }
        return filter;
      };
      // Addresses could be async (ENS names or Addressables)
      var address = [];
      if (filter.address) {
        if (Array.isArray(filter.address)) {
          var _iterator = _createForOfIteratorHelper(filter.address),
            _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var addr = _step.value;
              address.push(this._getAddress(addr));
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        } else {
          address.push(this._getAddress(filter.address));
        }
      }
      var fromBlock = undefined;
      if ("fromBlock" in filter) {
        fromBlock = this._getBlockTag(filter.fromBlock);
      }
      var toBlock = undefined;
      if ("toBlock" in filter) {
        toBlock = this._getBlockTag(filter.toBlock);
      }
      if (address.filter(function (a) {
        return typeof a !== "string";
      }).length || fromBlock != null && typeof fromBlock !== "string" || toBlock != null && typeof toBlock !== "string") {
        return Promise.all([Promise.all(address), fromBlock, toBlock]).then(function (result) {
          return resolve(result[0], result[1], result[2]);
        });
      }
      return resolve(address, fromBlock, toBlock);
    }
    /**
     *  Returns or resolves to a transaction for %%request%%, resolving
     *  any ENS names or [[Addressable]] and returning if already a valid
     *  transaction.
     */
  }, {
    key: "_getTransactionRequest",
    value: function _getTransactionRequest(_request) {
      var _this2 = this;
      var request = (0, provider_js_1.copyRequest)(_request);
      var promises = [];
      ["to", "from"].forEach(function (key) {
        if (request[key] == null) {
          return;
        }
        var addr = (0, index_js_1.resolveAddress)(request[key], _this2);
        if (isPromise(addr)) {
          promises.push(_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
            return _regeneratorRuntime().wrap(function _callee4$(_context4) {
              while (1) switch (_context4.prev = _context4.next) {
                case 0:
                  _context4.next = 2;
                  return addr;
                case 2:
                  request[key] = _context4.sent;
                case 3:
                case "end":
                  return _context4.stop();
              }
            }, _callee4);
          }))());
        } else {
          request[key] = addr;
        }
      });
      if (request.blockTag != null) {
        var blockTag = this._getBlockTag(request.blockTag);
        if (isPromise(blockTag)) {
          promises.push(_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
            return _regeneratorRuntime().wrap(function _callee5$(_context5) {
              while (1) switch (_context5.prev = _context5.next) {
                case 0:
                  _context5.next = 2;
                  return blockTag;
                case 2:
                  request.blockTag = _context5.sent;
                case 3:
                case "end":
                  return _context5.stop();
              }
            }, _callee5);
          }))());
        } else {
          request.blockTag = blockTag;
        }
      }
      if (promises.length) {
        return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
          return _regeneratorRuntime().wrap(function _callee6$(_context6) {
            while (1) switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return Promise.all(promises);
              case 2:
                return _context6.abrupt("return", request);
              case 3:
              case "end":
                return _context6.stop();
            }
          }, _callee6);
        }))();
      }
      return request;
    }
  }, {
    key: "getNetwork",
    value: function () {
      var _getNetwork = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {
        var _this3 = this;
        var detectNetwork, networkPromise, _yield$Promise$all, _yield$Promise$all2, expected, actual;
        return _regeneratorRuntime().wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              if (!(_classPrivateFieldGet(_networkPromise, this) == null)) {
                _context8.next = 6;
                break;
              }
              // Detect the current network (shared with all calls)
              detectNetwork = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {
                var network;
                return _regeneratorRuntime().wrap(function _callee7$(_context7) {
                  while (1) switch (_context7.prev = _context7.next) {
                    case 0:
                      _context7.prev = 0;
                      _context7.next = 3;
                      return _this3._detectNetwork();
                    case 3:
                      network = _context7.sent;
                      _this3.emit("network", network, null);
                      return _context7.abrupt("return", network);
                    case 8:
                      _context7.prev = 8;
                      _context7.t0 = _context7["catch"](0);
                      if (_classPrivateFieldGet(_networkPromise, _this3) === detectNetwork) {
                        _classPrivateFieldSet(_networkPromise, _this3, null);
                      }
                      throw _context7.t0;
                    case 12:
                    case "end":
                      return _context7.stop();
                  }
                }, _callee7, null, [[0, 8]]);
              }))();
              _classPrivateFieldSet(_networkPromise, this, detectNetwork);
              _context8.next = 5;
              return detectNetwork;
            case 5:
              return _context8.abrupt("return", _context8.sent.clone());
            case 6:
              networkPromise = _classPrivateFieldGet(_networkPromise, this);
              _context8.next = 9;
              return Promise.all([networkPromise, this._detectNetwork() // The actual connected network
              ]);
            case 9:
              _yield$Promise$all = _context8.sent;
              _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);
              expected = _yield$Promise$all2[0];
              actual = _yield$Promise$all2[1];
              if (expected.chainId !== actual.chainId) {
                if (_classPrivateFieldGet(_anyNetwork, this)) {
                  // The "any" network can change, so notify listeners
                  this.emit("network", actual, expected);
                  // Update the network if something else hasn't already changed it
                  if (_classPrivateFieldGet(_networkPromise, this) === networkPromise) {
                    _classPrivateFieldSet(_networkPromise, this, Promise.resolve(actual));
                  }
                } else {
                  // Otherwise, we do not allow changes to the underlying network
                  (0, index_js_6.assert)(false, "network changed: ".concat(expected.chainId, " => ").concat(actual.chainId, " "), "NETWORK_ERROR", {
                    event: "changed"
                  });
                }
              }
              return _context8.abrupt("return", expected.clone());
            case 15:
            case "end":
              return _context8.stop();
          }
        }, _callee8, this);
      }));
      function getNetwork() {
        return _getNetwork.apply(this, arguments);
      }
      return getNetwork;
    }()
  }, {
    key: "getFeeData",
    value: function () {
      var _getFeeData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {
        var _this4 = this;
        var network, getFeeDataFunc, plugin, req, feeData;
        return _regeneratorRuntime().wrap(function _callee12$(_context12) {
          while (1) switch (_context12.prev = _context12.next) {
            case 0:
              _context12.next = 2;
              return this.getNetwork();
            case 2:
              network = _context12.sent;
              getFeeDataFunc = /*#__PURE__*/function () {
                var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {
                  var _yield, _block, gasPrice, priorityFee, maxFeePerGas, maxPriorityFeePerGas, block;
                  return _regeneratorRuntime().wrap(function _callee11$(_context11) {
                    while (1) switch (_context11.prev = _context11.next) {
                      case 0:
                        _context11.next = 2;
                        return (0, index_js_6.resolveProperties)({
                          _block: _assertClassBrand(_AbstractProvider_brand, _this4, _getBlock).call(_this4, "latest", false),
                          gasPrice: _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {
                            var value;
                            return _regeneratorRuntime().wrap(function _callee9$(_context9) {
                              while (1) switch (_context9.prev = _context9.next) {
                                case 0:
                                  _context9.prev = 0;
                                  _context9.next = 3;
                                  return _assertClassBrand(_AbstractProvider_brand, _this4, _perform).call(_this4, {
                                    method: "getGasPrice"
                                  });
                                case 3:
                                  value = _context9.sent;
                                  return _context9.abrupt("return", (0, index_js_6.getBigInt)(value, "%response"));
                                case 7:
                                  _context9.prev = 7;
                                  _context9.t0 = _context9["catch"](0);
                                case 9:
                                  return _context9.abrupt("return", null);
                                case 10:
                                case "end":
                                  return _context9.stop();
                              }
                            }, _callee9, null, [[0, 7]]);
                          }))(),
                          priorityFee: _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {
                            var value;
                            return _regeneratorRuntime().wrap(function _callee10$(_context10) {
                              while (1) switch (_context10.prev = _context10.next) {
                                case 0:
                                  _context10.prev = 0;
                                  _context10.next = 3;
                                  return _assertClassBrand(_AbstractProvider_brand, _this4, _perform).call(_this4, {
                                    method: "getPriorityFee"
                                  });
                                case 3:
                                  value = _context10.sent;
                                  return _context10.abrupt("return", (0, index_js_6.getBigInt)(value, "%response"));
                                case 7:
                                  _context10.prev = 7;
                                  _context10.t0 = _context10["catch"](0);
                                case 9:
                                  return _context10.abrupt("return", null);
                                case 10:
                                case "end":
                                  return _context10.stop();
                              }
                            }, _callee10, null, [[0, 7]]);
                          }))()
                        });
                      case 2:
                        _yield = _context11.sent;
                        _block = _yield._block;
                        gasPrice = _yield.gasPrice;
                        priorityFee = _yield.priorityFee;
                        maxFeePerGas = null;
                        maxPriorityFeePerGas = null; // These are the recommended EIP-1559 heuristics for fee data
                        block = _this4._wrapBlock(_block, network);
                        if (block && block.baseFeePerGas) {
                          maxPriorityFeePerGas = priorityFee != null ? priorityFee : BigInt("1000000000");
                          maxFeePerGas = block.baseFeePerGas * BN_2 + maxPriorityFeePerGas;
                        }
                        return _context11.abrupt("return", new provider_js_1.FeeData(gasPrice, maxFeePerGas, maxPriorityFeePerGas));
                      case 11:
                      case "end":
                        return _context11.stop();
                    }
                  }, _callee11);
                }));
                return function getFeeDataFunc() {
                  return _ref5.apply(this, arguments);
                };
              }(); // Check for a FeeDataNetWorkPlugin
              plugin = network.getPlugin("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
              if (!plugin) {
                _context12.next = 11;
                break;
              }
              req = new index_js_6.FetchRequest(plugin.url);
              _context12.next = 9;
              return plugin.processFunc(getFeeDataFunc, this, req);
            case 9:
              feeData = _context12.sent;
              return _context12.abrupt("return", new provider_js_1.FeeData(feeData.gasPrice, feeData.maxFeePerGas, feeData.maxPriorityFeePerGas));
            case 11:
              _context12.next = 13;
              return getFeeDataFunc();
            case 13:
              return _context12.abrupt("return", _context12.sent);
            case 14:
            case "end":
              return _context12.stop();
          }
        }, _callee12, this);
      }));
      function getFeeData() {
        return _getFeeData.apply(this, arguments);
      }
      return getFeeData;
    }()
  }, {
    key: "estimateGas",
    value: function () {
      var _estimateGas = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(_tx) {
        var tx;
        return _regeneratorRuntime().wrap(function _callee13$(_context13) {
          while (1) switch (_context13.prev = _context13.next) {
            case 0:
              tx = this._getTransactionRequest(_tx);
              if (!isPromise(tx)) {
                _context13.next = 5;
                break;
              }
              _context13.next = 4;
              return tx;
            case 4:
              tx = _context13.sent;
            case 5:
              _context13.t0 = (0, index_js_6.getBigInt);
              _context13.next = 8;
              return _assertClassBrand(_AbstractProvider_brand, this, _perform).call(this, {
                method: "estimateGas",
                transaction: tx
              });
            case 8:
              _context13.t1 = _context13.sent;
              return _context13.abrupt("return", (0, _context13.t0)(_context13.t1, "%response"));
            case 10:
            case "end":
              return _context13.stop();
          }
        }, _callee13, this);
      }));
      function estimateGas(_x7) {
        return _estimateGas.apply(this, arguments);
      }
      return estimateGas;
    }()
  }, {
    key: "call",
    value: function () {
      var _call2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14(_tx) {
        var _yield2, tx, blockTag;
        return _regeneratorRuntime().wrap(function _callee14$(_context14) {
          while (1) switch (_context14.prev = _context14.next) {
            case 0:
              _context14.next = 2;
              return (0, index_js_6.resolveProperties)({
                tx: this._getTransactionRequest(_tx),
                blockTag: this._getBlockTag(_tx.blockTag)
              });
            case 2:
              _yield2 = _context14.sent;
              tx = _yield2.tx;
              blockTag = _yield2.blockTag;
              _context14.next = 7;
              return _assertClassBrand(_AbstractProvider_brand, this, _checkNetwork).call(this, _assertClassBrand(_AbstractProvider_brand, this, _call).call(this, tx, blockTag, _tx.enableCcipRead ? 0 : -1));
            case 7:
              return _context14.abrupt("return", _context14.sent);
            case 8:
            case "end":
              return _context14.stop();
          }
        }, _callee14, this);
      }));
      function call(_x8) {
        return _call2.apply(this, arguments);
      }
      return call;
    }() // Account
  }, {
    key: "getBalance",
    value: function () {
      var _getBalance = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15(address, blockTag) {
        return _regeneratorRuntime().wrap(function _callee15$(_context15) {
          while (1) switch (_context15.prev = _context15.next) {
            case 0:
              _context15.t0 = (0, index_js_6.getBigInt);
              _context15.next = 3;
              return _assertClassBrand(_AbstractProvider_brand, this, _getAccountValue).call(this, {
                method: "getBalance"
              }, address, blockTag);
            case 3:
              _context15.t1 = _context15.sent;
              return _context15.abrupt("return", (0, _context15.t0)(_context15.t1, "%response"));
            case 5:
            case "end":
              return _context15.stop();
          }
        }, _callee15, this);
      }));
      function getBalance(_x9, _x10) {
        return _getBalance.apply(this, arguments);
      }
      return getBalance;
    }()
  }, {
    key: "getTransactionCount",
    value: function () {
      var _getTransactionCount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16(address, blockTag) {
        return _regeneratorRuntime().wrap(function _callee16$(_context16) {
          while (1) switch (_context16.prev = _context16.next) {
            case 0:
              _context16.t0 = (0, index_js_6.getNumber);
              _context16.next = 3;
              return _assertClassBrand(_AbstractProvider_brand, this, _getAccountValue).call(this, {
                method: "getTransactionCount"
              }, address, blockTag);
            case 3:
              _context16.t1 = _context16.sent;
              return _context16.abrupt("return", (0, _context16.t0)(_context16.t1, "%response"));
            case 5:
            case "end":
              return _context16.stop();
          }
        }, _callee16, this);
      }));
      function getTransactionCount(_x11, _x12) {
        return _getTransactionCount.apply(this, arguments);
      }
      return getTransactionCount;
    }()
  }, {
    key: "getCode",
    value: function () {
      var _getCode = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17(address, blockTag) {
        return _regeneratorRuntime().wrap(function _callee17$(_context17) {
          while (1) switch (_context17.prev = _context17.next) {
            case 0:
              _context17.t0 = (0, index_js_6.hexlify);
              _context17.next = 3;
              return _assertClassBrand(_AbstractProvider_brand, this, _getAccountValue).call(this, {
                method: "getCode"
              }, address, blockTag);
            case 3:
              _context17.t1 = _context17.sent;
              return _context17.abrupt("return", (0, _context17.t0)(_context17.t1));
            case 5:
            case "end":
              return _context17.stop();
          }
        }, _callee17, this);
      }));
      function getCode(_x13, _x14) {
        return _getCode.apply(this, arguments);
      }
      return getCode;
    }()
  }, {
    key: "getStorage",
    value: function () {
      var _getStorage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee18(address, _position, blockTag) {
        var position;
        return _regeneratorRuntime().wrap(function _callee18$(_context18) {
          while (1) switch (_context18.prev = _context18.next) {
            case 0:
              position = (0, index_js_6.getBigInt)(_position, "position");
              _context18.t0 = (0, index_js_6.hexlify);
              _context18.next = 4;
              return _assertClassBrand(_AbstractProvider_brand, this, _getAccountValue).call(this, {
                method: "getStorage",
                position: position
              }, address, blockTag);
            case 4:
              _context18.t1 = _context18.sent;
              return _context18.abrupt("return", (0, _context18.t0)(_context18.t1));
            case 6:
            case "end":
              return _context18.stop();
          }
        }, _callee18, this);
      }));
      function getStorage(_x15, _x16, _x17) {
        return _getStorage.apply(this, arguments);
      }
      return getStorage;
    }() // Write
  }, {
    key: "broadcastTransaction",
    value: function () {
      var _broadcastTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee19(signedTx) {
        var _yield3, blockNumber, hash, network, tx;
        return _regeneratorRuntime().wrap(function _callee19$(_context19) {
          while (1) switch (_context19.prev = _context19.next) {
            case 0:
              _context19.next = 2;
              return (0, index_js_6.resolveProperties)({
                blockNumber: this.getBlockNumber(),
                hash: this._perform({
                  method: "broadcastTransaction",
                  signedTransaction: signedTx
                }),
                network: this.getNetwork()
              });
            case 2:
              _yield3 = _context19.sent;
              blockNumber = _yield3.blockNumber;
              hash = _yield3.hash;
              network = _yield3.network;
              tx = index_js_5.Transaction.from(signedTx);
              if (!(tx.hash !== hash)) {
                _context19.next = 9;
                break;
              }
              throw new Error("@TODO: the returned hash did not match");
            case 9:
              return _context19.abrupt("return", this._wrapTransactionResponse(tx, network).replaceableTransaction(blockNumber));
            case 10:
            case "end":
              return _context19.stop();
          }
        }, _callee19, this);
      }));
      function broadcastTransaction(_x18) {
        return _broadcastTransaction.apply(this, arguments);
      }
      return broadcastTransaction;
    }()
  }, {
    key: "getBlock",
    value: // Queries
    function () {
      var _getBlock2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee20(block, prefetchTxs) {
        var _yield4, network, params;
        return _regeneratorRuntime().wrap(function _callee20$(_context20) {
          while (1) switch (_context20.prev = _context20.next) {
            case 0:
              _context20.next = 2;
              return (0, index_js_6.resolveProperties)({
                network: this.getNetwork(),
                params: _assertClassBrand(_AbstractProvider_brand, this, _getBlock).call(this, block, !!prefetchTxs)
              });
            case 2:
              _yield4 = _context20.sent;
              network = _yield4.network;
              params = _yield4.params;
              if (!(params == null)) {
                _context20.next = 7;
                break;
              }
              return _context20.abrupt("return", null);
            case 7:
              return _context20.abrupt("return", this._wrapBlock(params, network));
            case 8:
            case "end":
              return _context20.stop();
          }
        }, _callee20, this);
      }));
      function getBlock(_x19, _x20) {
        return _getBlock2.apply(this, arguments);
      }
      return getBlock;
    }()
  }, {
    key: "getTransaction",
    value: function () {
      var _getTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee21(hash) {
        var _yield5, network, params;
        return _regeneratorRuntime().wrap(function _callee21$(_context21) {
          while (1) switch (_context21.prev = _context21.next) {
            case 0:
              _context21.next = 2;
              return (0, index_js_6.resolveProperties)({
                network: this.getNetwork(),
                params: _assertClassBrand(_AbstractProvider_brand, this, _perform).call(this, {
                  method: "getTransaction",
                  hash: hash
                })
              });
            case 2:
              _yield5 = _context21.sent;
              network = _yield5.network;
              params = _yield5.params;
              if (!(params == null)) {
                _context21.next = 7;
                break;
              }
              return _context21.abrupt("return", null);
            case 7:
              return _context21.abrupt("return", this._wrapTransactionResponse(params, network));
            case 8:
            case "end":
              return _context21.stop();
          }
        }, _callee21, this);
      }));
      function getTransaction(_x21) {
        return _getTransaction.apply(this, arguments);
      }
      return getTransaction;
    }()
  }, {
    key: "getTransactionReceipt",
    value: function () {
      var _getTransactionReceipt = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee22(hash) {
        var _yield6, network, params, tx;
        return _regeneratorRuntime().wrap(function _callee22$(_context22) {
          while (1) switch (_context22.prev = _context22.next) {
            case 0:
              _context22.next = 2;
              return (0, index_js_6.resolveProperties)({
                network: this.getNetwork(),
                params: _assertClassBrand(_AbstractProvider_brand, this, _perform).call(this, {
                  method: "getTransactionReceipt",
                  hash: hash
                })
              });
            case 2:
              _yield6 = _context22.sent;
              network = _yield6.network;
              params = _yield6.params;
              if (!(params == null)) {
                _context22.next = 7;
                break;
              }
              return _context22.abrupt("return", null);
            case 7:
              if (!(params.gasPrice == null && params.effectiveGasPrice == null)) {
                _context22.next = 14;
                break;
              }
              _context22.next = 10;
              return _assertClassBrand(_AbstractProvider_brand, this, _perform).call(this, {
                method: "getTransaction",
                hash: hash
              });
            case 10:
              tx = _context22.sent;
              if (!(tx == null)) {
                _context22.next = 13;
                break;
              }
              throw new Error("report this; could not find tx or effectiveGasPrice");
            case 13:
              params.effectiveGasPrice = tx.gasPrice;
            case 14:
              return _context22.abrupt("return", this._wrapTransactionReceipt(params, network));
            case 15:
            case "end":
              return _context22.stop();
          }
        }, _callee22, this);
      }));
      function getTransactionReceipt(_x22) {
        return _getTransactionReceipt.apply(this, arguments);
      }
      return getTransactionReceipt;
    }()
  }, {
    key: "getTransactionResult",
    value: function () {
      var _getTransactionResult = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee23(hash) {
        var _yield7, result;
        return _regeneratorRuntime().wrap(function _callee23$(_context23) {
          while (1) switch (_context23.prev = _context23.next) {
            case 0:
              _context23.next = 2;
              return (0, index_js_6.resolveProperties)({
                network: this.getNetwork(),
                result: _assertClassBrand(_AbstractProvider_brand, this, _perform).call(this, {
                  method: "getTransactionResult",
                  hash: hash
                })
              });
            case 2:
              _yield7 = _context23.sent;
              result = _yield7.result;
              if (!(result == null)) {
                _context23.next = 6;
                break;
              }
              return _context23.abrupt("return", null);
            case 6:
              return _context23.abrupt("return", (0, index_js_6.hexlify)(result));
            case 7:
            case "end":
              return _context23.stop();
          }
        }, _callee23, this);
      }));
      function getTransactionResult(_x23) {
        return _getTransactionResult.apply(this, arguments);
      }
      return getTransactionResult;
    }() // Bloom-filter Queries
  }, {
    key: "getLogs",
    value: function () {
      var _getLogs = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee24(_filter) {
        var _this5 = this;
        var filter, _yield8, network, params;
        return _regeneratorRuntime().wrap(function _callee24$(_context24) {
          while (1) switch (_context24.prev = _context24.next) {
            case 0:
              filter = this._getFilter(_filter);
              if (!isPromise(filter)) {
                _context24.next = 5;
                break;
              }
              _context24.next = 4;
              return filter;
            case 4:
              filter = _context24.sent;
            case 5:
              _context24.next = 7;
              return (0, index_js_6.resolveProperties)({
                network: this.getNetwork(),
                params: _assertClassBrand(_AbstractProvider_brand, this, _perform).call(this, {
                  method: "getLogs",
                  filter: filter
                })
              });
            case 7:
              _yield8 = _context24.sent;
              network = _yield8.network;
              params = _yield8.params;
              return _context24.abrupt("return", params.map(function (p) {
                return _this5._wrapLog(p, network);
              }));
            case 11:
            case "end":
              return _context24.stop();
          }
        }, _callee24, this);
      }));
      function getLogs(_x24) {
        return _getLogs.apply(this, arguments);
      }
      return getLogs;
    }() // ENS
  }, {
    key: "_getProvider",
    value: function _getProvider(chainId) {
      (0, index_js_6.assert)(false, "provider cannot connect to target network", "UNSUPPORTED_OPERATION", {
        operation: "_getProvider()"
      });
    }
  }, {
    key: "getResolver",
    value: function () {
      var _getResolver = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee25(name) {
        return _regeneratorRuntime().wrap(function _callee25$(_context25) {
          while (1) switch (_context25.prev = _context25.next) {
            case 0:
              _context25.next = 2;
              return ens_resolver_js_1.EnsResolver.fromName(this, name);
            case 2:
              return _context25.abrupt("return", _context25.sent);
            case 3:
            case "end":
              return _context25.stop();
          }
        }, _callee25, this);
      }));
      function getResolver(_x25) {
        return _getResolver.apply(this, arguments);
      }
      return getResolver;
    }()
  }, {
    key: "getAvatar",
    value: function () {
      var _getAvatar = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee26(name) {
        var resolver;
        return _regeneratorRuntime().wrap(function _callee26$(_context26) {
          while (1) switch (_context26.prev = _context26.next) {
            case 0:
              _context26.next = 2;
              return this.getResolver(name);
            case 2:
              resolver = _context26.sent;
              if (!resolver) {
                _context26.next = 7;
                break;
              }
              _context26.next = 6;
              return resolver.getAvatar();
            case 6:
              return _context26.abrupt("return", _context26.sent);
            case 7:
              return _context26.abrupt("return", null);
            case 8:
            case "end":
              return _context26.stop();
          }
        }, _callee26, this);
      }));
      function getAvatar(_x26) {
        return _getAvatar.apply(this, arguments);
      }
      return getAvatar;
    }()
  }, {
    key: "resolveName",
    value: function () {
      var _resolveName = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee27(name) {
        var resolver;
        return _regeneratorRuntime().wrap(function _callee27$(_context27) {
          while (1) switch (_context27.prev = _context27.next) {
            case 0:
              _context27.next = 2;
              return this.getResolver(name);
            case 2:
              resolver = _context27.sent;
              if (!resolver) {
                _context27.next = 7;
                break;
              }
              _context27.next = 6;
              return resolver.getAddress();
            case 6:
              return _context27.abrupt("return", _context27.sent);
            case 7:
              return _context27.abrupt("return", null);
            case 8:
            case "end":
              return _context27.stop();
          }
        }, _callee27, this);
      }));
      function resolveName(_x27) {
        return _resolveName.apply(this, arguments);
      }
      return resolveName;
    }()
  }, {
    key: "lookupAddress",
    value: function () {
      var _lookupAddress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee28(address) {
        var node, ensAddr, ensContract, resolver, resolverContract, name, check;
        return _regeneratorRuntime().wrap(function _callee28$(_context28) {
          while (1) switch (_context28.prev = _context28.next) {
            case 0:
              address = (0, index_js_1.getAddress)(address);
              node = (0, index_js_4.namehash)(address.substring(2).toLowerCase() + ".addr.reverse");
              _context28.prev = 2;
              _context28.next = 5;
              return ens_resolver_js_1.EnsResolver.getEnsAddress(this);
            case 5:
              ensAddr = _context28.sent;
              ensContract = new index_js_3.Contract(ensAddr, ["function resolver(bytes32) view returns (address)"], this);
              _context28.next = 9;
              return ensContract.resolver(node);
            case 9:
              resolver = _context28.sent;
              if (!(resolver == null || resolver === index_js_2.ZeroAddress)) {
                _context28.next = 12;
                break;
              }
              return _context28.abrupt("return", null);
            case 12:
              resolverContract = new index_js_3.Contract(resolver, ["function name(bytes32) view returns (string)"], this);
              _context28.next = 15;
              return resolverContract.name(node);
            case 15:
              name = _context28.sent;
              _context28.next = 18;
              return this.resolveName(name);
            case 18:
              check = _context28.sent;
              if (!(check !== address)) {
                _context28.next = 21;
                break;
              }
              return _context28.abrupt("return", null);
            case 21:
              return _context28.abrupt("return", name);
            case 24:
              _context28.prev = 24;
              _context28.t0 = _context28["catch"](2);
              if (!((0, index_js_6.isError)(_context28.t0, "BAD_DATA") && _context28.t0.value === "0x")) {
                _context28.next = 28;
                break;
              }
              return _context28.abrupt("return", null);
            case 28:
              if (!(0, index_js_6.isError)(_context28.t0, "CALL_EXCEPTION")) {
                _context28.next = 30;
                break;
              }
              return _context28.abrupt("return", null);
            case 30:
              throw _context28.t0;
            case 31:
              return _context28.abrupt("return", null);
            case 32:
            case "end":
              return _context28.stop();
          }
        }, _callee28, this, [[2, 24]]);
      }));
      function lookupAddress(_x28) {
        return _lookupAddress.apply(this, arguments);
      }
      return lookupAddress;
    }()
  }, {
    key: "waitForTransaction",
    value: function () {
      var _waitForTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee31(hash, _confirms, timeout) {
        var _this6 = this;
        var confirms;
        return _regeneratorRuntime().wrap(function _callee31$(_context31) {
          while (1) switch (_context31.prev = _context31.next) {
            case 0:
              confirms = _confirms != null ? _confirms : 1;
              if (!(confirms === 0)) {
                _context31.next = 3;
                break;
              }
              return _context31.abrupt("return", this.getTransactionReceipt(hash));
            case 3:
              return _context31.abrupt("return", new Promise( /*#__PURE__*/function () {
                var _ref8 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee30(resolve, reject) {
                  var timer, listener;
                  return _regeneratorRuntime().wrap(function _callee30$(_context30) {
                    while (1) switch (_context30.prev = _context30.next) {
                      case 0:
                        timer = null;
                        listener = /*#__PURE__*/function () {
                          var _ref9 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee29(blockNumber) {
                            var receipt;
                            return _regeneratorRuntime().wrap(function _callee29$(_context29) {
                              while (1) switch (_context29.prev = _context29.next) {
                                case 0:
                                  _context29.prev = 0;
                                  _context29.next = 3;
                                  return _this6.getTransactionReceipt(hash);
                                case 3:
                                  receipt = _context29.sent;
                                  if (!(receipt != null)) {
                                    _context29.next = 9;
                                    break;
                                  }
                                  if (!(blockNumber - receipt.blockNumber + 1 >= confirms)) {
                                    _context29.next = 9;
                                    break;
                                  }
                                  resolve(receipt);
                                  //this.off("block", listener);
                                  if (timer) {
                                    clearTimeout(timer);
                                    timer = null;
                                  }
                                  return _context29.abrupt("return");
                                case 9:
                                  _context29.next = 14;
                                  break;
                                case 11:
                                  _context29.prev = 11;
                                  _context29.t0 = _context29["catch"](0);
                                  console.log("EEE", _context29.t0);
                                case 14:
                                  _this6.once("block", listener);
                                case 15:
                                case "end":
                                  return _context29.stop();
                              }
                            }, _callee29, null, [[0, 11]]);
                          }));
                          return function listener(_x34) {
                            return _ref9.apply(this, arguments);
                          };
                        }();
                        if (timeout != null) {
                          timer = setTimeout(function () {
                            if (timer == null) {
                              return;
                            }
                            timer = null;
                            _this6.off("block", listener);
                            reject((0, index_js_6.makeError)("timeout", "TIMEOUT", {
                              reason: "timeout"
                            }));
                          }, timeout);
                        }
                        _context30.t0 = listener;
                        _context30.next = 6;
                        return _this6.getBlockNumber();
                      case 6:
                        _context30.t1 = _context30.sent;
                        (0, _context30.t0)(_context30.t1);
                      case 8:
                      case "end":
                        return _context30.stop();
                    }
                  }, _callee30);
                }));
                return function (_x32, _x33) {
                  return _ref8.apply(this, arguments);
                };
              }()));
            case 4:
            case "end":
              return _context31.stop();
          }
        }, _callee31, this);
      }));
      function waitForTransaction(_x29, _x30, _x31) {
        return _waitForTransaction.apply(this, arguments);
      }
      return waitForTransaction;
    }()
  }, {
    key: "waitForBlock",
    value: function () {
      var _waitForBlock = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee32(blockTag) {
        return _regeneratorRuntime().wrap(function _callee32$(_context32) {
          while (1) switch (_context32.prev = _context32.next) {
            case 0:
              (0, index_js_6.assert)(false, "not implemented yet", "NOT_IMPLEMENTED", {
                operation: "waitForBlock"
              });
            case 1:
            case "end":
              return _context32.stop();
          }
        }, _callee32);
      }));
      function waitForBlock(_x35) {
        return _waitForBlock.apply(this, arguments);
      }
      return waitForBlock;
    }()
    /**
     *  Clear a timer created using the [[_setTimeout]] method.
     */
  }, {
    key: "_clearTimeout",
    value: function _clearTimeout(timerId) {
      var timer = _classPrivateFieldGet(_timers, this).get(timerId);
      if (!timer) {
        return;
      }
      if (timer.timer) {
        clearTimeout(timer.timer);
      }
      _classPrivateFieldGet(_timers, this)["delete"](timerId);
    }
    /**
     *  Create a timer that will execute %%func%% after at least %%timeout%%
     *  (in ms). If %%timeout%% is unspecified, then %%func%% will execute
     *  in the next event loop.
     *
     *  [Pausing](AbstractProvider-paused) the provider will pause any
     *  associated timers.
     */
  }, {
    key: "_setTimeout",
    value: function _setTimeout(_func, timeout) {
      var _this$nextTimer,
        _this$nextTimer2,
        _this7 = this;
      if (timeout == null) {
        timeout = 0;
      }
      var timerId = (_classPrivateFieldSet(_nextTimer, this, (_this$nextTimer = _classPrivateFieldGet(_nextTimer, this), _this$nextTimer2 = _this$nextTimer++, _this$nextTimer)), _this$nextTimer2);
      var func = function func() {
        _classPrivateFieldGet(_timers, _this7)["delete"](timerId);
        _func();
      };
      if (this.paused) {
        _classPrivateFieldGet(_timers, this).set(timerId, {
          timer: null,
          func: func,
          time: timeout
        });
      } else {
        var timer = setTimeout(func, timeout);
        _classPrivateFieldGet(_timers, this).set(timerId, {
          timer: timer,
          func: func,
          time: getTime()
        });
      }
      return timerId;
    }
    /**
     *  Perform %%func%% on each subscriber.
     */
  }, {
    key: "_forEachSubscriber",
    value: function _forEachSubscriber(func) {
      var _iterator2 = _createForOfIteratorHelper(_classPrivateFieldGet(_subs, this).values()),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var sub = _step2.value;
          func(sub.subscriber);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }
    /**
     *  Sub-classes may override this to customize subscription
     *  implementations.
     */
  }, {
    key: "_getSubscriber",
    value: function _getSubscriber(sub) {
      switch (sub.type) {
        case "debug":
        case "error":
        case "network":
          return new UnmanagedSubscriber(sub.type);
        case "block":
          {
            var subscriber = new subscriber_polling_js_1.PollingBlockSubscriber(this);
            subscriber.pollingInterval = this.pollingInterval;
            return subscriber;
          }
        case "safe":
        case "finalized":
          return new subscriber_polling_js_1.PollingBlockTagSubscriber(this, sub.type);
        case "event":
          return new subscriber_polling_js_1.PollingEventSubscriber(this, sub.filter);
        case "transaction":
          return new subscriber_polling_js_1.PollingTransactionSubscriber(this, sub.hash);
        case "orphan":
          return new subscriber_polling_js_1.PollingOrphanSubscriber(this, sub.filter);
      }
      throw new Error("unsupported event: ".concat(sub.type));
    }
    /**
     *  If a [[Subscriber]] fails and needs to replace itself, this
     *  method may be used.
     *
     *  For example, this is used for providers when using the
     *  ``eth_getFilterChanges`` method, which can return null if state
     *  filters are not supported by the backend, allowing the Subscriber
     *  to swap in a [[PollingEventSubscriber]].
     */
  }, {
    key: "_recoverSubscriber",
    value: function _recoverSubscriber(oldSub, newSub) {
      var _iterator3 = _createForOfIteratorHelper(_classPrivateFieldGet(_subs, this).values()),
        _step3;
      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var sub = _step3.value;
          if (sub.subscriber === oldSub) {
            if (sub.started) {
              sub.subscriber.stop();
            }
            sub.subscriber = newSub;
            if (sub.started) {
              newSub.start();
            }
            if (_classPrivateFieldGet(_pausedState, this) != null) {
              newSub.pause(_classPrivateFieldGet(_pausedState, this));
            }
            break;
          }
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
    }
  }, {
    key: "on",
    value: function () {
      var _on = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee33(event, listener) {
        var sub;
        return _regeneratorRuntime().wrap(function _callee33$(_context33) {
          while (1) switch (_context33.prev = _context33.next) {
            case 0:
              _context33.next = 2;
              return _assertClassBrand(_AbstractProvider_brand, this, _getSub).call(this, event);
            case 2:
              sub = _context33.sent;
              sub.listeners.push({
                listener: listener,
                once: false
              });
              if (!sub.started) {
                sub.subscriber.start();
                sub.started = true;
                if (_classPrivateFieldGet(_pausedState, this) != null) {
                  sub.subscriber.pause(_classPrivateFieldGet(_pausedState, this));
                }
              }
              return _context33.abrupt("return", this);
            case 6:
            case "end":
              return _context33.stop();
          }
        }, _callee33, this);
      }));
      function on(_x36, _x37) {
        return _on.apply(this, arguments);
      }
      return on;
    }()
  }, {
    key: "once",
    value: function () {
      var _once = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee34(event, listener) {
        var sub;
        return _regeneratorRuntime().wrap(function _callee34$(_context34) {
          while (1) switch (_context34.prev = _context34.next) {
            case 0:
              _context34.next = 2;
              return _assertClassBrand(_AbstractProvider_brand, this, _getSub).call(this, event);
            case 2:
              sub = _context34.sent;
              sub.listeners.push({
                listener: listener,
                once: true
              });
              if (!sub.started) {
                sub.subscriber.start();
                sub.started = true;
                if (_classPrivateFieldGet(_pausedState, this) != null) {
                  sub.subscriber.pause(_classPrivateFieldGet(_pausedState, this));
                }
              }
              return _context34.abrupt("return", this);
            case 6:
            case "end":
              return _context34.stop();
          }
        }, _callee34, this);
      }));
      function once(_x38, _x39) {
        return _once.apply(this, arguments);
      }
      return once;
    }()
  }, {
    key: "emit",
    value: function () {
      var _emit = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee35(event) {
        var _this8 = this;
        var _len,
          args,
          _key,
          sub,
          count,
          _args35 = arguments;
        return _regeneratorRuntime().wrap(function _callee35$(_context35) {
          while (1) switch (_context35.prev = _context35.next) {
            case 0:
              for (_len = _args35.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = _args35[_key];
              }
              _context35.next = 3;
              return _assertClassBrand(_AbstractProvider_brand, this, _hasSub).call(this, event, args);
            case 3:
              sub = _context35.sent;
              if (!(!sub || sub.listeners.length === 0)) {
                _context35.next = 6;
                break;
              }
              return _context35.abrupt("return", false);
            case 6:
              ;
              count = sub.listeners.length;
              sub.listeners = sub.listeners.filter(function (_ref10) {
                var listener = _ref10.listener,
                  once = _ref10.once;
                var payload = new index_js_6.EventPayload(_this8, once ? null : listener, event);
                try {
                  listener.call.apply(listener, [_this8].concat(args, [payload]));
                } catch (error) {}
                return !once;
              });
              if (sub.listeners.length === 0) {
                if (sub.started) {
                  sub.subscriber.stop();
                }
                _classPrivateFieldGet(_subs, this)["delete"](sub.tag);
              }
              return _context35.abrupt("return", count > 0);
            case 11:
            case "end":
              return _context35.stop();
          }
        }, _callee35, this);
      }));
      function emit(_x40) {
        return _emit.apply(this, arguments);
      }
      return emit;
    }()
  }, {
    key: "listenerCount",
    value: function () {
      var _listenerCount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee36(event) {
        var sub, total, _iterator4, _step4, listeners;
        return _regeneratorRuntime().wrap(function _callee36$(_context36) {
          while (1) switch (_context36.prev = _context36.next) {
            case 0:
              if (!event) {
                _context36.next = 7;
                break;
              }
              _context36.next = 3;
              return _assertClassBrand(_AbstractProvider_brand, this, _hasSub).call(this, event);
            case 3:
              sub = _context36.sent;
              if (sub) {
                _context36.next = 6;
                break;
              }
              return _context36.abrupt("return", 0);
            case 6:
              return _context36.abrupt("return", sub.listeners.length);
            case 7:
              total = 0;
              _iterator4 = _createForOfIteratorHelper(_classPrivateFieldGet(_subs, this).values());
              try {
                for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                  listeners = _step4.value.listeners;
                  total += listeners.length;
                }
              } catch (err) {
                _iterator4.e(err);
              } finally {
                _iterator4.f();
              }
              return _context36.abrupt("return", total);
            case 11:
            case "end":
              return _context36.stop();
          }
        }, _callee36, this);
      }));
      function listenerCount(_x41) {
        return _listenerCount.apply(this, arguments);
      }
      return listenerCount;
    }()
  }, {
    key: "listeners",
    value: function () {
      var _listeners = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee37(event) {
        var sub, result, _iterator5, _step5, _listeners2;
        return _regeneratorRuntime().wrap(function _callee37$(_context37) {
          while (1) switch (_context37.prev = _context37.next) {
            case 0:
              if (!event) {
                _context37.next = 7;
                break;
              }
              _context37.next = 3;
              return _assertClassBrand(_AbstractProvider_brand, this, _hasSub).call(this, event);
            case 3:
              sub = _context37.sent;
              if (sub) {
                _context37.next = 6;
                break;
              }
              return _context37.abrupt("return", []);
            case 6:
              return _context37.abrupt("return", sub.listeners.map(function (_ref11) {
                var listener = _ref11.listener;
                return listener;
              }));
            case 7:
              result = [];
              _iterator5 = _createForOfIteratorHelper(_classPrivateFieldGet(_subs, this).values());
              try {
                for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
                  _listeners2 = _step5.value.listeners;
                  result = result.concat(_listeners2.map(function (_ref12) {
                    var listener = _ref12.listener;
                    return listener;
                  }));
                }
              } catch (err) {
                _iterator5.e(err);
              } finally {
                _iterator5.f();
              }
              return _context37.abrupt("return", result);
            case 11:
            case "end":
              return _context37.stop();
          }
        }, _callee37, this);
      }));
      function listeners(_x42) {
        return _listeners.apply(this, arguments);
      }
      return listeners;
    }()
  }, {
    key: "off",
    value: function () {
      var _off = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee38(event, listener) {
        var sub, index;
        return _regeneratorRuntime().wrap(function _callee38$(_context38) {
          while (1) switch (_context38.prev = _context38.next) {
            case 0:
              _context38.next = 2;
              return _assertClassBrand(_AbstractProvider_brand, this, _hasSub).call(this, event);
            case 2:
              sub = _context38.sent;
              if (sub) {
                _context38.next = 5;
                break;
              }
              return _context38.abrupt("return", this);
            case 5:
              if (listener) {
                index = sub.listeners.map(function (_ref13) {
                  var listener = _ref13.listener;
                  return listener;
                }).indexOf(listener);
                if (index >= 0) {
                  sub.listeners.splice(index, 1);
                }
              }
              if (!listener || sub.listeners.length === 0) {
                if (sub.started) {
                  sub.subscriber.stop();
                }
                _classPrivateFieldGet(_subs, this)["delete"](sub.tag);
              }
              return _context38.abrupt("return", this);
            case 8:
            case "end":
              return _context38.stop();
          }
        }, _callee38, this);
      }));
      function off(_x43, _x44) {
        return _off.apply(this, arguments);
      }
      return off;
    }()
  }, {
    key: "removeAllListeners",
    value: function () {
      var _removeAllListeners = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee39(event) {
        var _yield$_assertClassBr, tag, started, subscriber, _iterator6, _step6, _step6$value, _tag, _step6$value$, _started, _subscriber;
        return _regeneratorRuntime().wrap(function _callee39$(_context39) {
          while (1) switch (_context39.prev = _context39.next) {
            case 0:
              if (!event) {
                _context39.next = 11;
                break;
              }
              _context39.next = 3;
              return _assertClassBrand(_AbstractProvider_brand, this, _getSub).call(this, event);
            case 3:
              _yield$_assertClassBr = _context39.sent;
              tag = _yield$_assertClassBr.tag;
              started = _yield$_assertClassBr.started;
              subscriber = _yield$_assertClassBr.subscriber;
              if (started) {
                subscriber.stop();
              }
              _classPrivateFieldGet(_subs, this)["delete"](tag);
              _context39.next = 13;
              break;
            case 11:
              _iterator6 = _createForOfIteratorHelper(_classPrivateFieldGet(_subs, this));
              try {
                for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
                  _step6$value = _slicedToArray(_step6.value, 2), _tag = _step6$value[0], _step6$value$ = _step6$value[1], _started = _step6$value$.started, _subscriber = _step6$value$.subscriber;
                  if (_started) {
                    _subscriber.stop();
                  }
                  _classPrivateFieldGet(_subs, this)["delete"](_tag);
                }
              } catch (err) {
                _iterator6.e(err);
              } finally {
                _iterator6.f();
              }
            case 13:
              return _context39.abrupt("return", this);
            case 14:
            case "end":
              return _context39.stop();
          }
        }, _callee39, this);
      }));
      function removeAllListeners(_x45) {
        return _removeAllListeners.apply(this, arguments);
      }
      return removeAllListeners;
    }() // Alias for "on"
  }, {
    key: "addListener",
    value: function () {
      var _addListener = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee40(event, listener) {
        return _regeneratorRuntime().wrap(function _callee40$(_context40) {
          while (1) switch (_context40.prev = _context40.next) {
            case 0:
              _context40.next = 2;
              return this.on(event, listener);
            case 2:
              return _context40.abrupt("return", _context40.sent);
            case 3:
            case "end":
              return _context40.stop();
          }
        }, _callee40, this);
      }));
      function addListener(_x46, _x47) {
        return _addListener.apply(this, arguments);
      }
      return addListener;
    }() // Alias for "off"
  }, {
    key: "removeListener",
    value: function () {
      var _removeListener = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee41(event, listener) {
        return _regeneratorRuntime().wrap(function _callee41$(_context41) {
          while (1) switch (_context41.prev = _context41.next) {
            case 0:
              return _context41.abrupt("return", this.off(event, listener));
            case 1:
            case "end":
              return _context41.stop();
          }
        }, _callee41, this);
      }));
      function removeListener(_x48, _x49) {
        return _removeListener.apply(this, arguments);
      }
      return removeListener;
    }()
    /**
     *  If this provider has been destroyed using the [[destroy]] method.
     *
     *  Once destroyed, all resources are reclaimed, internal event loops
     *  and timers are cleaned up and no further requests may be sent to
     *  the provider.
     */
  }, {
    key: "destroyed",
    get: function get() {
      return _classPrivateFieldGet(_destroyed, this);
    }
    /**
     *  Sub-classes may use this to shutdown any sockets or release their
     *  resources and reject any pending requests.
     *
     *  Sub-classes **must** call ``super.destroy()``.
     */
  }, {
    key: "destroy",
    value: function destroy() {
      // Stop all listeners
      this.removeAllListeners();
      // Shut down all tiemrs
      var _iterator7 = _createForOfIteratorHelper(_classPrivateFieldGet(_timers, this).keys()),
        _step7;
      try {
        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
          var timerId = _step7.value;
          this._clearTimeout(timerId);
        }
      } catch (err) {
        _iterator7.e(err);
      } finally {
        _iterator7.f();
      }
      _classPrivateFieldSet(_destroyed, this, true);
    }
    /**
     *  Whether the provider is currently paused.
     *
     *  A paused provider will not emit any events, and generally should
     *  not make any requests to the network, but that is up to sub-classes
     *  to manage.
     *
     *  Setting ``paused = true`` is identical to calling ``.pause(false)``,
     *  which will buffer any events that occur while paused until the
     *  provider is unpaused.
     */
  }, {
    key: "paused",
    get: function get() {
      return _classPrivateFieldGet(_pausedState, this) != null;
    },
    set: function set(pause) {
      if (!!pause === this.paused) {
        return;
      }
      if (this.paused) {
        this.resume();
      } else {
        this.pause(false);
      }
    }
    /**
     *  Pause the provider. If %%dropWhilePaused%%, any events that occur
     *  while paused are dropped, otherwise all events will be emitted once
     *  the provider is unpaused.
     */
  }, {
    key: "pause",
    value: function pause(dropWhilePaused) {
      _classPrivateFieldSet(_lastBlockNumber, this, -1);
      if (_classPrivateFieldGet(_pausedState, this) != null) {
        if (_classPrivateFieldGet(_pausedState, this) == !!dropWhilePaused) {
          return;
        }
        (0, index_js_6.assert)(false, "cannot change pause type; resume first", "UNSUPPORTED_OPERATION", {
          operation: "pause"
        });
      }
      this._forEachSubscriber(function (s) {
        return s.pause(dropWhilePaused);
      });
      _classPrivateFieldSet(_pausedState, this, !!dropWhilePaused);
      var _iterator8 = _createForOfIteratorHelper(_classPrivateFieldGet(_timers, this).values()),
        _step8;
      try {
        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
          var timer = _step8.value;
          // Clear the timer
          if (timer.timer) {
            clearTimeout(timer.timer);
          }
          // Remaining time needed for when we become unpaused
          timer.time = getTime() - timer.time;
        }
      } catch (err) {
        _iterator8.e(err);
      } finally {
        _iterator8.f();
      }
    }
    /**
     *  Resume the provider.
     */
  }, {
    key: "resume",
    value: function resume() {
      if (_classPrivateFieldGet(_pausedState, this) == null) {
        return;
      }
      this._forEachSubscriber(function (s) {
        return s.resume();
      });
      _classPrivateFieldSet(_pausedState, this, null);
      var _iterator9 = _createForOfIteratorHelper(_classPrivateFieldGet(_timers, this).values()),
        _step9;
      try {
        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
          var timer = _step9.value;
          // Remaining time when we were paused
          var timeout = timer.time;
          if (timeout < 0) {
            timeout = 0;
          }
          // Start time (in cause paused, so we con compute remaininf time)
          timer.time = getTime();
          // Start the timer
          setTimeout(timer.func, timeout);
        }
      } catch (err) {
        _iterator9.e(err);
      } finally {
        _iterator9.f();
      }
    }
  }]);
}();
function _perform(_x50) {
  return _perform3.apply(this, arguments);
}
function _perform3() {
  _perform3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee44(req) {
    var _this9 = this;
    var timeout, tag, perform;
    return _regeneratorRuntime().wrap(function _callee44$(_context44) {
      while (1) switch (_context44.prev = _context44.next) {
        case 0:
          timeout = _classPrivateFieldGet(_options, this).cacheTimeout; // Caching disabled
          if (!(timeout < 0)) {
            _context44.next = 5;
            break;
          }
          _context44.next = 4;
          return this._perform(req);
        case 4:
          return _context44.abrupt("return", _context44.sent);
        case 5:
          // Create a tag
          tag = getTag(req.method, req);
          perform = _classPrivateFieldGet(_performCache, this).get(tag);
          if (!perform) {
            perform = this._perform(req);
            _classPrivateFieldGet(_performCache, this).set(tag, perform);
            setTimeout(function () {
              if (_classPrivateFieldGet(_performCache, _this9).get(tag) === perform) {
                _classPrivateFieldGet(_performCache, _this9)["delete"](tag);
              }
            }, timeout);
          }
          _context44.next = 10;
          return perform;
        case 10:
          return _context44.abrupt("return", _context44.sent);
        case 11:
        case "end":
          return _context44.stop();
      }
    }, _callee44, this);
  }));
  return _perform3.apply(this, arguments);
}
function _call(_x51, _x52, _x53) {
  return _call3.apply(this, arguments);
}
function _call3() {
  _call3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee45(tx, blockTag, attempt) {
    var transaction, data, txSender, ccipArgs, ccipResult, _tx2, result;
    return _regeneratorRuntime().wrap(function _callee45$(_context45) {
      while (1) switch (_context45.prev = _context45.next) {
        case 0:
          (0, index_js_6.assert)(attempt < MAX_CCIP_REDIRECTS, "CCIP read exceeded maximum redirections", "OFFCHAIN_FAULT", {
            reason: "TOO_MANY_REDIRECTS",
            transaction: Object.assign({}, tx, {
              blockTag: blockTag,
              enableCcipRead: true
            })
          });
          // This came in as a PerformActionTransaction, so to/from are safe; we can cast
          transaction = (0, provider_js_1.copyRequest)(tx);
          _context45.prev = 2;
          _context45.t0 = (0, index_js_6.hexlify);
          _context45.next = 6;
          return this._perform({
            method: "call",
            transaction: transaction,
            blockTag: blockTag
          });
        case 6:
          _context45.t1 = _context45.sent;
          return _context45.abrupt("return", (0, _context45.t0)(_context45.t1));
        case 10:
          _context45.prev = 10;
          _context45.t2 = _context45["catch"](2);
          if (!(!this.disableCcipRead && (0, index_js_6.isCallException)(_context45.t2) && _context45.t2.data && attempt >= 0 && blockTag === "latest" && transaction.to != null && (0, index_js_6.dataSlice)(_context45.t2.data, 0, 4) === "0x556f1830")) {
            _context45.next = 37;
            break;
          }
          data = _context45.t2.data;
          _context45.next = 16;
          return (0, index_js_1.resolveAddress)(transaction.to, this);
        case 16:
          txSender = _context45.sent;
          try {
            ccipArgs = parseOffchainLookup((0, index_js_6.dataSlice)(_context45.t2.data, 4));
          } catch (error) {
            (0, index_js_6.assert)(false, error.message, "OFFCHAIN_FAULT", {
              reason: "BAD_DATA",
              transaction: transaction,
              info: {
                data: data
              }
            });
          }
          // Check the sender of the OffchainLookup matches the transaction
          (0, index_js_6.assert)(ccipArgs.sender.toLowerCase() === txSender.toLowerCase(), "CCIP Read sender mismatch", "CALL_EXCEPTION", {
            action: "call",
            data: data,
            reason: "OffchainLookup",
            transaction: transaction,
            invocation: null,
            revert: {
              signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
              name: "OffchainLookup",
              args: ccipArgs.errorArgs
            }
          });
          _context45.next = 21;
          return this.ccipReadFetch(transaction, ccipArgs.calldata, ccipArgs.urls);
        case 21:
          ccipResult = _context45.sent;
          (0, index_js_6.assert)(ccipResult != null, "CCIP Read failed to fetch data", "OFFCHAIN_FAULT", {
            reason: "FETCH_FAILED",
            transaction: transaction,
            info: {
              data: _context45.t2.data,
              errorArgs: ccipArgs.errorArgs
            }
          });
          _tx2 = {
            to: txSender,
            data: (0, index_js_6.concat)([ccipArgs.selector, encodeBytes([ccipResult, ccipArgs.extraData])])
          };
          this.emit("debug", {
            action: "sendCcipReadCall",
            transaction: _tx2
          });
          _context45.prev = 25;
          _context45.next = 28;
          return _assertClassBrand(_AbstractProvider_brand, this, _call).call(this, _tx2, blockTag, attempt + 1);
        case 28:
          result = _context45.sent;
          this.emit("debug", {
            action: "receiveCcipReadCallResult",
            transaction: Object.assign({}, _tx2),
            result: result
          });
          return _context45.abrupt("return", result);
        case 33:
          _context45.prev = 33;
          _context45.t3 = _context45["catch"](25);
          this.emit("debug", {
            action: "receiveCcipReadCallError",
            transaction: Object.assign({}, _tx2),
            error: _context45.t3
          });
          throw _context45.t3;
        case 37:
          throw _context45.t2;
        case 38:
        case "end":
          return _context45.stop();
      }
    }, _callee45, this, [[2, 10], [25, 33]]);
  }));
  return _call3.apply(this, arguments);
}
function _checkNetwork(_x54) {
  return _checkNetwork2.apply(this, arguments);
}
function _checkNetwork2() {
  _checkNetwork2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee46(promise) {
    var _yield9, value;
    return _regeneratorRuntime().wrap(function _callee46$(_context46) {
      while (1) switch (_context46.prev = _context46.next) {
        case 0:
          _context46.next = 2;
          return (0, index_js_6.resolveProperties)({
            network: this.getNetwork(),
            value: promise
          });
        case 2:
          _yield9 = _context46.sent;
          value = _yield9.value;
          return _context46.abrupt("return", value);
        case 5:
        case "end":
          return _context46.stop();
      }
    }, _callee46, this);
  }));
  return _checkNetwork2.apply(this, arguments);
}
function _getAccountValue(_x55, _x56, _x57) {
  return _getAccountValue2.apply(this, arguments);
}
function _getAccountValue2() {
  _getAccountValue2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee47(request, _address, _blockTag) {
    var address, blockTag, _yield$Promise$all3, _yield$Promise$all4;
    return _regeneratorRuntime().wrap(function _callee47$(_context47) {
      while (1) switch (_context47.prev = _context47.next) {
        case 0:
          address = this._getAddress(_address);
          blockTag = this._getBlockTag(_blockTag);
          if (!(typeof address !== "string" || typeof blockTag !== "string")) {
            _context47.next = 9;
            break;
          }
          _context47.next = 5;
          return Promise.all([address, blockTag]);
        case 5:
          _yield$Promise$all3 = _context47.sent;
          _yield$Promise$all4 = _slicedToArray(_yield$Promise$all3, 2);
          address = _yield$Promise$all4[0];
          blockTag = _yield$Promise$all4[1];
        case 9:
          _context47.next = 11;
          return _assertClassBrand(_AbstractProvider_brand, this, _checkNetwork).call(this, _assertClassBrand(_AbstractProvider_brand, this, _perform).call(this, Object.assign(request, {
            address: address,
            blockTag: blockTag
          })));
        case 11:
          return _context47.abrupt("return", _context47.sent);
        case 12:
        case "end":
          return _context47.stop();
      }
    }, _callee47, this);
  }));
  return _getAccountValue2.apply(this, arguments);
}
function _getBlock(_x58, _x59) {
  return _getBlock3.apply(this, arguments);
}
function _getBlock3() {
  _getBlock3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee48(block, includeTransactions) {
    var blockTag;
    return _regeneratorRuntime().wrap(function _callee48$(_context48) {
      while (1) switch (_context48.prev = _context48.next) {
        case 0:
          if (!(0, index_js_6.isHexString)(block, 32)) {
            _context48.next = 4;
            break;
          }
          _context48.next = 3;
          return _assertClassBrand(_AbstractProvider_brand, this, _perform).call(this, {
            method: "getBlock",
            blockHash: block,
            includeTransactions: includeTransactions
          });
        case 3:
          return _context48.abrupt("return", _context48.sent);
        case 4:
          blockTag = this._getBlockTag(block);
          if (!(typeof blockTag !== "string")) {
            _context48.next = 9;
            break;
          }
          _context48.next = 8;
          return blockTag;
        case 8:
          blockTag = _context48.sent;
        case 9:
          _context48.next = 11;
          return _assertClassBrand(_AbstractProvider_brand, this, _perform).call(this, {
            method: "getBlock",
            blockTag: blockTag,
            includeTransactions: includeTransactions
          });
        case 11:
          return _context48.abrupt("return", _context48.sent);
        case 12:
        case "end":
          return _context48.stop();
      }
    }, _callee48, this);
  }));
  return _getBlock3.apply(this, arguments);
}
function _hasSub(_x60, _x61) {
  return _hasSub2.apply(this, arguments);
}
function _hasSub2() {
  _hasSub2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee49(event, emitArgs) {
    var sub;
    return _regeneratorRuntime().wrap(function _callee49$(_context49) {
      while (1) switch (_context49.prev = _context49.next) {
        case 0:
          _context49.next = 2;
          return getSubscription(event, this);
        case 2:
          sub = _context49.sent;
          if (!(sub.type === "event" && emitArgs && emitArgs.length > 0 && emitArgs[0].removed === true)) {
            _context49.next = 7;
            break;
          }
          _context49.next = 6;
          return getSubscription({
            orphan: "drop-log",
            log: emitArgs[0]
          }, this);
        case 6:
          sub = _context49.sent;
        case 7:
          return _context49.abrupt("return", _classPrivateFieldGet(_subs, this).get(sub.tag) || null);
        case 8:
        case "end":
          return _context49.stop();
      }
    }, _callee49, this);
  }));
  return _hasSub2.apply(this, arguments);
}
function _getSub(_x62) {
  return _getSub2.apply(this, arguments);
}
function _getSub2() {
  _getSub2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee50(event) {
    var subscription, tag, sub, subscriber, addressableMap, nameMap;
    return _regeneratorRuntime().wrap(function _callee50$(_context50) {
      while (1) switch (_context50.prev = _context50.next) {
        case 0:
          _context50.next = 2;
          return getSubscription(event, this);
        case 2:
          subscription = _context50.sent;
          // Prevent tampering with our tag in any subclass' _getSubscriber
          tag = subscription.tag;
          sub = _classPrivateFieldGet(_subs, this).get(tag);
          if (!sub) {
            subscriber = this._getSubscriber(subscription);
            addressableMap = new WeakMap();
            nameMap = new Map();
            sub = {
              subscriber: subscriber,
              tag: tag,
              addressableMap: addressableMap,
              nameMap: nameMap,
              started: false,
              listeners: []
            };
            _classPrivateFieldGet(_subs, this).set(tag, sub);
          }
          return _context50.abrupt("return", sub);
        case 7:
        case "end":
          return _context50.stop();
      }
    }, _callee50, this);
  }));
  return _getSub2.apply(this, arguments);
}
exports.AbstractProvider = AbstractProvider;
function _parseString(result, start) {
  try {
    var bytes = _parseBytes(result, start);
    if (bytes) {
      return (0, index_js_6.toUtf8String)(bytes);
    }
  } catch (error) {}
  return null;
}
function _parseBytes(result, start) {
  if (result === "0x") {
    return null;
  }
  try {
    var offset = (0, index_js_6.getNumber)((0, index_js_6.dataSlice)(result, start, start + 32));
    var length = (0, index_js_6.getNumber)((0, index_js_6.dataSlice)(result, offset, offset + 32));
    return (0, index_js_6.dataSlice)(result, offset + 32, offset + 32 + length);
  } catch (error) {}
  return null;
}
function numPad(value) {
  var result = (0, index_js_6.toBeArray)(value);
  if (result.length > 32) {
    throw new Error("internal; should not happen");
  }
  var padded = new Uint8Array(32);
  padded.set(result, 32 - result.length);
  return padded;
}
function bytesPad(value) {
  if (value.length % 32 === 0) {
    return value;
  }
  var result = new Uint8Array(Math.ceil(value.length / 32) * 32);
  result.set(value);
  return result;
}
var empty = new Uint8Array([]);
// ABI Encodes a series of (bytes, bytes, ...)
function encodeBytes(datas) {
  var result = [];
  var byteCount = 0;
  // Add place-holders for pointers as we add items
  for (var i = 0; i < datas.length; i++) {
    result.push(empty);
    byteCount += 32;
  }
  for (var _i = 0; _i < datas.length; _i++) {
    var data = (0, index_js_6.getBytes)(datas[_i]);
    // Update the bytes offset
    result[_i] = numPad(byteCount);
    // The length and padded value of data
    result.push(numPad(data.length));
    result.push(bytesPad(data));
    byteCount += 32 + Math.ceil(data.length / 32) * 32;
  }
  return (0, index_js_6.concat)(result);
}
var zeros = "0x0000000000000000000000000000000000000000000000000000000000000000";
function parseOffchainLookup(data) {
  var result = {
    sender: "",
    urls: [],
    calldata: "",
    selector: "",
    extraData: "",
    errorArgs: []
  };
  (0, index_js_6.assert)((0, index_js_6.dataLength)(data) >= 5 * 32, "insufficient OffchainLookup data", "OFFCHAIN_FAULT", {
    reason: "insufficient OffchainLookup data"
  });
  var sender = (0, index_js_6.dataSlice)(data, 0, 32);
  (0, index_js_6.assert)((0, index_js_6.dataSlice)(sender, 0, 12) === (0, index_js_6.dataSlice)(zeros, 0, 12), "corrupt OffchainLookup sender", "OFFCHAIN_FAULT", {
    reason: "corrupt OffchainLookup sender"
  });
  result.sender = (0, index_js_6.dataSlice)(sender, 12);
  // Read the URLs from the response
  try {
    var urls = [];
    var urlsOffset = (0, index_js_6.getNumber)((0, index_js_6.dataSlice)(data, 32, 64));
    var urlsLength = (0, index_js_6.getNumber)((0, index_js_6.dataSlice)(data, urlsOffset, urlsOffset + 32));
    var urlsData = (0, index_js_6.dataSlice)(data, urlsOffset + 32);
    for (var u = 0; u < urlsLength; u++) {
      var url = _parseString(urlsData, u * 32);
      if (url == null) {
        throw new Error("abort");
      }
      urls.push(url);
    }
    result.urls = urls;
  } catch (error) {
    (0, index_js_6.assert)(false, "corrupt OffchainLookup urls", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup urls"
    });
  }
  // Get the CCIP calldata to forward
  try {
    var calldata = _parseBytes(data, 64);
    if (calldata == null) {
      throw new Error("abort");
    }
    result.calldata = calldata;
  } catch (error) {
    (0, index_js_6.assert)(false, "corrupt OffchainLookup calldata", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup calldata"
    });
  }
  // Get the callbackSelector (bytes4)
  (0, index_js_6.assert)((0, index_js_6.dataSlice)(data, 100, 128) === (0, index_js_6.dataSlice)(zeros, 0, 28), "corrupt OffchainLookup callbaackSelector", "OFFCHAIN_FAULT", {
    reason: "corrupt OffchainLookup callbaackSelector"
  });
  result.selector = (0, index_js_6.dataSlice)(data, 96, 100);
  // Get the extra data to send back to the contract as context
  try {
    var extraData = _parseBytes(data, 128);
    if (extraData == null) {
      throw new Error("abort");
    }
    result.extraData = extraData;
  } catch (error) {
    (0, index_js_6.assert)(false, "corrupt OffchainLookup extraData", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup extraData"
    });
  }
  result.errorArgs = "sender,urls,calldata,selector,extraData".split(/,/).map(function (k) {
    return result[k];
  });
  return result;
}

},{"../address/index.js":207,"../constants/index.js":210,"../contract/index.js":215,"../hash/index.js":230,"../transaction/index.js":266,"../utils/index.js":276,"./ens-resolver.js":240,"./format.js":241,"./network.js":243,"./provider.js":259,"./subscriber-polling.js":262}],237:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VoidSigner = exports.AbstractSigner = void 0;
/**
 *  Generally the [[Wallet]] and [[JsonRpcSigner]] and their sub-classes
 *  are sufficent for most developers, but this is provided to
 *  fascilitate more complex Signers.
 *
 *  @_section: api/providers/abstract-signer: Subclassing Signer [abstract-signer]
 */
var index_js_1 = require("../address/index.js");
var index_js_2 = require("../transaction/index.js");
var index_js_3 = require("../utils/index.js");
var provider_js_1 = require("./provider.js");
function checkProvider(signer, operation) {
  if (signer.provider) {
    return signer.provider;
  }
  (0, index_js_3.assert)(false, "missing provider", "UNSUPPORTED_OPERATION", {
    operation: operation
  });
}
function populate(_x, _x2) {
  return _populate.apply(this, arguments);
}
/**
 *  An **AbstractSigner** includes most of teh functionality required
 *  to get a [[Signer]] working as expected, but requires a few
 *  Signer-specific methods be overridden.
 *
 */
function _populate() {
  _populate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(signer, tx) {
    var pop, from;
    return _regeneratorRuntime().wrap(function _callee12$(_context12) {
      while (1) switch (_context12.prev = _context12.next) {
        case 0:
          pop = (0, provider_js_1.copyRequest)(tx);
          if (pop.to != null) {
            pop.to = (0, index_js_1.resolveAddress)(pop.to, signer);
          }
          if (pop.from != null) {
            from = pop.from;
            pop.from = Promise.all([signer.getAddress(), (0, index_js_1.resolveAddress)(from, signer)]).then(function (_ref) {
              var _ref2 = _slicedToArray(_ref, 2),
                address = _ref2[0],
                from = _ref2[1];
              (0, index_js_3.assertArgument)(address.toLowerCase() === from.toLowerCase(), "transaction from mismatch", "tx.from", from);
              return address;
            });
          } else {
            pop.from = signer.getAddress();
          }
          _context12.next = 5;
          return (0, index_js_3.resolveProperties)(pop);
        case 5:
          return _context12.abrupt("return", _context12.sent);
        case 6:
        case "end":
          return _context12.stop();
      }
    }, _callee12);
  }));
  return _populate.apply(this, arguments);
}
var AbstractSigner = /*#__PURE__*/function () {
  /**
   *  Creates a new Signer connected to %%provider%%.
   */
  function AbstractSigner(provider) {
    _classCallCheck(this, AbstractSigner);
    /**
     *  The provider this signer is connected to.
     */
    _defineProperty(this, "provider", void 0);
    (0, index_js_3.defineProperties)(this, {
      provider: provider || null
    });
  }
  return _createClass(AbstractSigner, [{
    key: "getNonce",
    value: function () {
      var _getNonce = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(blockTag) {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.t0 = checkProvider(this, "getTransactionCount");
              _context.next = 3;
              return this.getAddress();
            case 3:
              _context.t1 = _context.sent;
              _context.t2 = blockTag;
              return _context.abrupt("return", _context.t0.getTransactionCount.call(_context.t0, _context.t1, _context.t2));
            case 6:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function getNonce(_x3) {
        return _getNonce.apply(this, arguments);
      }
      return getNonce;
    }()
  }, {
    key: "populateCall",
    value: function () {
      var _populateCall = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(tx) {
        var pop;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return populate(this, tx);
            case 2:
              pop = _context2.sent;
              return _context2.abrupt("return", pop);
            case 4:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function populateCall(_x4) {
        return _populateCall.apply(this, arguments);
      }
      return populateCall;
    }()
  }, {
    key: "populateTransaction",
    value: function () {
      var _populateTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(tx) {
        var provider, pop, network, chainId, hasEip1559, feeData, _feeData, gasPrice;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              provider = checkProvider(this, "populateTransaction");
              _context3.next = 3;
              return populate(this, tx);
            case 3:
              pop = _context3.sent;
              if (!(pop.nonce == null)) {
                _context3.next = 8;
                break;
              }
              _context3.next = 7;
              return this.getNonce("pending");
            case 7:
              pop.nonce = _context3.sent;
            case 8:
              if (!(pop.gasLimit == null)) {
                _context3.next = 12;
                break;
              }
              _context3.next = 11;
              return this.estimateGas(pop);
            case 11:
              pop.gasLimit = _context3.sent;
            case 12:
              _context3.next = 14;
              return this.provider.getNetwork();
            case 14:
              network = _context3.sent;
              if (pop.chainId != null) {
                chainId = (0, index_js_3.getBigInt)(pop.chainId);
                (0, index_js_3.assertArgument)(chainId === network.chainId, "transaction chainId mismatch", "tx.chainId", tx.chainId);
              } else {
                pop.chainId = network.chainId;
              }
              // Do not allow mixing pre-eip-1559 and eip-1559 properties
              hasEip1559 = pop.maxFeePerGas != null || pop.maxPriorityFeePerGas != null;
              if (pop.gasPrice != null && (pop.type === 2 || hasEip1559)) {
                (0, index_js_3.assertArgument)(false, "eip-1559 transaction do not support gasPrice", "tx", tx);
              } else if ((pop.type === 0 || pop.type === 1) && hasEip1559) {
                (0, index_js_3.assertArgument)(false, "pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "tx", tx);
              }
              if (!((pop.type === 2 || pop.type == null) && pop.maxFeePerGas != null && pop.maxPriorityFeePerGas != null)) {
                _context3.next = 22;
                break;
              }
              // Fully-formed EIP-1559 transaction (skip getFeeData)
              pop.type = 2;
              _context3.next = 34;
              break;
            case 22:
              if (!(pop.type === 0 || pop.type === 1)) {
                _context3.next = 30;
                break;
              }
              _context3.next = 25;
              return provider.getFeeData();
            case 25:
              feeData = _context3.sent;
              (0, index_js_3.assert)(feeData.gasPrice != null, "network does not support gasPrice", "UNSUPPORTED_OPERATION", {
                operation: "getGasPrice"
              });
              // Populate missing gasPrice
              if (pop.gasPrice == null) {
                pop.gasPrice = feeData.gasPrice;
              }
              _context3.next = 34;
              break;
            case 30:
              _context3.next = 32;
              return provider.getFeeData();
            case 32:
              _feeData = _context3.sent;
              if (pop.type == null) {
                // We need to auto-detect the intended type of this transaction...
                if (_feeData.maxFeePerGas != null && _feeData.maxPriorityFeePerGas != null) {
                  // The network supports EIP-1559!
                  // Upgrade transaction from null to eip-1559
                  pop.type = 2;
                  if (pop.gasPrice != null) {
                    // Using legacy gasPrice property on an eip-1559 network,
                    // so use gasPrice as both fee properties
                    gasPrice = pop.gasPrice;
                    delete pop.gasPrice;
                    pop.maxFeePerGas = gasPrice;
                    pop.maxPriorityFeePerGas = gasPrice;
                  } else {
                    // Populate missing fee data
                    if (pop.maxFeePerGas == null) {
                      pop.maxFeePerGas = _feeData.maxFeePerGas;
                    }
                    if (pop.maxPriorityFeePerGas == null) {
                      pop.maxPriorityFeePerGas = _feeData.maxPriorityFeePerGas;
                    }
                  }
                } else if (_feeData.gasPrice != null) {
                  // Network doesn't support EIP-1559...
                  // ...but they are trying to use EIP-1559 properties
                  (0, index_js_3.assert)(!hasEip1559, "network does not support EIP-1559", "UNSUPPORTED_OPERATION", {
                    operation: "populateTransaction"
                  });
                  // Populate missing fee data
                  if (pop.gasPrice == null) {
                    pop.gasPrice = _feeData.gasPrice;
                  }
                  // Explicitly set untyped transaction to legacy
                  // @TODO: Maybe this shold allow type 1?
                  pop.type = 0;
                } else {
                  // getFeeData has failed us.
                  (0, index_js_3.assert)(false, "failed to get consistent fee data", "UNSUPPORTED_OPERATION", {
                    operation: "signer.getFeeData"
                  });
                }
              } else if (pop.type === 2 || pop.type === 3) {
                // Explicitly using EIP-1559 or EIP-4844
                // Populate missing fee data
                if (pop.maxFeePerGas == null) {
                  pop.maxFeePerGas = _feeData.maxFeePerGas;
                }
                if (pop.maxPriorityFeePerGas == null) {
                  pop.maxPriorityFeePerGas = _feeData.maxPriorityFeePerGas;
                }
              }
            case 34:
              _context3.next = 36;
              return (0, index_js_3.resolveProperties)(pop);
            case 36:
              return _context3.abrupt("return", _context3.sent);
            case 37:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function populateTransaction(_x5) {
        return _populateTransaction.apply(this, arguments);
      }
      return populateTransaction;
    }()
  }, {
    key: "estimateGas",
    value: function () {
      var _estimateGas = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(tx) {
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              _context4.t0 = checkProvider(this, "estimateGas");
              _context4.next = 3;
              return this.populateCall(tx);
            case 3:
              _context4.t1 = _context4.sent;
              return _context4.abrupt("return", _context4.t0.estimateGas.call(_context4.t0, _context4.t1));
            case 5:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));
      function estimateGas(_x6) {
        return _estimateGas.apply(this, arguments);
      }
      return estimateGas;
    }()
  }, {
    key: "call",
    value: function () {
      var _call = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(tx) {
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              _context5.t0 = checkProvider(this, "call");
              _context5.next = 3;
              return this.populateCall(tx);
            case 3:
              _context5.t1 = _context5.sent;
              return _context5.abrupt("return", _context5.t0.call.call(_context5.t0, _context5.t1));
            case 5:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this);
      }));
      function call(_x7) {
        return _call.apply(this, arguments);
      }
      return call;
    }()
  }, {
    key: "resolveName",
    value: function () {
      var _resolveName = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(name) {
        var provider;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              provider = checkProvider(this, "resolveName");
              _context6.next = 3;
              return provider.resolveName(name);
            case 3:
              return _context6.abrupt("return", _context6.sent);
            case 4:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this);
      }));
      function resolveName(_x8) {
        return _resolveName.apply(this, arguments);
      }
      return resolveName;
    }()
  }, {
    key: "sendTransaction",
    value: function () {
      var _sendTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(tx) {
        var provider, pop, txObj;
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              provider = checkProvider(this, "sendTransaction");
              _context7.next = 3;
              return this.populateTransaction(tx);
            case 3:
              pop = _context7.sent;
              delete pop.from;
              txObj = index_js_2.Transaction.from(pop);
              _context7.t0 = provider;
              _context7.next = 9;
              return this.signTransaction(txObj);
            case 9:
              _context7.t1 = _context7.sent;
              _context7.next = 12;
              return _context7.t0.broadcastTransaction.call(_context7.t0, _context7.t1);
            case 12:
              return _context7.abrupt("return", _context7.sent);
            case 13:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this);
      }));
      function sendTransaction(_x9) {
        return _sendTransaction.apply(this, arguments);
      }
      return sendTransaction;
    }()
  }]);
}();
exports.AbstractSigner = AbstractSigner;
/**
 *  A **VoidSigner** is a class deisgned to allow an address to be used
 *  in any API which accepts a Signer, but for which there are no
 *  credentials available to perform any actual signing.
 *
 *  This for example allow impersonating an account for the purpose of
 *  static calls or estimating gas, but does not allow sending transactions.
 */
var _VoidSigner_brand = /*#__PURE__*/new WeakSet();
var VoidSigner = /*#__PURE__*/function (_AbstractSigner2) {
  /**
   *  Creates a new **VoidSigner** with %%address%% attached to
   *  %%provider%%.
   */
  function VoidSigner(address, provider) {
    var _this;
    _classCallCheck(this, VoidSigner);
    _this = _callSuper(this, VoidSigner, [provider]);
    _classPrivateMethodInitSpec(_this, _VoidSigner_brand);
    /**
     *  The signer address.
     */
    _defineProperty(_this, "address", void 0);
    (0, index_js_3.defineProperties)(_this, {
      address: address
    });
    return _this;
  }
  _inherits(VoidSigner, _AbstractSigner2);
  return _createClass(VoidSigner, [{
    key: "getAddress",
    value: function () {
      var _getAddress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {
        return _regeneratorRuntime().wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              return _context8.abrupt("return", this.address);
            case 1:
            case "end":
              return _context8.stop();
          }
        }, _callee8, this);
      }));
      function getAddress() {
        return _getAddress.apply(this, arguments);
      }
      return getAddress;
    }()
  }, {
    key: "connect",
    value: function connect(provider) {
      return new VoidSigner(this.address, provider);
    }
  }, {
    key: "signTransaction",
    value: function () {
      var _signTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(tx) {
        return _regeneratorRuntime().wrap(function _callee9$(_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
              _assertClassBrand(_VoidSigner_brand, this, _throwUnsupported).call(this, "transactions", "signTransaction");
            case 1:
            case "end":
              return _context9.stop();
          }
        }, _callee9, this);
      }));
      function signTransaction(_x10) {
        return _signTransaction.apply(this, arguments);
      }
      return signTransaction;
    }()
  }, {
    key: "signMessage",
    value: function () {
      var _signMessage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(message) {
        return _regeneratorRuntime().wrap(function _callee10$(_context10) {
          while (1) switch (_context10.prev = _context10.next) {
            case 0:
              _assertClassBrand(_VoidSigner_brand, this, _throwUnsupported).call(this, "messages", "signMessage");
            case 1:
            case "end":
              return _context10.stop();
          }
        }, _callee10, this);
      }));
      function signMessage(_x11) {
        return _signMessage.apply(this, arguments);
      }
      return signMessage;
    }()
  }, {
    key: "signTypedData",
    value: function () {
      var _signTypedData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(domain, types, value) {
        return _regeneratorRuntime().wrap(function _callee11$(_context11) {
          while (1) switch (_context11.prev = _context11.next) {
            case 0:
              _assertClassBrand(_VoidSigner_brand, this, _throwUnsupported).call(this, "typed-data", "signTypedData");
            case 1:
            case "end":
              return _context11.stop();
          }
        }, _callee11, this);
      }));
      function signTypedData(_x12, _x13, _x14) {
        return _signTypedData.apply(this, arguments);
      }
      return signTypedData;
    }()
  }]);
}(AbstractSigner);
function _throwUnsupported(suffix, operation) {
  (0, index_js_3.assert)(false, "VoidSigner cannot sign ".concat(suffix), "UNSUPPORTED_OPERATION", {
    operation: operation
  });
}
exports.VoidSigner = VoidSigner;

},{"../address/index.js":207,"../transaction/index.js":266,"../utils/index.js":276,"./provider.js":259}],238:[function(require,module,exports){
"use strict";

/**
 *  There are many awesome community services that provide Ethereum
 *  nodes both for developers just starting out and for large-scale
 *  communities.
 *
 *  @_section: api/providers/thirdparty: Community Providers  [thirdparty]
 */
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.showThrottleMessage = void 0;
// Show the throttle message only once per service
var shown = new Set();
/**
 *  Displays a warning in tht console when the community resource is
 *  being used too heavily by the app, recommending the developer
 *  acquire their own credentials instead of using the community
 *  credentials.
 *
 *  The notification will only occur once per service.
 */
function showThrottleMessage(service) {
  if (shown.has(service)) {
    return;
  }
  shown.add(service);
  console.log("========= NOTICE =========");
  console.log("Request-Rate Exceeded for ".concat(service, " (this message will not be repeated)"));
  console.log("");
  console.log("The default API keys for each service are provided as a highly-throttled,");
  console.log("community resource for low-traffic projects and early prototyping.");
  console.log("");
  console.log("While your application will continue to function, we highly recommended");
  console.log("signing up for your own API keys to improve performance, increase your");
  console.log("request rate/limit and enable other perks, such as metrics and advanced APIs.");
  console.log("");
  console.log("For more details: https:/\/docs.ethers.org/api-keys/");
  console.log("==========================");
}
exports.showThrottleMessage = showThrottleMessage;

},{}],239:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDefaultProvider = void 0;
var index_js_1 = require("../utils/index.js");
var provider_ankr_js_1 = require("./provider-ankr.js");
var provider_alchemy_js_1 = require("./provider-alchemy.js");
var provider_chainstack_js_1 = require("./provider-chainstack.js");
var provider_cloudflare_js_1 = require("./provider-cloudflare.js");
var provider_etherscan_js_1 = require("./provider-etherscan.js");
var provider_infura_js_1 = require("./provider-infura.js");
//import { PocketProvider } from "./provider-pocket.js";
var provider_quicknode_js_1 = require("./provider-quicknode.js");
var provider_fallback_js_1 = require("./provider-fallback.js");
var provider_jsonrpc_js_1 = require("./provider-jsonrpc.js");
var network_js_1 = require("./network.js");
var provider_websocket_js_1 = require("./provider-websocket.js");
function isWebSocketLike(value) {
  return value && typeof value.send === "function" && typeof value.close === "function";
}
var Testnets = "goerli kovan sepolia classicKotti optimism-goerli arbitrum-goerli matic-mumbai bnbt".split(" ");
/**
 *  Returns a default provider for %%network%%.
 *
 *  If %%network%% is a [[WebSocketLike]] or string that begins with
 *  ``"ws:"`` or ``"wss:"``, a [[WebSocketProvider]] is returned backed
 *  by that WebSocket or URL.
 *
 *  If %%network%% is a string that begins with ``"HTTP:"`` or ``"HTTPS:"``,
 *  a [[JsonRpcProvider]] is returned connected to that URL.
 *
 *  Otherwise, a default provider is created backed by well-known public
 *  Web3 backends (such as [[link-infura]]) using community-provided API
 *  keys.
 *
 *  The %%options%% allows specifying custom API keys per backend (setting
 *  an API key to ``"-"`` will omit that provider) and ``options.exclusive``
 *  can be set to either a backend name or and array of backend names, which
 *  will whitelist **only** those backends.
 *
 *  Current backend strings supported are:
 *  - ``"alchemy"``
 *  - ``"ankr"``
 *  - ``"cloudflare"``
 *  - ``"chainstack"``
 *  - ``"etherscan"``
 *  - ``"infura"``
 *  - ``"publicPolygon"``
 *  - ``"quicknode"``
 *
 *  @example:
 *    // Connect to a local Geth node
 *    provider = getDefaultProvider("http://localhost:8545/");
 *
 *    // Connect to Ethereum mainnet with any current and future
 *    // third-party services available
 *    provider = getDefaultProvider("mainnet");
 *
 *    // Connect to Polygon, but only allow Etherscan and
 *    // INFURA and use "MY_API_KEY" in calls to Etherscan.
 *    provider = getDefaultProvider("matic", {
 *      etherscan: "MY_API_KEY",
 *      exclusive: [ "etherscan", "infura" ]
 *    });
 */
function getDefaultProvider(network, options) {
  if (options == null) {
    options = {};
  }
  var allowService = function allowService(name) {
    if (options[name] === "-") {
      return false;
    }
    if (typeof options.exclusive === "string") {
      return name === options.exclusive;
    }
    if (Array.isArray(options.exclusive)) {
      return options.exclusive.indexOf(name) !== -1;
    }
    return true;
  };
  if (typeof network === "string" && network.match(/^https?:/)) {
    return new provider_jsonrpc_js_1.JsonRpcProvider(network);
  }
  if (typeof network === "string" && network.match(/^wss?:/) || isWebSocketLike(network)) {
    return new provider_websocket_js_1.WebSocketProvider(network);
  }
  // Get the network and name, if possible
  var staticNetwork = null;
  try {
    staticNetwork = network_js_1.Network.from(network);
  } catch (error) {}
  var providers = [];
  if (allowService("publicPolygon") && staticNetwork) {
    if (staticNetwork.name === "matic") {
      providers.push(new provider_jsonrpc_js_1.JsonRpcProvider("https:/\/polygon-rpc.com/", staticNetwork, {
        staticNetwork: staticNetwork
      }));
    } else if (staticNetwork.name === "matic-amoy") {
      providers.push(new provider_jsonrpc_js_1.JsonRpcProvider("https:/\/rpc-amoy.polygon.technology/", staticNetwork, {
        staticNetwork: staticNetwork
      }));
    }
  }
  if (allowService("alchemy")) {
    try {
      providers.push(new provider_alchemy_js_1.AlchemyProvider(network, options.alchemy));
    } catch (error) {}
  }
  if (allowService("ankr") && options.ankr != null) {
    try {
      providers.push(new provider_ankr_js_1.AnkrProvider(network, options.ankr));
    } catch (error) {}
  }
  if (allowService("chainstack")) {
    try {
      providers.push(new provider_chainstack_js_1.ChainstackProvider(network, options.chainstack));
    } catch (error) {}
  }
  if (allowService("cloudflare")) {
    try {
      providers.push(new provider_cloudflare_js_1.CloudflareProvider(network));
    } catch (error) {}
  }
  if (allowService("etherscan")) {
    try {
      providers.push(new provider_etherscan_js_1.EtherscanProvider(network, options.etherscan));
    } catch (error) {}
  }
  if (allowService("infura")) {
    try {
      var projectId = options.infura;
      var projectSecret = undefined;
      if (_typeof(projectId) === "object") {
        projectSecret = projectId.projectSecret;
        projectId = projectId.projectId;
      }
      providers.push(new provider_infura_js_1.InfuraProvider(network, projectId, projectSecret));
    } catch (error) {}
  }
  /*
      if (options.pocket !== "-") {
          try {
              let appId = options.pocket;
              let secretKey: undefined | string = undefined;
              let loadBalancer: undefined | boolean = undefined;
              if (typeof(appId) === "object") {
                  loadBalancer = !!appId.loadBalancer;
                  secretKey = appId.secretKey;
                  appId = appId.appId;
              }
              providers.push(new PocketProvider(network, appId, secretKey, loadBalancer));
          } catch (error) { console.log(error); }
      }
  */
  if (allowService("quicknode")) {
    try {
      var token = options.quicknode;
      providers.push(new provider_quicknode_js_1.QuickNodeProvider(network, token));
    } catch (error) {}
  }
  (0, index_js_1.assert)(providers.length, "unsupported default network", "UNSUPPORTED_OPERATION", {
    operation: "getDefaultProvider"
  });
  // No need for a FallbackProvider
  if (providers.length === 1) {
    return providers[0];
  }
  // We use the floor because public third-party providers can be unreliable,
  // so a low number of providers with a large quorum will fail too often
  var quorum = Math.floor(providers.length / 2);
  if (quorum > 2) {
    quorum = 2;
  }
  // Testnets don't need as strong a security gaurantee and speed is
  // more useful during testing
  if (staticNetwork && Testnets.indexOf(staticNetwork.name) !== -1) {
    quorum = 1;
  }
  // Provided override qorum takes priority
  if (options && options.quorum) {
    quorum = options.quorum;
  }
  return new provider_fallback_js_1.FallbackProvider(providers, undefined, {
    quorum: quorum
  });
}
exports.getDefaultProvider = getDefaultProvider;

},{"../utils/index.js":276,"./network.js":243,"./provider-alchemy.js":245,"./provider-ankr.js":246,"./provider-chainstack.js":248,"./provider-cloudflare.js":249,"./provider-etherscan.js":250,"./provider-fallback.js":251,"./provider-infura.js":252,"./provider-jsonrpc.js":254,"./provider-quicknode.js":256,"./provider-websocket.js":258}],240:[function(require,module,exports){
"use strict";

/**
 *  ENS is a service which allows easy-to-remember names to map to
 *  network addresses.
 *
 *  @_section: api/providers/ens-resolver:ENS Resolver  [about-ens-rsolver]
 */
var _EnsResolver;
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EnsResolver = exports.BasicMulticoinProviderPlugin = exports.MulticoinProviderPlugin = void 0;
var index_js_1 = require("../address/index.js");
var index_js_2 = require("../constants/index.js");
var index_js_3 = require("../contract/index.js");
var index_js_4 = require("../hash/index.js");
var index_js_5 = require("../utils/index.js");
// @TODO: This should use the fetch-data:ipfs gateway
// Trim off the ipfs:// prefix and return the default gateway URL
function getIpfsLink(link) {
  if (link.match(/^ipfs:\/\/ipfs\//i)) {
    link = link.substring(12);
  } else if (link.match(/^ipfs:\/\//i)) {
    link = link.substring(7);
  } else {
    (0, index_js_5.assertArgument)(false, "unsupported IPFS format", "link", link);
  }
  return "https://gateway.ipfs.io/ipfs/".concat(link);
}
;
;
/**
 *  A provider plugin super-class for processing multicoin address types.
 */
var MulticoinProviderPlugin = /*#__PURE__*/function () {
  /**
   *  Creates a new **MulticoinProviderPluing** for %%name%%.
   */
  function MulticoinProviderPlugin(name) {
    _classCallCheck(this, MulticoinProviderPlugin);
    /**
     *  The name.
     */
    _defineProperty(this, "name", void 0);
    (0, index_js_5.defineProperties)(this, {
      name: name
    });
  }
  return _createClass(MulticoinProviderPlugin, [{
    key: "connect",
    value: function connect(proivder) {
      return this;
    }
    /**
     *  Returns ``true`` if %%coinType%% is supported by this plugin.
     */
  }, {
    key: "supportsCoinType",
    value: function supportsCoinType(coinType) {
      return false;
    }
    /**
     *  Resolves to the encoded %%address%% for %%coinType%%.
     */
  }, {
    key: "encodeAddress",
    value: (function () {
      var _encodeAddress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(coinType, address) {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              throw new Error("unsupported coin");
            case 1:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));
      function encodeAddress(_x, _x2) {
        return _encodeAddress.apply(this, arguments);
      }
      return encodeAddress;
    }()
    /**
     *  Resolves to the decoded %%data%% for %%coinType%%.
     */
    )
  }, {
    key: "decodeAddress",
    value: (function () {
      var _decodeAddress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(coinType, data) {
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              throw new Error("unsupported coin");
            case 1:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      }));
      function decodeAddress(_x3, _x4) {
        return _decodeAddress.apply(this, arguments);
      }
      return decodeAddress;
    }())
  }]);
}();
exports.MulticoinProviderPlugin = MulticoinProviderPlugin;
var BasicMulticoinPluginId = "org.ethers.plugins.provider.BasicMulticoin";
/**
 *  A **BasicMulticoinProviderPlugin** provides service for common
 *  coin types, which do not require additional libraries to encode or
 *  decode.
 */
var BasicMulticoinProviderPlugin = /*#__PURE__*/function (_MulticoinProviderPlu) {
  /**
   *  Creates a new **BasicMulticoinProviderPlugin**.
   */
  function BasicMulticoinProviderPlugin() {
    _classCallCheck(this, BasicMulticoinProviderPlugin);
    return _callSuper(this, BasicMulticoinProviderPlugin, [BasicMulticoinPluginId]);
  }
  _inherits(BasicMulticoinProviderPlugin, _MulticoinProviderPlu);
  return _createClass(BasicMulticoinProviderPlugin);
}(MulticoinProviderPlugin);
exports.BasicMulticoinProviderPlugin = BasicMulticoinProviderPlugin;
var matcherIpfs = new RegExp("^(ipfs):/\/(.*)$", "i");
var matchers = [new RegExp("^(https):/\/(.*)$", "i"), new RegExp("^(data):(.*)$", "i"), matcherIpfs, new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")];
/**
 *  A connected object to a resolved ENS name resolver, which can be
 *  used to query additional details.
 */
var _supports = /*#__PURE__*/new WeakMap();
var _resolver = /*#__PURE__*/new WeakMap();
var _EnsResolver_brand = /*#__PURE__*/new WeakSet();
var EnsResolver = /*#__PURE__*/function () {
  function EnsResolver(provider, address, name) {
    _classCallCheck(this, EnsResolver);
    _classPrivateMethodInitSpec(this, _EnsResolver_brand);
    /**
     *  The connected provider.
     */
    _defineProperty(this, "provider", void 0);
    /**
     *  The address of the resolver.
     */
    _defineProperty(this, "address", void 0);
    /**
     *  The name this resolver was resolved against.
     */
    _defineProperty(this, "name", void 0);
    // For EIP-2544 names, the ancestor that provided the resolver
    _classPrivateFieldInitSpec(this, _supports, void 0);
    _classPrivateFieldInitSpec(this, _resolver, void 0);
    (0, index_js_5.defineProperties)(this, {
      provider: provider,
      address: address,
      name: name
    });
    _classPrivateFieldSet(_supports, this, null);
    _classPrivateFieldSet(_resolver, this, new index_js_3.Contract(address, ["function supportsInterface(bytes4) view returns (bool)", "function resolve(bytes, bytes) view returns (bytes)", "function addr(bytes32) view returns (address)", "function addr(bytes32, uint) view returns (bytes)", "function text(bytes32, string) view returns (string)", "function contenthash(bytes32) view returns (bytes)"], provider));
  }
  /**
   *  Resolves to true if the resolver supports wildcard resolution.
   */
  return _createClass(EnsResolver, [{
    key: "supportsWildcard",
    value: (function () {
      var _supportsWildcard = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
        var _this = this;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              if (_classPrivateFieldGet(_supports, this) == null) {
                _classPrivateFieldSet(_supports, this, _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
                  return _regeneratorRuntime().wrap(function _callee3$(_context3) {
                    while (1) switch (_context3.prev = _context3.next) {
                      case 0:
                        _context3.prev = 0;
                        _context3.next = 3;
                        return _classPrivateFieldGet(_resolver, _this).supportsInterface("0x9061b923");
                      case 3:
                        return _context3.abrupt("return", _context3.sent);
                      case 6:
                        _context3.prev = 6;
                        _context3.t0 = _context3["catch"](0);
                        if (!(0, index_js_5.isError)(_context3.t0, "CALL_EXCEPTION")) {
                          _context3.next = 10;
                          break;
                        }
                        return _context3.abrupt("return", false);
                      case 10:
                        // Let future attempts try again...
                        _classPrivateFieldSet(_supports, _this, null);
                        throw _context3.t0;
                      case 12:
                      case "end":
                        return _context3.stop();
                    }
                  }, _callee3, null, [[0, 6]]);
                }))());
              }
              _context4.next = 3;
              return _classPrivateFieldGet(_supports, this);
            case 3:
              return _context4.abrupt("return", _context4.sent);
            case 4:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));
      function supportsWildcard() {
        return _supportsWildcard.apply(this, arguments);
      }
      return supportsWildcard;
    }())
  }, {
    key: "getAddress",
    value: (
    /**
     *  Resolves to the address for %%coinType%% or null if the
     *  provided %%coinType%% has not been configured.
     */
    function () {
      var _getAddress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(coinType) {
        var result, ethCoinType, _data, coinPlugin, _iterator, _step, plugin, data, address;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              if (coinType == null) {
                coinType = 60;
              }
              if (!(coinType === 60)) {
                _context5.next = 16;
                break;
              }
              _context5.prev = 2;
              _context5.next = 5;
              return _assertClassBrand(_EnsResolver_brand, this, _fetch).call(this, "addr(bytes32)");
            case 5:
              result = _context5.sent;
              if (!(result == null || result === index_js_2.ZeroAddress)) {
                _context5.next = 8;
                break;
              }
              return _context5.abrupt("return", null);
            case 8:
              return _context5.abrupt("return", result);
            case 11:
              _context5.prev = 11;
              _context5.t0 = _context5["catch"](2);
              if (!(0, index_js_5.isError)(_context5.t0, "CALL_EXCEPTION")) {
                _context5.next = 15;
                break;
              }
              return _context5.abrupt("return", null);
            case 15:
              throw _context5.t0;
            case 16:
              if (!(coinType >= 0 && coinType < 0x80000000)) {
                _context5.next = 23;
                break;
              }
              ethCoinType = coinType + 0x80000000;
              _context5.next = 20;
              return _assertClassBrand(_EnsResolver_brand, this, _fetch).call(this, "addr(bytes32,uint)", [ethCoinType]);
            case 20:
              _data = _context5.sent;
              if (!(0, index_js_5.isHexString)(_data, 20)) {
                _context5.next = 23;
                break;
              }
              return _context5.abrupt("return", (0, index_js_1.getAddress)(_data));
            case 23:
              coinPlugin = null;
              _iterator = _createForOfIteratorHelper(this.provider.plugins);
              _context5.prev = 25;
              _iterator.s();
            case 27:
              if ((_step = _iterator.n()).done) {
                _context5.next = 36;
                break;
              }
              plugin = _step.value;
              if (plugin instanceof MulticoinProviderPlugin) {
                _context5.next = 31;
                break;
              }
              return _context5.abrupt("continue", 34);
            case 31:
              if (!plugin.supportsCoinType(coinType)) {
                _context5.next = 34;
                break;
              }
              coinPlugin = plugin;
              return _context5.abrupt("break", 36);
            case 34:
              _context5.next = 27;
              break;
            case 36:
              _context5.next = 41;
              break;
            case 38:
              _context5.prev = 38;
              _context5.t1 = _context5["catch"](25);
              _iterator.e(_context5.t1);
            case 41:
              _context5.prev = 41;
              _iterator.f();
              return _context5.finish(41);
            case 44:
              if (!(coinPlugin == null)) {
                _context5.next = 46;
                break;
              }
              return _context5.abrupt("return", null);
            case 46:
              _context5.next = 48;
              return _assertClassBrand(_EnsResolver_brand, this, _fetch).call(this, "addr(bytes32,uint)", [coinType]);
            case 48:
              data = _context5.sent;
              if (!(data == null || data === "0x")) {
                _context5.next = 51;
                break;
              }
              return _context5.abrupt("return", null);
            case 51:
              _context5.next = 53;
              return coinPlugin.decodeAddress(coinType, data);
            case 53:
              address = _context5.sent;
              if (!(address != null)) {
                _context5.next = 56;
                break;
              }
              return _context5.abrupt("return", address);
            case 56:
              (0, index_js_5.assert)(false, "invalid coin data", "UNSUPPORTED_OPERATION", {
                operation: "getAddress(".concat(coinType, ")"),
                info: {
                  coinType: coinType,
                  data: data
                }
              });
            case 57:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this, [[2, 11], [25, 38, 41, 44]]);
      }));
      function getAddress(_x5) {
        return _getAddress.apply(this, arguments);
      }
      return getAddress;
    }()
    /**
     *  Resolves to the EIP-634 text record for %%key%%, or ``null``
     *  if unconfigured.
     */
    )
  }, {
    key: "getText",
    value: (function () {
      var _getText = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(key) {
        var data;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              _context6.next = 2;
              return _assertClassBrand(_EnsResolver_brand, this, _fetch).call(this, "text(bytes32,string)", [key]);
            case 2:
              data = _context6.sent;
              if (!(data == null || data === "0x")) {
                _context6.next = 5;
                break;
              }
              return _context6.abrupt("return", null);
            case 5:
              return _context6.abrupt("return", data);
            case 6:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this);
      }));
      function getText(_x6) {
        return _getText.apply(this, arguments);
      }
      return getText;
    }()
    /**
     *  Rsolves to the content-hash or ``null`` if unconfigured.
     */
    )
  }, {
    key: "getContentHash",
    value: (function () {
      var _getContentHash = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {
        var data, ipfs, scheme, length, swarm;
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              _context7.next = 2;
              return _assertClassBrand(_EnsResolver_brand, this, _fetch).call(this, "contenthash(bytes32)");
            case 2:
              data = _context7.sent;
              if (!(data == null || data === "0x")) {
                _context7.next = 5;
                break;
              }
              return _context7.abrupt("return", null);
            case 5:
              // IPFS (CID: 1, Type: 70=DAG-PB, 72=libp2p-key)
              ipfs = data.match(/^0x(e3010170|e5010172)(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
              if (!ipfs) {
                _context7.next = 11;
                break;
              }
              scheme = ipfs[1] === "e3010170" ? "ipfs" : "ipns";
              length = parseInt(ipfs[4], 16);
              if (!(ipfs[5].length === length * 2)) {
                _context7.next = 11;
                break;
              }
              return _context7.abrupt("return", "".concat(scheme, "://").concat((0, index_js_5.encodeBase58)("0x" + ipfs[2])));
            case 11:
              // Swarm (CID: 1, Type: swarm-manifest; hash/length hard-coded to keccak256/32)
              swarm = data.match(/^0xe40101fa011b20([0-9a-f]*)$/);
              if (!(swarm && swarm[1].length === 64)) {
                _context7.next = 14;
                break;
              }
              return _context7.abrupt("return", "bzz://".concat(swarm[1]));
            case 14:
              (0, index_js_5.assert)(false, "invalid or unsupported content hash data", "UNSUPPORTED_OPERATION", {
                operation: "getContentHash()",
                info: {
                  data: data
                }
              });
            case 15:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this);
      }));
      function getContentHash() {
        return _getContentHash.apply(this, arguments);
      }
      return getContentHash;
    }()
    /**
     *  Resolves to the avatar url or ``null`` if the avatar is either
     *  unconfigured or incorrectly configured (e.g. references an NFT
     *  not owned by the address).
     *
     *  If diagnosing issues with configurations, the [[_getAvatar]]
     *  method may be useful.
     */
    )
  }, {
    key: "getAvatar",
    value: (function () {
      var _getAvatar2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {
        var avatar;
        return _regeneratorRuntime().wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              _context8.next = 2;
              return this._getAvatar();
            case 2:
              avatar = _context8.sent;
              return _context8.abrupt("return", avatar.url);
            case 4:
            case "end":
              return _context8.stop();
          }
        }, _callee8, this);
      }));
      function getAvatar() {
        return _getAvatar2.apply(this, arguments);
      }
      return getAvatar;
    }()
    /**
     *  When resolving an avatar, there are many steps involved, such
     *  fetching metadata and possibly validating ownership of an
     *  NFT.
     *
     *  This method can be used to examine each step and the value it
     *  was working from.
     */
    )
  }, {
    key: "_getAvatar",
    value: (function () {
      var _getAvatar3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {
        var linkage, avatar, i, match, scheme, url, selector, owner, comps, tokenId, contract, tokenOwner, balance, metadataUrl, metadata, response, bytes, imageUrl, ipfs;
        return _regeneratorRuntime().wrap(function _callee9$(_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
              linkage = [{
                type: "name",
                value: this.name
              }];
              _context9.prev = 1;
              _context9.next = 4;
              return this.getText("avatar");
            case 4:
              avatar = _context9.sent;
              if (!(avatar == null)) {
                _context9.next = 8;
                break;
              }
              linkage.push({
                type: "!avatar",
                value: ""
              });
              return _context9.abrupt("return", {
                url: null,
                linkage: linkage
              });
            case 8:
              linkage.push({
                type: "avatar",
                value: avatar
              });
              i = 0;
            case 10:
              if (!(i < matchers.length)) {
                _context9.next = 109;
                break;
              }
              match = avatar.match(matchers[i]);
              if (!(match == null)) {
                _context9.next = 14;
                break;
              }
              return _context9.abrupt("continue", 106);
            case 14:
              scheme = match[1].toLowerCase();
              _context9.t0 = scheme;
              _context9.next = _context9.t0 === "https" ? 18 : _context9.t0 === "data" ? 18 : _context9.t0 === "ipfs" ? 20 : _context9.t0 === "erc721" ? 24 : _context9.t0 === "erc1155" ? 24 : 106;
              break;
            case 18:
              linkage.push({
                type: "url",
                value: avatar
              });
              return _context9.abrupt("return", {
                linkage: linkage,
                url: avatar
              });
            case 20:
              url = getIpfsLink(avatar);
              linkage.push({
                type: "ipfs",
                value: avatar
              });
              linkage.push({
                type: "url",
                value: url
              });
              return _context9.abrupt("return", {
                linkage: linkage,
                url: url
              });
            case 24:
              // Depending on the ERC type, use tokenURI(uint256) or url(uint256)
              selector = scheme === "erc721" ? "tokenURI(uint256)" : "uri(uint256)";
              linkage.push({
                type: scheme,
                value: avatar
              });
              // The owner of this name
              _context9.next = 28;
              return this.getAddress();
            case 28:
              owner = _context9.sent;
              if (!(owner == null)) {
                _context9.next = 32;
                break;
              }
              linkage.push({
                type: "!owner",
                value: ""
              });
              return _context9.abrupt("return", {
                url: null,
                linkage: linkage
              });
            case 32:
              comps = (match[2] || "").split("/");
              if (!(comps.length !== 2)) {
                _context9.next = 36;
                break;
              }
              linkage.push({
                type: "!".concat(scheme, "caip"),
                value: match[2] || ""
              });
              return _context9.abrupt("return", {
                url: null,
                linkage: linkage
              });
            case 36:
              tokenId = comps[1];
              contract = new index_js_3.Contract(comps[0], [
              // ERC-721
              "function tokenURI(uint) view returns (string)", "function ownerOf(uint) view returns (address)",
              // ERC-1155
              "function uri(uint) view returns (string)", "function balanceOf(address, uint256) view returns (uint)"], this.provider); // Check that this account owns the token
              if (!(scheme === "erc721")) {
                _context9.next = 48;
                break;
              }
              _context9.next = 41;
              return contract.ownerOf(tokenId);
            case 41:
              tokenOwner = _context9.sent;
              if (!(owner !== tokenOwner)) {
                _context9.next = 45;
                break;
              }
              linkage.push({
                type: "!owner",
                value: tokenOwner
              });
              return _context9.abrupt("return", {
                url: null,
                linkage: linkage
              });
            case 45:
              linkage.push({
                type: "owner",
                value: tokenOwner
              });
              _context9.next = 56;
              break;
            case 48:
              if (!(scheme === "erc1155")) {
                _context9.next = 56;
                break;
              }
              _context9.next = 51;
              return contract.balanceOf(owner, tokenId);
            case 51:
              balance = _context9.sent;
              if (balance) {
                _context9.next = 55;
                break;
              }
              linkage.push({
                type: "!balance",
                value: "0"
              });
              return _context9.abrupt("return", {
                url: null,
                linkage: linkage
              });
            case 55:
              linkage.push({
                type: "balance",
                value: balance.toString()
              });
            case 56:
              _context9.next = 58;
              return contract[selector](tokenId);
            case 58:
              metadataUrl = _context9.sent;
              if (!(metadataUrl == null || metadataUrl === "0x")) {
                _context9.next = 62;
                break;
              }
              linkage.push({
                type: "!metadata-url",
                value: ""
              });
              return _context9.abrupt("return", {
                url: null,
                linkage: linkage
              });
            case 62:
              linkage.push({
                type: "metadata-url-base",
                value: metadataUrl
              });
              // ERC-1155 allows a generic {id} in the URL
              if (scheme === "erc1155") {
                metadataUrl = metadataUrl.replace("{id}", (0, index_js_5.toBeHex)(tokenId, 32).substring(2));
                linkage.push({
                  type: "metadata-url-expanded",
                  value: metadataUrl
                });
              }
              // Transform IPFS metadata links
              if (metadataUrl.match(/^ipfs:/i)) {
                metadataUrl = getIpfsLink(metadataUrl);
              }
              linkage.push({
                type: "metadata-url",
                value: metadataUrl
              });
              // Get the token metadata
              metadata = {};
              _context9.next = 69;
              return new index_js_5.FetchRequest(metadataUrl).send();
            case 69:
              response = _context9.sent;
              response.assertOk();
              _context9.prev = 71;
              metadata = response.bodyJson;
              _context9.next = 87;
              break;
            case 75:
              _context9.prev = 75;
              _context9.t1 = _context9["catch"](71);
              _context9.prev = 77;
              linkage.push({
                type: "!metadata",
                value: response.bodyText
              });
              _context9.next = 86;
              break;
            case 81:
              _context9.prev = 81;
              _context9.t2 = _context9["catch"](77);
              bytes = response.body;
              if (bytes) {
                linkage.push({
                  type: "!metadata",
                  value: (0, index_js_5.hexlify)(bytes)
                });
              }
              return _context9.abrupt("return", {
                url: null,
                linkage: linkage
              });
            case 86:
              return _context9.abrupt("return", {
                url: null,
                linkage: linkage
              });
            case 87:
              if (metadata) {
                _context9.next = 90;
                break;
              }
              linkage.push({
                type: "!metadata",
                value: ""
              });
              return _context9.abrupt("return", {
                url: null,
                linkage: linkage
              });
            case 90:
              linkage.push({
                type: "metadata",
                value: JSON.stringify(metadata)
              });
              // Pull the image URL out
              imageUrl = metadata.image;
              if (!(typeof imageUrl !== "string")) {
                _context9.next = 95;
                break;
              }
              linkage.push({
                type: "!imageUrl",
                value: ""
              });
              return _context9.abrupt("return", {
                url: null,
                linkage: linkage
              });
            case 95:
              if (!imageUrl.match(/^(https:\/\/|data:)/i)) {
                _context9.next = 98;
                break;
              }
              _context9.next = 104;
              break;
            case 98:
              // Transform IPFS link to gateway
              ipfs = imageUrl.match(matcherIpfs);
              if (!(ipfs == null)) {
                _context9.next = 102;
                break;
              }
              linkage.push({
                type: "!imageUrl-ipfs",
                value: imageUrl
              });
              return _context9.abrupt("return", {
                url: null,
                linkage: linkage
              });
            case 102:
              linkage.push({
                type: "imageUrl-ipfs",
                value: imageUrl
              });
              imageUrl = getIpfsLink(imageUrl);
            case 104:
              linkage.push({
                type: "url",
                value: imageUrl
              });
              return _context9.abrupt("return", {
                linkage: linkage,
                url: imageUrl
              });
            case 106:
              i++;
              _context9.next = 10;
              break;
            case 109:
              _context9.next = 113;
              break;
            case 111:
              _context9.prev = 111;
              _context9.t3 = _context9["catch"](1);
            case 113:
              return _context9.abrupt("return", {
                linkage: linkage,
                url: null
              });
            case 114:
            case "end":
              return _context9.stop();
          }
        }, _callee9, this, [[1, 111], [71, 75], [77, 81]]);
      }));
      function _getAvatar() {
        return _getAvatar3.apply(this, arguments);
      }
      return _getAvatar;
    }())
  }], [{
    key: "getEnsAddress",
    value: function () {
      var _getEnsAddress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(provider) {
        var network, ensPlugin;
        return _regeneratorRuntime().wrap(function _callee10$(_context10) {
          while (1) switch (_context10.prev = _context10.next) {
            case 0:
              _context10.next = 2;
              return provider.getNetwork();
            case 2:
              network = _context10.sent;
              ensPlugin = network.getPlugin("org.ethers.plugins.network.Ens"); // No ENS...
              (0, index_js_5.assert)(ensPlugin, "network does not support ENS", "UNSUPPORTED_OPERATION", {
                operation: "getEnsAddress",
                info: {
                  network: network
                }
              });
              return _context10.abrupt("return", ensPlugin.address);
            case 6:
            case "end":
              return _context10.stop();
          }
        }, _callee10);
      }));
      function getEnsAddress(_x7) {
        return _getEnsAddress.apply(this, arguments);
      }
      return getEnsAddress;
    }()
  }, {
    key: "fromName",
    value: (
    /**
     *  Resolve to the ENS resolver for %%name%% using %%provider%% or
     *  ``null`` if unconfigured.
     */
    function () {
      var _fromName = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(provider, name) {
        var currentName, addr, resolver;
        return _regeneratorRuntime().wrap(function _callee11$(_context11) {
          while (1) switch (_context11.prev = _context11.next) {
            case 0:
              currentName = name;
            case 1:
              if (!true) {
                _context11.next = 22;
                break;
              }
              if (!(currentName === "" || currentName === ".")) {
                _context11.next = 4;
                break;
              }
              return _context11.abrupt("return", null);
            case 4:
              if (!(name !== "eth" && currentName === "eth")) {
                _context11.next = 6;
                break;
              }
              return _context11.abrupt("return", null);
            case 6:
              _context11.next = 8;
              return _getResolver.call(EnsResolver, provider, currentName);
            case 8:
              addr = _context11.sent;
              if (!(addr != null)) {
                _context11.next = 19;
                break;
              }
              resolver = new EnsResolver(provider, addr, name); // Legacy resolver found, using EIP-2544 so it isn't safe to use
              _context11.t0 = currentName !== name;
              if (!_context11.t0) {
                _context11.next = 16;
                break;
              }
              _context11.next = 15;
              return resolver.supportsWildcard();
            case 15:
              _context11.t0 = !_context11.sent;
            case 16:
              if (!_context11.t0) {
                _context11.next = 18;
                break;
              }
              return _context11.abrupt("return", null);
            case 18:
              return _context11.abrupt("return", resolver);
            case 19:
              // Get the parent node
              currentName = currentName.split(".").slice(1).join(".");
              _context11.next = 1;
              break;
            case 22:
            case "end":
              return _context11.stop();
          }
        }, _callee11);
      }));
      function fromName(_x8, _x9) {
        return _fromName.apply(this, arguments);
      }
      return fromName;
    }())
  }]);
}();
_EnsResolver = EnsResolver;
function _fetch(_x10, _x11) {
  return _fetch2.apply(this, arguments);
}
function _fetch2() {
  _fetch2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(funcName, params) {
    var iface, fragment, _classPrivateFieldGet2, result;
    return _regeneratorRuntime().wrap(function _callee12$(_context12) {
      while (1) switch (_context12.prev = _context12.next) {
        case 0:
          params = (params || []).slice();
          iface = _classPrivateFieldGet(_resolver, this)["interface"]; // The first parameters is always the nodehash
          params.unshift((0, index_js_4.namehash)(this.name));
          fragment = null;
          _context12.next = 6;
          return this.supportsWildcard();
        case 6:
          if (!_context12.sent) {
            _context12.next = 11;
            break;
          }
          fragment = iface.getFunction(funcName);
          (0, index_js_5.assert)(fragment, "missing fragment", "UNKNOWN_ERROR", {
            info: {
              funcName: funcName
            }
          });
          params = [(0, index_js_4.dnsEncode)(this.name, 255), iface.encodeFunctionData(fragment, params)];
          funcName = "resolve(bytes,bytes)";
        case 11:
          params.push({
            enableCcipRead: true
          });
          _context12.prev = 12;
          _context12.next = 15;
          return (_classPrivateFieldGet2 = _classPrivateFieldGet(_resolver, this))[funcName].apply(_classPrivateFieldGet2, _toConsumableArray(params));
        case 15:
          result = _context12.sent;
          if (!fragment) {
            _context12.next = 18;
            break;
          }
          return _context12.abrupt("return", iface.decodeFunctionResult(fragment, result)[0]);
        case 18:
          return _context12.abrupt("return", result);
        case 21:
          _context12.prev = 21;
          _context12.t0 = _context12["catch"](12);
          if ((0, index_js_5.isError)(_context12.t0, "CALL_EXCEPTION")) {
            _context12.next = 25;
            break;
          }
          throw _context12.t0;
        case 25:
          return _context12.abrupt("return", null);
        case 26:
        case "end":
          return _context12.stop();
      }
    }, _callee12, this, [[12, 21]]);
  }));
  return _fetch2.apply(this, arguments);
}
function _getResolver(_x12, _x13) {
  return _getResolver3.apply(this, arguments);
}
function _getResolver3() {
  _getResolver3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(provider, name) {
    var ensAddr, contract, addr;
    return _regeneratorRuntime().wrap(function _callee13$(_context13) {
      while (1) switch (_context13.prev = _context13.next) {
        case 0:
          _context13.next = 2;
          return _EnsResolver.getEnsAddress(provider);
        case 2:
          ensAddr = _context13.sent;
          _context13.prev = 3;
          contract = new index_js_3.Contract(ensAddr, ["function resolver(bytes32) view returns (address)"], provider);
          _context13.next = 7;
          return contract.resolver((0, index_js_4.namehash)(name), {
            enableCcipRead: true
          });
        case 7:
          addr = _context13.sent;
          if (!(addr === index_js_2.ZeroAddress)) {
            _context13.next = 10;
            break;
          }
          return _context13.abrupt("return", null);
        case 10:
          return _context13.abrupt("return", addr);
        case 13:
          _context13.prev = 13;
          _context13.t0 = _context13["catch"](3);
          throw _context13.t0;
        case 16:
          return _context13.abrupt("return", null);
        case 17:
        case "end":
          return _context13.stop();
      }
    }, _callee13, null, [[3, 13]]);
  }));
  return _getResolver3.apply(this, arguments);
}
exports.EnsResolver = EnsResolver;

},{"../address/index.js":207,"../constants/index.js":210,"../contract/index.js":215,"../hash/index.js":230,"../utils/index.js":276}],241:[function(require,module,exports){
"use strict";

function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.formatTransactionResponse = exports.formatTransactionReceipt = exports.formatReceiptLog = exports.formatBlock = exports.formatLog = exports.formatUint256 = exports.formatHash = exports.formatData = exports.formatBoolean = exports.object = exports.arrayOf = exports.allowNull = void 0;
/**
 *  @_ignore
 */
var index_js_1 = require("../address/index.js");
var index_js_2 = require("../crypto/index.js");
var index_js_3 = require("../transaction/index.js");
var index_js_4 = require("../utils/index.js");
var BN_0 = BigInt(0);
function allowNull(format, nullValue) {
  return function (value) {
    if (value == null) {
      return nullValue;
    }
    return format(value);
  };
}
exports.allowNull = allowNull;
function arrayOf(format, allowNull) {
  return function (array) {
    if (allowNull && array == null) {
      return null;
    }
    if (!Array.isArray(array)) {
      throw new Error("not an array");
    }
    return array.map(function (i) {
      return format(i);
    });
  };
}
exports.arrayOf = arrayOf;
// Requires an object which matches a fleet of other formatters
// Any FormatFunc may return `undefined` to have the value omitted
// from the result object. Calls preserve `this`.
function object(format, altNames) {
  return function (value) {
    var result = {};
    for (var key in format) {
      var srcKey = key;
      if (altNames && key in altNames && !(srcKey in value)) {
        var _iterator = _createForOfIteratorHelper(altNames[key]),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var altKey = _step.value;
            if (altKey in value) {
              srcKey = altKey;
              break;
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
      try {
        var nv = format[key](value[srcKey]);
        if (nv !== undefined) {
          result[key] = nv;
        }
      } catch (error) {
        var message = error instanceof Error ? error.message : "not-an-error";
        (0, index_js_4.assert)(false, "invalid value for value.".concat(key, " (").concat(message, ")"), "BAD_DATA", {
          value: value
        });
      }
    }
    return result;
  };
}
exports.object = object;
function formatBoolean(value) {
  switch (value) {
    case true:
    case "true":
      return true;
    case false:
    case "false":
      return false;
  }
  (0, index_js_4.assertArgument)(false, "invalid boolean; ".concat(JSON.stringify(value)), "value", value);
}
exports.formatBoolean = formatBoolean;
function formatData(value) {
  (0, index_js_4.assertArgument)((0, index_js_4.isHexString)(value, true), "invalid data", "value", value);
  return value;
}
exports.formatData = formatData;
function formatHash(value) {
  (0, index_js_4.assertArgument)((0, index_js_4.isHexString)(value, 32), "invalid hash", "value", value);
  return value;
}
exports.formatHash = formatHash;
function formatUint256(value) {
  if (!(0, index_js_4.isHexString)(value)) {
    throw new Error("invalid uint256");
  }
  return (0, index_js_4.zeroPadValue)(value, 32);
}
exports.formatUint256 = formatUint256;
var _formatLog = object({
  address: index_js_1.getAddress,
  blockHash: formatHash,
  blockNumber: index_js_4.getNumber,
  data: formatData,
  index: index_js_4.getNumber,
  removed: allowNull(formatBoolean, false),
  topics: arrayOf(formatHash),
  transactionHash: formatHash,
  transactionIndex: index_js_4.getNumber
}, {
  index: ["logIndex"]
});
function formatLog(value) {
  return _formatLog(value);
}
exports.formatLog = formatLog;
var _formatBlock = object({
  hash: allowNull(formatHash),
  parentHash: formatHash,
  parentBeaconBlockRoot: allowNull(formatHash, null),
  number: index_js_4.getNumber,
  timestamp: index_js_4.getNumber,
  nonce: allowNull(formatData),
  difficulty: index_js_4.getBigInt,
  gasLimit: index_js_4.getBigInt,
  gasUsed: index_js_4.getBigInt,
  stateRoot: allowNull(formatHash, null),
  receiptsRoot: allowNull(formatHash, null),
  blobGasUsed: allowNull(index_js_4.getBigInt, null),
  excessBlobGas: allowNull(index_js_4.getBigInt, null),
  miner: allowNull(index_js_1.getAddress),
  prevRandao: allowNull(formatHash, null),
  extraData: formatData,
  baseFeePerGas: allowNull(index_js_4.getBigInt)
}, {
  prevRandao: ["mixHash"]
});
function formatBlock(value) {
  var result = _formatBlock(value);
  result.transactions = value.transactions.map(function (tx) {
    if (typeof tx === "string") {
      return tx;
    }
    return formatTransactionResponse(tx);
  });
  return result;
}
exports.formatBlock = formatBlock;
var _formatReceiptLog = object({
  transactionIndex: index_js_4.getNumber,
  blockNumber: index_js_4.getNumber,
  transactionHash: formatHash,
  address: index_js_1.getAddress,
  topics: arrayOf(formatHash),
  data: formatData,
  index: index_js_4.getNumber,
  blockHash: formatHash
}, {
  index: ["logIndex"]
});
function formatReceiptLog(value) {
  return _formatReceiptLog(value);
}
exports.formatReceiptLog = formatReceiptLog;
var _formatTransactionReceipt = object({
  to: allowNull(index_js_1.getAddress, null),
  from: allowNull(index_js_1.getAddress, null),
  contractAddress: allowNull(index_js_1.getAddress, null),
  // should be allowNull(hash), but broken-EIP-658 support is handled in receipt
  index: index_js_4.getNumber,
  root: allowNull(index_js_4.hexlify),
  gasUsed: index_js_4.getBigInt,
  blobGasUsed: allowNull(index_js_4.getBigInt, null),
  logsBloom: allowNull(formatData),
  blockHash: formatHash,
  hash: formatHash,
  logs: arrayOf(formatReceiptLog),
  blockNumber: index_js_4.getNumber,
  //confirmations: allowNull(getNumber, null),
  cumulativeGasUsed: index_js_4.getBigInt,
  effectiveGasPrice: allowNull(index_js_4.getBigInt),
  blobGasPrice: allowNull(index_js_4.getBigInt, null),
  status: allowNull(index_js_4.getNumber),
  type: allowNull(index_js_4.getNumber, 0)
}, {
  effectiveGasPrice: ["gasPrice"],
  hash: ["transactionHash"],
  index: ["transactionIndex"]
});
function formatTransactionReceipt(value) {
  return _formatTransactionReceipt(value);
}
exports.formatTransactionReceipt = formatTransactionReceipt;
function formatTransactionResponse(value) {
  // Some clients (TestRPC) do strange things like return 0x0 for the
  // 0 address; correct this to be a real address
  if (value.to && (0, index_js_4.getBigInt)(value.to) === BN_0) {
    value.to = "0x0000000000000000000000000000000000000000";
  }
  var result = object({
    hash: formatHash,
    // Some nodes do not return this, usually test nodes (like Ganache)
    index: allowNull(index_js_4.getNumber, undefined),
    type: function type(value) {
      if (value === "0x" || value == null) {
        return 0;
      }
      return (0, index_js_4.getNumber)(value);
    },
    accessList: allowNull(index_js_3.accessListify, null),
    blobVersionedHashes: allowNull(arrayOf(formatHash, true), null),
    blockHash: allowNull(formatHash, null),
    blockNumber: allowNull(index_js_4.getNumber, null),
    transactionIndex: allowNull(index_js_4.getNumber, null),
    from: index_js_1.getAddress,
    // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas) must be set
    gasPrice: allowNull(index_js_4.getBigInt),
    maxPriorityFeePerGas: allowNull(index_js_4.getBigInt),
    maxFeePerGas: allowNull(index_js_4.getBigInt),
    maxFeePerBlobGas: allowNull(index_js_4.getBigInt, null),
    gasLimit: index_js_4.getBigInt,
    to: allowNull(index_js_1.getAddress, null),
    value: index_js_4.getBigInt,
    nonce: index_js_4.getNumber,
    data: formatData,
    creates: allowNull(index_js_1.getAddress, null),
    chainId: allowNull(index_js_4.getBigInt, null)
  }, {
    data: ["input"],
    gasLimit: ["gas"],
    index: ["transactionIndex"]
  })(value);
  // If to and creates are empty, populate the creates from the value
  if (result.to == null && result.creates == null) {
    result.creates = (0, index_js_1.getCreateAddress)(result);
  }
  // @TODO: Check fee data
  // Add an access list to supported transaction types
  if ((value.type === 1 || value.type === 2) && value.accessList == null) {
    result.accessList = [];
  }
  // Compute the signature
  if (value.signature) {
    result.signature = index_js_2.Signature.from(value.signature);
  } else {
    result.signature = index_js_2.Signature.from(value);
  }
  // Some backends omit ChainId on legacy transactions, but we can compute it
  if (result.chainId == null) {
    var chainId = result.signature.legacyChainId;
    if (chainId != null) {
      result.chainId = chainId;
    }
  }
  // @TODO: check chainID
  /*
  if (value.chainId != null) {
      let chainId = value.chainId;
       if (isHexString(chainId)) {
          chainId = BigNumber.from(chainId).toNumber();
      }
       result.chainId = chainId;
   } else {
      let chainId = value.networkId;
       // geth-etc returns chainId
      if (chainId == null && result.v == null) {
          chainId = value.chainId;
      }
       if (isHexString(chainId)) {
          chainId = BigNumber.from(chainId).toNumber();
      }
       if (typeof(chainId) !== "number" && result.v != null) {
          chainId = (result.v - 35) / 2;
          if (chainId < 0) { chainId = 0; }
          chainId = parseInt(chainId);
      }
       if (typeof(chainId) !== "number") { chainId = 0; }
       result.chainId = chainId;
  }
  */
  // 0x0000... should actually be null
  if (result.blockHash && (0, index_js_4.getBigInt)(result.blockHash) === BN_0) {
    result.blockHash = null;
  }
  return result;
}
exports.formatTransactionResponse = formatTransactionResponse;

},{"../address/index.js":207,"../crypto/index.js":219,"../transaction/index.js":266,"../utils/index.js":276}],242:[function(require,module,exports){
"use strict";

/**
 *  A **Provider** provides a connection to the blockchain, whch can be
 *  used to query its current state, simulate execution and send transactions
 *  to update the state.
 *
 *  It is one of the most fundamental components of interacting with a
 *  blockchain application, and there are many ways to connect, such as over
 *  HTTP, WebSockets or injected providers such as [MetaMask](link-metamask).
 *
 *  @_section: api/providers:Providers  [about-providers]
 */
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SocketEventSubscriber = exports.SocketPendingSubscriber = exports.SocketBlockSubscriber = exports.SocketSubscriber = exports.WebSocketProvider = exports.SocketProvider = exports.IpcSocketProvider = exports.QuickNodeProvider = exports.PocketProvider = exports.InfuraWebSocketProvider = exports.InfuraProvider = exports.EtherscanPlugin = exports.EtherscanProvider = exports.ChainstackProvider = exports.CloudflareProvider = exports.AnkrProvider = exports.AlchemyProvider = exports.BrowserProvider = exports.JsonRpcSigner = exports.JsonRpcProvider = exports.JsonRpcApiProvider = exports.FallbackProvider = exports.copyRequest = exports.TransactionResponse = exports.TransactionReceipt = exports.Log = exports.FeeData = exports.Block = exports.FetchUrlFeeDataNetworkPlugin = exports.FeeDataNetworkPlugin = exports.EnsPlugin = exports.GasCostPlugin = exports.NetworkPlugin = exports.NonceManager = exports.Network = exports.MulticoinProviderPlugin = exports.EnsResolver = exports.getDefaultProvider = exports.showThrottleMessage = exports.VoidSigner = exports.AbstractSigner = exports.UnmanagedSubscriber = exports.AbstractProvider = void 0;
var abstract_provider_js_1 = require("./abstract-provider.js");
Object.defineProperty(exports, "AbstractProvider", {
  enumerable: true,
  get: function get() {
    return abstract_provider_js_1.AbstractProvider;
  }
});
Object.defineProperty(exports, "UnmanagedSubscriber", {
  enumerable: true,
  get: function get() {
    return abstract_provider_js_1.UnmanagedSubscriber;
  }
});
var abstract_signer_js_1 = require("./abstract-signer.js");
Object.defineProperty(exports, "AbstractSigner", {
  enumerable: true,
  get: function get() {
    return abstract_signer_js_1.AbstractSigner;
  }
});
Object.defineProperty(exports, "VoidSigner", {
  enumerable: true,
  get: function get() {
    return abstract_signer_js_1.VoidSigner;
  }
});
var community_js_1 = require("./community.js");
Object.defineProperty(exports, "showThrottleMessage", {
  enumerable: true,
  get: function get() {
    return community_js_1.showThrottleMessage;
  }
});
var default_provider_js_1 = require("./default-provider.js");
Object.defineProperty(exports, "getDefaultProvider", {
  enumerable: true,
  get: function get() {
    return default_provider_js_1.getDefaultProvider;
  }
});
var ens_resolver_js_1 = require("./ens-resolver.js");
Object.defineProperty(exports, "EnsResolver", {
  enumerable: true,
  get: function get() {
    return ens_resolver_js_1.EnsResolver;
  }
});
Object.defineProperty(exports, "MulticoinProviderPlugin", {
  enumerable: true,
  get: function get() {
    return ens_resolver_js_1.MulticoinProviderPlugin;
  }
});
var network_js_1 = require("./network.js");
Object.defineProperty(exports, "Network", {
  enumerable: true,
  get: function get() {
    return network_js_1.Network;
  }
});
var signer_noncemanager_js_1 = require("./signer-noncemanager.js");
Object.defineProperty(exports, "NonceManager", {
  enumerable: true,
  get: function get() {
    return signer_noncemanager_js_1.NonceManager;
  }
});
var plugins_network_js_1 = require("./plugins-network.js");
Object.defineProperty(exports, "NetworkPlugin", {
  enumerable: true,
  get: function get() {
    return plugins_network_js_1.NetworkPlugin;
  }
});
Object.defineProperty(exports, "GasCostPlugin", {
  enumerable: true,
  get: function get() {
    return plugins_network_js_1.GasCostPlugin;
  }
});
Object.defineProperty(exports, "EnsPlugin", {
  enumerable: true,
  get: function get() {
    return plugins_network_js_1.EnsPlugin;
  }
});
Object.defineProperty(exports, "FeeDataNetworkPlugin", {
  enumerable: true,
  get: function get() {
    return plugins_network_js_1.FeeDataNetworkPlugin;
  }
});
Object.defineProperty(exports, "FetchUrlFeeDataNetworkPlugin", {
  enumerable: true,
  get: function get() {
    return plugins_network_js_1.FetchUrlFeeDataNetworkPlugin;
  }
});
var provider_js_1 = require("./provider.js");
Object.defineProperty(exports, "Block", {
  enumerable: true,
  get: function get() {
    return provider_js_1.Block;
  }
});
Object.defineProperty(exports, "FeeData", {
  enumerable: true,
  get: function get() {
    return provider_js_1.FeeData;
  }
});
Object.defineProperty(exports, "Log", {
  enumerable: true,
  get: function get() {
    return provider_js_1.Log;
  }
});
Object.defineProperty(exports, "TransactionReceipt", {
  enumerable: true,
  get: function get() {
    return provider_js_1.TransactionReceipt;
  }
});
Object.defineProperty(exports, "TransactionResponse", {
  enumerable: true,
  get: function get() {
    return provider_js_1.TransactionResponse;
  }
});
Object.defineProperty(exports, "copyRequest", {
  enumerable: true,
  get: function get() {
    return provider_js_1.copyRequest;
  }
});
var provider_fallback_js_1 = require("./provider-fallback.js");
Object.defineProperty(exports, "FallbackProvider", {
  enumerable: true,
  get: function get() {
    return provider_fallback_js_1.FallbackProvider;
  }
});
var provider_jsonrpc_js_1 = require("./provider-jsonrpc.js");
Object.defineProperty(exports, "JsonRpcApiProvider", {
  enumerable: true,
  get: function get() {
    return provider_jsonrpc_js_1.JsonRpcApiProvider;
  }
});
Object.defineProperty(exports, "JsonRpcProvider", {
  enumerable: true,
  get: function get() {
    return provider_jsonrpc_js_1.JsonRpcProvider;
  }
});
Object.defineProperty(exports, "JsonRpcSigner", {
  enumerable: true,
  get: function get() {
    return provider_jsonrpc_js_1.JsonRpcSigner;
  }
});
var provider_browser_js_1 = require("./provider-browser.js");
Object.defineProperty(exports, "BrowserProvider", {
  enumerable: true,
  get: function get() {
    return provider_browser_js_1.BrowserProvider;
  }
});
var provider_alchemy_js_1 = require("./provider-alchemy.js");
Object.defineProperty(exports, "AlchemyProvider", {
  enumerable: true,
  get: function get() {
    return provider_alchemy_js_1.AlchemyProvider;
  }
});
var provider_ankr_js_1 = require("./provider-ankr.js");
Object.defineProperty(exports, "AnkrProvider", {
  enumerable: true,
  get: function get() {
    return provider_ankr_js_1.AnkrProvider;
  }
});
var provider_cloudflare_js_1 = require("./provider-cloudflare.js");
Object.defineProperty(exports, "CloudflareProvider", {
  enumerable: true,
  get: function get() {
    return provider_cloudflare_js_1.CloudflareProvider;
  }
});
var provider_chainstack_js_1 = require("./provider-chainstack.js");
Object.defineProperty(exports, "ChainstackProvider", {
  enumerable: true,
  get: function get() {
    return provider_chainstack_js_1.ChainstackProvider;
  }
});
var provider_etherscan_js_1 = require("./provider-etherscan.js");
Object.defineProperty(exports, "EtherscanProvider", {
  enumerable: true,
  get: function get() {
    return provider_etherscan_js_1.EtherscanProvider;
  }
});
Object.defineProperty(exports, "EtherscanPlugin", {
  enumerable: true,
  get: function get() {
    return provider_etherscan_js_1.EtherscanPlugin;
  }
});
var provider_infura_js_1 = require("./provider-infura.js");
Object.defineProperty(exports, "InfuraProvider", {
  enumerable: true,
  get: function get() {
    return provider_infura_js_1.InfuraProvider;
  }
});
Object.defineProperty(exports, "InfuraWebSocketProvider", {
  enumerable: true,
  get: function get() {
    return provider_infura_js_1.InfuraWebSocketProvider;
  }
});
var provider_pocket_js_1 = require("./provider-pocket.js");
Object.defineProperty(exports, "PocketProvider", {
  enumerable: true,
  get: function get() {
    return provider_pocket_js_1.PocketProvider;
  }
});
var provider_quicknode_js_1 = require("./provider-quicknode.js");
Object.defineProperty(exports, "QuickNodeProvider", {
  enumerable: true,
  get: function get() {
    return provider_quicknode_js_1.QuickNodeProvider;
  }
});
var provider_ipcsocket_js_1 = require("./provider-ipcsocket.js"); /*-browser*/
Object.defineProperty(exports, "IpcSocketProvider", {
  enumerable: true,
  get: function get() {
    return provider_ipcsocket_js_1.IpcSocketProvider;
  }
});
var provider_socket_js_1 = require("./provider-socket.js");
Object.defineProperty(exports, "SocketProvider", {
  enumerable: true,
  get: function get() {
    return provider_socket_js_1.SocketProvider;
  }
});
var provider_websocket_js_1 = require("./provider-websocket.js");
Object.defineProperty(exports, "WebSocketProvider", {
  enumerable: true,
  get: function get() {
    return provider_websocket_js_1.WebSocketProvider;
  }
});
var provider_socket_js_2 = require("./provider-socket.js");
Object.defineProperty(exports, "SocketSubscriber", {
  enumerable: true,
  get: function get() {
    return provider_socket_js_2.SocketSubscriber;
  }
});
Object.defineProperty(exports, "SocketBlockSubscriber", {
  enumerable: true,
  get: function get() {
    return provider_socket_js_2.SocketBlockSubscriber;
  }
});
Object.defineProperty(exports, "SocketPendingSubscriber", {
  enumerable: true,
  get: function get() {
    return provider_socket_js_2.SocketPendingSubscriber;
  }
});
Object.defineProperty(exports, "SocketEventSubscriber", {
  enumerable: true,
  get: function get() {
    return provider_socket_js_2.SocketEventSubscriber;
  }
});

},{"./abstract-provider.js":236,"./abstract-signer.js":237,"./community.js":238,"./default-provider.js":239,"./ens-resolver.js":240,"./network.js":243,"./plugins-network.js":244,"./provider-alchemy.js":245,"./provider-ankr.js":246,"./provider-browser.js":247,"./provider-chainstack.js":248,"./provider-cloudflare.js":249,"./provider-etherscan.js":250,"./provider-fallback.js":251,"./provider-infura.js":252,"./provider-ipcsocket.js":253,"./provider-jsonrpc.js":254,"./provider-pocket.js":255,"./provider-quicknode.js":256,"./provider-socket.js":257,"./provider-websocket.js":258,"./provider.js":259,"./signer-noncemanager.js":260}],243:[function(require,module,exports){
"use strict";

/**
 *  A **Network** encapsulates the various properties required to
 *  interact with a specific chain.
 *
 *  @_subsection: api/providers:Networks  [networks]
 */
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Network = void 0;
var index_js_1 = require("../transaction/index.js");
var index_js_2 = require("../utils/index.js");
var plugins_network_js_1 = require("./plugins-network.js");
/* * * *
// Networks which operation against an L2 can use this plugin to
// specify how to access L1, for the purpose of resolving ENS,
// for example.
export class LayerOneConnectionPlugin extends NetworkPlugin {
    readonly provider!: Provider;
// @TODO: Rename to ChainAccess and allow for connecting to any chain
    constructor(provider: Provider) {
        super("org.ethers.plugins.layer-one-connection");
        defineProperties<LayerOneConnectionPlugin>(this, { provider });
    }

    clone(): LayerOneConnectionPlugin {
        return new LayerOneConnectionPlugin(this.provider);
    }
}
*/
var Networks = new Map();
/**
 *  A **Network** provides access to a chain's properties and allows
 *  for plug-ins to extend functionality.
 */
var _name = /*#__PURE__*/new WeakMap();
var _chainId = /*#__PURE__*/new WeakMap();
var _plugins = /*#__PURE__*/new WeakMap();
var Network = /*#__PURE__*/function () {
  /**
   *  Creates a new **Network** for %%name%% and %%chainId%%.
   */
  function Network(name, chainId) {
    _classCallCheck(this, Network);
    _classPrivateFieldInitSpec(this, _name, void 0);
    _classPrivateFieldInitSpec(this, _chainId, void 0);
    _classPrivateFieldInitSpec(this, _plugins, void 0);
    _classPrivateFieldSet(_name, this, name);
    _classPrivateFieldSet(_chainId, this, (0, index_js_2.getBigInt)(chainId));
    _classPrivateFieldSet(_plugins, this, new Map());
  }
  /**
   *  Returns a JSON-compatible representation of a Network.
   */
  return _createClass(Network, [{
    key: "toJSON",
    value: function toJSON() {
      return {
        name: this.name,
        chainId: String(this.chainId)
      };
    }
    /**
     *  The network common name.
     *
     *  This is the canonical name, as networks migh have multiple
     *  names.
     */
  }, {
    key: "name",
    get: function get() {
      return _classPrivateFieldGet(_name, this);
    },
    set: function set(value) {
      _classPrivateFieldSet(_name, this, value);
    }
    /**
     *  The network chain ID.
     */
  }, {
    key: "chainId",
    get: function get() {
      return _classPrivateFieldGet(_chainId, this);
    },
    set: function set(value) {
      _classPrivateFieldSet(_chainId, this, (0, index_js_2.getBigInt)(value, "chainId"));
    }
    /**
     *  Returns true if %%other%% matches this network. Any chain ID
     *  must match, and if no chain ID is present, the name must match.
     *
     *  This method does not currently check for additional properties,
     *  such as ENS address or plug-in compatibility.
     */
  }, {
    key: "matches",
    value: function matches(other) {
      if (other == null) {
        return false;
      }
      if (typeof other === "string") {
        try {
          return this.chainId === (0, index_js_2.getBigInt)(other);
        } catch (error) {}
        return this.name === other;
      }
      if (typeof other === "number" || typeof other === "bigint") {
        try {
          return this.chainId === (0, index_js_2.getBigInt)(other);
        } catch (error) {}
        return false;
      }
      if (_typeof(other) === "object") {
        if (other.chainId != null) {
          try {
            return this.chainId === (0, index_js_2.getBigInt)(other.chainId);
          } catch (error) {}
          return false;
        }
        if (other.name != null) {
          return this.name === other.name;
        }
        return false;
      }
      return false;
    }
    /**
     *  Returns the list of plugins currently attached to this Network.
     */
  }, {
    key: "plugins",
    get: function get() {
      return Array.from(_classPrivateFieldGet(_plugins, this).values());
    }
    /**
     *  Attach a new %%plugin%% to this Network. The network name
     *  must be unique, excluding any fragment.
     */
  }, {
    key: "attachPlugin",
    value: function attachPlugin(plugin) {
      if (_classPrivateFieldGet(_plugins, this).get(plugin.name)) {
        throw new Error("cannot replace existing plugin: ".concat(plugin.name, " "));
      }
      _classPrivateFieldGet(_plugins, this).set(plugin.name, plugin.clone());
      return this;
    }
    /**
     *  Return the plugin, if any, matching %%name%% exactly. Plugins
     *  with fragments will not be returned unless %%name%% includes
     *  a fragment.
     */
  }, {
    key: "getPlugin",
    value: function getPlugin(name) {
      return _classPrivateFieldGet(_plugins, this).get(name) || null;
    }
    /**
     *  Gets a list of all plugins that match %%name%%, with otr without
     *  a fragment.
     */
  }, {
    key: "getPlugins",
    value: function getPlugins(basename) {
      return this.plugins.filter(function (p) {
        return p.name.split("#")[0] === basename;
      });
    }
    /**
     *  Create a copy of this Network.
     */
  }, {
    key: "clone",
    value: function clone() {
      var clone = new Network(this.name, this.chainId);
      this.plugins.forEach(function (plugin) {
        clone.attachPlugin(plugin.clone());
      });
      return clone;
    }
    /**
     *  Compute the intrinsic gas required for a transaction.
     *
     *  A GasCostPlugin can be attached to override the default
     *  values.
     */
  }, {
    key: "computeIntrinsicGas",
    value: function computeIntrinsicGas(tx) {
      var costs = this.getPlugin("org.ethers.plugins.network.GasCost") || new plugins_network_js_1.GasCostPlugin();
      var gas = costs.txBase;
      if (tx.to == null) {
        gas += costs.txCreate;
      }
      if (tx.data) {
        for (var i = 2; i < tx.data.length; i += 2) {
          if (tx.data.substring(i, i + 2) === "00") {
            gas += costs.txDataZero;
          } else {
            gas += costs.txDataNonzero;
          }
        }
      }
      if (tx.accessList) {
        var accessList = (0, index_js_1.accessListify)(tx.accessList);
        for (var addr in accessList) {
          gas += costs.txAccessListAddress + costs.txAccessListStorageKey * accessList[addr].storageKeys.length;
        }
      }
      return gas;
    }
    /**
     *  Returns a new Network for the %%network%% name or chainId.
     */
  }], [{
    key: "from",
    value: function from(network) {
      injectCommonNetworks();
      // Default network
      if (network == null) {
        return Network.from("mainnet");
      }
      // Canonical name or chain ID
      if (typeof network === "number") {
        network = BigInt(network);
      }
      if (typeof network === "string" || typeof network === "bigint") {
        var networkFunc = Networks.get(network);
        if (networkFunc) {
          return networkFunc();
        }
        if (typeof network === "bigint") {
          return new Network("unknown", network);
        }
        (0, index_js_2.assertArgument)(false, "unknown network", "network", network);
      }
      // Clonable with network-like abilities
      if (typeof network.clone === "function") {
        var clone = network.clone();
        //if (typeof(network.name) !== "string" || typeof(network.chainId) !== "number") {
        //}
        return clone;
      }
      // Networkish
      if (_typeof(network) === "object") {
        (0, index_js_2.assertArgument)(typeof network.name === "string" && typeof network.chainId === "number", "invalid network object name or chainId", "network", network);
        var custom = new Network(network.name, network.chainId);
        if (network.ensAddress || network.ensNetwork != null) {
          custom.attachPlugin(new plugins_network_js_1.EnsPlugin(network.ensAddress, network.ensNetwork));
        }
        //if ((<any>network).layerOneConnection) {
        //    custom.attachPlugin(new LayerOneConnectionPlugin((<any>network).layerOneConnection));
        //}
        return custom;
      }
      (0, index_js_2.assertArgument)(false, "invalid network", "network", network);
    }
    /**
     *  Register %%nameOrChainId%% with a function which returns
     *  an instance of a Network representing that chain.
     */
  }, {
    key: "register",
    value: function register(nameOrChainId, networkFunc) {
      if (typeof nameOrChainId === "number") {
        nameOrChainId = BigInt(nameOrChainId);
      }
      var existing = Networks.get(nameOrChainId);
      if (existing) {
        (0, index_js_2.assertArgument)(false, "conflicting network for ".concat(JSON.stringify(existing.name)), "nameOrChainId", nameOrChainId);
      }
      Networks.set(nameOrChainId, networkFunc);
    }
  }]);
}();
exports.Network = Network;
// We don't want to bring in formatUnits because it is backed by
// FixedNumber and we want to keep Networks tiny. The values
// included by the Gas Stations are also IEEE 754 with lots of
// rounding issues and exceed the strict checks formatUnits has.
function parseUnits(_value, decimals) {
  var value = String(_value);
  if (!value.match(/^[0-9.]+$/)) {
    throw new Error("invalid gwei value: ".concat(_value));
  }
  // Break into [ whole, fraction ]
  var comps = value.split(".");
  if (comps.length === 1) {
    comps.push("");
  }
  // More than 1 decimal point or too many fractional positions
  if (comps.length !== 2) {
    throw new Error("invalid gwei value: ".concat(_value));
  }
  // Pad the fraction to 9 decimalplaces
  while (comps[1].length < decimals) {
    comps[1] += "0";
  }
  // Too many decimals and some non-zero ending, take the ceiling
  if (comps[1].length > 9) {
    var frac = BigInt(comps[1].substring(0, 9));
    if (!comps[1].substring(9).match(/^0+$/)) {
      frac++;
    }
    comps[1] = frac.toString();
  }
  return BigInt(comps[0] + comps[1]);
}
// Used by Polygon to use a gas station for fee data
function getGasStationPlugin(url) {
  return new plugins_network_js_1.FetchUrlFeeDataNetworkPlugin(url, /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(fetchFeeData, provider, request) {
      var response, _yield$Promise$all, _yield$Promise$all2, _response, _feeData, payload, feeData;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            // Prevent Cloudflare from blocking our request in node.js
            request.setHeader("User-Agent", "ethers");
            _context.prev = 1;
            _context.next = 4;
            return Promise.all([request.send(), fetchFeeData()]);
          case 4:
            _yield$Promise$all = _context.sent;
            _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);
            _response = _yield$Promise$all2[0];
            _feeData = _yield$Promise$all2[1];
            response = _response;
            payload = response.bodyJson.standard;
            feeData = {
              gasPrice: _feeData.gasPrice,
              maxFeePerGas: parseUnits(payload.maxFee, 9),
              maxPriorityFeePerGas: parseUnits(payload.maxPriorityFee, 9)
            };
            return _context.abrupt("return", feeData);
          case 14:
            _context.prev = 14;
            _context.t0 = _context["catch"](1);
            (0, index_js_2.assert)(false, "error encountered with polygon gas station (".concat(JSON.stringify(request.url), ")"), "SERVER_ERROR", {
              request: request,
              response: response,
              error: _context.t0
            });
          case 17:
          case "end":
            return _context.stop();
        }
      }, _callee, null, [[1, 14]]);
    }));
    return function (_x, _x2, _x3) {
      return _ref.apply(this, arguments);
    };
  }());
}
// See: https://chainlist.org
var injected = false;
function injectCommonNetworks() {
  if (injected) {
    return;
  }
  injected = true;
  /// Register popular Ethereum networks
  function registerEth(name, chainId, options) {
    var func = function func() {
      var network = new Network(name, chainId);
      // We use 0 to disable ENS
      if (options.ensNetwork != null) {
        network.attachPlugin(new plugins_network_js_1.EnsPlugin(null, options.ensNetwork));
      }
      network.attachPlugin(new plugins_network_js_1.GasCostPlugin());
      (options.plugins || []).forEach(function (plugin) {
        network.attachPlugin(plugin);
      });
      return network;
    };
    // Register the network by name and chain ID
    Network.register(name, func);
    Network.register(chainId, func);
    if (options.altNames) {
      options.altNames.forEach(function (name) {
        Network.register(name, func);
      });
    }
  }
  registerEth("mainnet", 1, {
    ensNetwork: 1,
    altNames: ["homestead"]
  });
  registerEth("ropsten", 3, {
    ensNetwork: 3
  });
  registerEth("rinkeby", 4, {
    ensNetwork: 4
  });
  registerEth("goerli", 5, {
    ensNetwork: 5
  });
  registerEth("kovan", 42, {
    ensNetwork: 42
  });
  registerEth("sepolia", 11155111, {
    ensNetwork: 11155111
  });
  registerEth("holesky", 17000, {
    ensNetwork: 17000
  });
  registerEth("classic", 61, {});
  registerEth("classicKotti", 6, {});
  registerEth("arbitrum", 42161, {
    ensNetwork: 1
  });
  registerEth("arbitrum-goerli", 421613, {});
  registerEth("arbitrum-sepolia", 421614, {});
  registerEth("base", 8453, {
    ensNetwork: 1
  });
  registerEth("base-goerli", 84531, {});
  registerEth("base-sepolia", 84532, {});
  registerEth("bnb", 56, {
    ensNetwork: 1
  });
  registerEth("bnbt", 97, {});
  registerEth("linea", 59144, {
    ensNetwork: 1
  });
  registerEth("linea-goerli", 59140, {});
  registerEth("linea-sepolia", 59141, {});
  registerEth("matic", 137, {
    ensNetwork: 1,
    plugins: [getGasStationPlugin("https:/\/gasstation.polygon.technology/v2")]
  });
  registerEth("matic-amoy", 80002, {});
  registerEth("matic-mumbai", 80001, {
    altNames: ["maticMumbai", "maticmum"],
    plugins: [getGasStationPlugin("https:/\/gasstation-testnet.polygon.technology/v2")]
  });
  registerEth("optimism", 10, {
    ensNetwork: 1,
    plugins: []
  });
  registerEth("optimism-goerli", 420, {});
  registerEth("optimism-sepolia", 11155420, {});
  registerEth("xdai", 100, {
    ensNetwork: 1
  });
}

},{"../transaction/index.js":266,"../utils/index.js":276,"./plugins-network.js":244}],244:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FetchUrlFeeDataNetworkPlugin = exports.FeeDataNetworkPlugin = exports.EnsPlugin = exports.GasCostPlugin = exports.NetworkPlugin = void 0;
var properties_js_1 = require("../utils/properties.js");
var index_js_1 = require("../utils/index.js");
var EnsAddress = "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e";
/**
 *  A **NetworkPlugin** provides additional functionality on a [[Network]].
 */
var NetworkPlugin = /*#__PURE__*/function () {
  /**
   *  Creates a new **NetworkPlugin**.
   */
  function NetworkPlugin(name) {
    _classCallCheck(this, NetworkPlugin);
    /**
     *  The name of the plugin.
     *
     *  It is recommended to use reverse-domain-notation, which permits
     *  unique names with a known authority as well as hierarchal entries.
     */
    _defineProperty(this, "name", void 0);
    (0, properties_js_1.defineProperties)(this, {
      name: name
    });
  }
  /**
   *  Creates a copy of this plugin.
   */
  return _createClass(NetworkPlugin, [{
    key: "clone",
    value: function clone() {
      return new NetworkPlugin(this.name);
    }
  }]);
}();
exports.NetworkPlugin = NetworkPlugin;
/**
 *  A **GasCostPlugin** allows a network to provide alternative values when
 *  computing the intrinsic gas required for a transaction.
 */
var GasCostPlugin = /*#__PURE__*/function (_NetworkPlugin2) {
  /**
   *  Creates a new GasCostPlugin from %%effectiveBlock%% until the
   *  latest block or another GasCostPlugin supercedes that block number,
   *  with the associated %%costs%%.
   */
  function GasCostPlugin(effectiveBlock, costs) {
    var _this;
    _classCallCheck(this, GasCostPlugin);
    if (effectiveBlock == null) {
      effectiveBlock = 0;
    }
    _this = _callSuper(this, GasCostPlugin, ["org.ethers.network.plugins.GasCost#".concat(effectiveBlock || 0)]);
    /**
     *  The block number to treat these values as valid from.
     *
     *  This allows a hardfork to have updated values included as well as
     *  mulutiple hardforks to be supported.
     */
    _defineProperty(_this, "effectiveBlock", void 0);
    /**
     *  The transactions base fee.
     */
    _defineProperty(_this, "txBase", void 0);
    /**
     *  The fee for creating a new account.
     */
    _defineProperty(_this, "txCreate", void 0);
    /**
     *  The fee per zero-byte in the data.
     */
    _defineProperty(_this, "txDataZero", void 0);
    /**
     *  The fee per non-zero-byte in the data.
     */
    _defineProperty(_this, "txDataNonzero", void 0);
    /**
     *  The fee per storage key in the [[link-eip-2930]] access list.
     */
    _defineProperty(_this, "txAccessListStorageKey", void 0);
    /**
     *  The fee per address in the [[link-eip-2930]] access list.
     */
    _defineProperty(_this, "txAccessListAddress", void 0);
    var props = {
      effectiveBlock: effectiveBlock
    };
    function set(name, nullish) {
      var value = (costs || {})[name];
      if (value == null) {
        value = nullish;
      }
      (0, index_js_1.assertArgument)(typeof value === "number", "invalud value for ".concat(name), "costs", costs);
      props[name] = value;
    }
    set("txBase", 21000);
    set("txCreate", 32000);
    set("txDataZero", 4);
    set("txDataNonzero", 16);
    set("txAccessListStorageKey", 1900);
    set("txAccessListAddress", 2400);
    (0, properties_js_1.defineProperties)(_this, props);
    return _this;
  }
  _inherits(GasCostPlugin, _NetworkPlugin2);
  return _createClass(GasCostPlugin, [{
    key: "clone",
    value: function clone() {
      return new GasCostPlugin(this.effectiveBlock, this);
    }
  }]);
}(NetworkPlugin);
exports.GasCostPlugin = GasCostPlugin;
/**
 *  An **EnsPlugin** allows a [[Network]] to specify the ENS Registry
 *  Contract address and the target network to use when using that
 *  contract.
 *
 *  Various testnets have their own instance of the contract to use, but
 *  in general, the mainnet instance supports multi-chain addresses and
 *  should be used.
 */
var EnsPlugin = /*#__PURE__*/function (_NetworkPlugin3) {
  /**
   *  Creates a new **EnsPlugin** connected to %%address%% on the
   *  %%targetNetwork%%. The default ENS address and mainnet is used
   *  if unspecified.
   */
  function EnsPlugin(address, targetNetwork) {
    var _this2;
    _classCallCheck(this, EnsPlugin);
    _this2 = _callSuper(this, EnsPlugin, ["org.ethers.plugins.network.Ens"]);
    /**
     *  The ENS Registrty Contract address.
     */
    _defineProperty(_this2, "address", void 0);
    /**
     *  The chain ID that the ENS contract lives on.
     */
    _defineProperty(_this2, "targetNetwork", void 0);
    (0, properties_js_1.defineProperties)(_this2, {
      address: address || EnsAddress,
      targetNetwork: targetNetwork == null ? 1 : targetNetwork
    });
    return _this2;
  }
  _inherits(EnsPlugin, _NetworkPlugin3);
  return _createClass(EnsPlugin, [{
    key: "clone",
    value: function clone() {
      return new EnsPlugin(this.address, this.targetNetwork);
    }
  }]);
}(NetworkPlugin);
exports.EnsPlugin = EnsPlugin;
/**
 *  A **FeeDataNetworkPlugin** allows a network to provide and alternate
 *  means to specify its fee data.
 *
 *  For example, a network which does not support [[link-eip-1559]] may
 *  choose to use a Gas Station site to approximate the gas price.
 */
var _feeDataFunc = /*#__PURE__*/new WeakMap();
var FeeDataNetworkPlugin = /*#__PURE__*/function (_NetworkPlugin4) {
  /**
   *  Creates a new **FeeDataNetworkPlugin**.
   */
  function FeeDataNetworkPlugin(feeDataFunc) {
    var _this3;
    _classCallCheck(this, FeeDataNetworkPlugin);
    _this3 = _callSuper(this, FeeDataNetworkPlugin, ["org.ethers.plugins.network.FeeData"]);
    _classPrivateFieldInitSpec(_this3, _feeDataFunc, void 0);
    _classPrivateFieldSet(_feeDataFunc, _this3, feeDataFunc);
    return _this3;
  }
  /**
   *  Resolves to the fee data.
   */
  _inherits(FeeDataNetworkPlugin, _NetworkPlugin4);
  return _createClass(FeeDataNetworkPlugin, [{
    key: "feeDataFunc",
    get:
    /**
     *  The fee data function provided to the constructor.
     */
    function get() {
      return _classPrivateFieldGet(_feeDataFunc, this);
    }
  }, {
    key: "getFeeData",
    value: (function () {
      var _getFeeData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(provider) {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return _classPrivateFieldGet(_feeDataFunc, this).call(this, provider);
            case 2:
              return _context.abrupt("return", _context.sent);
            case 3:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function getFeeData(_x) {
        return _getFeeData.apply(this, arguments);
      }
      return getFeeData;
    }())
  }, {
    key: "clone",
    value: function clone() {
      return new FeeDataNetworkPlugin(_classPrivateFieldGet(_feeDataFunc, this));
    }
  }]);
}(NetworkPlugin);
exports.FeeDataNetworkPlugin = FeeDataNetworkPlugin;
var _url = /*#__PURE__*/new WeakMap();
var _processFunc = /*#__PURE__*/new WeakMap();
var FetchUrlFeeDataNetworkPlugin = /*#__PURE__*/function (_NetworkPlugin5) {
  /**
   *  Creates a new **FetchUrlFeeDataNetworkPlugin** which will
   *  be used when computing the fee data for the network.
   */
  function FetchUrlFeeDataNetworkPlugin(url, processFunc) {
    var _this4;
    _classCallCheck(this, FetchUrlFeeDataNetworkPlugin);
    _this4 = _callSuper(this, FetchUrlFeeDataNetworkPlugin, ["org.ethers.plugins.network.FetchUrlFeeDataPlugin"]);
    _classPrivateFieldInitSpec(_this4, _url, void 0);
    _classPrivateFieldInitSpec(_this4, _processFunc, void 0);
    _classPrivateFieldSet(_url, _this4, url);
    _classPrivateFieldSet(_processFunc, _this4, processFunc);
    return _this4;
  }
  // We are immutable, so we can serve as our own clone
  _inherits(FetchUrlFeeDataNetworkPlugin, _NetworkPlugin5);
  return _createClass(FetchUrlFeeDataNetworkPlugin, [{
    key: "url",
    get:
    /**
     *  The URL to initialize the FetchRequest with in %%processFunc%%.
     */
    function get() {
      return _classPrivateFieldGet(_url, this);
    }
    /**
     *  The callback to use when computing the FeeData.
     */
  }, {
    key: "processFunc",
    get: function get() {
      return _classPrivateFieldGet(_processFunc, this);
    }
  }, {
    key: "clone",
    value: function clone() {
      return this;
    }
  }]);
}(NetworkPlugin);
exports.FetchUrlFeeDataNetworkPlugin = FetchUrlFeeDataNetworkPlugin;
/*
export class CustomBlockNetworkPlugin extends NetworkPlugin {
    readonly #blockFunc: (provider: Provider, block: BlockParams<string>) => Block<string>;
    readonly #blockWithTxsFunc: (provider: Provider, block: BlockParams<TransactionResponseParams>) => Block<TransactionResponse>;

    constructor(blockFunc: (provider: Provider, block: BlockParams<string>) => Block<string>, blockWithTxsFunc: (provider: Provider, block: BlockParams<TransactionResponseParams>) => Block<TransactionResponse>) {
        super("org.ethers.network-plugins.custom-block");
        this.#blockFunc = blockFunc;
        this.#blockWithTxsFunc = blockWithTxsFunc;
    }

    async getBlock(provider: Provider, block: BlockParams<string>): Promise<Block<string>> {
        return await this.#blockFunc(provider, block);
    }

    async getBlockions(provider: Provider, block: BlockParams<TransactionResponseParams>): Promise<Block<TransactionResponse>> {
        return await this.#blockWithTxsFunc(provider, block);
    }

    clone(): CustomBlockNetworkPlugin {
        return new CustomBlockNetworkPlugin(this.#blockFunc, this.#blockWithTxsFunc);
    }
}
*/

},{"../utils/index.js":276,"../utils/properties.js":278}],245:[function(require,module,exports){
"use strict";

/**
 *  [[link-alchemy]] provides a third-party service for connecting to
 *  various blockchains over JSON-RPC.
 *
 *  **Supported Networks**
 *
 *  - Ethereum Mainnet (``mainnet``)
 *  - Goerli Testnet (``goerli``)
 *  - Sepolia Testnet (``sepolia``)
 *  - Arbitrum (``arbitrum``)
 *  - Arbitrum Goerli Testnet (``arbitrum-goerli``)
 *  - Arbitrum Sepolia Testnet (``arbitrum-sepolia``)
 *  - Base (``base``)
 *  - Base Goerlia Testnet (``base-goerli``)
 *  - Base Sepolia Testnet (``base-sepolia``)
 *  - Optimism (``optimism``)
 *  - Optimism Goerli Testnet (``optimism-goerli``)
 *  - Optimism Sepolia Testnet (``optimism-sepolia``)
 *  - Polygon (``matic``)
 *  - Polygon Amoy Testnet (``matic-amoy``)
 *  - Polygon Mumbai Testnet (``matic-mumbai``)
 *
 *  @_subsection: api/providers/thirdparty:Alchemy  [providers-alchemy]
 */
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _get() { return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }
function _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AlchemyProvider = void 0;
var index_js_1 = require("../utils/index.js");
var community_js_1 = require("./community.js");
var network_js_1 = require("./network.js");
var provider_jsonrpc_js_1 = require("./provider-jsonrpc.js");
var defaultApiKey = "_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC";
function getHost(name) {
  switch (name) {
    case "mainnet":
      return "eth-mainnet.alchemyapi.io";
    case "goerli":
      return "eth-goerli.g.alchemy.com";
    case "sepolia":
      return "eth-sepolia.g.alchemy.com";
    case "arbitrum":
      return "arb-mainnet.g.alchemy.com";
    case "arbitrum-goerli":
      return "arb-goerli.g.alchemy.com";
    case "arbitrum-sepolia":
      return "arb-sepolia.g.alchemy.com";
    case "base":
      return "base-mainnet.g.alchemy.com";
    case "base-goerli":
      return "base-goerli.g.alchemy.com";
    case "base-sepolia":
      return "base-sepolia.g.alchemy.com";
    case "matic":
      return "polygon-mainnet.g.alchemy.com";
    case "matic-amoy":
      return "polygon-amoy.g.alchemy.com";
    case "matic-mumbai":
      return "polygon-mumbai.g.alchemy.com";
    case "optimism":
      return "opt-mainnet.g.alchemy.com";
    case "optimism-goerli":
      return "opt-goerli.g.alchemy.com";
    case "optimism-sepolia":
      return "opt-sepolia.g.alchemy.com";
  }
  (0, index_js_1.assertArgument)(false, "unsupported network", "network", name);
}
/**
 *  The **AlchemyProvider** connects to the [[link-alchemy]]
 *  JSON-RPC end-points.
 *
 *  By default, a highly-throttled API key is used, which is
 *  appropriate for quick prototypes and simple scripts. To
 *  gain access to an increased rate-limit, it is highly
 *  recommended to [sign up here](link-alchemy-signup).
 *
 *  @_docloc: api/providers/thirdparty
 */
var AlchemyProvider = /*#__PURE__*/function (_provider_jsonrpc_js_) {
  function AlchemyProvider(_network, apiKey) {
    var _this;
    _classCallCheck(this, AlchemyProvider);
    if (_network == null) {
      _network = "mainnet";
    }
    var network = network_js_1.Network.from(_network);
    if (apiKey == null) {
      apiKey = defaultApiKey;
    }
    var request = AlchemyProvider.getRequest(network, apiKey);
    _this = _callSuper(this, AlchemyProvider, [request, network, {
      staticNetwork: network
    }]);
    _defineProperty(_this, "apiKey", void 0);
    (0, index_js_1.defineProperties)(_this, {
      apiKey: apiKey
    });
    return _this;
  }
  _inherits(AlchemyProvider, _provider_jsonrpc_js_);
  return _createClass(AlchemyProvider, [{
    key: "_getProvider",
    value: function _getProvider(chainId) {
      try {
        return new AlchemyProvider(chainId, this.apiKey);
      } catch (error) {}
      return _get(_getPrototypeOf(AlchemyProvider.prototype), "_getProvider", this).call(this, chainId);
    }
  }, {
    key: "_perform",
    value: function () {
      var _perform2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(req) {
        var _yield, trace, tx, data, error;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              if (!(req.method === "getTransactionResult")) {
                _context.next = 14;
                break;
              }
              _context.next = 3;
              return (0, index_js_1.resolveProperties)({
                trace: this.send("trace_transaction", [req.hash]),
                tx: this.getTransaction(req.hash)
              });
            case 3:
              _yield = _context.sent;
              trace = _yield.trace;
              tx = _yield.tx;
              if (!(trace == null || tx == null)) {
                _context.next = 8;
                break;
              }
              return _context.abrupt("return", null);
            case 8:
              error = false;
              try {
                data = trace[0].result.output;
                error = trace[0].error === "Reverted";
              } catch (error) {}
              if (!data) {
                _context.next = 13;
                break;
              }
              (0, index_js_1.assert)(!error, "an error occurred during transaction executions", "CALL_EXCEPTION", {
                action: "getTransactionResult",
                data: data,
                reason: null,
                transaction: tx,
                invocation: null,
                revert: null // @TODO
              });
              return _context.abrupt("return", data);
            case 13:
              (0, index_js_1.assert)(false, "could not parse trace result", "BAD_DATA", {
                value: trace
              });
            case 14:
              _context.next = 16;
              return _get(_getPrototypeOf(AlchemyProvider.prototype), "_perform", this).call(this, req);
            case 16:
              return _context.abrupt("return", _context.sent);
            case 17:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function _perform(_x) {
        return _perform2.apply(this, arguments);
      }
      return _perform;
    }()
  }, {
    key: "isCommunityResource",
    value: function isCommunityResource() {
      return this.apiKey === defaultApiKey;
    }
  }], [{
    key: "getRequest",
    value: function getRequest(network, apiKey) {
      if (apiKey == null) {
        apiKey = defaultApiKey;
      }
      var request = new index_js_1.FetchRequest("https://".concat(getHost(network.name), "/v2/").concat(apiKey));
      request.allowGzip = true;
      if (apiKey === defaultApiKey) {
        request.retryFunc = /*#__PURE__*/function () {
          var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(request, response, attempt) {
            return _regeneratorRuntime().wrap(function _callee2$(_context2) {
              while (1) switch (_context2.prev = _context2.next) {
                case 0:
                  (0, community_js_1.showThrottleMessage)("alchemy");
                  return _context2.abrupt("return", true);
                case 2:
                case "end":
                  return _context2.stop();
              }
            }, _callee2);
          }));
          return function (_x2, _x3, _x4) {
            return _ref.apply(this, arguments);
          };
        }();
      }
      return request;
    }
  }]);
}(provider_jsonrpc_js_1.JsonRpcProvider);
exports.AlchemyProvider = AlchemyProvider;

},{"../utils/index.js":276,"./community.js":238,"./network.js":243,"./provider-jsonrpc.js":254}],246:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _get() { return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }
function _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AnkrProvider = void 0;
/**
 *  [[link-ankr]] provides a third-party service for connecting to
 *  various blockchains over JSON-RPC.
 *
 *  **Supported Networks**
 *
 *  - Ethereum Mainnet (``mainnet``)
 *  - Goerli Testnet (``goerli``)
 *  - Sepolia Testnet (``sepolia``)
 *  - Arbitrum (``arbitrum``)
 *  - Base (``base``)
 *  - Base Goerlia Testnet (``base-goerli``)
 *  - Base Sepolia Testnet (``base-sepolia``)
 *  - BNB (``bnb``)
 *  - BNB Testnet (``bnbt``)
 *  - Optimism (``optimism``)
 *  - Optimism Goerli Testnet (``optimism-goerli``)
 *  - Optimism Sepolia Testnet (``optimism-sepolia``)
 *  - Polygon (``matic``)
 *  - Polygon Mumbai Testnet (``matic-mumbai``)
 *
 *  @_subsection: api/providers/thirdparty:Ankr  [providers-ankr]
 */
var index_js_1 = require("../utils/index.js");
var community_js_1 = require("./community.js");
var network_js_1 = require("./network.js");
var provider_jsonrpc_js_1 = require("./provider-jsonrpc.js");
var defaultApiKey = "9f7d929b018cdffb338517efa06f58359e86ff1ffd350bc889738523659e7972";
function getHost(name) {
  switch (name) {
    case "mainnet":
      return "rpc.ankr.com/eth";
    case "goerli":
      return "rpc.ankr.com/eth_goerli";
    case "sepolia":
      return "rpc.ankr.com/eth_sepolia";
    case "arbitrum":
      return "rpc.ankr.com/arbitrum";
    case "base":
      return "rpc.ankr.com/base";
    case "base-goerli":
      return "rpc.ankr.com/base_goerli";
    case "base-sepolia":
      return "rpc.ankr.com/base_sepolia";
    case "bnb":
      return "rpc.ankr.com/bsc";
    case "bnbt":
      return "rpc.ankr.com/bsc_testnet_chapel";
    case "matic":
      return "rpc.ankr.com/polygon";
    case "matic-mumbai":
      return "rpc.ankr.com/polygon_mumbai";
    case "optimism":
      return "rpc.ankr.com/optimism";
    case "optimism-goerli":
      return "rpc.ankr.com/optimism_testnet";
    case "optimism-sepolia":
      return "rpc.ankr.com/optimism_sepolia";
  }
  (0, index_js_1.assertArgument)(false, "unsupported network", "network", name);
}
/**
 *  The **AnkrProvider** connects to the [[link-ankr]]
 *  JSON-RPC end-points.
 *
 *  By default, a highly-throttled API key is used, which is
 *  appropriate for quick prototypes and simple scripts. To
 *  gain access to an increased rate-limit, it is highly
 *  recommended to [sign up here](link-ankr-signup).
 */
var AnkrProvider = /*#__PURE__*/function (_provider_jsonrpc_js_) {
  /**
   *  Create a new **AnkrProvider**.
   *
   *  By default connecting to ``mainnet`` with a highly throttled
   *  API key.
   */
  function AnkrProvider(_network, apiKey) {
    var _this;
    _classCallCheck(this, AnkrProvider);
    if (_network == null) {
      _network = "mainnet";
    }
    var network = network_js_1.Network.from(_network);
    if (apiKey == null) {
      apiKey = defaultApiKey;
    }
    // Ankr does not support filterId, so we force polling
    var options = {
      polling: true,
      staticNetwork: network
    };
    var request = AnkrProvider.getRequest(network, apiKey);
    _this = _callSuper(this, AnkrProvider, [request, network, options]);
    /**
     *  The API key for the Ankr connection.
     */
    _defineProperty(_this, "apiKey", void 0);
    (0, index_js_1.defineProperties)(_this, {
      apiKey: apiKey
    });
    return _this;
  }
  _inherits(AnkrProvider, _provider_jsonrpc_js_);
  return _createClass(AnkrProvider, [{
    key: "_getProvider",
    value: function _getProvider(chainId) {
      try {
        return new AnkrProvider(chainId, this.apiKey);
      } catch (error) {}
      return _get(_getPrototypeOf(AnkrProvider.prototype), "_getProvider", this).call(this, chainId);
    }
    /**
     *  Returns a prepared request for connecting to %%network%% with
     *  %%apiKey%%.
     */
  }, {
    key: "getRpcError",
    value: function getRpcError(payload, error) {
      if (payload.method === "eth_sendRawTransaction") {
        if (error && error.error && error.error.message === "INTERNAL_ERROR: could not replace existing tx") {
          error.error.message = "replacement transaction underpriced";
        }
      }
      return _get(_getPrototypeOf(AnkrProvider.prototype), "getRpcError", this).call(this, payload, error);
    }
  }, {
    key: "isCommunityResource",
    value: function isCommunityResource() {
      return this.apiKey === defaultApiKey;
    }
  }], [{
    key: "getRequest",
    value: function getRequest(network, apiKey) {
      if (apiKey == null) {
        apiKey = defaultApiKey;
      }
      var request = new index_js_1.FetchRequest("https://".concat(getHost(network.name), "/").concat(apiKey));
      request.allowGzip = true;
      if (apiKey === defaultApiKey) {
        request.retryFunc = /*#__PURE__*/function () {
          var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(request, response, attempt) {
            return _regeneratorRuntime().wrap(function _callee$(_context) {
              while (1) switch (_context.prev = _context.next) {
                case 0:
                  (0, community_js_1.showThrottleMessage)("AnkrProvider");
                  return _context.abrupt("return", true);
                case 2:
                case "end":
                  return _context.stop();
              }
            }, _callee);
          }));
          return function (_x, _x2, _x3) {
            return _ref.apply(this, arguments);
          };
        }();
      }
      return request;
    }
  }]);
}(provider_jsonrpc_js_1.JsonRpcProvider);
exports.AnkrProvider = AnkrProvider;

},{"../utils/index.js":276,"./community.js":238,"./network.js":243,"./provider-jsonrpc.js":254}],247:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _get() { return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }
function _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BrowserProvider = void 0;
var index_js_1 = require("../utils/index.js");
var provider_jsonrpc_js_1 = require("./provider-jsonrpc.js");
;
/**
 *  A **BrowserProvider** is intended to wrap an injected provider which
 *  adheres to the [[link-eip-1193]] standard, which most (if not all)
 *  currently do.
 */
var _request = /*#__PURE__*/new WeakMap();
var BrowserProvider = /*#__PURE__*/function (_provider_jsonrpc_js_) {
  /**
   *  Connnect to the %%ethereum%% provider, optionally forcing the
   *  %%network%%.
   */
  function BrowserProvider(ethereum, network, _options) {
    var _this;
    _classCallCheck(this, BrowserProvider);
    // Copy the options
    var options = Object.assign({}, _options != null ? _options : {}, {
      batchMaxCount: 1
    });
    (0, index_js_1.assertArgument)(ethereum && ethereum.request, "invalid EIP-1193 provider", "ethereum", ethereum);
    _this = _callSuper(this, BrowserProvider, [network, options]);
    _classPrivateFieldInitSpec(_this, _request, void 0);
    _classPrivateFieldSet(_request, _this, /*#__PURE__*/function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(method, params) {
        var payload, result, error;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              payload = {
                method: method,
                params: params
              };
              _this.emit("debug", {
                action: "sendEip1193Request",
                payload: payload
              });
              _context.prev = 2;
              _context.next = 5;
              return ethereum.request(payload);
            case 5:
              result = _context.sent;
              _this.emit("debug", {
                action: "receiveEip1193Result",
                result: result
              });
              return _context.abrupt("return", result);
            case 10:
              _context.prev = 10;
              _context.t0 = _context["catch"](2);
              error = new Error(_context.t0.message);
              error.code = _context.t0.code;
              error.data = _context.t0.data;
              error.payload = payload;
              _this.emit("debug", {
                action: "receiveEip1193Error",
                error: error
              });
              throw error;
            case 18:
            case "end":
              return _context.stop();
          }
        }, _callee, null, [[2, 10]]);
      }));
      return function (_x, _x2) {
        return _ref.apply(this, arguments);
      };
    }());
    return _this;
  }
  _inherits(BrowserProvider, _provider_jsonrpc_js_);
  return _createClass(BrowserProvider, [{
    key: "send",
    value: function () {
      var _send2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(method, params) {
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return this._start();
            case 2:
              _context2.next = 4;
              return _get(_getPrototypeOf(BrowserProvider.prototype), "send", this).call(this, method, params);
            case 4:
              return _context2.abrupt("return", _context2.sent);
            case 5:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function send(_x3, _x4) {
        return _send2.apply(this, arguments);
      }
      return send;
    }()
  }, {
    key: "_send",
    value: function () {
      var _send3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(payload) {
        var result;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              (0, index_js_1.assertArgument)(!Array.isArray(payload), "EIP-1193 does not support batch request", "payload", payload);
              _context3.prev = 1;
              _context3.next = 4;
              return _classPrivateFieldGet(_request, this).call(this, payload.method, payload.params || []);
            case 4:
              result = _context3.sent;
              return _context3.abrupt("return", [{
                id: payload.id,
                result: result
              }]);
            case 8:
              _context3.prev = 8;
              _context3.t0 = _context3["catch"](1);
              return _context3.abrupt("return", [{
                id: payload.id,
                error: {
                  code: _context3.t0.code,
                  data: _context3.t0.data,
                  message: _context3.t0.message
                }
              }]);
            case 11:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this, [[1, 8]]);
      }));
      function _send(_x5) {
        return _send3.apply(this, arguments);
      }
      return _send;
    }()
  }, {
    key: "getRpcError",
    value: function getRpcError(payload, error) {
      error = JSON.parse(JSON.stringify(error));
      // EIP-1193 gives us some machine-readable error codes, so rewrite
      // them into 
      switch (error.error.code || -1) {
        case 4001:
          error.error.message = "ethers-user-denied: ".concat(error.error.message);
          break;
        case 4200:
          error.error.message = "ethers-unsupported: ".concat(error.error.message);
          break;
      }
      return _get(_getPrototypeOf(BrowserProvider.prototype), "getRpcError", this).call(this, payload, error);
    }
    /**
     *  Resolves to ``true`` if the provider manages the %%address%%.
     */
  }, {
    key: "hasSigner",
    value: (function () {
      var _hasSigner = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(address) {
        var accounts;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              if (address == null) {
                address = 0;
              }
              _context4.next = 3;
              return this.send("eth_accounts", []);
            case 3:
              accounts = _context4.sent;
              if (!(typeof address === "number")) {
                _context4.next = 6;
                break;
              }
              return _context4.abrupt("return", accounts.length > address);
            case 6:
              address = address.toLowerCase();
              return _context4.abrupt("return", accounts.filter(function (a) {
                return a.toLowerCase() === address;
              }).length !== 0);
            case 8:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));
      function hasSigner(_x6) {
        return _hasSigner.apply(this, arguments);
      }
      return hasSigner;
    }())
  }, {
    key: "getSigner",
    value: function () {
      var _getSigner = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(address) {
        var payload;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              if (address == null) {
                address = 0;
              }
              _context5.next = 3;
              return this.hasSigner(address);
            case 3:
              if (_context5.sent) {
                _context5.next = 13;
                break;
              }
              _context5.prev = 4;
              _context5.next = 7;
              return _classPrivateFieldGet(_request, this).call(this, "eth_requestAccounts", []);
            case 7:
              _context5.next = 13;
              break;
            case 9:
              _context5.prev = 9;
              _context5.t0 = _context5["catch"](4);
              payload = _context5.t0.payload;
              throw this.getRpcError(payload, {
                id: payload.id,
                error: _context5.t0
              });
            case 13:
              _context5.next = 15;
              return _get(_getPrototypeOf(BrowserProvider.prototype), "getSigner", this).call(this, address);
            case 15:
              return _context5.abrupt("return", _context5.sent);
            case 16:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this, [[4, 9]]);
      }));
      function getSigner(_x7) {
        return _getSigner.apply(this, arguments);
      }
      return getSigner;
    }()
  }]);
}(provider_jsonrpc_js_1.JsonRpcApiPollingProvider);
exports.BrowserProvider = BrowserProvider;

},{"../utils/index.js":276,"./provider-jsonrpc.js":254}],248:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _get() { return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }
function _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ChainstackProvider = void 0;
/**
 *  [[link-chainstack]] provides a third-party service for connecting to
 *  various blockchains over JSON-RPC.
 *
 *  **Supported Networks**
 *
 *  - Ethereum Mainnet (``mainnet``)
 *  - Arbitrum (``arbitrum``)
 *  - BNB Smart Chain Mainnet (``bnb``)
 *  - Polygon (``matic``)
 *
 *  @_subsection: api/providers/thirdparty:Chainstack  [providers-chainstack]
 */
var index_js_1 = require("../utils/index.js");
var community_js_1 = require("./community.js");
var network_js_1 = require("./network.js");
var provider_jsonrpc_js_1 = require("./provider-jsonrpc.js");
function getApiKey(name) {
  switch (name) {
    case "mainnet":
      return "39f1d67cedf8b7831010a665328c9197";
    case "arbitrum":
      return "0550c209db33c3abf4cc927e1e18cea1";
    case "bnb":
      return "98b5a77e531614387366f6fc5da097f8";
    case "matic":
      return "cd9d4d70377471aa7c142ec4a4205249";
  }
  (0, index_js_1.assertArgument)(false, "unsupported network", "network", name);
}
function getHost(name) {
  switch (name) {
    case "mainnet":
      return "ethereum-mainnet.core.chainstack.com";
    case "arbitrum":
      return "arbitrum-mainnet.core.chainstack.com";
    case "bnb":
      return "bsc-mainnet.core.chainstack.com";
    case "matic":
      return "polygon-mainnet.core.chainstack.com";
  }
  (0, index_js_1.assertArgument)(false, "unsupported network", "network", name);
}
/**
 *  The **ChainstackProvider** connects to the [[link-chainstack]]
 *  JSON-RPC end-points.
 *
 *  By default, a highly-throttled API key is used, which is
 *  appropriate for quick prototypes and simple scripts. To
 *  gain access to an increased rate-limit, it is highly
 *  recommended to [sign up here](link-chainstack).
 */
var ChainstackProvider = /*#__PURE__*/function (_provider_jsonrpc_js_) {
  /**
   *  Creates a new **ChainstackProvider**.
   */
  function ChainstackProvider(_network, apiKey) {
    var _this;
    _classCallCheck(this, ChainstackProvider);
    if (_network == null) {
      _network = "mainnet";
    }
    var network = network_js_1.Network.from(_network);
    if (apiKey == null) {
      apiKey = getApiKey(network.name);
    }
    var request = ChainstackProvider.getRequest(network, apiKey);
    _this = _callSuper(this, ChainstackProvider, [request, network, {
      staticNetwork: network
    }]);
    /**
     *  The API key for the Chainstack connection.
     */
    _defineProperty(_this, "apiKey", void 0);
    (0, index_js_1.defineProperties)(_this, {
      apiKey: apiKey
    });
    return _this;
  }
  _inherits(ChainstackProvider, _provider_jsonrpc_js_);
  return _createClass(ChainstackProvider, [{
    key: "_getProvider",
    value: function _getProvider(chainId) {
      try {
        return new ChainstackProvider(chainId, this.apiKey);
      } catch (error) {}
      return _get(_getPrototypeOf(ChainstackProvider.prototype), "_getProvider", this).call(this, chainId);
    }
  }, {
    key: "isCommunityResource",
    value: function isCommunityResource() {
      return this.apiKey === getApiKey(this._network.name);
    }
    /**
     *  Returns a prepared request for connecting to %%network%%
     *  with %%apiKey%% and %%projectSecret%%.
     */
  }], [{
    key: "getRequest",
    value: function getRequest(network, apiKey) {
      if (apiKey == null) {
        apiKey = getApiKey(network.name);
      }
      var request = new index_js_1.FetchRequest("https://".concat(getHost(network.name), "/").concat(apiKey));
      request.allowGzip = true;
      if (apiKey === getApiKey(network.name)) {
        request.retryFunc = /*#__PURE__*/function () {
          var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(request, response, attempt) {
            return _regeneratorRuntime().wrap(function _callee$(_context) {
              while (1) switch (_context.prev = _context.next) {
                case 0:
                  (0, community_js_1.showThrottleMessage)("ChainstackProvider");
                  return _context.abrupt("return", true);
                case 2:
                case "end":
                  return _context.stop();
              }
            }, _callee);
          }));
          return function (_x, _x2, _x3) {
            return _ref.apply(this, arguments);
          };
        }();
      }
      return request;
    }
  }]);
}(provider_jsonrpc_js_1.JsonRpcProvider);
exports.ChainstackProvider = ChainstackProvider;

},{"../utils/index.js":276,"./community.js":238,"./network.js":243,"./provider-jsonrpc.js":254}],249:[function(require,module,exports){
"use strict";

/**
 *  About Cloudflare
 *
 *  @_subsection: api/providers/thirdparty:Cloudflare  [providers-cloudflare]
 */
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CloudflareProvider = void 0;
var index_js_1 = require("../utils/index.js");
var network_js_1 = require("./network.js");
var provider_jsonrpc_js_1 = require("./provider-jsonrpc.js");
/**
 *  About Cloudflare...
 */
var CloudflareProvider = /*#__PURE__*/function (_provider_jsonrpc_js_) {
  function CloudflareProvider(_network) {
    _classCallCheck(this, CloudflareProvider);
    if (_network == null) {
      _network = "mainnet";
    }
    var network = network_js_1.Network.from(_network);
    (0, index_js_1.assertArgument)(network.name === "mainnet", "unsupported network", "network", _network);
    return _callSuper(this, CloudflareProvider, ["https:/\/cloudflare-eth.com/", network, {
      staticNetwork: network
    }]);
  }
  _inherits(CloudflareProvider, _provider_jsonrpc_js_);
  return _createClass(CloudflareProvider);
}(provider_jsonrpc_js_1.JsonRpcProvider);
exports.CloudflareProvider = CloudflareProvider;

},{"../utils/index.js":276,"./network.js":243,"./provider-jsonrpc.js":254}],250:[function(require,module,exports){
"use strict";

/**
 *  [[link-etherscan]] provides a third-party service for connecting to
 *  various blockchains over a combination of JSON-RPC and custom API
 *  endpoints.
 *
 *  **Supported Networks**
 *
 *  - Ethereum Mainnet (``mainnet``)
 *  - Goerli Testnet (``goerli``)
 *  - Sepolia Testnet (``sepolia``)
 *  - Holesky Testnet (``holesky``)
 *  - Arbitrum (``arbitrum``)
 *  - Arbitrum Goerli Testnet (``arbitrum-goerli``)
 *  - Base (``base``)
 *  - Base Sepolia Testnet (``base-sepolia``)
 *  - BNB Smart Chain Mainnet (``bnb``)
 *  - BNB Smart Chain Testnet (``bnbt``)
 *  - Optimism (``optimism``)
 *  - Optimism Goerli Testnet (``optimism-goerli``)
 *  - Polygon (``matic``)
 *  - Polygon Mumbai Testnet (``matic-mumbai``)
 *  - Polygon Amoy Testnet (``matic-amoy``)
 *
 *  @_subsection api/providers/thirdparty:Etherscan  [providers-etherscan]
 */
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _get() { return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }
function _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EtherscanProvider = exports.EtherscanPlugin = void 0;
var index_js_1 = require("../abi/index.js");
var index_js_2 = require("../contract/index.js");
var index_js_3 = require("../transaction/index.js");
var index_js_4 = require("../utils/index.js");
var abstract_provider_js_1 = require("./abstract-provider.js");
var network_js_1 = require("./network.js");
var plugins_network_js_1 = require("./plugins-network.js");
var community_js_1 = require("./community.js");
var THROTTLE = 2000;
function isPromise(value) {
  return value && typeof value.then === "function";
}
var EtherscanPluginId = "org.ethers.plugins.provider.Etherscan";
/**
 *  A Network can include an **EtherscanPlugin** to provide
 *  a custom base URL.
 *
 *  @_docloc: api/providers/thirdparty:Etherscan
 */
var EtherscanPlugin = /*#__PURE__*/function (_plugins_network_js_) {
  /**
   *  Creates a new **EtherscanProvider** which will use
   *  %%baseUrl%%.
   */
  function EtherscanPlugin(baseUrl) {
    var _this;
    _classCallCheck(this, EtherscanPlugin);
    _this = _callSuper(this, EtherscanPlugin, [EtherscanPluginId]);
    /**
     *  The Etherscan API base URL.
     */
    _defineProperty(_this, "baseUrl", void 0);
    (0, index_js_4.defineProperties)(_this, {
      baseUrl: baseUrl
    });
    return _this;
  }
  _inherits(EtherscanPlugin, _plugins_network_js_);
  return _createClass(EtherscanPlugin, [{
    key: "clone",
    value: function clone() {
      return new EtherscanPlugin(this.baseUrl);
    }
  }]);
}(plugins_network_js_1.NetworkPlugin);
exports.EtherscanPlugin = EtherscanPlugin;
var skipKeys = ["enableCcipRead"];
var nextId = 1;
/**
 *  The **EtherscanBaseProvider** is the super-class of
 *  [[EtherscanProvider]], which should generally be used instead.
 *
 *  Since the **EtherscanProvider** includes additional code for
 *  [[Contract]] access, in //rare cases// that contracts are not
 *  used, this class can reduce code size.
 *
 *  @_docloc: api/providers/thirdparty:Etherscan
 */
var _plugin = /*#__PURE__*/new WeakMap();
var EtherscanProvider = /*#__PURE__*/function (_abstract_provider_js) {
  /**
   *  Creates a new **EtherscanBaseProvider**.
   */
  function EtherscanProvider(_network, _apiKey) {
    var _this2;
    _classCallCheck(this, EtherscanProvider);
    var apiKey = _apiKey != null ? _apiKey : null;
    _this2 = _callSuper(this, EtherscanProvider);
    /**
     *  The connected network.
     */
    _defineProperty(_this2, "network", void 0);
    /**
     *  The API key or null if using the community provided bandwidth.
     */
    _defineProperty(_this2, "apiKey", void 0);
    _classPrivateFieldInitSpec(_this2, _plugin, void 0);
    var network = network_js_1.Network.from(_network);
    _classPrivateFieldSet(_plugin, _this2, network.getPlugin(EtherscanPluginId));
    (0, index_js_4.defineProperties)(_this2, {
      apiKey: apiKey,
      network: network
    });
    // Test that the network is supported by Etherscan
    _this2.getBaseUrl();
    return _this2;
  }
  /**
   *  Returns the base URL.
   *
   *  If an [[EtherscanPlugin]] is configured on the
   *  [[EtherscanBaseProvider_network]], returns the plugin's
   *  baseUrl.
   */
  _inherits(EtherscanProvider, _abstract_provider_js);
  return _createClass(EtherscanProvider, [{
    key: "getBaseUrl",
    value: function getBaseUrl() {
      if (_classPrivateFieldGet(_plugin, this)) {
        return _classPrivateFieldGet(_plugin, this).baseUrl;
      }
      switch (this.network.name) {
        case "mainnet":
          return "https:/\/api.etherscan.io";
        case "goerli":
          return "https:/\/api-goerli.etherscan.io";
        case "sepolia":
          return "https:/\/api-sepolia.etherscan.io";
        case "holesky":
          return "https:/\/api-holesky.etherscan.io";
        case "arbitrum":
          return "https:/\/api.arbiscan.io";
        case "arbitrum-goerli":
          return "https:/\/api-goerli.arbiscan.io";
        case "base":
          return "https:/\/api.basescan.org";
        case "base-sepolia":
          return "https:/\/api-sepolia.basescan.org";
        case "bnb":
          return "https:/\/api.bscscan.com";
        case "bnbt":
          return "https:/\/api-testnet.bscscan.com";
        case "matic":
          return "https:/\/api.polygonscan.com";
        case "matic-amoy":
          return "https:/\/api-amoy.polygonscan.com";
        case "matic-mumbai":
          return "https:/\/api-testnet.polygonscan.com";
        case "optimism":
          return "https:/\/api-optimistic.etherscan.io";
        case "optimism-goerli":
          return "https:/\/api-goerli-optimistic.etherscan.io";
        default:
      }
      (0, index_js_4.assertArgument)(false, "unsupported network", "network", this.network);
    }
    /**
     *  Returns the URL for the %%module%% and %%params%%.
     */
  }, {
    key: "getUrl",
    value: function getUrl(module, params) {
      var query = Object.keys(params).reduce(function (accum, key) {
        var value = params[key];
        if (value != null) {
          accum += "&".concat(key, "=").concat(value);
        }
        return accum;
      }, "");
      var apiKey = this.apiKey ? "&apikey=".concat(this.apiKey) : "";
      return "".concat(this.getBaseUrl(), "/api?module=").concat(module).concat(query).concat(apiKey);
    }
    /**
     *  Returns the URL for using POST requests.
     */
  }, {
    key: "getPostUrl",
    value: function getPostUrl() {
      return "".concat(this.getBaseUrl(), "/api");
    }
    /**
     *  Returns the parameters for using POST requests.
     */
  }, {
    key: "getPostData",
    value: function getPostData(module, params) {
      params.module = module;
      params.apikey = this.apiKey;
      return params;
    }
  }, {
    key: "detectNetwork",
    value: function () {
      var _detectNetwork2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", this.network);
            case 1:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function detectNetwork() {
        return _detectNetwork2.apply(this, arguments);
      }
      return detectNetwork;
    }()
    /**
     *  Resolves to the result of calling %%module%% with %%params%%.
     *
     *  If %%post%%, the request is made as a POST request.
     */
  }, {
    key: "fetch",
    value: (function () {
      var _fetch = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(module, params, post) {
        var _this3 = this;
        var id, url, payload, request, response, result;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              id = nextId++;
              url = post ? this.getPostUrl() : this.getUrl(module, params);
              payload = post ? this.getPostData(module, params) : null;
              this.emit("debug", {
                action: "sendRequest",
                id: id,
                url: url,
                payload: payload
              });
              request = new index_js_4.FetchRequest(url);
              request.setThrottleParams({
                slotInterval: 1000
              });
              request.retryFunc = function (req, resp, attempt) {
                if (_this3.isCommunityResource()) {
                  (0, community_js_1.showThrottleMessage)("Etherscan");
                }
                return Promise.resolve(true);
              };
              request.processFunc = /*#__PURE__*/function () {
                var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(request, response) {
                  var result, throttle;
                  return _regeneratorRuntime().wrap(function _callee2$(_context2) {
                    while (1) switch (_context2.prev = _context2.next) {
                      case 0:
                        result = response.hasBody() ? JSON.parse((0, index_js_4.toUtf8String)(response.body)) : {};
                        throttle = (typeof result.result === "string" ? result.result : "").toLowerCase().indexOf("rate limit") >= 0;
                        if (module === "proxy") {
                          // This JSON response indicates we are being throttled
                          if (result && result.status == 0 && result.message == "NOTOK" && throttle) {
                            _this3.emit("debug", {
                              action: "receiveError",
                              id: id,
                              reason: "proxy-NOTOK",
                              error: result
                            });
                            response.throwThrottleError(result.result, THROTTLE);
                          }
                        } else {
                          if (throttle) {
                            _this3.emit("debug", {
                              action: "receiveError",
                              id: id,
                              reason: "null result",
                              error: result.result
                            });
                            response.throwThrottleError(result.result, THROTTLE);
                          }
                        }
                        return _context2.abrupt("return", response);
                      case 4:
                      case "end":
                        return _context2.stop();
                    }
                  }, _callee2);
                }));
                return function (_x4, _x5) {
                  return _ref.apply(this, arguments);
                };
              }();
              if (payload) {
                request.setHeader("content-type", "application/x-www-form-urlencoded; charset=UTF-8");
                request.body = Object.keys(payload).map(function (k) {
                  return "".concat(k, "=").concat(payload[k]);
                }).join("&");
              }
              _context3.next = 11;
              return request.send();
            case 11:
              response = _context3.sent;
              try {
                response.assertOk();
              } catch (error) {
                this.emit("debug", {
                  action: "receiveError",
                  id: id,
                  error: error,
                  reason: "assertOk"
                });
                (0, index_js_4.assert)(false, "response error", "SERVER_ERROR", {
                  request: request,
                  response: response
                });
              }
              if (!response.hasBody()) {
                this.emit("debug", {
                  action: "receiveError",
                  id: id,
                  error: "missing body",
                  reason: "null body"
                });
                (0, index_js_4.assert)(false, "missing response", "SERVER_ERROR", {
                  request: request,
                  response: response
                });
              }
              result = JSON.parse((0, index_js_4.toUtf8String)(response.body));
              if (!(module === "proxy")) {
                _context3.next = 22;
                break;
              }
              if (result.jsonrpc != "2.0") {
                this.emit("debug", {
                  action: "receiveError",
                  id: id,
                  result: result,
                  reason: "invalid JSON-RPC"
                });
                (0, index_js_4.assert)(false, "invalid JSON-RPC response (missing jsonrpc='2.0')", "SERVER_ERROR", {
                  request: request,
                  response: response,
                  info: {
                    result: result
                  }
                });
              }
              if (result.error) {
                this.emit("debug", {
                  action: "receiveError",
                  id: id,
                  result: result,
                  reason: "JSON-RPC error"
                });
                (0, index_js_4.assert)(false, "error response", "SERVER_ERROR", {
                  request: request,
                  response: response,
                  info: {
                    result: result
                  }
                });
              }
              this.emit("debug", {
                action: "receiveRequest",
                id: id,
                result: result
              });
              return _context3.abrupt("return", result.result);
            case 22:
              if (!(result.status == 0 && (result.message === "No records found" || result.message === "No transactions found"))) {
                _context3.next = 25;
                break;
              }
              this.emit("debug", {
                action: "receiveRequest",
                id: id,
                result: result
              });
              return _context3.abrupt("return", result.result);
            case 25:
              if (result.status != 1 || typeof result.message === "string" && !result.message.match(/^OK/)) {
                this.emit("debug", {
                  action: "receiveError",
                  id: id,
                  result: result
                });
                (0, index_js_4.assert)(false, "error response", "SERVER_ERROR", {
                  request: request,
                  response: response,
                  info: {
                    result: result
                  }
                });
              }
              this.emit("debug", {
                action: "receiveRequest",
                id: id,
                result: result
              });
              return _context3.abrupt("return", result.result);
            case 28:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function fetch(_x, _x2, _x3) {
        return _fetch.apply(this, arguments);
      }
      return fetch;
    }()
    /**
     *  Returns %%transaction%% normalized for the Etherscan API.
     */
    )
  }, {
    key: "_getTransactionPostData",
    value: function _getTransactionPostData(transaction) {
      var result = {};
      for (var key in transaction) {
        if (skipKeys.indexOf(key) >= 0) {
          continue;
        }
        if (transaction[key] == null) {
          continue;
        }
        var value = transaction[key];
        if (key === "type" && value === 0) {
          continue;
        }
        if (key === "blockTag" && value === "latest") {
          continue;
        }
        // Quantity-types require no leading zero, unless 0
        if ({
          type: true,
          gasLimit: true,
          gasPrice: true,
          maxFeePerGs: true,
          maxPriorityFeePerGas: true,
          nonce: true,
          value: true
        }[key]) {
          value = (0, index_js_4.toQuantity)(value);
        } else if (key === "accessList") {
          value = "[" + (0, index_js_3.accessListify)(value).map(function (set) {
            return "{address:\"".concat(set.address, "\",storageKeys:[\"").concat(set.storageKeys.join('","'), "\"]}");
          }).join(",") + "]";
        } else if (key === "blobVersionedHashes") {
          if (value.length === 0) {
            continue;
          }
          // @TODO: update this once the API supports blobs
          (0, index_js_4.assert)(false, "Etherscan API does not support blobVersionedHashes", "UNSUPPORTED_OPERATION", {
            operation: "_getTransactionPostData",
            info: {
              transaction: transaction
            }
          });
        } else {
          value = (0, index_js_4.hexlify)(value);
        }
        result[key] = value;
      }
      return result;
    }
    /**
     *  Throws the normalized Etherscan error.
     */
  }, {
    key: "_checkError",
    value: function _checkError(req, error, transaction) {
      // Pull any message out if, possible
      var message = "";
      if ((0, index_js_4.isError)(error, "SERVER_ERROR")) {
        // Check for an error emitted by a proxy call
        try {
          message = error.info.result.error.message;
        } catch (e) {}
        if (!message) {
          try {
            message = error.info.message;
          } catch (e) {}
        }
      }
      if (req.method === "estimateGas") {
        if (!message.match(/revert/i) && message.match(/insufficient funds/i)) {
          (0, index_js_4.assert)(false, "insufficient funds", "INSUFFICIENT_FUNDS", {
            transaction: req.transaction
          });
        }
      }
      if (req.method === "call" || req.method === "estimateGas") {
        if (message.match(/execution reverted/i)) {
          var data = "";
          try {
            data = error.info.result.error.data;
          } catch (error) {}
          var _e = index_js_1.AbiCoder.getBuiltinCallException(req.method, req.transaction, data);
          _e.info = {
            request: req,
            error: error
          };
          throw _e;
        }
      }
      if (message) {
        if (req.method === "broadcastTransaction") {
          var _transaction = index_js_3.Transaction.from(req.signedTransaction);
          if (message.match(/replacement/i) && message.match(/underpriced/i)) {
            (0, index_js_4.assert)(false, "replacement fee too low", "REPLACEMENT_UNDERPRICED", {
              transaction: _transaction
            });
          }
          if (message.match(/insufficient funds/)) {
            (0, index_js_4.assert)(false, "insufficient funds for intrinsic transaction cost", "INSUFFICIENT_FUNDS", {
              transaction: _transaction
            });
          }
          if (message.match(/same hash was already imported|transaction nonce is too low|nonce too low/)) {
            (0, index_js_4.assert)(false, "nonce has already been used", "NONCE_EXPIRED", {
              transaction: _transaction
            });
          }
        }
      }
      // Something we could not process
      throw error;
    }
  }, {
    key: "_detectNetwork",
    value: function () {
      var _detectNetwork3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              return _context4.abrupt("return", this.network);
            case 1:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));
      function _detectNetwork() {
        return _detectNetwork3.apply(this, arguments);
      }
      return _detectNetwork;
    }()
  }, {
    key: "_perform",
    value: function () {
      var _perform2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(req) {
        var _this4 = this;
        var postData, _postData;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              _context5.t0 = req.method;
              _context5.next = _context5.t0 === "chainId" ? 3 : _context5.t0 === "getBlockNumber" ? 4 : _context5.t0 === "getGasPrice" ? 5 : _context5.t0 === "getPriorityFee" ? 6 : _context5.t0 === "getBalance" ? 15 : _context5.t0 === "getTransactionCount" ? 16 : _context5.t0 === "getCode" ? 17 : _context5.t0 === "getStorage" ? 18 : _context5.t0 === "broadcastTransaction" ? 19 : _context5.t0 === "getBlock" ? 20 : _context5.t0 === "getTransaction" ? 23 : _context5.t0 === "getTransactionReceipt" ? 24 : _context5.t0 === "call" ? 25 : _context5.t0 === "estimateGas" ? 39 : 51;
              break;
            case 3:
              return _context5.abrupt("return", this.network.chainId);
            case 4:
              return _context5.abrupt("return", this.fetch("proxy", {
                action: "eth_blockNumber"
              }));
            case 5:
              return _context5.abrupt("return", this.fetch("proxy", {
                action: "eth_gasPrice"
              }));
            case 6:
              if (!(this.network.name === "mainnet")) {
                _context5.next = 10;
                break;
              }
              return _context5.abrupt("return", "1000000000");
            case 10:
              if (!(this.network.name === "optimism")) {
                _context5.next = 14;
                break;
              }
              return _context5.abrupt("return", "1000000");
            case 14:
              throw new Error("fallback onto the AbstractProvider default");
            case 15:
              return _context5.abrupt("return", this.fetch("account", {
                action: "balance",
                address: req.address,
                tag: req.blockTag
              }));
            case 16:
              return _context5.abrupt("return", this.fetch("proxy", {
                action: "eth_getTransactionCount",
                address: req.address,
                tag: req.blockTag
              }));
            case 17:
              return _context5.abrupt("return", this.fetch("proxy", {
                action: "eth_getCode",
                address: req.address,
                tag: req.blockTag
              }));
            case 18:
              return _context5.abrupt("return", this.fetch("proxy", {
                action: "eth_getStorageAt",
                address: req.address,
                position: req.position,
                tag: req.blockTag
              }));
            case 19:
              return _context5.abrupt("return", this.fetch("proxy", {
                action: "eth_sendRawTransaction",
                hex: req.signedTransaction
              }, true)["catch"](function (error) {
                return _this4._checkError(req, error, req.signedTransaction);
              }));
            case 20:
              if (!("blockTag" in req)) {
                _context5.next = 22;
                break;
              }
              return _context5.abrupt("return", this.fetch("proxy", {
                action: "eth_getBlockByNumber",
                tag: req.blockTag,
                "boolean": req.includeTransactions ? "true" : "false"
              }));
            case 22:
              (0, index_js_4.assert)(false, "getBlock by blockHash not supported by Etherscan", "UNSUPPORTED_OPERATION", {
                operation: "getBlock(blockHash)"
              });
            case 23:
              return _context5.abrupt("return", this.fetch("proxy", {
                action: "eth_getTransactionByHash",
                txhash: req.hash
              }));
            case 24:
              return _context5.abrupt("return", this.fetch("proxy", {
                action: "eth_getTransactionReceipt",
                txhash: req.hash
              }));
            case 25:
              if (!(req.blockTag !== "latest")) {
                _context5.next = 27;
                break;
              }
              throw new Error("EtherscanProvider does not support blockTag for call");
            case 27:
              postData = this._getTransactionPostData(req.transaction);
              postData.module = "proxy";
              postData.action = "eth_call";
              _context5.prev = 30;
              _context5.next = 33;
              return this.fetch("proxy", postData, true);
            case 33:
              return _context5.abrupt("return", _context5.sent);
            case 36:
              _context5.prev = 36;
              _context5.t1 = _context5["catch"](30);
              return _context5.abrupt("return", this._checkError(req, _context5.t1, req.transaction));
            case 39:
              _postData = this._getTransactionPostData(req.transaction);
              _postData.module = "proxy";
              _postData.action = "eth_estimateGas";
              _context5.prev = 42;
              _context5.next = 45;
              return this.fetch("proxy", _postData, true);
            case 45:
              return _context5.abrupt("return", _context5.sent);
            case 48:
              _context5.prev = 48;
              _context5.t2 = _context5["catch"](42);
              return _context5.abrupt("return", this._checkError(req, _context5.t2, req.transaction));
            case 51:
              return _context5.abrupt("break", 52);
            case 52:
              return _context5.abrupt("return", _get(_getPrototypeOf(EtherscanProvider.prototype), "_perform", this).call(this, req));
            case 53:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this, [[30, 36], [42, 48]]);
      }));
      function _perform(_x6) {
        return _perform2.apply(this, arguments);
      }
      return _perform;
    }()
  }, {
    key: "getNetwork",
    value: function () {
      var _getNetwork = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              return _context6.abrupt("return", this.network);
            case 1:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this);
      }));
      function getNetwork() {
        return _getNetwork.apply(this, arguments);
      }
      return getNetwork;
    }()
    /**
     *  Resolves to the current price of ether.
     *
     *  This returns ``0`` on any network other than ``mainnet``.
     */
  }, {
    key: "getEtherPrice",
    value: (function () {
      var _getEtherPrice = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              if (!(this.network.name !== "mainnet")) {
                _context7.next = 2;
                break;
              }
              return _context7.abrupt("return", 0.0);
            case 2:
              _context7.t0 = parseFloat;
              _context7.next = 5;
              return this.fetch("stats", {
                action: "ethprice"
              });
            case 5:
              _context7.t1 = _context7.sent.ethusd;
              return _context7.abrupt("return", (0, _context7.t0)(_context7.t1));
            case 7:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this);
      }));
      function getEtherPrice() {
        return _getEtherPrice.apply(this, arguments);
      }
      return getEtherPrice;
    }()
    /**
     *  Resolves to a [Contract]] for %%address%%, using the
     *  Etherscan API to retreive the Contract ABI.
     */
    )
  }, {
    key: "getContract",
    value: (function () {
      var _getContract = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(_address) {
        var address, resp, abi;
        return _regeneratorRuntime().wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              address = this._getAddress(_address);
              if (!isPromise(address)) {
                _context8.next = 5;
                break;
              }
              _context8.next = 4;
              return address;
            case 4:
              address = _context8.sent;
            case 5:
              _context8.prev = 5;
              _context8.next = 8;
              return this.fetch("contract", {
                action: "getabi",
                address: address
              });
            case 8:
              resp = _context8.sent;
              abi = JSON.parse(resp);
              return _context8.abrupt("return", new index_js_2.Contract(address, abi, this));
            case 13:
              _context8.prev = 13;
              _context8.t0 = _context8["catch"](5);
              return _context8.abrupt("return", null);
            case 16:
            case "end":
              return _context8.stop();
          }
        }, _callee8, this, [[5, 13]]);
      }));
      function getContract(_x7) {
        return _getContract.apply(this, arguments);
      }
      return getContract;
    }())
  }, {
    key: "isCommunityResource",
    value: function isCommunityResource() {
      return this.apiKey == null;
    }
  }]);
}(abstract_provider_js_1.AbstractProvider);
exports.EtherscanProvider = EtherscanProvider;

},{"../abi/index.js":201,"../contract/index.js":215,"../transaction/index.js":266,"../utils/index.js":276,"./abstract-provider.js":236,"./community.js":238,"./network.js":243,"./plugins-network.js":244}],251:[function(require,module,exports){
"use strict";

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _get() { return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }
function _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FallbackProvider = void 0;
/**
 *  A **FallbackProvider** provides resilience, security and performance
 *  in a way that is customizable and configurable.
 *
 *  @_section: api/providers/fallback-provider:Fallback Provider [about-fallback-provider]
 */
var index_js_1 = require("../utils/index.js");
var abstract_provider_js_1 = require("./abstract-provider.js");
var network_js_1 = require("./network.js");
var BN_1 = BigInt("1");
var BN_2 = BigInt("2");
function shuffle(array) {
  for (var i = array.length - 1; i > 0; i--) {
    var j = Math.floor(Math.random() * (i + 1));
    var tmp = array[i];
    array[i] = array[j];
    array[j] = tmp;
  }
}
function stall(duration) {
  return new Promise(function (resolve) {
    setTimeout(resolve, duration);
  });
}
function getTime() {
  return new Date().getTime();
}
function stringify(value) {
  return JSON.stringify(value, function (key, value) {
    if (typeof value === "bigint") {
      return {
        type: "bigint",
        value: value.toString()
      };
    }
    return value;
  });
}
;
var defaultConfig = {
  stallTimeout: 400,
  priority: 1,
  weight: 1
};
var defaultState = {
  blockNumber: -2,
  requests: 0,
  lateResponses: 0,
  errorResponses: 0,
  outOfSync: -1,
  unsupportedEvents: 0,
  rollingDuration: 0,
  score: 0,
  _network: null,
  _updateNumber: null,
  _totalTime: 0,
  _lastFatalError: null,
  _lastFatalErrorTimestamp: 0
};
function waitForSync(_x, _x2) {
  return _waitForSync.apply(this, arguments);
}
function _waitForSync() {
  _waitForSync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(config, blockNumber) {
    return _regeneratorRuntime().wrap(function _callee7$(_context7) {
      while (1) switch (_context7.prev = _context7.next) {
        case 0:
          if (!(config.blockNumber < 0 || config.blockNumber < blockNumber)) {
            _context7.next = 9;
            break;
          }
          if (!config._updateNumber) {
            config._updateNumber = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
              var _blockNumber;
              return _regeneratorRuntime().wrap(function _callee6$(_context6) {
                while (1) switch (_context6.prev = _context6.next) {
                  case 0:
                    _context6.prev = 0;
                    _context6.next = 3;
                    return config.provider.getBlockNumber();
                  case 3:
                    _blockNumber = _context6.sent;
                    if (_blockNumber > config.blockNumber) {
                      config.blockNumber = _blockNumber;
                    }
                    _context6.next = 12;
                    break;
                  case 7:
                    _context6.prev = 7;
                    _context6.t0 = _context6["catch"](0);
                    config.blockNumber = -2;
                    config._lastFatalError = _context6.t0;
                    config._lastFatalErrorTimestamp = getTime();
                  case 12:
                    config._updateNumber = null;
                  case 13:
                  case "end":
                    return _context6.stop();
                }
              }, _callee6, null, [[0, 7]]);
            }))();
          }
          _context7.next = 4;
          return config._updateNumber;
        case 4:
          config.outOfSync++;
          if (!config._lastFatalError) {
            _context7.next = 7;
            break;
          }
          return _context7.abrupt("break", 9);
        case 7:
          _context7.next = 0;
          break;
        case 9:
        case "end":
          return _context7.stop();
      }
    }, _callee7);
  }));
  return _waitForSync.apply(this, arguments);
}
function _normalize(value) {
  if (value == null) {
    return "null";
  }
  if (Array.isArray(value)) {
    return "[" + value.map(_normalize).join(",") + "]";
  }
  if (_typeof(value) === "object" && typeof value.toJSON === "function") {
    return _normalize(value.toJSON());
  }
  switch (_typeof(value)) {
    case "boolean":
    case "symbol":
      return value.toString();
    case "bigint":
    case "number":
      return BigInt(value).toString();
    case "string":
      return JSON.stringify(value);
    case "object":
      {
        var keys = Object.keys(value);
        keys.sort();
        return "{" + keys.map(function (k) {
          return "".concat(JSON.stringify(k), ":").concat(_normalize(value[k]));
        }).join(",") + "}";
      }
  }
  console.log("Could not serialize", value);
  throw new Error("Hmm...");
}
function normalizeResult(value) {
  if ("error" in value) {
    var error = value.error;
    return {
      tag: _normalize(error),
      value: error
    };
  }
  var result = value.result;
  return {
    tag: _normalize(result),
    value: result
  };
}
// This strategy picks the highest weight result, as long as the weight is
// equal to or greater than quorum
function checkQuorum(quorum, results) {
  var tally = new Map();
  var _iterator = _createForOfIteratorHelper(results),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _step$value = _step.value,
        value = _step$value.value,
        tag = _step$value.tag,
        weight = _step$value.weight;
      var t = tally.get(tag) || {
        value: value,
        weight: 0
      };
      t.weight += weight;
      tally.set(tag, t);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  var best = null;
  var _iterator2 = _createForOfIteratorHelper(tally.values()),
    _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var r = _step2.value;
      if (r.weight >= quorum && (!best || r.weight > best.weight)) {
        best = r;
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
  if (best) {
    return best.value;
  }
  return undefined;
}
function getMedian(quorum, results) {
  var resultWeight = 0;
  var errorMap = new Map();
  var bestError = null;
  var values = [];
  var _iterator3 = _createForOfIteratorHelper(results),
    _step3;
  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var _step3$value = _step3.value,
        value = _step3$value.value,
        tag = _step3$value.tag,
        weight = _step3$value.weight;
      if (value instanceof Error) {
        var e = errorMap.get(tag) || {
          value: value,
          weight: 0
        };
        e.weight += weight;
        errorMap.set(tag, e);
        if (bestError == null || e.weight > bestError.weight) {
          bestError = e;
        }
      } else {
        values.push(BigInt(value));
        resultWeight += weight;
      }
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }
  if (resultWeight < quorum) {
    // We have quorum for an error
    if (bestError && bestError.weight >= quorum) {
      return bestError.value;
    }
    // We do not have quorum for a result
    return undefined;
  }
  // Get the sorted values
  values.sort(function (a, b) {
    return a < b ? -1 : b > a ? 1 : 0;
  });
  var mid = Math.floor(values.length / 2);
  // Odd-length; take the middle value
  if (values.length % 2) {
    return values[mid];
  }
  // Even length; take the ceiling of the mean of the center two values
  return (values[mid - 1] + values[mid] + BN_1) / BN_2;
}
function getAnyResult(quorum, results) {
  // If any value or error meets quorum, that is our preferred result
  var result = checkQuorum(quorum, results);
  if (result !== undefined) {
    return result;
  }
  // Otherwise, do we have any result?
  var _iterator4 = _createForOfIteratorHelper(results),
    _step4;
  try {
    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
      var r = _step4.value;
      if (r.value) {
        return r.value;
      }
    }
    // Nope!
  } catch (err) {
    _iterator4.e(err);
  } finally {
    _iterator4.f();
  }
  return undefined;
}
function getFuzzyMode(quorum, results) {
  if (quorum === 1) {
    return (0, index_js_1.getNumber)(getMedian(quorum, results), "%internal");
  }
  var tally = new Map();
  var add = function add(result, weight) {
    var t = tally.get(result) || {
      result: result,
      weight: 0
    };
    t.weight += weight;
    tally.set(result, t);
  };
  var _iterator5 = _createForOfIteratorHelper(results),
    _step5;
  try {
    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
      var _step5$value = _step5.value,
        weight = _step5$value.weight,
        value = _step5$value.value;
      var r = (0, index_js_1.getNumber)(value);
      add(r - 1, weight);
      add(r, weight);
      add(r + 1, weight);
    }
  } catch (err) {
    _iterator5.e(err);
  } finally {
    _iterator5.f();
  }
  var bestWeight = 0;
  var bestResult = undefined;
  var _iterator6 = _createForOfIteratorHelper(tally.values()),
    _step6;
  try {
    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
      var _step6$value = _step6.value,
        _weight = _step6$value.weight,
        result = _step6$value.result;
      // Use this result, if this result meets quorum and has either:
      // - a better weight
      // - or equal weight, but the result is larger
      if (_weight >= quorum && (_weight > bestWeight || bestResult != null && _weight === bestWeight && result > bestResult)) {
        bestWeight = _weight;
        bestResult = result;
      }
    }
  } catch (err) {
    _iterator6.e(err);
  } finally {
    _iterator6.f();
  }
  return bestResult;
}
/**
 *  A **FallbackProvider** manages several [[Providers]] providing
 *  resilience by switching between slow or misbehaving nodes, security
 *  by requiring multiple backends to aggree and performance by allowing
 *  faster backends to respond earlier.
 *
 */
var _configs = /*#__PURE__*/new WeakMap();
var _height = /*#__PURE__*/new WeakMap();
var _initialSyncPromise = /*#__PURE__*/new WeakMap();
var _FallbackProvider_brand = /*#__PURE__*/new WeakSet();
var FallbackProvider = /*#__PURE__*/function (_abstract_provider_js) {
  /**
   *  Creates a new **FallbackProvider** with %%providers%% connected to
   *  %%network%%.
   *
   *  If a [[Provider]] is included in %%providers%%, defaults are used
   *  for the configuration.
   */
  function FallbackProvider(providers, _network, options) {
    var _this;
    _classCallCheck(this, FallbackProvider);
    _this = _callSuper(this, FallbackProvider, [_network, options]);
    // Grab the next (random) config that is not already part of
    // the running set
    _classPrivateMethodInitSpec(_this, _FallbackProvider_brand);
    /**
     *  The number of backends that must agree on a value before it is
     *  accpeted.
     */
    _defineProperty(_this, "quorum", void 0);
    /**
     *  @_ignore:
     */
    _defineProperty(_this, "eventQuorum", void 0);
    /**
     *  @_ignore:
     */
    _defineProperty(_this, "eventWorkers", void 0);
    _classPrivateFieldInitSpec(_this, _configs, void 0);
    _classPrivateFieldInitSpec(_this, _height, void 0);
    _classPrivateFieldInitSpec(_this, _initialSyncPromise, void 0);
    _classPrivateFieldSet(_configs, _this, providers.map(function (p) {
      if (p instanceof abstract_provider_js_1.AbstractProvider) {
        return Object.assign({
          provider: p
        }, defaultConfig, defaultState);
      } else {
        return Object.assign({}, defaultConfig, p, defaultState);
      }
    }));
    _classPrivateFieldSet(_height, _this, -2);
    _classPrivateFieldSet(_initialSyncPromise, _this, null);
    if (options && options.quorum != null) {
      _this.quorum = options.quorum;
    } else {
      _this.quorum = Math.ceil(_classPrivateFieldGet(_configs, _this).reduce(function (accum, config) {
        accum += config.weight;
        return accum;
      }, 0) / 2);
    }
    _this.eventQuorum = 1;
    _this.eventWorkers = 1;
    (0, index_js_1.assertArgument)(_this.quorum <= _classPrivateFieldGet(_configs, _this).reduce(function (a, c) {
      return a + c.weight;
    }, 0), "quorum exceed provider weight", "quorum", _this.quorum);
    return _this;
  }
  _inherits(FallbackProvider, _abstract_provider_js);
  return _createClass(FallbackProvider, [{
    key: "providerConfigs",
    get: function get() {
      return _classPrivateFieldGet(_configs, this).map(function (c) {
        var result = Object.assign({}, c);
        for (var key in result) {
          if (key[0] === "_") {
            delete result[key];
          }
        }
        return result;
      });
    }
  }, {
    key: "_detectNetwork",
    value: function () {
      var _detectNetwork2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.t0 = network_js_1.Network;
              _context.t1 = (0, index_js_1.getBigInt);
              _context.next = 4;
              return this._perform({
                method: "chainId"
              });
            case 4:
              _context.t2 = _context.sent;
              _context.t3 = (0, _context.t1)(_context.t2);
              return _context.abrupt("return", _context.t0.from.call(_context.t0, _context.t3));
            case 7:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function _detectNetwork() {
        return _detectNetwork2.apply(this, arguments);
      }
      return _detectNetwork;
    }() // @TODO: Add support to select providers to be the event subscriber
    //_getSubscriber(sub: Subscription): Subscriber {
    //    throw new Error("@TODO");
    //}
    /**
     *  Transforms a %%req%% into the correct method call on %%provider%%.
     */
  }, {
    key: "_translatePerform",
    value: function () {
      var _translatePerform2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(provider, req) {
        var block;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.t0 = req.method;
              _context2.next = _context2.t0 === "broadcastTransaction" ? 3 : _context2.t0 === "call" ? 6 : _context2.t0 === "chainId" ? 9 : _context2.t0 === "estimateGas" ? 12 : _context2.t0 === "getBalance" ? 15 : _context2.t0 === "getBlock" ? 18 : _context2.t0 === "getBlockNumber" ? 22 : _context2.t0 === "getCode" ? 25 : _context2.t0 === "getGasPrice" ? 28 : _context2.t0 === "getPriorityFee" ? 31 : _context2.t0 === "getLogs" ? 34 : _context2.t0 === "getStorage" ? 37 : _context2.t0 === "getTransaction" ? 40 : _context2.t0 === "getTransactionCount" ? 43 : _context2.t0 === "getTransactionReceipt" ? 46 : _context2.t0 === "getTransactionResult" ? 49 : 52;
              break;
            case 3:
              _context2.next = 5;
              return provider.broadcastTransaction(req.signedTransaction);
            case 5:
              return _context2.abrupt("return", _context2.sent);
            case 6:
              _context2.next = 8;
              return provider.call(Object.assign({}, req.transaction, {
                blockTag: req.blockTag
              }));
            case 8:
              return _context2.abrupt("return", _context2.sent);
            case 9:
              _context2.next = 11;
              return provider.getNetwork();
            case 11:
              return _context2.abrupt("return", _context2.sent.chainId);
            case 12:
              _context2.next = 14;
              return provider.estimateGas(req.transaction);
            case 14:
              return _context2.abrupt("return", _context2.sent);
            case 15:
              _context2.next = 17;
              return provider.getBalance(req.address, req.blockTag);
            case 17:
              return _context2.abrupt("return", _context2.sent);
            case 18:
              block = "blockHash" in req ? req.blockHash : req.blockTag;
              _context2.next = 21;
              return provider.getBlock(block, req.includeTransactions);
            case 21:
              return _context2.abrupt("return", _context2.sent);
            case 22:
              _context2.next = 24;
              return provider.getBlockNumber();
            case 24:
              return _context2.abrupt("return", _context2.sent);
            case 25:
              _context2.next = 27;
              return provider.getCode(req.address, req.blockTag);
            case 27:
              return _context2.abrupt("return", _context2.sent);
            case 28:
              _context2.next = 30;
              return provider.getFeeData();
            case 30:
              return _context2.abrupt("return", _context2.sent.gasPrice);
            case 31:
              _context2.next = 33;
              return provider.getFeeData();
            case 33:
              return _context2.abrupt("return", _context2.sent.maxPriorityFeePerGas);
            case 34:
              _context2.next = 36;
              return provider.getLogs(req.filter);
            case 36:
              return _context2.abrupt("return", _context2.sent);
            case 37:
              _context2.next = 39;
              return provider.getStorage(req.address, req.position, req.blockTag);
            case 39:
              return _context2.abrupt("return", _context2.sent);
            case 40:
              _context2.next = 42;
              return provider.getTransaction(req.hash);
            case 42:
              return _context2.abrupt("return", _context2.sent);
            case 43:
              _context2.next = 45;
              return provider.getTransactionCount(req.address, req.blockTag);
            case 45:
              return _context2.abrupt("return", _context2.sent);
            case 46:
              _context2.next = 48;
              return provider.getTransactionReceipt(req.hash);
            case 48:
              return _context2.abrupt("return", _context2.sent);
            case 49:
              _context2.next = 51;
              return provider.getTransactionResult(req.hash);
            case 51:
              return _context2.abrupt("return", _context2.sent);
            case 52:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      }));
      function _translatePerform(_x3, _x4) {
        return _translatePerform2.apply(this, arguments);
      }
      return _translatePerform;
    }()
  }, {
    key: "_perform",
    value: function () {
      var _perform2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(req) {
        var results, broadcasts, done, _iterator7, _step7, value, _result2, waiting, _result3, running, inflightQuorum, runner, result, _iterator8, _step8, _runner;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              if (!(req.method === "broadcastTransaction")) {
                _context4.next = 37;
                break;
              }
              // Once any broadcast provides a positive result, use it. No
              // need to wait for anyone else
              results = _classPrivateFieldGet(_configs, this).map(function (c) {
                return null;
              });
              broadcasts = _classPrivateFieldGet(_configs, this).map( /*#__PURE__*/function () {
                var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(_ref, index) {
                  var provider, weight, _result;
                  return _regeneratorRuntime().wrap(function _callee3$(_context3) {
                    while (1) switch (_context3.prev = _context3.next) {
                      case 0:
                        provider = _ref.provider, weight = _ref.weight;
                        _context3.prev = 1;
                        _context3.next = 4;
                        return provider._perform(req);
                      case 4:
                        _result = _context3.sent;
                        results[index] = Object.assign(normalizeResult({
                          result: _result
                        }), {
                          weight: weight
                        });
                        _context3.next = 11;
                        break;
                      case 8:
                        _context3.prev = 8;
                        _context3.t0 = _context3["catch"](1);
                        results[index] = Object.assign(normalizeResult({
                          error: _context3.t0
                        }), {
                          weight: weight
                        });
                      case 11:
                      case "end":
                        return _context3.stop();
                    }
                  }, _callee3, null, [[1, 8]]);
                }));
                return function (_x6, _x7) {
                  return _ref2.apply(this, arguments);
                };
              }()); // As each promise finishes...
            case 3:
              if (!true) {
                _context4.next = 32;
                break;
              }
              // Check for a valid broadcast result
              done = results.filter(function (r) {
                return r != null;
              });
              _iterator7 = _createForOfIteratorHelper(done);
              _context4.prev = 6;
              _iterator7.s();
            case 8:
              if ((_step7 = _iterator7.n()).done) {
                _context4.next = 14;
                break;
              }
              value = _step7.value.value;
              if (value instanceof Error) {
                _context4.next = 12;
                break;
              }
              return _context4.abrupt("return", value);
            case 12:
              _context4.next = 8;
              break;
            case 14:
              _context4.next = 19;
              break;
            case 16:
              _context4.prev = 16;
              _context4.t0 = _context4["catch"](6);
              _iterator7.e(_context4.t0);
            case 19:
              _context4.prev = 19;
              _iterator7.f();
              return _context4.finish(19);
            case 22:
              // Check for a legit broadcast error (one which we cannot
              // recover from; some nodes may return the following red
              // herring events:
              // - alredy seend (UNKNOWN_ERROR)
              // - NONCE_EXPIRED
              // - REPLACEMENT_UNDERPRICED
              _result2 = checkQuorum(this.quorum, results.filter(function (r) {
                return r != null;
              }));
              if (!(0, index_js_1.isError)(_result2, "INSUFFICIENT_FUNDS")) {
                _context4.next = 25;
                break;
              }
              throw _result2;
            case 25:
              // Kick off the next provider (if any)
              waiting = broadcasts.filter(function (b, i) {
                return results[i] == null;
              });
              if (!(waiting.length === 0)) {
                _context4.next = 28;
                break;
              }
              return _context4.abrupt("break", 32);
            case 28:
              _context4.next = 30;
              return Promise.race(waiting);
            case 30:
              _context4.next = 3;
              break;
            case 32:
              // Use standard quorum results; any result was returned above,
              // so this will find any error that met quorum if any
              _result3 = getAnyResult(this.quorum, results);
              (0, index_js_1.assert)(_result3 !== undefined, "problem multi-broadcasting", "SERVER_ERROR", {
                request: "%sub-requests",
                info: {
                  request: req,
                  results: results.map(stringify)
                }
              });
              if (!(_result3 instanceof Error)) {
                _context4.next = 36;
                break;
              }
              throw _result3;
            case 36:
              return _context4.abrupt("return", _result3);
            case 37:
              _context4.next = 39;
              return _assertClassBrand(_FallbackProvider_brand, this, _initialSync).call(this);
            case 39:
              // Bootstrap enough runners to meet quorum
              running = new Set();
              inflightQuorum = 0;
            case 41:
              if (!true) {
                _context4.next = 50;
                break;
              }
              runner = _assertClassBrand(_FallbackProvider_brand, this, _addRunner).call(this, running, req);
              if (!(runner == null)) {
                _context4.next = 45;
                break;
              }
              return _context4.abrupt("break", 50);
            case 45:
              inflightQuorum += runner.config.weight;
              if (!(inflightQuorum >= this.quorum)) {
                _context4.next = 48;
                break;
              }
              return _context4.abrupt("break", 50);
            case 48:
              _context4.next = 41;
              break;
            case 50:
              _context4.next = 52;
              return _assertClassBrand(_FallbackProvider_brand, this, _waitForQuorum).call(this, running, req);
            case 52:
              result = _context4.sent;
              // Track requests sent to a provider that are still
              // outstanding after quorum has been otherwise found
              _iterator8 = _createForOfIteratorHelper(running);
              try {
                for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
                  _runner = _step8.value;
                  if (_runner.perform && _runner.result == null) {
                    _runner.config.lateResponses++;
                  }
                }
              } catch (err) {
                _iterator8.e(err);
              } finally {
                _iterator8.f();
              }
              return _context4.abrupt("return", result);
            case 56:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this, [[6, 16, 19, 22]]);
      }));
      function _perform(_x5) {
        return _perform2.apply(this, arguments);
      }
      return _perform;
    }()
  }, {
    key: "destroy",
    value: function () {
      var _destroy = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
        var _iterator9, _step9, provider;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              _iterator9 = _createForOfIteratorHelper(_classPrivateFieldGet(_configs, this));
              try {
                for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
                  provider = _step9.value.provider;
                  provider.destroy();
                }
              } catch (err) {
                _iterator9.e(err);
              } finally {
                _iterator9.f();
              }
              _get(_getPrototypeOf(FallbackProvider.prototype), "destroy", this).call(this);
            case 3:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this);
      }));
      function destroy() {
        return _destroy.apply(this, arguments);
      }
      return destroy;
    }()
  }]);
}(abstract_provider_js_1.AbstractProvider);
function _getNextConfig(running) {
  // @TODO: Maybe do a check here to favour (heavily) providers that
  //        do not require waitForSync and disfavour providers that
  //        seem down-ish or are behaving slowly
  var configs = Array.from(running).map(function (r) {
    return r.config;
  });
  // Shuffle the states, sorted by priority
  var allConfigs = _classPrivateFieldGet(_configs, this).slice();
  shuffle(allConfigs);
  allConfigs.sort(function (a, b) {
    return a.priority - b.priority;
  });
  var _iterator10 = _createForOfIteratorHelper(allConfigs),
    _step10;
  try {
    for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
      var config = _step10.value;
      if (config._lastFatalError) {
        continue;
      }
      if (configs.indexOf(config) === -1) {
        return config;
      }
    }
  } catch (err) {
    _iterator10.e(err);
  } finally {
    _iterator10.f();
  }
  return null;
}
// Adds a new runner (if available) to running.
function _addRunner(running, req) {
  var _this2 = this;
  var config = _assertClassBrand(_FallbackProvider_brand, this, _getNextConfig).call(this, running);
  // No runners available
  if (config == null) {
    return null;
  }
  // Create a new runner
  var runner = {
    config: config,
    result: null,
    didBump: false,
    perform: null,
    staller: null
  };
  var now = getTime();
  // Start performing this operation
  runner.perform = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {
    var result, dt;
    return _regeneratorRuntime().wrap(function _callee8$(_context8) {
      while (1) switch (_context8.prev = _context8.next) {
        case 0:
          _context8.prev = 0;
          config.requests++;
          _context8.next = 4;
          return _this2._translatePerform(config.provider, req);
        case 4:
          result = _context8.sent;
          runner.result = {
            result: result
          };
          _context8.next = 12;
          break;
        case 8:
          _context8.prev = 8;
          _context8.t0 = _context8["catch"](0);
          config.errorResponses++;
          runner.result = {
            error: _context8.t0
          };
        case 12:
          dt = getTime() - now;
          config._totalTime += dt;
          config.rollingDuration = 0.95 * config.rollingDuration + 0.05 * dt;
          runner.perform = null;
        case 16:
        case "end":
          return _context8.stop();
      }
    }, _callee8, null, [[0, 8]]);
  }))();
  // Start a staller; when this times out, it's time to force
  // kicking off another runner because we are taking too long
  runner.staller = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {
    return _regeneratorRuntime().wrap(function _callee9$(_context9) {
      while (1) switch (_context9.prev = _context9.next) {
        case 0:
          _context9.next = 2;
          return stall(config.stallTimeout);
        case 2:
          runner.staller = null;
        case 3:
        case "end":
          return _context9.stop();
      }
    }, _callee9);
  }))();
  running.add(runner);
  return runner;
}
// Initializes the blockNumber and network for each runner and
// blocks until initialized
function _initialSync() {
  return _initialSync2.apply(this, arguments);
}
function _initialSync2() {
  _initialSync2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {
    var _this3 = this;
    var initialSync, promises;
    return _regeneratorRuntime().wrap(function _callee12$(_context12) {
      while (1) switch (_context12.prev = _context12.next) {
        case 0:
          initialSync = _classPrivateFieldGet(_initialSyncPromise, this);
          if (!initialSync) {
            promises = [];
            _classPrivateFieldGet(_configs, this).forEach(function (config) {
              promises.push(_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {
                return _regeneratorRuntime().wrap(function _callee10$(_context10) {
                  while (1) switch (_context10.prev = _context10.next) {
                    case 0:
                      _context10.next = 2;
                      return waitForSync(config, 0);
                    case 2:
                      if (config._lastFatalError) {
                        _context10.next = 6;
                        break;
                      }
                      _context10.next = 5;
                      return config.provider.getNetwork();
                    case 5:
                      config._network = _context10.sent;
                    case 6:
                    case "end":
                      return _context10.stop();
                  }
                }, _callee10);
              }))());
            });
            _classPrivateFieldSet(_initialSyncPromise, this, initialSync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {
              var chainId, _iterator11, _step11, config, network;
              return _regeneratorRuntime().wrap(function _callee11$(_context11) {
                while (1) switch (_context11.prev = _context11.next) {
                  case 0:
                    _context11.next = 2;
                    return Promise.all(promises);
                  case 2:
                    // Check all the networks match
                    chainId = null;
                    _iterator11 = _createForOfIteratorHelper(_classPrivateFieldGet(_configs, _this3));
                    _context11.prev = 4;
                    _iterator11.s();
                  case 6:
                    if ((_step11 = _iterator11.n()).done) {
                      _context11.next = 14;
                      break;
                    }
                    config = _step11.value;
                    if (!config._lastFatalError) {
                      _context11.next = 10;
                      break;
                    }
                    return _context11.abrupt("continue", 12);
                  case 10:
                    network = config._network;
                    if (chainId == null) {
                      chainId = network.chainId;
                    } else if (network.chainId !== chainId) {
                      (0, index_js_1.assert)(false, "cannot mix providers on different networks", "UNSUPPORTED_OPERATION", {
                        operation: "new FallbackProvider"
                      });
                    }
                  case 12:
                    _context11.next = 6;
                    break;
                  case 14:
                    _context11.next = 19;
                    break;
                  case 16:
                    _context11.prev = 16;
                    _context11.t0 = _context11["catch"](4);
                    _iterator11.e(_context11.t0);
                  case 19:
                    _context11.prev = 19;
                    _iterator11.f();
                    return _context11.finish(19);
                  case 22:
                  case "end":
                    return _context11.stop();
                }
              }, _callee11, null, [[4, 16, 19, 22]]);
            }))());
          }
          _context12.next = 4;
          return initialSync;
        case 4:
        case "end":
          return _context12.stop();
      }
    }, _callee12, this);
  }));
  return _initialSync2.apply(this, arguments);
}
function _checkQuorum(_x8, _x9) {
  return _checkQuorum2.apply(this, arguments);
}
function _checkQuorum2() {
  _checkQuorum2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(running, req) {
    var results, _iterator12, _step12, runner, _normalizeResult, tag, value, mode;
    return _regeneratorRuntime().wrap(function _callee13$(_context13) {
      while (1) switch (_context13.prev = _context13.next) {
        case 0:
          // Get all the result objects
          results = [];
          _iterator12 = _createForOfIteratorHelper(running);
          try {
            for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
              runner = _step12.value;
              if (runner.result != null) {
                _normalizeResult = normalizeResult(runner.result), tag = _normalizeResult.tag, value = _normalizeResult.value;
                results.push({
                  tag: tag,
                  value: value,
                  weight: runner.config.weight
                });
              }
            }
            // Are there enough results to event meet quorum?
          } catch (err) {
            _iterator12.e(err);
          } finally {
            _iterator12.f();
          }
          if (!(results.reduce(function (a, r) {
            return a + r.weight;
          }, 0) < this.quorum)) {
            _context13.next = 5;
            break;
          }
          return _context13.abrupt("return", undefined);
        case 5:
          _context13.t0 = req.method;
          _context13.next = _context13.t0 === "getBlockNumber" ? 8 : _context13.t0 === "getGasPrice" ? 14 : _context13.t0 === "getPriorityFee" ? 14 : _context13.t0 === "estimateGas" ? 14 : _context13.t0 === "getBlock" ? 15 : _context13.t0 === "call" ? 18 : _context13.t0 === "chainId" ? 18 : _context13.t0 === "getBalance" ? 18 : _context13.t0 === "getTransactionCount" ? 18 : _context13.t0 === "getCode" ? 18 : _context13.t0 === "getStorage" ? 18 : _context13.t0 === "getTransaction" ? 18 : _context13.t0 === "getTransactionReceipt" ? 18 : _context13.t0 === "getLogs" ? 18 : _context13.t0 === "broadcastTransaction" ? 19 : 20;
          break;
        case 8:
          // We need to get the bootstrap block height
          if (_classPrivateFieldGet(_height, this) === -2) {
            _classPrivateFieldSet(_height, this, Math.ceil((0, index_js_1.getNumber)(getMedian(this.quorum, _classPrivateFieldGet(_configs, this).filter(function (c) {
              return !c._lastFatalError;
            }).map(function (c) {
              return {
                value: c.blockNumber,
                tag: (0, index_js_1.getNumber)(c.blockNumber).toString(),
                weight: c.weight
              };
            })))));
          }
          // Find the mode across all the providers, allowing for
          // a little drift between block heights
          mode = getFuzzyMode(this.quorum, results);
          if (!(mode === undefined)) {
            _context13.next = 12;
            break;
          }
          return _context13.abrupt("return", undefined);
        case 12:
          if (mode > _classPrivateFieldGet(_height, this)) {
            _classPrivateFieldSet(_height, this, mode);
          }
          return _context13.abrupt("return", _classPrivateFieldGet(_height, this));
        case 14:
          return _context13.abrupt("return", getMedian(this.quorum, results));
        case 15:
          if (!("blockTag" in req && req.blockTag === "pending")) {
            _context13.next = 17;
            break;
          }
          return _context13.abrupt("return", getAnyResult(this.quorum, results));
        case 17:
          return _context13.abrupt("return", checkQuorum(this.quorum, results));
        case 18:
          return _context13.abrupt("return", checkQuorum(this.quorum, results));
        case 19:
          return _context13.abrupt("return", getAnyResult(this.quorum, results));
        case 20:
          (0, index_js_1.assert)(false, "unsupported method", "UNSUPPORTED_OPERATION", {
            operation: "_perform(".concat(stringify(req.method), ")")
          });
        case 21:
        case "end":
          return _context13.stop();
      }
    }, _callee13, this);
  }));
  return _checkQuorum2.apply(this, arguments);
}
function _waitForQuorum(_x10, _x11) {
  return _waitForQuorum2.apply(this, arguments);
}
function _waitForQuorum2() {
  _waitForQuorum2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14(running, req) {
    var interesting, newRunners, _iterator13, _step13, runner, value, i;
    return _regeneratorRuntime().wrap(function _callee14$(_context14) {
      while (1) switch (_context14.prev = _context14.next) {
        case 0:
          if (!(running.size === 0)) {
            _context14.next = 2;
            break;
          }
          throw new Error("no runners?!");
        case 2:
          // Any promises that are interesting to watch for; an expired stall
          // or a successful perform
          interesting = [];
          newRunners = 0;
          _iterator13 = _createForOfIteratorHelper(running);
          _context14.prev = 5;
          _iterator13.s();
        case 7:
          if ((_step13 = _iterator13.n()).done) {
            _context14.next = 19;
            break;
          }
          runner = _step13.value;
          // No responses, yet; keep an eye on it
          if (runner.perform) {
            interesting.push(runner.perform);
          }
          // Still stalling...
          if (!runner.staller) {
            _context14.next = 13;
            break;
          }
          interesting.push(runner.staller);
          return _context14.abrupt("continue", 17);
        case 13:
          if (!runner.didBump) {
            _context14.next = 15;
            break;
          }
          return _context14.abrupt("continue", 17);
        case 15:
          // Got a response (result or error) or stalled; kick off another runner
          runner.didBump = true;
          newRunners++;
        case 17:
          _context14.next = 7;
          break;
        case 19:
          _context14.next = 24;
          break;
        case 21:
          _context14.prev = 21;
          _context14.t0 = _context14["catch"](5);
          _iterator13.e(_context14.t0);
        case 24:
          _context14.prev = 24;
          _iterator13.f();
          return _context14.finish(24);
        case 27:
          _context14.next = 29;
          return _assertClassBrand(_FallbackProvider_brand, this, _checkQuorum).call(this, running, req);
        case 29:
          value = _context14.sent;
          if (!(value !== undefined)) {
            _context14.next = 34;
            break;
          }
          if (!(value instanceof Error)) {
            _context14.next = 33;
            break;
          }
          throw value;
        case 33:
          return _context14.abrupt("return", value);
        case 34:
          // Add any new runners, because a staller timed out or a result
          // or error response came in.
          for (i = 0; i < newRunners; i++) {
            _assertClassBrand(_FallbackProvider_brand, this, _addRunner).call(this, running, req);
          }
          // All providers have returned, and we have no result
          (0, index_js_1.assert)(interesting.length > 0, "quorum not met", "SERVER_ERROR", {
            request: "%sub-requests",
            info: {
              request: req,
              results: Array.from(running).map(function (r) {
                return stringify(r.result);
              })
            }
          });
          // Wait for someone to either complete its perform or stall out
          _context14.next = 38;
          return Promise.race(interesting);
        case 38:
          _context14.next = 40;
          return _assertClassBrand(_FallbackProvider_brand, this, _waitForQuorum).call(this, running, req);
        case 40:
          return _context14.abrupt("return", _context14.sent);
        case 41:
        case "end":
          return _context14.stop();
      }
    }, _callee14, this, [[5, 21, 24, 27]]);
  }));
  return _waitForQuorum2.apply(this, arguments);
}
exports.FallbackProvider = FallbackProvider;

},{"../utils/index.js":276,"./abstract-provider.js":236,"./network.js":243}],252:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _get() { return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }
function _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.InfuraProvider = exports.InfuraWebSocketProvider = void 0;
/**
 *  [[link-infura]] provides a third-party service for connecting to
 *  various blockchains over JSON-RPC.
 *
 *  **Supported Networks**
 *
 *  - Ethereum Mainnet (``mainnet``)
 *  - Goerli Testnet (``goerli``)
 *  - Sepolia Testnet (``sepolia``)
 *  - Arbitrum (``arbitrum``)
 *  - Arbitrum Goerli Testnet (``arbitrum-goerli``)
 *  - Arbitrum Sepolia Testnet (``arbitrum-sepolia``)
 *  - Base (``base``)
 *  - Base Goerlia Testnet (``base-goerli``)
 *  - Base Sepolia Testnet (``base-sepolia``)
 *  - BNB Smart Chain Mainnet (``bnb``)
 *  - BNB Smart Chain Testnet (``bnbt``)
 *  - Linea (``linea``)
 *  - Linea Goerli Testnet (``linea-goerli``)
 *  - Linea Sepolia Testnet (``linea-sepolia``)
 *  - Optimism (``optimism``)
 *  - Optimism Goerli Testnet (``optimism-goerli``)
 *  - Optimism Sepolia Testnet (``optimism-sepolia``)
 *  - Polygon (``matic``)
 *  - Polygon Amoy Testnet (``matic-amoy``)
 *  - Polygon Mumbai Testnet (``matic-mumbai``)
 *
 *  @_subsection: api/providers/thirdparty:INFURA  [providers-infura]
 */
var index_js_1 = require("../utils/index.js");
var community_js_1 = require("./community.js");
var network_js_1 = require("./network.js");
var provider_jsonrpc_js_1 = require("./provider-jsonrpc.js");
var provider_websocket_js_1 = require("./provider-websocket.js");
var defaultProjectId = "84842078b09946638c03157f83405213";
function getHost(name) {
  switch (name) {
    case "mainnet":
      return "mainnet.infura.io";
    case "goerli":
      return "goerli.infura.io";
    case "sepolia":
      return "sepolia.infura.io";
    case "arbitrum":
      return "arbitrum-mainnet.infura.io";
    case "arbitrum-goerli":
      return "arbitrum-goerli.infura.io";
    case "arbitrum-sepolia":
      return "arbitrum-sepolia.infura.io";
    case "base":
      return "base-mainnet.infura.io";
    case "base-goerlia":
      return "base-goerli.infura.io";
    case "base-sepolia":
      return "base-sepolia.infura.io";
    case "bnb":
      return "bnbsmartchain-mainnet.infura.io";
    case "bnbt":
      return "bnbsmartchain-testnet.infura.io";
    case "linea":
      return "linea-mainnet.infura.io";
    case "linea-goerli":
      return "linea-goerli.infura.io";
    case "linea-sepolia":
      return "linea-sepolia.infura.io";
    case "matic":
      return "polygon-mainnet.infura.io";
    case "matic-amoy":
      return "polygon-amoy.infura.io";
    case "matic-mumbai":
      return "polygon-mumbai.infura.io";
    case "optimism":
      return "optimism-mainnet.infura.io";
    case "optimism-goerli":
      return "optimism-goerli.infura.io";
    case "optimism-sepolia":
      return "optimism-sepolia.infura.io";
  }
  (0, index_js_1.assertArgument)(false, "unsupported network", "network", name);
}
/**
 *  The **InfuraWebSocketProvider** connects to the [[link-infura]]
 *  WebSocket end-points.
 *
 *  By default, a highly-throttled API key is used, which is
 *  appropriate for quick prototypes and simple scripts. To
 *  gain access to an increased rate-limit, it is highly
 *  recommended to [sign up here](link-infura-signup).
 */
var InfuraWebSocketProvider = /*#__PURE__*/function (_provider_websocket_j) {
  /**
   *  Creates a new **InfuraWebSocketProvider**.
   */
  function InfuraWebSocketProvider(network, projectId) {
    var _this;
    _classCallCheck(this, InfuraWebSocketProvider);
    var provider = new InfuraProvider(network, projectId);
    var req = provider._getConnection();
    (0, index_js_1.assert)(!req.credentials, "INFURA WebSocket project secrets unsupported", "UNSUPPORTED_OPERATION", {
      operation: "InfuraProvider.getWebSocketProvider()"
    });
    var url = req.url.replace(/^http/i, "ws").replace("/v3/", "/ws/v3/");
    _this = _callSuper(this, InfuraWebSocketProvider, [url, provider._network]);
    /**
     *  The Project ID for the INFURA connection.
     */
    _defineProperty(_this, "projectId", void 0);
    /**
     *  The Project Secret.
     *
     *  If null, no authenticated requests are made. This should not
     *  be used outside of private contexts.
     */
    _defineProperty(_this, "projectSecret", void 0);
    (0, index_js_1.defineProperties)(_this, {
      projectId: provider.projectId,
      projectSecret: provider.projectSecret
    });
    return _this;
  }
  _inherits(InfuraWebSocketProvider, _provider_websocket_j);
  return _createClass(InfuraWebSocketProvider, [{
    key: "isCommunityResource",
    value: function isCommunityResource() {
      return this.projectId === defaultProjectId;
    }
  }]);
}(provider_websocket_js_1.WebSocketProvider);
exports.InfuraWebSocketProvider = InfuraWebSocketProvider;
/**
 *  The **InfuraProvider** connects to the [[link-infura]]
 *  JSON-RPC end-points.
 *
 *  By default, a highly-throttled API key is used, which is
 *  appropriate for quick prototypes and simple scripts. To
 *  gain access to an increased rate-limit, it is highly
 *  recommended to [sign up here](link-infura-signup).
 */
var InfuraProvider = /*#__PURE__*/function (_provider_jsonrpc_js_) {
  /**
   *  Creates a new **InfuraProvider**.
   */
  function InfuraProvider(_network, projectId, projectSecret) {
    var _this2;
    _classCallCheck(this, InfuraProvider);
    if (_network == null) {
      _network = "mainnet";
    }
    var network = network_js_1.Network.from(_network);
    if (projectId == null) {
      projectId = defaultProjectId;
    }
    if (projectSecret == null) {
      projectSecret = null;
    }
    var request = InfuraProvider.getRequest(network, projectId, projectSecret);
    _this2 = _callSuper(this, InfuraProvider, [request, network, {
      staticNetwork: network
    }]);
    /**
     *  The Project ID for the INFURA connection.
     */
    _defineProperty(_this2, "projectId", void 0);
    /**
     *  The Project Secret.
     *
     *  If null, no authenticated requests are made. This should not
     *  be used outside of private contexts.
     */
    _defineProperty(_this2, "projectSecret", void 0);
    (0, index_js_1.defineProperties)(_this2, {
      projectId: projectId,
      projectSecret: projectSecret
    });
    return _this2;
  }
  _inherits(InfuraProvider, _provider_jsonrpc_js_);
  return _createClass(InfuraProvider, [{
    key: "_getProvider",
    value: function _getProvider(chainId) {
      try {
        return new InfuraProvider(chainId, this.projectId, this.projectSecret);
      } catch (error) {}
      return _get(_getPrototypeOf(InfuraProvider.prototype), "_getProvider", this).call(this, chainId);
    }
  }, {
    key: "isCommunityResource",
    value: function isCommunityResource() {
      return this.projectId === defaultProjectId;
    }
    /**
     *  Creates a new **InfuraWebSocketProvider**.
     */
  }], [{
    key: "getWebSocketProvider",
    value: function getWebSocketProvider(network, projectId) {
      return new InfuraWebSocketProvider(network, projectId);
    }
    /**
     *  Returns a prepared request for connecting to %%network%%
     *  with %%projectId%% and %%projectSecret%%.
     */
  }, {
    key: "getRequest",
    value: function getRequest(network, projectId, projectSecret) {
      if (projectId == null) {
        projectId = defaultProjectId;
      }
      if (projectSecret == null) {
        projectSecret = null;
      }
      var request = new index_js_1.FetchRequest("https://".concat(getHost(network.name), "/v3/").concat(projectId));
      request.allowGzip = true;
      if (projectSecret) {
        request.setCredentials("", projectSecret);
      }
      if (projectId === defaultProjectId) {
        request.retryFunc = /*#__PURE__*/function () {
          var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(request, response, attempt) {
            return _regeneratorRuntime().wrap(function _callee$(_context) {
              while (1) switch (_context.prev = _context.next) {
                case 0:
                  (0, community_js_1.showThrottleMessage)("InfuraProvider");
                  return _context.abrupt("return", true);
                case 2:
                case "end":
                  return _context.stop();
              }
            }, _callee);
          }));
          return function (_x, _x2, _x3) {
            return _ref.apply(this, arguments);
          };
        }();
      }
      return request;
    }
  }]);
}(provider_jsonrpc_js_1.JsonRpcProvider);
exports.InfuraProvider = InfuraProvider;

},{"../utils/index.js":276,"./community.js":238,"./network.js":243,"./provider-jsonrpc.js":254,"./provider-websocket.js":258}],253:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IpcSocketProvider = void 0;
var IpcSocketProvider = undefined;
exports.IpcSocketProvider = IpcSocketProvider;

},{}],254:[function(require,module,exports){
"use strict";

/**
 *  One of the most common ways to interact with the blockchain is
 *  by a node running a JSON-RPC interface which can be connected to,
 *  based on the transport, using:
 *
 *  - HTTP or HTTPS - [[JsonRpcProvider]]
 *  - WebSocket - [[WebSocketProvider]]
 *  - IPC - [[IpcSocketProvider]]
 *
 * @_section: api/providers/jsonrpc:JSON-RPC Provider  [about-jsonrpcProvider]
 */
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _get() { return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }
function _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }
function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.JsonRpcProvider = exports.JsonRpcApiPollingProvider = exports.JsonRpcApiProvider = exports.JsonRpcSigner = void 0;
// @TODO:
// - Add the batching API
// https://playground.open-rpc.org/?schemaUrl=https://raw.githubusercontent.com/ethereum/eth1.0-apis/assembled-spec/openrpc.json&uiSchema%5BappBar%5D%5Bui:splitView%5D=true&uiSchema%5BappBar%5D%5Bui:input%5D=false&uiSchema%5BappBar%5D%5Bui:examplesDropdown%5D=false
var index_js_1 = require("../abi/index.js");
var index_js_2 = require("../address/index.js");
var index_js_3 = require("../hash/index.js");
var index_js_4 = require("../transaction/index.js");
var index_js_5 = require("../utils/index.js");
var abstract_provider_js_1 = require("./abstract-provider.js");
var abstract_signer_js_1 = require("./abstract-signer.js");
var network_js_1 = require("./network.js");
var subscriber_filterid_js_1 = require("./subscriber-filterid.js");
var subscriber_polling_js_1 = require("./subscriber-polling.js");
var Primitive = "bigint,boolean,function,number,string,symbol".split(/,/g);
//const Methods = "getAddress,then".split(/,/g);
function deepCopy(value) {
  if (value == null || Primitive.indexOf(_typeof(value)) >= 0) {
    return value;
  }
  // Keep any Addressable
  if (typeof value.getAddress === "function") {
    return value;
  }
  if (Array.isArray(value)) {
    return value.map(deepCopy);
  }
  if (_typeof(value) === "object") {
    return Object.keys(value).reduce(function (accum, key) {
      accum[key] = value[key];
      return accum;
    }, {});
  }
  throw new Error("should not happen: ".concat(value, " (").concat(_typeof(value), ")"));
}
function stall(duration) {
  return new Promise(function (resolve) {
    setTimeout(resolve, duration);
  });
}
function getLowerCase(value) {
  if (value) {
    return value.toLowerCase();
  }
  return value;
}
function isPollable(value) {
  return value && typeof value.pollingInterval === "number";
}
var defaultOptions = {
  polling: false,
  staticNetwork: null,
  batchStallTime: 10,
  batchMaxSize: 1 << 20,
  batchMaxCount: 100,
  cacheTimeout: 250,
  pollingInterval: 4000
};
// @TODO: Unchecked Signers
var JsonRpcSigner = /*#__PURE__*/function (_abstract_signer_js_) {
  function JsonRpcSigner(provider, address) {
    var _this;
    _classCallCheck(this, JsonRpcSigner);
    _this = _callSuper(this, JsonRpcSigner, [provider]);
    _defineProperty(_this, "address", void 0);
    address = (0, index_js_2.getAddress)(address);
    (0, index_js_5.defineProperties)(_this, {
      address: address
    });
    return _this;
  }
  _inherits(JsonRpcSigner, _abstract_signer_js_);
  return _createClass(JsonRpcSigner, [{
    key: "connect",
    value: function connect(provider) {
      (0, index_js_5.assert)(false, "cannot reconnect JsonRpcSigner", "UNSUPPORTED_OPERATION", {
        operation: "signer.connect"
      });
    }
  }, {
    key: "getAddress",
    value: function () {
      var _getAddress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", this.address);
            case 1:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function getAddress() {
        return _getAddress.apply(this, arguments);
      }
      return getAddress;
    }() // JSON-RPC will automatially fill in nonce, etc. so we just check from
  }, {
    key: "populateTransaction",
    value: function () {
      var _populateTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(tx) {
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return this.populateCall(tx);
            case 2:
              return _context2.abrupt("return", _context2.sent);
            case 3:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function populateTransaction(_x) {
        return _populateTransaction.apply(this, arguments);
      }
      return populateTransaction;
    }() // Returns just the hash of the transaction after sent, which is what
    // the bare JSON-RPC API does;
  }, {
    key: "sendUncheckedTransaction",
    value: function () {
      var _sendUncheckedTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(_tx) {
        var _this2 = this;
        var tx, promises, _from, _to, hexTx;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              tx = deepCopy(_tx);
              promises = []; // Make sure the from matches the sender
              if (tx.from) {
                _from = tx.from;
                promises.push(_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
                  var from;
                  return _regeneratorRuntime().wrap(function _callee3$(_context3) {
                    while (1) switch (_context3.prev = _context3.next) {
                      case 0:
                        _context3.next = 2;
                        return (0, index_js_2.resolveAddress)(_from, _this2.provider);
                      case 2:
                        from = _context3.sent;
                        (0, index_js_5.assertArgument)(from != null && from.toLowerCase() === _this2.address.toLowerCase(), "from address mismatch", "transaction", _tx);
                        tx.from = from;
                      case 5:
                      case "end":
                        return _context3.stop();
                    }
                  }, _callee3);
                }))());
              } else {
                tx.from = this.address;
              }
              // The JSON-RPC for eth_sendTransaction uses 90000 gas; if the user
              // wishes to use this, it is easy to specify explicitly, otherwise
              // we look it up for them.
              if (tx.gasLimit == null) {
                promises.push(_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
                  return _regeneratorRuntime().wrap(function _callee4$(_context4) {
                    while (1) switch (_context4.prev = _context4.next) {
                      case 0:
                        _context4.next = 2;
                        return _this2.provider.estimateGas(_objectSpread(_objectSpread({}, tx), {}, {
                          from: _this2.address
                        }));
                      case 2:
                        tx.gasLimit = _context4.sent;
                      case 3:
                      case "end":
                        return _context4.stop();
                    }
                  }, _callee4);
                }))());
              }
              // The address may be an ENS name or Addressable
              if (tx.to != null) {
                _to = tx.to;
                promises.push(_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
                  return _regeneratorRuntime().wrap(function _callee5$(_context5) {
                    while (1) switch (_context5.prev = _context5.next) {
                      case 0:
                        _context5.next = 2;
                        return (0, index_js_2.resolveAddress)(_to, _this2.provider);
                      case 2:
                        tx.to = _context5.sent;
                      case 3:
                      case "end":
                        return _context5.stop();
                    }
                  }, _callee5);
                }))());
              }
              // Wait until all of our properties are filled in
              if (!promises.length) {
                _context6.next = 8;
                break;
              }
              _context6.next = 8;
              return Promise.all(promises);
            case 8:
              hexTx = this.provider.getRpcTransaction(tx);
              return _context6.abrupt("return", this.provider.send("eth_sendTransaction", [hexTx]));
            case 10:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this);
      }));
      function sendUncheckedTransaction(_x2) {
        return _sendUncheckedTransaction.apply(this, arguments);
      }
      return sendUncheckedTransaction;
    }()
  }, {
    key: "sendTransaction",
    value: function () {
      var _sendTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(tx) {
        var _this3 = this;
        var blockNumber, hash;
        return _regeneratorRuntime().wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              _context8.next = 2;
              return this.provider.getBlockNumber();
            case 2:
              blockNumber = _context8.sent;
              _context8.next = 5;
              return this.sendUncheckedTransaction(tx);
            case 5:
              hash = _context8.sent;
              _context8.next = 8;
              return new Promise(function (resolve, reject) {
                var timeouts = [1000, 100];
                var invalids = 0;
                var checkTx = /*#__PURE__*/function () {
                  var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {
                    var _tx2;
                    return _regeneratorRuntime().wrap(function _callee7$(_context7) {
                      while (1) switch (_context7.prev = _context7.next) {
                        case 0:
                          _context7.prev = 0;
                          _context7.next = 3;
                          return _this3.provider.getTransaction(hash);
                        case 3:
                          _tx2 = _context7.sent;
                          if (!(_tx2 != null)) {
                            _context7.next = 7;
                            break;
                          }
                          resolve(_tx2.replaceableTransaction(blockNumber));
                          return _context7.abrupt("return");
                        case 7:
                          _context7.next = 24;
                          break;
                        case 9:
                          _context7.prev = 9;
                          _context7.t0 = _context7["catch"](0);
                          if (!((0, index_js_5.isError)(_context7.t0, "CANCELLED") || (0, index_js_5.isError)(_context7.t0, "BAD_DATA") || (0, index_js_5.isError)(_context7.t0, "NETWORK_ERROR" || (0, index_js_5.isError)(_context7.t0, "UNSUPPORTED_OPERATION")))) {
                            _context7.next = 16;
                            break;
                          }
                          if (_context7.t0.info == null) {
                            _context7.t0.info = {};
                          }
                          _context7.t0.info.sendTransactionHash = hash;
                          reject(_context7.t0);
                          return _context7.abrupt("return");
                        case 16:
                          if (!(0, index_js_5.isError)(_context7.t0, "INVALID_ARGUMENT")) {
                            _context7.next = 23;
                            break;
                          }
                          invalids++;
                          if (_context7.t0.info == null) {
                            _context7.t0.info = {};
                          }
                          _context7.t0.info.sendTransactionHash = hash;
                          if (!(invalids > 10)) {
                            _context7.next = 23;
                            break;
                          }
                          reject(_context7.t0);
                          return _context7.abrupt("return");
                        case 23:
                          // Notify anyone that cares; but we will try again, since
                          // it is likely an intermittent service error
                          _this3.provider.emit("error", (0, index_js_5.makeError)("failed to fetch transation after sending (will try again)", "UNKNOWN_ERROR", {
                            error: _context7.t0
                          }));
                        case 24:
                          // Wait another 4 seconds
                          _this3.provider._setTimeout(function () {
                            checkTx();
                          }, timeouts.pop() || 4000);
                        case 25:
                        case "end":
                          return _context7.stop();
                      }
                    }, _callee7, null, [[0, 9]]);
                  }));
                  return function checkTx() {
                    return _ref4.apply(this, arguments);
                  };
                }();
                checkTx();
              });
            case 8:
              return _context8.abrupt("return", _context8.sent);
            case 9:
            case "end":
              return _context8.stop();
          }
        }, _callee8, this);
      }));
      function sendTransaction(_x3) {
        return _sendTransaction.apply(this, arguments);
      }
      return sendTransaction;
    }()
  }, {
    key: "signTransaction",
    value: function () {
      var _signTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(_tx) {
        var tx, from, hexTx;
        return _regeneratorRuntime().wrap(function _callee9$(_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
              tx = deepCopy(_tx); // Make sure the from matches the sender
              if (!tx.from) {
                _context9.next = 9;
                break;
              }
              _context9.next = 4;
              return (0, index_js_2.resolveAddress)(tx.from, this.provider);
            case 4:
              from = _context9.sent;
              (0, index_js_5.assertArgument)(from != null && from.toLowerCase() === this.address.toLowerCase(), "from address mismatch", "transaction", _tx);
              tx.from = from;
              _context9.next = 10;
              break;
            case 9:
              tx.from = this.address;
            case 10:
              hexTx = this.provider.getRpcTransaction(tx);
              _context9.next = 13;
              return this.provider.send("eth_signTransaction", [hexTx]);
            case 13:
              return _context9.abrupt("return", _context9.sent);
            case 14:
            case "end":
              return _context9.stop();
          }
        }, _callee9, this);
      }));
      function signTransaction(_x4) {
        return _signTransaction.apply(this, arguments);
      }
      return signTransaction;
    }()
  }, {
    key: "signMessage",
    value: function () {
      var _signMessage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(_message) {
        var message;
        return _regeneratorRuntime().wrap(function _callee10$(_context10) {
          while (1) switch (_context10.prev = _context10.next) {
            case 0:
              message = typeof _message === "string" ? (0, index_js_5.toUtf8Bytes)(_message) : _message;
              _context10.next = 3;
              return this.provider.send("personal_sign", [(0, index_js_5.hexlify)(message), this.address.toLowerCase()]);
            case 3:
              return _context10.abrupt("return", _context10.sent);
            case 4:
            case "end":
              return _context10.stop();
          }
        }, _callee10, this);
      }));
      function signMessage(_x5) {
        return _signMessage.apply(this, arguments);
      }
      return signMessage;
    }()
  }, {
    key: "signTypedData",
    value: function () {
      var _signTypedData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(domain, types, _value) {
        var value, populated;
        return _regeneratorRuntime().wrap(function _callee12$(_context12) {
          while (1) switch (_context12.prev = _context12.next) {
            case 0:
              value = deepCopy(_value); // Populate any ENS names (in-place)
              _context12.next = 3;
              return index_js_3.TypedDataEncoder.resolveNames(domain, types, value, /*#__PURE__*/function () {
                var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(value) {
                  var address;
                  return _regeneratorRuntime().wrap(function _callee11$(_context11) {
                    while (1) switch (_context11.prev = _context11.next) {
                      case 0:
                        _context11.next = 2;
                        return (0, index_js_2.resolveAddress)(value);
                      case 2:
                        address = _context11.sent;
                        (0, index_js_5.assertArgument)(address != null, "TypedData does not support null address", "value", value);
                        return _context11.abrupt("return", address);
                      case 5:
                      case "end":
                        return _context11.stop();
                    }
                  }, _callee11);
                }));
                return function (_x9) {
                  return _ref5.apply(this, arguments);
                };
              }());
            case 3:
              populated = _context12.sent;
              _context12.next = 6;
              return this.provider.send("eth_signTypedData_v4", [this.address.toLowerCase(), JSON.stringify(index_js_3.TypedDataEncoder.getPayload(populated.domain, types, populated.value))]);
            case 6:
              return _context12.abrupt("return", _context12.sent);
            case 7:
            case "end":
              return _context12.stop();
          }
        }, _callee12, this);
      }));
      function signTypedData(_x6, _x7, _x8) {
        return _signTypedData.apply(this, arguments);
      }
      return signTypedData;
    }()
  }, {
    key: "unlock",
    value: function () {
      var _unlock = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(password) {
        return _regeneratorRuntime().wrap(function _callee13$(_context13) {
          while (1) switch (_context13.prev = _context13.next) {
            case 0:
              return _context13.abrupt("return", this.provider.send("personal_unlockAccount", [this.address.toLowerCase(), password, null]));
            case 1:
            case "end":
              return _context13.stop();
          }
        }, _callee13, this);
      }));
      function unlock(_x10) {
        return _unlock.apply(this, arguments);
      }
      return unlock;
    }() // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign
  }, {
    key: "_legacySignMessage",
    value: function () {
      var _legacySignMessage2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14(_message) {
        var message;
        return _regeneratorRuntime().wrap(function _callee14$(_context14) {
          while (1) switch (_context14.prev = _context14.next) {
            case 0:
              message = typeof _message === "string" ? (0, index_js_5.toUtf8Bytes)(_message) : _message;
              _context14.next = 3;
              return this.provider.send("eth_sign", [this.address.toLowerCase(), (0, index_js_5.hexlify)(message)]);
            case 3:
              return _context14.abrupt("return", _context14.sent);
            case 4:
            case "end":
              return _context14.stop();
          }
        }, _callee14, this);
      }));
      function _legacySignMessage(_x11) {
        return _legacySignMessage2.apply(this, arguments);
      }
      return _legacySignMessage;
    }()
  }]);
}(abstract_signer_js_1.AbstractSigner);
exports.JsonRpcSigner = JsonRpcSigner;
/**
 *  The JsonRpcApiProvider is an abstract class and **MUST** be
 *  sub-classed.
 *
 *  It provides the base for all JSON-RPC-based Provider interaction.
 *
 *  Sub-classing Notes:
 *  - a sub-class MUST override _send
 *  - a sub-class MUST call the `_start()` method once connected
 */
var _options = /*#__PURE__*/new WeakMap();
var _nextId = /*#__PURE__*/new WeakMap();
var _payloads = /*#__PURE__*/new WeakMap();
var _drainTimer = /*#__PURE__*/new WeakMap();
var _notReady = /*#__PURE__*/new WeakMap();
var _network = /*#__PURE__*/new WeakMap();
var _pendingDetectNetwork = /*#__PURE__*/new WeakMap();
var _JsonRpcApiProvider_brand = /*#__PURE__*/new WeakSet();
var JsonRpcApiProvider = /*#__PURE__*/function (_abstract_provider_js) {
  function JsonRpcApiProvider(network, options) {
    var _this4;
    _classCallCheck(this, JsonRpcApiProvider);
    _this4 = _callSuper(this, JsonRpcApiProvider, [network, options]);
    _classPrivateMethodInitSpec(_this4, _JsonRpcApiProvider_brand);
    _classPrivateFieldInitSpec(_this4, _options, void 0);
    // The next ID to use for the JSON-RPC ID field
    _classPrivateFieldInitSpec(_this4, _nextId, void 0);
    // Payloads are queued and triggered in batches using the drainTimer
    _classPrivateFieldInitSpec(_this4, _payloads, void 0);
    _classPrivateFieldInitSpec(_this4, _drainTimer, void 0);
    _classPrivateFieldInitSpec(_this4, _notReady, void 0);
    _classPrivateFieldInitSpec(_this4, _network, void 0);
    _classPrivateFieldInitSpec(_this4, _pendingDetectNetwork, void 0);
    _classPrivateFieldSet(_nextId, _this4, 1);
    _classPrivateFieldSet(_options, _this4, Object.assign({}, defaultOptions, options || {}));
    _classPrivateFieldSet(_payloads, _this4, []);
    _classPrivateFieldSet(_drainTimer, _this4, null);
    _classPrivateFieldSet(_network, _this4, null);
    _classPrivateFieldSet(_pendingDetectNetwork, _this4, null);
    {
      var resolve = null;
      var promise = new Promise(function (_resolve) {
        resolve = _resolve;
      });
      _classPrivateFieldSet(_notReady, _this4, {
        promise: promise,
        resolve: resolve
      });
    }
    var staticNetwork = _this4._getOption("staticNetwork");
    if (typeof staticNetwork === "boolean") {
      (0, index_js_5.assertArgument)(!staticNetwork || network !== "any", "staticNetwork cannot be used on special network 'any'", "options", options);
      if (staticNetwork && network != null) {
        _classPrivateFieldSet(_network, _this4, network_js_1.Network.from(network));
      }
    } else if (staticNetwork) {
      // Make sure any static network is compatbile with the provided netwrok
      (0, index_js_5.assertArgument)(network == null || staticNetwork.matches(network), "staticNetwork MUST match network object", "options", options);
      _classPrivateFieldSet(_network, _this4, staticNetwork);
    }
    return _this4;
  }
  /**
   *  Returns the value associated with the option %%key%%.
   *
   *  Sub-classes can use this to inquire about configuration options.
   */
  _inherits(JsonRpcApiProvider, _abstract_provider_js);
  return _createClass(JsonRpcApiProvider, [{
    key: "_getOption",
    value: function _getOption(key) {
      return _classPrivateFieldGet(_options, this)[key];
    }
    /**
     *  Gets the [[Network]] this provider has committed to. On each call, the network
     *  is detected, and if it has changed, the call will reject.
     */
  }, {
    key: "_network",
    get: function get() {
      (0, index_js_5.assert)(_classPrivateFieldGet(_network, this), "network is not available yet", "NETWORK_ERROR");
      return _classPrivateFieldGet(_network, this);
    }
    /**
     *  Resolves to the non-normalized value by performing %%req%%.
     *
     *  Sub-classes may override this to modify behavior of actions,
     *  and should generally call ``super._perform`` as a fallback.
     */
  }, {
    key: "_perform",
    value: (function () {
      var _perform2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15(req) {
        var tx, feeData, request;
        return _regeneratorRuntime().wrap(function _callee15$(_context15) {
          while (1) switch (_context15.prev = _context15.next) {
            case 0:
              if (!(req.method === "call" || req.method === "estimateGas")) {
                _context15.next = 8;
                break;
              }
              tx = req.transaction;
              if (!(tx && tx.type != null && (0, index_js_5.getBigInt)(tx.type))) {
                _context15.next = 8;
                break;
              }
              if (!(tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null)) {
                _context15.next = 8;
                break;
              }
              _context15.next = 6;
              return this.getFeeData();
            case 6:
              feeData = _context15.sent;
              if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {
                // Network doesn't know about EIP-1559 (and hence type)
                req = Object.assign({}, req, {
                  transaction: Object.assign({}, tx, {
                    type: undefined
                  })
                });
              }
            case 8:
              request = this.getRpcRequest(req);
              if (!(request != null)) {
                _context15.next = 13;
                break;
              }
              _context15.next = 12;
              return this.send(request.method, request.args);
            case 12:
              return _context15.abrupt("return", _context15.sent);
            case 13:
              return _context15.abrupt("return", _get(_getPrototypeOf(JsonRpcApiProvider.prototype), "_perform", this).call(this, req));
            case 14:
            case "end":
              return _context15.stop();
          }
        }, _callee15, this);
      }));
      function _perform(_x12) {
        return _perform2.apply(this, arguments);
      }
      return _perform;
    }()
    /**
     *  Sub-classes may override this; it detects the *actual* network that
     *  we are **currently** connected to.
     *
     *  Keep in mind that [[send]] may only be used once [[ready]], otherwise the
     *  _send primitive must be used instead.
     */
    )
  }, {
    key: "_detectNetwork",
    value: (function () {
      var _detectNetwork2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee18() {
        var _this5 = this;
        var network;
        return _regeneratorRuntime().wrap(function _callee18$(_context18) {
          while (1) switch (_context18.prev = _context18.next) {
            case 0:
              network = this._getOption("staticNetwork");
              if (!network) {
                _context18.next = 8;
                break;
              }
              if (!(network === true)) {
                _context18.next = 7;
                break;
              }
              if (!_classPrivateFieldGet(_network, this)) {
                _context18.next = 5;
                break;
              }
              return _context18.abrupt("return", _classPrivateFieldGet(_network, this));
            case 5:
              _context18.next = 8;
              break;
            case 7:
              return _context18.abrupt("return", network);
            case 8:
              if (!_classPrivateFieldGet(_pendingDetectNetwork, this)) {
                _context18.next = 12;
                break;
              }
              _context18.next = 11;
              return _classPrivateFieldGet(_pendingDetectNetwork, this);
            case 11:
              return _context18.abrupt("return", _context18.sent);
            case 12:
              if (!this.ready) {
                _context18.next = 17;
                break;
              }
              _classPrivateFieldSet(_pendingDetectNetwork, this, _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16() {
                var result;
                return _regeneratorRuntime().wrap(function _callee16$(_context16) {
                  while (1) switch (_context16.prev = _context16.next) {
                    case 0:
                      _context16.prev = 0;
                      _context16.t0 = network_js_1.Network;
                      _context16.t1 = (0, index_js_5.getBigInt);
                      _context16.next = 5;
                      return _this5.send("eth_chainId", []);
                    case 5:
                      _context16.t2 = _context16.sent;
                      _context16.t3 = (0, _context16.t1)(_context16.t2);
                      result = _context16.t0.from.call(_context16.t0, _context16.t3);
                      _classPrivateFieldSet(_pendingDetectNetwork, _this5, null);
                      return _context16.abrupt("return", result);
                    case 12:
                      _context16.prev = 12;
                      _context16.t4 = _context16["catch"](0);
                      _classPrivateFieldSet(_pendingDetectNetwork, _this5, null);
                      throw _context16.t4;
                    case 16:
                    case "end":
                      return _context16.stop();
                  }
                }, _callee16, null, [[0, 12]]);
              }))());
              _context18.next = 16;
              return _classPrivateFieldGet(_pendingDetectNetwork, this);
            case 16:
              return _context18.abrupt("return", _context18.sent);
            case 17:
              // We are not ready yet; use the primitive _send
              _classPrivateFieldSet(_pendingDetectNetwork, this, function () {
                var _ref7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17(_this$nextId, _this$nextId2) {
                  var payload, result;
                  return _regeneratorRuntime().wrap(function _callee17$(_context17) {
                    while (1) switch (_context17.prev = _context17.next) {
                      case 0:
                        payload = {
                          id: (_classPrivateFieldSet(_nextId, _this5, (_this$nextId = _classPrivateFieldGet(_nextId, _this5), _this$nextId2 = _this$nextId++, _this$nextId)), _this$nextId2),
                          method: "eth_chainId",
                          params: [],
                          jsonrpc: "2.0"
                        };
                        _this5.emit("debug", {
                          action: "sendRpcPayload",
                          payload: payload
                        });
                        _context17.prev = 2;
                        _context17.next = 5;
                        return _this5._send(payload);
                      case 5:
                        result = _context17.sent[0];
                        _classPrivateFieldSet(_pendingDetectNetwork, _this5, null);
                        _context17.next = 14;
                        break;
                      case 9:
                        _context17.prev = 9;
                        _context17.t0 = _context17["catch"](2);
                        _classPrivateFieldSet(_pendingDetectNetwork, _this5, null);
                        _this5.emit("debug", {
                          action: "receiveRpcError",
                          error: _context17.t0
                        });
                        throw _context17.t0;
                      case 14:
                        _this5.emit("debug", {
                          action: "receiveRpcResult",
                          result: result
                        });
                        if (!("result" in result)) {
                          _context17.next = 17;
                          break;
                        }
                        return _context17.abrupt("return", network_js_1.Network.from((0, index_js_5.getBigInt)(result.result)));
                      case 17:
                        throw _this5.getRpcError(payload, result);
                      case 18:
                      case "end":
                        return _context17.stop();
                    }
                  }, _callee17, null, [[2, 9]]);
                }));
                return function (_x13, _x14) {
                  return _ref7.apply(this, arguments);
                };
              }()());
              _context18.next = 20;
              return _classPrivateFieldGet(_pendingDetectNetwork, this);
            case 20:
              return _context18.abrupt("return", _context18.sent);
            case 21:
            case "end":
              return _context18.stop();
          }
        }, _callee18, this);
      }));
      function _detectNetwork() {
        return _detectNetwork2.apply(this, arguments);
      }
      return _detectNetwork;
    }()
    /**
     *  Sub-classes **MUST** call this. Until [[_start]] has been called, no calls
     *  will be passed to [[_send]] from [[send]]. If it is overridden, then
     *  ``super._start()`` **MUST** be called.
     *
     *  Calling it multiple times is safe and has no effect.
     */
    )
  }, {
    key: "_start",
    value: function _start() {
      var _this6 = this;
      if (_classPrivateFieldGet(_notReady, this) == null || _classPrivateFieldGet(_notReady, this).resolve == null) {
        return;
      }
      _classPrivateFieldGet(_notReady, this).resolve();
      _classPrivateFieldSet(_notReady, this, null);
      _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee19() {
        return _regeneratorRuntime().wrap(function _callee19$(_context19) {
          while (1) switch (_context19.prev = _context19.next) {
            case 0:
              if (!(_classPrivateFieldGet(_network, _this6) == null && !_this6.destroyed)) {
                _context19.next = 21;
                break;
              }
              _context19.prev = 1;
              _context19.t0 = _classPrivateFieldSet;
              _context19.t1 = _network;
              _context19.t2 = _this6;
              _context19.next = 7;
              return _this6._detectNetwork();
            case 7:
              _context19.t3 = _context19.sent;
              (0, _context19.t0)(_context19.t1, _context19.t2, _context19.t3);
              _context19.next = 19;
              break;
            case 11:
              _context19.prev = 11;
              _context19.t4 = _context19["catch"](1);
              if (!_this6.destroyed) {
                _context19.next = 15;
                break;
              }
              return _context19.abrupt("break", 21);
            case 15:
              console.log("JsonRpcProvider failed to detect network and cannot start up; retry in 1s (perhaps the URL is wrong or the node is not started)");
              _this6.emit("error", (0, index_js_5.makeError)("failed to bootstrap network detection", "NETWORK_ERROR", {
                event: "initial-network-discovery",
                info: {
                  error: _context19.t4
                }
              }));
              _context19.next = 19;
              return stall(1000);
            case 19:
              _context19.next = 0;
              break;
            case 21:
              // Start dispatching requests
              _assertClassBrand(_JsonRpcApiProvider_brand, _this6, _scheduleDrain).call(_this6);
            case 22:
            case "end":
              return _context19.stop();
          }
        }, _callee19, null, [[1, 11]]);
      }))();
    }
    /**
     *  Resolves once the [[_start]] has been called. This can be used in
     *  sub-classes to defer sending data until the connection has been
     *  established.
     */
  }, {
    key: "_waitUntilReady",
    value: (function () {
      var _waitUntilReady2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee20() {
        return _regeneratorRuntime().wrap(function _callee20$(_context20) {
          while (1) switch (_context20.prev = _context20.next) {
            case 0:
              if (!(_classPrivateFieldGet(_notReady, this) == null)) {
                _context20.next = 2;
                break;
              }
              return _context20.abrupt("return");
            case 2:
              _context20.next = 4;
              return _classPrivateFieldGet(_notReady, this).promise;
            case 4:
              return _context20.abrupt("return", _context20.sent);
            case 5:
            case "end":
              return _context20.stop();
          }
        }, _callee20, this);
      }));
      function _waitUntilReady() {
        return _waitUntilReady2.apply(this, arguments);
      }
      return _waitUntilReady;
    }()
    /**
     *  Return a Subscriber that will manage the %%sub%%.
     *
     *  Sub-classes may override this to modify the behavior of
     *  subscription management.
     */
    )
  }, {
    key: "_getSubscriber",
    value: function _getSubscriber(sub) {
      // Pending Filters aren't availble via polling
      if (sub.type === "pending") {
        return new subscriber_filterid_js_1.FilterIdPendingSubscriber(this);
      }
      if (sub.type === "event") {
        if (this._getOption("polling")) {
          return new subscriber_polling_js_1.PollingEventSubscriber(this, sub.filter);
        }
        return new subscriber_filterid_js_1.FilterIdEventSubscriber(this, sub.filter);
      }
      // Orphaned Logs are handled automatically, by the filter, since
      // logs with removed are emitted by it
      if (sub.type === "orphan" && sub.filter.orphan === "drop-log") {
        return new abstract_provider_js_1.UnmanagedSubscriber("orphan");
      }
      return _get(_getPrototypeOf(JsonRpcApiProvider.prototype), "_getSubscriber", this).call(this, sub);
    }
    /**
     *  Returns true only if the [[_start]] has been called.
     */
  }, {
    key: "ready",
    get: function get() {
      return _classPrivateFieldGet(_notReady, this) == null;
    }
    /**
     *  Returns %%tx%% as a normalized JSON-RPC transaction request,
     *  which has all values hexlified and any numeric values converted
     *  to Quantity values.
     */
  }, {
    key: "getRpcTransaction",
    value: function getRpcTransaction(tx) {
      var result = {};
      // JSON-RPC now requires numeric values to be "quantity" values
      ["chainId", "gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach(function (key) {
        if (tx[key] == null) {
          return;
        }
        var dstKey = key;
        if (key === "gasLimit") {
          dstKey = "gas";
        }
        result[dstKey] = (0, index_js_5.toQuantity)((0, index_js_5.getBigInt)(tx[key], "tx.".concat(key)));
      });
      // Make sure addresses and data are lowercase
      ["from", "to", "data"].forEach(function (key) {
        if (tx[key] == null) {
          return;
        }
        result[key] = (0, index_js_5.hexlify)(tx[key]);
      });
      // Normalize the access list object
      if (tx.accessList) {
        result["accessList"] = (0, index_js_4.accessListify)(tx.accessList);
      }
      if (tx.blobVersionedHashes) {
        // @TODO: Remove this <any> case once EIP-4844 added to prepared tx
        result["blobVersionedHashes"] = tx.blobVersionedHashes.map(function (h) {
          return h.toLowerCase();
        });
      }
      // @TODO: blobs should probably also be copied over, optionally
      // accounting for the kzg property to backfill blobVersionedHashes
      // using the commitment. Or should that be left as an exercise to
      // the caller?
      return result;
    }
    /**
     *  Returns the request method and arguments required to perform
     *  %%req%%.
     */
  }, {
    key: "getRpcRequest",
    value: function getRpcRequest(req) {
      switch (req.method) {
        case "chainId":
          return {
            method: "eth_chainId",
            args: []
          };
        case "getBlockNumber":
          return {
            method: "eth_blockNumber",
            args: []
          };
        case "getGasPrice":
          return {
            method: "eth_gasPrice",
            args: []
          };
        case "getPriorityFee":
          return {
            method: "eth_maxPriorityFeePerGas",
            args: []
          };
        case "getBalance":
          return {
            method: "eth_getBalance",
            args: [getLowerCase(req.address), req.blockTag]
          };
        case "getTransactionCount":
          return {
            method: "eth_getTransactionCount",
            args: [getLowerCase(req.address), req.blockTag]
          };
        case "getCode":
          return {
            method: "eth_getCode",
            args: [getLowerCase(req.address), req.blockTag]
          };
        case "getStorage":
          return {
            method: "eth_getStorageAt",
            args: [getLowerCase(req.address), "0x" + req.position.toString(16), req.blockTag]
          };
        case "broadcastTransaction":
          return {
            method: "eth_sendRawTransaction",
            args: [req.signedTransaction]
          };
        case "getBlock":
          if ("blockTag" in req) {
            return {
              method: "eth_getBlockByNumber",
              args: [req.blockTag, !!req.includeTransactions]
            };
          } else if ("blockHash" in req) {
            return {
              method: "eth_getBlockByHash",
              args: [req.blockHash, !!req.includeTransactions]
            };
          }
          break;
        case "getTransaction":
          return {
            method: "eth_getTransactionByHash",
            args: [req.hash]
          };
        case "getTransactionReceipt":
          return {
            method: "eth_getTransactionReceipt",
            args: [req.hash]
          };
        case "call":
          return {
            method: "eth_call",
            args: [this.getRpcTransaction(req.transaction), req.blockTag]
          };
        case "estimateGas":
          {
            return {
              method: "eth_estimateGas",
              args: [this.getRpcTransaction(req.transaction)]
            };
          }
        case "getLogs":
          if (req.filter && req.filter.address != null) {
            if (Array.isArray(req.filter.address)) {
              req.filter.address = req.filter.address.map(getLowerCase);
            } else {
              req.filter.address = getLowerCase(req.filter.address);
            }
          }
          return {
            method: "eth_getLogs",
            args: [req.filter]
          };
      }
      return null;
    }
    /**
     *  Returns an ethers-style Error for the given JSON-RPC error
     *  %%payload%%, coalescing the various strings and error shapes
     *  that different nodes return, coercing them into a machine-readable
     *  standardized error.
     */
  }, {
    key: "getRpcError",
    value: function getRpcError(payload, _error) {
      var method = payload.method;
      var error = _error.error;
      if (method === "eth_estimateGas" && error.message) {
        var msg = error.message;
        if (!msg.match(/revert/i) && msg.match(/insufficient funds/i)) {
          return (0, index_js_5.makeError)("insufficient funds", "INSUFFICIENT_FUNDS", {
            transaction: payload.params[0],
            info: {
              payload: payload,
              error: error
            }
          });
        }
      }
      if (method === "eth_call" || method === "eth_estimateGas") {
        var result = spelunkData(error);
        var _e = index_js_1.AbiCoder.getBuiltinCallException(method === "eth_call" ? "call" : "estimateGas", payload.params[0], result ? result.data : null);
        _e.info = {
          error: error,
          payload: payload
        };
        return _e;
      }
      // Only estimateGas and call can return arbitrary contract-defined text, so now we
      // we can process text safely.
      var message = JSON.stringify(spelunkMessage(error));
      if (typeof error.message === "string" && error.message.match(/user denied|ethers-user-denied/i)) {
        var actionMap = {
          eth_sign: "signMessage",
          personal_sign: "signMessage",
          eth_signTypedData_v4: "signTypedData",
          eth_signTransaction: "signTransaction",
          eth_sendTransaction: "sendTransaction",
          eth_requestAccounts: "requestAccess",
          wallet_requestAccounts: "requestAccess"
        };
        return (0, index_js_5.makeError)("user rejected action", "ACTION_REJECTED", {
          action: actionMap[method] || "unknown",
          reason: "rejected",
          info: {
            payload: payload,
            error: error
          }
        });
      }
      if (method === "eth_sendRawTransaction" || method === "eth_sendTransaction") {
        var transaction = payload.params[0];
        if (message.match(/insufficient funds|base fee exceeds gas limit/i)) {
          return (0, index_js_5.makeError)("insufficient funds for intrinsic transaction cost", "INSUFFICIENT_FUNDS", {
            transaction: transaction,
            info: {
              error: error
            }
          });
        }
        if (message.match(/nonce/i) && message.match(/too low/i)) {
          return (0, index_js_5.makeError)("nonce has already been used", "NONCE_EXPIRED", {
            transaction: transaction,
            info: {
              error: error
            }
          });
        }
        // "replacement transaction underpriced"
        if (message.match(/replacement transaction/i) && message.match(/underpriced/i)) {
          return (0, index_js_5.makeError)("replacement fee too low", "REPLACEMENT_UNDERPRICED", {
            transaction: transaction,
            info: {
              error: error
            }
          });
        }
        if (message.match(/only replay-protected/i)) {
          return (0, index_js_5.makeError)("legacy pre-eip-155 transactions not supported", "UNSUPPORTED_OPERATION", {
            operation: method,
            info: {
              transaction: transaction,
              info: {
                error: error
              }
            }
          });
        }
      }
      var unsupported = !!message.match(/the method .* does not exist/i);
      if (!unsupported) {
        if (error && error.details && error.details.startsWith("Unauthorized method:")) {
          unsupported = true;
        }
      }
      if (unsupported) {
        return (0, index_js_5.makeError)("unsupported operation", "UNSUPPORTED_OPERATION", {
          operation: payload.method,
          info: {
            error: error,
            payload: payload
          }
        });
      }
      return (0, index_js_5.makeError)("could not coalesce error", "UNKNOWN_ERROR", {
        error: error,
        payload: payload
      });
    }
    /**
     *  Requests the %%method%% with %%params%% via the JSON-RPC protocol
     *  over the underlying channel. This can be used to call methods
     *  on the backend that do not have a high-level API within the Provider
     *  API.
     *
     *  This method queues requests according to the batch constraints
     *  in the options, assigns the request a unique ID.
     *
     *  **Do NOT override** this method in sub-classes; instead
     *  override [[_send]] or force the options values in the
     *  call to the constructor to modify this method's behavior.
     */
  }, {
    key: "send",
    value: function send(method, params) {
      var _this$nextId3,
        _this$nextId4,
        _this7 = this;
      // @TODO: cache chainId?? purge on switch_networks
      // We have been destroyed; no operations are supported anymore
      if (this.destroyed) {
        return Promise.reject((0, index_js_5.makeError)("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", {
          operation: method
        }));
      }
      var id = (_classPrivateFieldSet(_nextId, this, (_this$nextId3 = _classPrivateFieldGet(_nextId, this), _this$nextId4 = _this$nextId3++, _this$nextId3)), _this$nextId4);
      var promise = new Promise(function (resolve, reject) {
        _classPrivateFieldGet(_payloads, _this7).push({
          resolve: resolve,
          reject: reject,
          payload: {
            method: method,
            params: params,
            id: id,
            jsonrpc: "2.0"
          }
        });
      });
      // If there is not a pending drainTimer, set one
      _assertClassBrand(_JsonRpcApiProvider_brand, this, _scheduleDrain).call(this);
      return promise;
    }
    /**
     *  Resolves to the [[Signer]] account for  %%address%% managed by
     *  the client.
     *
     *  If the %%address%% is a number, it is used as an index in the
     *  the accounts from [[listAccounts]].
     *
     *  This can only be used on clients which manage accounts (such as
     *  Geth with imported account or MetaMask).
     *
     *  Throws if the account doesn't exist.
     */
  }, {
    key: "getSigner",
    value: (function () {
      var _getSigner = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee21(address) {
        var accountsPromise, _accounts, _yield, accounts, _iterator, _step, account;
        return _regeneratorRuntime().wrap(function _callee21$(_context21) {
          while (1) switch (_context21.prev = _context21.next) {
            case 0:
              if (address == null) {
                address = 0;
              }
              accountsPromise = this.send("eth_accounts", []); // Account index
              if (!(typeof address === "number")) {
                _context21.next = 9;
                break;
              }
              _context21.next = 5;
              return accountsPromise;
            case 5:
              _accounts = _context21.sent;
              if (!(address >= _accounts.length)) {
                _context21.next = 8;
                break;
              }
              throw new Error("no such account");
            case 8:
              return _context21.abrupt("return", new JsonRpcSigner(this, _accounts[address]));
            case 9:
              _context21.next = 11;
              return (0, index_js_5.resolveProperties)({
                network: this.getNetwork(),
                accounts: accountsPromise
              });
            case 11:
              _yield = _context21.sent;
              accounts = _yield.accounts;
              // Account address
              address = (0, index_js_2.getAddress)(address);
              _iterator = _createForOfIteratorHelper(accounts);
              _context21.prev = 15;
              _iterator.s();
            case 17:
              if ((_step = _iterator.n()).done) {
                _context21.next = 23;
                break;
              }
              account = _step.value;
              if (!((0, index_js_2.getAddress)(account) === address)) {
                _context21.next = 21;
                break;
              }
              return _context21.abrupt("return", new JsonRpcSigner(this, address));
            case 21:
              _context21.next = 17;
              break;
            case 23:
              _context21.next = 28;
              break;
            case 25:
              _context21.prev = 25;
              _context21.t0 = _context21["catch"](15);
              _iterator.e(_context21.t0);
            case 28:
              _context21.prev = 28;
              _iterator.f();
              return _context21.finish(28);
            case 31:
              throw new Error("invalid account");
            case 32:
            case "end":
              return _context21.stop();
          }
        }, _callee21, this, [[15, 25, 28, 31]]);
      }));
      function getSigner(_x15) {
        return _getSigner.apply(this, arguments);
      }
      return getSigner;
    }())
  }, {
    key: "listAccounts",
    value: function () {
      var _listAccounts = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee22() {
        var _this8 = this;
        var accounts;
        return _regeneratorRuntime().wrap(function _callee22$(_context22) {
          while (1) switch (_context22.prev = _context22.next) {
            case 0:
              _context22.next = 2;
              return this.send("eth_accounts", []);
            case 2:
              accounts = _context22.sent;
              return _context22.abrupt("return", accounts.map(function (a) {
                return new JsonRpcSigner(_this8, a);
              }));
            case 4:
            case "end":
              return _context22.stop();
          }
        }, _callee22, this);
      }));
      function listAccounts() {
        return _listAccounts.apply(this, arguments);
      }
      return listAccounts;
    }()
  }, {
    key: "destroy",
    value: function destroy() {
      // Stop processing requests
      if (_classPrivateFieldGet(_drainTimer, this)) {
        clearTimeout(_classPrivateFieldGet(_drainTimer, this));
        _classPrivateFieldSet(_drainTimer, this, null);
      }
      // Cancel all pending requests
      var _iterator2 = _createForOfIteratorHelper(_classPrivateFieldGet(_payloads, this)),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var _step2$value = _step2.value,
            payload = _step2$value.payload,
            reject = _step2$value.reject;
          reject((0, index_js_5.makeError)("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", {
            operation: payload.method
          }));
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      _classPrivateFieldSet(_payloads, this, []);
      // Parent clean-up
      _get(_getPrototypeOf(JsonRpcApiProvider.prototype), "destroy", this).call(this);
    }
  }]);
}(abstract_provider_js_1.AbstractProvider);
function _scheduleDrain() {
  var _this12 = this;
  if (_classPrivateFieldGet(_drainTimer, this)) {
    return;
  }
  // If we aren't using batching, no harm in sending it immediately
  var stallTime = this._getOption("batchMaxCount") === 1 ? 0 : this._getOption("batchStallTime");
  _classPrivateFieldSet(_drainTimer, this, setTimeout(function () {
    _classPrivateFieldSet(_drainTimer, _this12, null);
    var payloads = _classPrivateFieldGet(_payloads, _this12);
    _classPrivateFieldSet(_payloads, _this12, []);
    var _loop = function _loop() {
      // Create payload batches that satisfy our batch constraints
      var batch = [payloads.shift()];
      while (payloads.length) {
        if (batch.length === _classPrivateFieldGet(_options, _this12).batchMaxCount) {
          break;
        }
        batch.push(payloads.shift());
        var bytes = JSON.stringify(batch.map(function (p) {
          return p.payload;
        }));
        if (bytes.length > _classPrivateFieldGet(_options, _this12).batchMaxSize) {
          payloads.unshift(batch.pop());
          break;
        }
      }
      // Process the result to each payload
      _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee25() {
        var payload, result, _loop2, _ret, _i, _batch, _i2, _batch2, reject;
        return _regeneratorRuntime().wrap(function _callee25$(_context26) {
          while (1) switch (_context26.prev = _context26.next) {
            case 0:
              payload = batch.length === 1 ? batch[0].payload : batch.map(function (p) {
                return p.payload;
              });
              _this12.emit("debug", {
                action: "sendRpcPayload",
                payload: payload
              });
              _context26.prev = 2;
              _context26.next = 5;
              return _this12._send(payload);
            case 5:
              result = _context26.sent;
              _this12.emit("debug", {
                action: "receiveRpcResult",
                result: result
              });
              // Process results in batch order
              _loop2 = /*#__PURE__*/_regeneratorRuntime().mark(function _loop2() {
                var _batch$_i, resolve, reject, payload, resp, error;
                return _regeneratorRuntime().wrap(function _loop2$(_context25) {
                  while (1) switch (_context25.prev = _context25.next) {
                    case 0:
                      _batch$_i = _batch[_i], resolve = _batch$_i.resolve, reject = _batch$_i.reject, payload = _batch$_i.payload;
                      if (!_this12.destroyed) {
                        _context25.next = 4;
                        break;
                      }
                      reject((0, index_js_5.makeError)("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", {
                        operation: payload.method
                      }));
                      return _context25.abrupt("return", 0);
                    case 4:
                      // Find the matching result
                      resp = result.filter(function (r) {
                        return r.id === payload.id;
                      })[0]; // No result; the node failed us in unexpected ways
                      if (!(resp == null)) {
                        _context25.next = 10;
                        break;
                      }
                      error = (0, index_js_5.makeError)("missing response for request", "BAD_DATA", {
                        value: result,
                        info: {
                          payload: payload
                        }
                      });
                      _this12.emit("error", error);
                      reject(error);
                      return _context25.abrupt("return", 0);
                    case 10:
                      if (!("error" in resp)) {
                        _context25.next = 13;
                        break;
                      }
                      reject(_this12.getRpcError(payload, resp));
                      return _context25.abrupt("return", 0);
                    case 13:
                      // All good; send the result
                      resolve(resp.result);
                    case 14:
                    case "end":
                      return _context25.stop();
                  }
                }, _loop2);
              });
              _i = 0, _batch = batch;
            case 9:
              if (!(_i < _batch.length)) {
                _context26.next = 17;
                break;
              }
              return _context26.delegateYield(_loop2(), "t0", 11);
            case 11:
              _ret = _context26.t0;
              if (!(_ret === 0)) {
                _context26.next = 14;
                break;
              }
              return _context26.abrupt("continue", 14);
            case 14:
              _i++;
              _context26.next = 9;
              break;
            case 17:
              _context26.next = 23;
              break;
            case 19:
              _context26.prev = 19;
              _context26.t1 = _context26["catch"](2);
              _this12.emit("debug", {
                action: "receiveRpcError",
                error: _context26.t1
              });
              for (_i2 = 0, _batch2 = batch; _i2 < _batch2.length; _i2++) {
                reject = _batch2[_i2].reject;
                // @TODO: augment the error with the payload
                reject(_context26.t1);
              }
            case 23:
            case "end":
              return _context26.stop();
          }
        }, _callee25, null, [[2, 19]]);
      }))();
    };
    while (payloads.length) {
      _loop();
    }
  }, stallTime));
}
exports.JsonRpcApiProvider = JsonRpcApiProvider;
// @TODO: remove this in v7, it is not exported because this functionality
// is exposed in the JsonRpcApiProvider by setting polling to true. It should
// be safe to remove regardless, because it isn't reachable, but just in case.
/**
 *  @_ignore:
 */
var _pollingInterval = /*#__PURE__*/new WeakMap();
var JsonRpcApiPollingProvider = /*#__PURE__*/function (_JsonRpcApiProvider2) {
  function JsonRpcApiPollingProvider(network, options) {
    var _this9;
    _classCallCheck(this, JsonRpcApiPollingProvider);
    _this9 = _callSuper(this, JsonRpcApiPollingProvider, [network, options]);
    _classPrivateFieldInitSpec(_this9, _pollingInterval, void 0);
    var pollingInterval = _this9._getOption("pollingInterval");
    if (pollingInterval == null) {
      pollingInterval = defaultOptions.pollingInterval;
    }
    _classPrivateFieldSet(_pollingInterval, _this9, pollingInterval);
    return _this9;
  }
  _inherits(JsonRpcApiPollingProvider, _JsonRpcApiProvider2);
  return _createClass(JsonRpcApiPollingProvider, [{
    key: "_getSubscriber",
    value: function _getSubscriber(sub) {
      var subscriber = _get(_getPrototypeOf(JsonRpcApiPollingProvider.prototype), "_getSubscriber", this).call(this, sub);
      if (isPollable(subscriber)) {
        subscriber.pollingInterval = _classPrivateFieldGet(_pollingInterval, this);
      }
      return subscriber;
    }
    /**
     *  The polling interval (default: 4000 ms)
     */
  }, {
    key: "pollingInterval",
    get: function get() {
      return _classPrivateFieldGet(_pollingInterval, this);
    },
    set: function set(value) {
      var _this10 = this;
      if (!Number.isInteger(value) || value < 0) {
        throw new Error("invalid interval");
      }
      _classPrivateFieldSet(_pollingInterval, this, value);
      this._forEachSubscriber(function (sub) {
        if (isPollable(sub)) {
          sub.pollingInterval = _classPrivateFieldGet(_pollingInterval, _this10);
        }
      });
    }
  }]);
}(JsonRpcApiProvider);
exports.JsonRpcApiPollingProvider = JsonRpcApiPollingProvider;
/**
 *  The JsonRpcProvider is one of the most common Providers,
 *  which performs all operations over HTTP (or HTTPS) requests.
 *
 *  Events are processed by polling the backend for the current block
 *  number; when it advances, all block-base events are then checked
 *  for updates.
 */
var _connect = /*#__PURE__*/new WeakMap();
var JsonRpcProvider = /*#__PURE__*/function (_JsonRpcApiPollingPro) {
  function JsonRpcProvider(url, network, options) {
    var _this11;
    _classCallCheck(this, JsonRpcProvider);
    if (url == null) {
      url = "http:/\/localhost:8545";
    }
    _this11 = _callSuper(this, JsonRpcProvider, [network, options]);
    _classPrivateFieldInitSpec(_this11, _connect, void 0);
    if (typeof url === "string") {
      _classPrivateFieldSet(_connect, _this11, new index_js_5.FetchRequest(url));
    } else {
      _classPrivateFieldSet(_connect, _this11, url.clone());
    }
    return _this11;
  }
  _inherits(JsonRpcProvider, _JsonRpcApiPollingPro);
  return _createClass(JsonRpcProvider, [{
    key: "_getConnection",
    value: function _getConnection() {
      return _classPrivateFieldGet(_connect, this).clone();
    }
  }, {
    key: "send",
    value: function () {
      var _send2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee23(method, params) {
        return _regeneratorRuntime().wrap(function _callee23$(_context23) {
          while (1) switch (_context23.prev = _context23.next) {
            case 0:
              _context23.next = 2;
              return this._start();
            case 2:
              _context23.next = 4;
              return _get(_getPrototypeOf(JsonRpcProvider.prototype), "send", this).call(this, method, params);
            case 4:
              return _context23.abrupt("return", _context23.sent);
            case 5:
            case "end":
              return _context23.stop();
          }
        }, _callee23, this);
      }));
      function send(_x16, _x17) {
        return _send2.apply(this, arguments);
      }
      return send;
    }()
  }, {
    key: "_send",
    value: function () {
      var _send3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee24(payload) {
        var request, response, resp;
        return _regeneratorRuntime().wrap(function _callee24$(_context24) {
          while (1) switch (_context24.prev = _context24.next) {
            case 0:
              // Configure a POST connection for the requested method
              request = this._getConnection();
              request.body = JSON.stringify(payload);
              request.setHeader("content-type", "application/json");
              _context24.next = 5;
              return request.send();
            case 5:
              response = _context24.sent;
              response.assertOk();
              resp = response.bodyJson;
              if (!Array.isArray(resp)) {
                resp = [resp];
              }
              return _context24.abrupt("return", resp);
            case 10:
            case "end":
              return _context24.stop();
          }
        }, _callee24, this);
      }));
      function _send(_x18) {
        return _send3.apply(this, arguments);
      }
      return _send;
    }()
  }]);
}(JsonRpcApiPollingProvider);
exports.JsonRpcProvider = JsonRpcProvider;
function spelunkData(value) {
  if (value == null) {
    return null;
  }
  // These *are* the droids we're looking for.
  if (typeof value.message === "string" && value.message.match(/revert/i) && (0, index_js_5.isHexString)(value.data)) {
    return {
      message: value.message,
      data: value.data
    };
  }
  // Spelunk further...
  if (_typeof(value) === "object") {
    for (var key in value) {
      var result = spelunkData(value[key]);
      if (result) {
        return result;
      }
    }
    return null;
  }
  // Might be a JSON string we can further descend...
  if (typeof value === "string") {
    try {
      return spelunkData(JSON.parse(value));
    } catch (error) {}
  }
  return null;
}
function _spelunkMessage(value, result) {
  if (value == null) {
    return;
  }
  // These *are* the droids we're looking for.
  if (typeof value.message === "string") {
    result.push(value.message);
  }
  // Spelunk further...
  if (_typeof(value) === "object") {
    for (var key in value) {
      _spelunkMessage(value[key], result);
    }
  }
  // Might be a JSON string we can further descend...
  if (typeof value === "string") {
    try {
      return _spelunkMessage(JSON.parse(value), result);
    } catch (error) {}
  }
}
function spelunkMessage(value) {
  var result = [];
  _spelunkMessage(value, result);
  return result;
}

},{"../abi/index.js":201,"../address/index.js":207,"../hash/index.js":230,"../transaction/index.js":266,"../utils/index.js":276,"./abstract-provider.js":236,"./abstract-signer.js":237,"./network.js":243,"./subscriber-filterid.js":261,"./subscriber-polling.js":262}],255:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _get() { return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }
function _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PocketProvider = void 0;
/**
 *  [[link-pocket]] provides a third-party service for connecting to
 *  various blockchains over JSON-RPC.
 *
 *  **Supported Networks**
 *
 *  - Ethereum Mainnet (``mainnet``)
 *  - Goerli Testnet (``goerli``)
 *  - Polygon (``matic``)
 *  - Arbitrum (``arbitrum``)
 *
 *  @_subsection: api/providers/thirdparty:Pocket  [providers-pocket]
 */
var index_js_1 = require("../utils/index.js");
var community_js_1 = require("./community.js");
var network_js_1 = require("./network.js");
var provider_jsonrpc_js_1 = require("./provider-jsonrpc.js");
var defaultApplicationId = "62e1ad51b37b8e00394bda3b";
function getHost(name) {
  switch (name) {
    case "mainnet":
      return "eth-mainnet.gateway.pokt.network";
    case "goerli":
      return "eth-goerli.gateway.pokt.network";
    case "matic":
      return "poly-mainnet.gateway.pokt.network";
    case "matic-mumbai":
      return "polygon-mumbai-rpc.gateway.pokt.network";
  }
  (0, index_js_1.assertArgument)(false, "unsupported network", "network", name);
}
/**
 *  The **PocketProvider** connects to the [[link-pocket]]
 *  JSON-RPC end-points.
 *
 *  By default, a highly-throttled API key is used, which is
 *  appropriate for quick prototypes and simple scripts. To
 *  gain access to an increased rate-limit, it is highly
 *  recommended to [sign up here](link-pocket-signup).
 */
var PocketProvider = /*#__PURE__*/function (_provider_jsonrpc_js_) {
  /**
   *  Create a new **PocketProvider**.
   *
   *  By default connecting to ``mainnet`` with a highly throttled
   *  API key.
   */
  function PocketProvider(_network, applicationId, applicationSecret) {
    var _this;
    _classCallCheck(this, PocketProvider);
    if (_network == null) {
      _network = "mainnet";
    }
    var network = network_js_1.Network.from(_network);
    if (applicationId == null) {
      applicationId = defaultApplicationId;
    }
    if (applicationSecret == null) {
      applicationSecret = null;
    }
    var options = {
      staticNetwork: network
    };
    var request = PocketProvider.getRequest(network, applicationId, applicationSecret);
    _this = _callSuper(this, PocketProvider, [request, network, options]);
    /**
     *  The Application ID for the Pocket connection.
     */
    _defineProperty(_this, "applicationId", void 0);
    /**
     *  The Application Secret for making authenticated requests
     *  to the Pocket connection.
     */
    _defineProperty(_this, "applicationSecret", void 0);
    (0, index_js_1.defineProperties)(_this, {
      applicationId: applicationId,
      applicationSecret: applicationSecret
    });
    return _this;
  }
  _inherits(PocketProvider, _provider_jsonrpc_js_);
  return _createClass(PocketProvider, [{
    key: "_getProvider",
    value: function _getProvider(chainId) {
      try {
        return new PocketProvider(chainId, this.applicationId, this.applicationSecret);
      } catch (error) {}
      return _get(_getPrototypeOf(PocketProvider.prototype), "_getProvider", this).call(this, chainId);
    }
    /**
     *  Returns a prepared request for connecting to %%network%% with
     *  %%applicationId%%.
     */
  }, {
    key: "isCommunityResource",
    value: function isCommunityResource() {
      return this.applicationId === defaultApplicationId;
    }
  }], [{
    key: "getRequest",
    value: function getRequest(network, applicationId, applicationSecret) {
      if (applicationId == null) {
        applicationId = defaultApplicationId;
      }
      var request = new index_js_1.FetchRequest("https://".concat(getHost(network.name), "/v1/lb/").concat(applicationId));
      request.allowGzip = true;
      if (applicationSecret) {
        request.setCredentials("", applicationSecret);
      }
      if (applicationId === defaultApplicationId) {
        request.retryFunc = /*#__PURE__*/function () {
          var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(request, response, attempt) {
            return _regeneratorRuntime().wrap(function _callee$(_context) {
              while (1) switch (_context.prev = _context.next) {
                case 0:
                  (0, community_js_1.showThrottleMessage)("PocketProvider");
                  return _context.abrupt("return", true);
                case 2:
                case "end":
                  return _context.stop();
              }
            }, _callee);
          }));
          return function (_x, _x2, _x3) {
            return _ref.apply(this, arguments);
          };
        }();
      }
      return request;
    }
  }]);
}(provider_jsonrpc_js_1.JsonRpcProvider);
exports.PocketProvider = PocketProvider;

},{"../utils/index.js":276,"./community.js":238,"./network.js":243,"./provider-jsonrpc.js":254}],256:[function(require,module,exports){
"use strict";

/**
 *  [[link-quicknode]] provides a third-party service for connecting to
 *  various blockchains over JSON-RPC.
 *
 *  **Supported Networks**
 *
 *  - Ethereum Mainnet (``mainnet``)
 *  - Goerli Testnet (``goerli``)
 *  - Sepolia Testnet (``sepolia``)
 *  - Holesky Testnet (``holesky``)
 *  - Arbitrum (``arbitrum``)
 *  - Arbitrum Goerli Testnet (``arbitrum-goerli``)
 *  - Arbitrum Sepolia Testnet (``arbitrum-sepolia``)
 *  - Base Mainnet (``base``);
 *  - Base Goerli Testnet (``base-goerli``);
 *  - Base Sepolia Testnet (``base-sepolia``);
 *  - BNB Smart Chain Mainnet (``bnb``)
 *  - BNB Smart Chain Testnet (``bnbt``)
 *  - Optimism (``optimism``)
 *  - Optimism Goerli Testnet (``optimism-goerli``)
 *  - Optimism Sepolia Testnet (``optimism-sepolia``)
 *  - Polygon (``matic``)
 *  - Polygon Mumbai Testnet (``matic-mumbai``)
 *
 *  @_subsection: api/providers/thirdparty:QuickNode  [providers-quicknode]
 */
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _get() { return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }
function _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.QuickNodeProvider = void 0;
var index_js_1 = require("../utils/index.js");
var community_js_1 = require("./community.js");
var network_js_1 = require("./network.js");
var provider_jsonrpc_js_1 = require("./provider-jsonrpc.js");
var defaultToken = "919b412a057b5e9c9b6dce193c5a60242d6efadb";
function getHost(name) {
  switch (name) {
    case "mainnet":
      return "ethers.quiknode.pro";
    case "goerli":
      return "ethers.ethereum-goerli.quiknode.pro";
    case "sepolia":
      return "ethers.ethereum-sepolia.quiknode.pro";
    case "holesky":
      return "ethers.ethereum-holesky.quiknode.pro";
    case "arbitrum":
      return "ethers.arbitrum-mainnet.quiknode.pro";
    case "arbitrum-goerli":
      return "ethers.arbitrum-goerli.quiknode.pro";
    case "arbitrum-sepolia":
      return "ethers.arbitrum-sepolia.quiknode.pro";
    case "base":
      return "ethers.base-mainnet.quiknode.pro";
    case "base-goerli":
      return "ethers.base-goerli.quiknode.pro";
    case "base-spolia":
      return "ethers.base-sepolia.quiknode.pro";
    case "bnb":
      return "ethers.bsc.quiknode.pro";
    case "bnbt":
      return "ethers.bsc-testnet.quiknode.pro";
    case "matic":
      return "ethers.matic.quiknode.pro";
    case "matic-mumbai":
      return "ethers.matic-testnet.quiknode.pro";
    case "optimism":
      return "ethers.optimism.quiknode.pro";
    case "optimism-goerli":
      return "ethers.optimism-goerli.quiknode.pro";
    case "optimism-sepolia":
      return "ethers.optimism-sepolia.quiknode.pro";
    case "xdai":
      return "ethers.xdai.quiknode.pro";
  }
  (0, index_js_1.assertArgument)(false, "unsupported network", "network", name);
}
/*
@TODO:
  These networks are not currently present in the Network
  default included networks. Research them and ensure they
  are EVM compatible and work with ethers

  http://ethers.matic-amoy.quiknode.pro

  http://ethers.avalanche-mainnet.quiknode.pro
  http://ethers.avalanche-testnet.quiknode.pro
  http://ethers.blast-sepolia.quiknode.pro
  http://ethers.celo-mainnet.quiknode.pro
  http://ethers.fantom.quiknode.pro
  http://ethers.imx-demo.quiknode.pro
  http://ethers.imx-mainnet.quiknode.pro
  http://ethers.imx-testnet.quiknode.pro
  http://ethers.near-mainnet.quiknode.pro
  http://ethers.near-testnet.quiknode.pro
  http://ethers.nova-mainnet.quiknode.pro
  http://ethers.scroll-mainnet.quiknode.pro
  http://ethers.scroll-testnet.quiknode.pro
  http://ethers.tron-mainnet.quiknode.pro
  http://ethers.zkevm-mainnet.quiknode.pro
  http://ethers.zkevm-testnet.quiknode.pro
  http://ethers.zksync-mainnet.quiknode.pro
  http://ethers.zksync-testnet.quiknode.pro
*/
/**
 *  The **QuickNodeProvider** connects to the [[link-quicknode]]
 *  JSON-RPC end-points.
 *
 *  By default, a highly-throttled API token is used, which is
 *  appropriate for quick prototypes and simple scripts. To
 *  gain access to an increased rate-limit, it is highly
 *  recommended to [sign up here](link-quicknode).
 */
var QuickNodeProvider = /*#__PURE__*/function (_provider_jsonrpc_js_) {
  /**
   *  Creates a new **QuickNodeProvider**.
   */
  function QuickNodeProvider(_network, token) {
    var _this;
    _classCallCheck(this, QuickNodeProvider);
    if (_network == null) {
      _network = "mainnet";
    }
    var network = network_js_1.Network.from(_network);
    if (token == null) {
      token = defaultToken;
    }
    var request = QuickNodeProvider.getRequest(network, token);
    _this = _callSuper(this, QuickNodeProvider, [request, network, {
      staticNetwork: network
    }]);
    /**
     *  The API token.
     */
    _defineProperty(_this, "token", void 0);
    (0, index_js_1.defineProperties)(_this, {
      token: token
    });
    return _this;
  }
  _inherits(QuickNodeProvider, _provider_jsonrpc_js_);
  return _createClass(QuickNodeProvider, [{
    key: "_getProvider",
    value: function _getProvider(chainId) {
      try {
        return new QuickNodeProvider(chainId, this.token);
      } catch (error) {}
      return _get(_getPrototypeOf(QuickNodeProvider.prototype), "_getProvider", this).call(this, chainId);
    }
  }, {
    key: "isCommunityResource",
    value: function isCommunityResource() {
      return this.token === defaultToken;
    }
    /**
     *  Returns a new request prepared for %%network%% and the
     *  %%token%%.
     */
  }], [{
    key: "getRequest",
    value: function getRequest(network, token) {
      if (token == null) {
        token = defaultToken;
      }
      var request = new index_js_1.FetchRequest("https://".concat(getHost(network.name), "/").concat(token));
      request.allowGzip = true;
      //if (projectSecret) { request.setCredentials("", projectSecret); }
      if (token === defaultToken) {
        request.retryFunc = /*#__PURE__*/function () {
          var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(request, response, attempt) {
            return _regeneratorRuntime().wrap(function _callee$(_context) {
              while (1) switch (_context.prev = _context.next) {
                case 0:
                  (0, community_js_1.showThrottleMessage)("QuickNodeProvider");
                  return _context.abrupt("return", true);
                case 2:
                case "end":
                  return _context.stop();
              }
            }, _callee);
          }));
          return function (_x, _x2, _x3) {
            return _ref.apply(this, arguments);
          };
        }();
      }
      return request;
    }
  }]);
}(provider_jsonrpc_js_1.JsonRpcProvider);
exports.QuickNodeProvider = QuickNodeProvider;

},{"../utils/index.js":276,"./community.js":238,"./network.js":243,"./provider-jsonrpc.js":254}],257:[function(require,module,exports){
"use strict";

/**
 *  Generic long-lived socket provider.
 *
 *  Sub-classing notes
 *  - a sub-class MUST call the `_start()` method once connected
 *  - a sub-class MUST override the `_write(string)` method
 *  - a sub-class MUST call `_processMessage(string)` for each message
 *
 *  @_subsection: api/providers/abstract-provider:Socket Providers  [about-socketProvider]
 */
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _get() { return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }
function _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SocketProvider = exports.SocketEventSubscriber = exports.SocketPendingSubscriber = exports.SocketBlockSubscriber = exports.SocketSubscriber = void 0;
var abstract_provider_js_1 = require("./abstract-provider.js");
var index_js_1 = require("../utils/index.js");
var provider_jsonrpc_js_1 = require("./provider-jsonrpc.js");
/**
 *  A **SocketSubscriber** uses a socket transport to handle events and
 *  should use [[_emit]] to manage the events.
 */
var _provider = /*#__PURE__*/new WeakMap();
var _filter = /*#__PURE__*/new WeakMap();
var _filterId = /*#__PURE__*/new WeakMap();
var _paused = /*#__PURE__*/new WeakMap();
var _emitPromise = /*#__PURE__*/new WeakMap();
var SocketSubscriber = /*#__PURE__*/function () {
  /**
   *  Creates a new **SocketSubscriber** attached to %%provider%% listening
   *  to %%filter%%.
   */
  function SocketSubscriber(provider, filter) {
    _classCallCheck(this, SocketSubscriber);
    _classPrivateFieldInitSpec(this, _provider, void 0);
    _classPrivateFieldInitSpec(this, _filter, void 0);
    _classPrivateFieldInitSpec(this, _filterId, void 0);
    _classPrivateFieldInitSpec(this, _paused, void 0);
    _classPrivateFieldInitSpec(this, _emitPromise, void 0);
    _classPrivateFieldSet(_provider, this, provider);
    _classPrivateFieldSet(_filter, this, JSON.stringify(filter));
    _classPrivateFieldSet(_filterId, this, null);
    _classPrivateFieldSet(_paused, this, null);
    _classPrivateFieldSet(_emitPromise, this, null);
  }
  return _createClass(SocketSubscriber, [{
    key: "filter",
    get:
    /**
     *  The filter.
     */
    function get() {
      return JSON.parse(_classPrivateFieldGet(_filter, this));
    }
  }, {
    key: "start",
    value: function start() {
      var _this = this;
      _classPrivateFieldSet(_filterId, this, _classPrivateFieldGet(_provider, this).send("eth_subscribe", this.filter).then(function (filterId) {
        ;
        _classPrivateFieldGet(_provider, _this)._register(filterId, _this);
        return filterId;
      }));
    }
  }, {
    key: "stop",
    value: function stop() {
      var _this2 = this;
      _classPrivateFieldGet(_filterId, this).then(function (filterId) {
        if (_classPrivateFieldGet(_provider, _this2).destroyed) {
          return;
        }
        _classPrivateFieldGet(_provider, _this2).send("eth_unsubscribe", [filterId]);
      });
      _classPrivateFieldSet(_filterId, this, null);
    }
    // @TODO: pause should trap the current blockNumber, unsub, and on resume use getLogs
    //        and resume
  }, {
    key: "pause",
    value: function pause(dropWhilePaused) {
      (0, index_js_1.assert)(dropWhilePaused, "preserve logs while paused not supported by SocketSubscriber yet", "UNSUPPORTED_OPERATION", {
        operation: "pause(false)"
      });
      _classPrivateFieldSet(_paused, this, !!dropWhilePaused);
    }
  }, {
    key: "resume",
    value: function resume() {
      _classPrivateFieldSet(_paused, this, null);
    }
    /**
     *  @_ignore:
     */
  }, {
    key: "_handleMessage",
    value: function _handleMessage(message) {
      var _this3 = this;
      if (_classPrivateFieldGet(_filterId, this) == null) {
        return;
      }
      if (_classPrivateFieldGet(_paused, this) === null) {
        var emitPromise = _classPrivateFieldGet(_emitPromise, this);
        if (emitPromise == null) {
          emitPromise = this._emit(_classPrivateFieldGet(_provider, this), message);
        } else {
          emitPromise = emitPromise.then( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
            return _regeneratorRuntime().wrap(function _callee$(_context) {
              while (1) switch (_context.prev = _context.next) {
                case 0:
                  _context.next = 2;
                  return _this3._emit(_classPrivateFieldGet(_provider, _this3), message);
                case 2:
                case "end":
                  return _context.stop();
              }
            }, _callee);
          })));
        }
        _classPrivateFieldSet(_emitPromise, this, emitPromise.then(function () {
          if (_classPrivateFieldGet(_emitPromise, _this3) === emitPromise) {
            _classPrivateFieldSet(_emitPromise, _this3, null);
          }
        }));
      }
    }
    /**
     *  Sub-classes **must** override this to emit the events on the
     *  provider.
     */
  }, {
    key: "_emit",
    value: (function () {
      var _emit2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(provider, message) {
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              throw new Error("sub-classes must implemente this; _emit");
            case 1:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      }));
      function _emit(_x, _x2) {
        return _emit2.apply(this, arguments);
      }
      return _emit;
    }())
  }]);
}();
exports.SocketSubscriber = SocketSubscriber;
/**
 *  A **SocketBlockSubscriber** listens for ``newHeads`` events and emits
 *  ``"block"`` events.
 */
var SocketBlockSubscriber = /*#__PURE__*/function (_SocketSubscriber2) {
  /**
   *  @_ignore:
   */
  function SocketBlockSubscriber(provider) {
    _classCallCheck(this, SocketBlockSubscriber);
    return _callSuper(this, SocketBlockSubscriber, [provider, ["newHeads"]]);
  }
  _inherits(SocketBlockSubscriber, _SocketSubscriber2);
  return _createClass(SocketBlockSubscriber, [{
    key: "_emit",
    value: function () {
      var _emit3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(provider, message) {
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              provider.emit("block", parseInt(message.number));
            case 1:
            case "end":
              return _context3.stop();
          }
        }, _callee3);
      }));
      function _emit(_x3, _x4) {
        return _emit3.apply(this, arguments);
      }
      return _emit;
    }()
  }]);
}(SocketSubscriber);
exports.SocketBlockSubscriber = SocketBlockSubscriber;
/**
 *  A **SocketPendingSubscriber** listens for pending transacitons and emits
 *  ``"pending"`` events.
 */
var SocketPendingSubscriber = /*#__PURE__*/function (_SocketSubscriber3) {
  /**
   *  @_ignore:
   */
  function SocketPendingSubscriber(provider) {
    _classCallCheck(this, SocketPendingSubscriber);
    return _callSuper(this, SocketPendingSubscriber, [provider, ["newPendingTransactions"]]);
  }
  _inherits(SocketPendingSubscriber, _SocketSubscriber3);
  return _createClass(SocketPendingSubscriber, [{
    key: "_emit",
    value: function () {
      var _emit4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(provider, message) {
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              provider.emit("pending", message);
            case 1:
            case "end":
              return _context4.stop();
          }
        }, _callee4);
      }));
      function _emit(_x5, _x6) {
        return _emit4.apply(this, arguments);
      }
      return _emit;
    }()
  }]);
}(SocketSubscriber);
exports.SocketPendingSubscriber = SocketPendingSubscriber;
/**
 *  A **SocketEventSubscriber** listens for event logs.
 */
var _logFilter = /*#__PURE__*/new WeakMap();
var SocketEventSubscriber = /*#__PURE__*/function (_SocketSubscriber4) {
  /**
   *  @_ignore:
   */
  function SocketEventSubscriber(provider, filter) {
    var _this4;
    _classCallCheck(this, SocketEventSubscriber);
    _this4 = _callSuper(this, SocketEventSubscriber, [provider, ["logs", filter]]);
    _classPrivateFieldInitSpec(_this4, _logFilter, void 0);
    _classPrivateFieldSet(_logFilter, _this4, JSON.stringify(filter));
    return _this4;
  }
  _inherits(SocketEventSubscriber, _SocketSubscriber4);
  return _createClass(SocketEventSubscriber, [{
    key: "logFilter",
    get:
    /**
     *  The filter.
     */
    function get() {
      return JSON.parse(_classPrivateFieldGet(_logFilter, this));
    }
  }, {
    key: "_emit",
    value: function () {
      var _emit5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(provider, message) {
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              provider.emit(this.logFilter, provider._wrapLog(message, provider._network));
            case 1:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this);
      }));
      function _emit(_x7, _x8) {
        return _emit5.apply(this, arguments);
      }
      return _emit;
    }()
  }]);
}(SocketSubscriber);
exports.SocketEventSubscriber = SocketEventSubscriber;
/**
 *  A **SocketProvider** is backed by a long-lived connection over a
 *  socket, which can subscribe and receive real-time messages over
 *  its communication channel.
 */
var _callbacks = /*#__PURE__*/new WeakMap();
var _subs = /*#__PURE__*/new WeakMap();
var _pending = /*#__PURE__*/new WeakMap();
var SocketProvider = /*#__PURE__*/function (_provider_jsonrpc_js_) {
  /**
   *  Creates a new **SocketProvider** connected to %%network%%.
   *
   *  If unspecified, the network will be discovered.
   */
  function SocketProvider(network, _options) {
    var _this5;
    _classCallCheck(this, SocketProvider);
    // Copy the options
    var options = Object.assign({}, _options != null ? _options : {});
    // Support for batches is generally not supported for
    // connection-base providers; if this changes in the future
    // the _send should be updated to reflect this
    (0, index_js_1.assertArgument)(options.batchMaxCount == null || options.batchMaxCount === 1, "sockets-based providers do not support batches", "options.batchMaxCount", _options);
    options.batchMaxCount = 1;
    // Socket-based Providers (generally) cannot change their network,
    // since they have a long-lived connection; but let people override
    // this if they have just cause.
    if (options.staticNetwork == null) {
      options.staticNetwork = true;
    }
    _this5 = _callSuper(this, SocketProvider, [network, options]);
    _classPrivateFieldInitSpec(_this5, _callbacks, void 0);
    // Maps each filterId to its subscriber
    _classPrivateFieldInitSpec(_this5, _subs, void 0);
    // If any events come in before a subscriber has finished
    // registering, queue them
    _classPrivateFieldInitSpec(_this5, _pending, void 0);
    _classPrivateFieldSet(_callbacks, _this5, new Map());
    _classPrivateFieldSet(_subs, _this5, new Map());
    _classPrivateFieldSet(_pending, _this5, new Map());
    return _this5;
  }
  // This value is only valid after _start has been called
  /*
  get _network(): Network {
      if (this.#network == null) {
          throw new Error("this shouldn't happen");
      }
      return this.#network.clone();
  }
  */
  _inherits(SocketProvider, _provider_jsonrpc_js_);
  return _createClass(SocketProvider, [{
    key: "_getSubscriber",
    value: function _getSubscriber(sub) {
      switch (sub.type) {
        case "close":
          return new abstract_provider_js_1.UnmanagedSubscriber("close");
        case "block":
          return new SocketBlockSubscriber(this);
        case "pending":
          return new SocketPendingSubscriber(this);
        case "event":
          return new SocketEventSubscriber(this, sub.filter);
        case "orphan":
          // Handled auto-matically within AbstractProvider
          // when the log.removed = true
          if (sub.filter.orphan === "drop-log") {
            return new abstract_provider_js_1.UnmanagedSubscriber("drop-log");
          }
      }
      return _get(_getPrototypeOf(SocketProvider.prototype), "_getSubscriber", this).call(this, sub);
    }
    /**
     *  Register a new subscriber. This is used internalled by Subscribers
     *  and generally is unecessary unless extending capabilities.
     */
  }, {
    key: "_register",
    value: function _register(filterId, subscriber) {
      _classPrivateFieldGet(_subs, this).set(filterId, subscriber);
      var pending = _classPrivateFieldGet(_pending, this).get(filterId);
      if (pending) {
        var _iterator = _createForOfIteratorHelper(pending),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var message = _step.value;
            subscriber._handleMessage(message);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        _classPrivateFieldGet(_pending, this)["delete"](filterId);
      }
    }
  }, {
    key: "_send",
    value: function () {
      var _send2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(payload) {
        var _this6 = this;
        var promise;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              // WebSocket provider doesn't accept batches
              (0, index_js_1.assertArgument)(!Array.isArray(payload), "WebSocket does not support batch send", "payload", payload);
              // @TODO: stringify payloads here and store to prevent mutations
              // Prepare a promise to respond to
              promise = new Promise(function (resolve, reject) {
                _classPrivateFieldGet(_callbacks, _this6).set(payload.id, {
                  payload: payload,
                  resolve: resolve,
                  reject: reject
                });
              }); // Wait until the socket is connected before writing to it
              _context6.next = 4;
              return this._waitUntilReady();
            case 4:
              _context6.next = 6;
              return this._write(JSON.stringify(payload));
            case 6:
              _context6.next = 8;
              return promise;
            case 8:
              _context6.t0 = _context6.sent;
              return _context6.abrupt("return", [_context6.t0]);
            case 10:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this);
      }));
      function _send(_x9) {
        return _send2.apply(this, arguments);
      }
      return _send;
    }() // Sub-classes must call this once they are connected
    /*
    async _start(): Promise<void> {
        if (this.#ready) { return; }
         for (const { payload } of this.#callbacks.values()) {
            await this._write(JSON.stringify(payload));
        }
         this.#ready = (async function() {
            await super._start();
        })();
    }
    */
    /**
     *  Sub-classes **must** call this with messages received over their
     *  transport to be processed and dispatched.
     */
  }, {
    key: "_processMessage",
    value: function () {
      var _processMessage2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(message) {
        var result, callback, filterId, subscriber, pending;
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              result = JSON.parse(message);
              if (!(result && _typeof(result) === "object" && "id" in result)) {
                _context7.next = 10;
                break;
              }
              callback = _classPrivateFieldGet(_callbacks, this).get(result.id);
              if (!(callback == null)) {
                _context7.next = 6;
                break;
              }
              this.emit("error", (0, index_js_1.makeError)("received result for unknown id", "UNKNOWN_ERROR", {
                reasonCode: "UNKNOWN_ID",
                result: result
              }));
              return _context7.abrupt("return");
            case 6:
              _classPrivateFieldGet(_callbacks, this)["delete"](result.id);
              callback.resolve(result);
              _context7.next = 18;
              break;
            case 10:
              if (!(result && result.method === "eth_subscription")) {
                _context7.next = 16;
                break;
              }
              filterId = result.params.subscription;
              subscriber = _classPrivateFieldGet(_subs, this).get(filterId);
              if (subscriber) {
                subscriber._handleMessage(result.params.result);
              } else {
                pending = _classPrivateFieldGet(_pending, this).get(filterId);
                if (pending == null) {
                  pending = [];
                  _classPrivateFieldGet(_pending, this).set(filterId, pending);
                }
                pending.push(result.params.result);
              }
              _context7.next = 18;
              break;
            case 16:
              this.emit("error", (0, index_js_1.makeError)("received unexpected message", "UNKNOWN_ERROR", {
                reasonCode: "UNEXPECTED_MESSAGE",
                result: result
              }));
              return _context7.abrupt("return");
            case 18:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this);
      }));
      function _processMessage(_x10) {
        return _processMessage2.apply(this, arguments);
      }
      return _processMessage;
    }()
    /**
     *  Sub-classes **must** override this to send %%message%% over their
     *  transport.
     */
  }, {
    key: "_write",
    value: (function () {
      var _write2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(message) {
        return _regeneratorRuntime().wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              throw new Error("sub-classes must override this");
            case 1:
            case "end":
              return _context8.stop();
          }
        }, _callee8);
      }));
      function _write(_x11) {
        return _write2.apply(this, arguments);
      }
      return _write;
    }())
  }]);
}(provider_jsonrpc_js_1.JsonRpcApiProvider);
exports.SocketProvider = SocketProvider;

},{"../utils/index.js":276,"./abstract-provider.js":236,"./provider-jsonrpc.js":254}],258:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _get() { return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }
function _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WebSocketProvider = void 0;
var ws_js_1 = require("./ws.js"); /*-browser*/
var provider_socket_js_1 = require("./provider-socket.js");
/**
 *  A JSON-RPC provider which is backed by a WebSocket.
 *
 *  WebSockets are often preferred because they retain a live connection
 *  to a server, which permits more instant access to events.
 *
 *  However, this incurs higher server infrasturture costs, so additional
 *  resources may be required to host your own WebSocket nodes and many
 *  third-party services charge additional fees for WebSocket endpoints.
 */
var _connect = /*#__PURE__*/new WeakMap();
var _websocket = /*#__PURE__*/new WeakMap();
var WebSocketProvider = /*#__PURE__*/function (_provider_socket_js_) {
  function WebSocketProvider(url, network, options) {
    var _this;
    _classCallCheck(this, WebSocketProvider);
    _this = _callSuper(this, WebSocketProvider, [network, options]);
    _classPrivateFieldInitSpec(_this, _connect, void 0);
    _classPrivateFieldInitSpec(_this, _websocket, void 0);
    if (typeof url === "string") {
      _classPrivateFieldSet(_connect, _this, function () {
        return new ws_js_1.WebSocket(url);
      });
      _classPrivateFieldSet(_websocket, _this, _classPrivateFieldGet(_connect, _this).call(_this));
    } else if (typeof url === "function") {
      _classPrivateFieldSet(_connect, _this, url);
      _classPrivateFieldSet(_websocket, _this, url());
    } else {
      _classPrivateFieldSet(_connect, _this, null);
      _classPrivateFieldSet(_websocket, _this, url);
    }
    _this.websocket.onopen = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            _context.prev = 0;
            _context.next = 3;
            return _this._start();
          case 3:
            _this.resume();
            _context.next = 9;
            break;
          case 6:
            _context.prev = 6;
            _context.t0 = _context["catch"](0);
            console.log("failed to start WebsocketProvider", _context.t0);
            // @TODO: now what? Attempt reconnect?
          case 9:
          case "end":
            return _context.stop();
        }
      }, _callee, null, [[0, 6]]);
    }));
    _this.websocket.onmessage = function (message) {
      _this._processMessage(message.data);
    };
    /*
            this.websocket.onclose = (event) => {
                // @TODO: What event.code should we reconnect on?
                const reconnect = false;
                if (reconnect) {
                    this.pause(true);
                    if (this.#connect) {
                        this.#websocket = this.#connect();
                        this.#websocket.onopen = ...
                        // @TODO: this requires the super class to rebroadcast; move it there
                    }
                    this._reconnect();
                }
            };
    */
    return _this;
  }
  _inherits(WebSocketProvider, _provider_socket_js_);
  return _createClass(WebSocketProvider, [{
    key: "websocket",
    get: function get() {
      if (_classPrivateFieldGet(_websocket, this) == null) {
        throw new Error("websocket closed");
      }
      return _classPrivateFieldGet(_websocket, this);
    }
  }, {
    key: "_write",
    value: function () {
      var _write2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(message) {
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              this.websocket.send(message);
            case 1:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function _write(_x) {
        return _write2.apply(this, arguments);
      }
      return _write;
    }()
  }, {
    key: "destroy",
    value: function () {
      var _destroy = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              if (_classPrivateFieldGet(_websocket, this) != null) {
                _classPrivateFieldGet(_websocket, this).close();
                _classPrivateFieldSet(_websocket, this, null);
              }
              _get(_getPrototypeOf(WebSocketProvider.prototype), "destroy", this).call(this);
            case 2:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function destroy() {
        return _destroy.apply(this, arguments);
      }
      return destroy;
    }()
  }]);
}(provider_socket_js_1.SocketProvider);
exports.WebSocketProvider = WebSocketProvider;

},{"./provider-socket.js":257,"./ws.js":263}],259:[function(require,module,exports){
"use strict";

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TransactionResponse = exports.TransactionReceipt = exports.Log = exports.Block = exports.copyRequest = exports.FeeData = void 0;
//import { resolveAddress } from "@ethersproject/address";
var index_js_1 = require("../utils/index.js");
var index_js_2 = require("../transaction/index.js");
var BN_0 = BigInt(0);
// -----------------------
function getValue(value) {
  if (value == null) {
    return null;
  }
  return value;
}
function toJson(value) {
  if (value == null) {
    return null;
  }
  return value.toString();
}
// @TODO? <T extends FeeData = { }> implements Required<T>
/**
 *  A **FeeData** wraps all the fee-related values associated with
 *  the network.
 */
var FeeData = /*#__PURE__*/function () {
  /**
   *  Creates a new FeeData for %%gasPrice%%, %%maxFeePerGas%% and
   *  %%maxPriorityFeePerGas%%.
   */
  function FeeData(gasPrice, maxFeePerGas, maxPriorityFeePerGas) {
    _classCallCheck(this, FeeData);
    /**
     *  The gas price for legacy networks.
     */
    _defineProperty(this, "gasPrice", void 0);
    /**
     *  The maximum fee to pay per gas.
     *
     *  The base fee per gas is defined by the network and based on
     *  congestion, increasing the cost during times of heavy load
     *  and lowering when less busy.
     *
     *  The actual fee per gas will be the base fee for the block
     *  and the priority fee, up to the max fee per gas.
     *
     *  This will be ``null`` on legacy networks (i.e. [pre-EIP-1559](link-eip-1559))
     */
    _defineProperty(this, "maxFeePerGas", void 0);
    /**
     *  The additional amout to pay per gas to encourage a validator
     *  to include the transaction.
     *
     *  The purpose of this is to compensate the validator for the
     *  adjusted risk for including a given transaction.
     *
     *  This will be ``null`` on legacy networks (i.e. [pre-EIP-1559](link-eip-1559))
     */
    _defineProperty(this, "maxPriorityFeePerGas", void 0);
    (0, index_js_1.defineProperties)(this, {
      gasPrice: getValue(gasPrice),
      maxFeePerGas: getValue(maxFeePerGas),
      maxPriorityFeePerGas: getValue(maxPriorityFeePerGas)
    });
  }
  /**
   *  Returns a JSON-friendly value.
   */
  return _createClass(FeeData, [{
    key: "toJSON",
    value: function toJSON() {
      var gasPrice = this.gasPrice,
        maxFeePerGas = this.maxFeePerGas,
        maxPriorityFeePerGas = this.maxPriorityFeePerGas;
      return {
        _type: "FeeData",
        gasPrice: toJson(gasPrice),
        maxFeePerGas: toJson(maxFeePerGas),
        maxPriorityFeePerGas: toJson(maxPriorityFeePerGas)
      };
    }
  }]);
}();
exports.FeeData = FeeData;
;
/**
 *  Returns a copy of %%req%% with all properties coerced to their strict
 *  types.
 */
function copyRequest(req) {
  var result = {};
  // These could be addresses, ENS names or Addressables
  if (req.to) {
    result.to = req.to;
  }
  if (req.from) {
    result.from = req.from;
  }
  if (req.data) {
    result.data = (0, index_js_1.hexlify)(req.data);
  }
  var bigIntKeys = "chainId,gasLimit,gasPrice,maxFeePerBlobGas,maxFeePerGas,maxPriorityFeePerGas,value".split(/,/);
  var _iterator = _createForOfIteratorHelper(bigIntKeys),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var key = _step.value;
      if (!(key in req) || req[key] == null) {
        continue;
      }
      result[key] = (0, index_js_1.getBigInt)(req[key], "request.".concat(key));
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  var numberKeys = "type,nonce".split(/,/);
  var _iterator2 = _createForOfIteratorHelper(numberKeys),
    _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var _key = _step2.value;
      if (!(_key in req) || req[_key] == null) {
        continue;
      }
      result[_key] = (0, index_js_1.getNumber)(req[_key], "request.".concat(_key));
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
  if (req.accessList) {
    result.accessList = (0, index_js_2.accessListify)(req.accessList);
  }
  if ("blockTag" in req) {
    result.blockTag = req.blockTag;
  }
  if ("enableCcipRead" in req) {
    result.enableCcipRead = !!req.enableCcipRead;
  }
  if ("customData" in req) {
    result.customData = req.customData;
  }
  if ("blobVersionedHashes" in req && req.blobVersionedHashes) {
    result.blobVersionedHashes = req.blobVersionedHashes.slice();
  }
  if ("kzg" in req) {
    result.kzg = req.kzg;
  }
  if ("blobs" in req && req.blobs) {
    result.blobs = req.blobs.map(function (b) {
      if ((0, index_js_1.isBytesLike)(b)) {
        return (0, index_js_1.hexlify)(b);
      }
      return Object.assign({}, b);
    });
  }
  return result;
}
exports.copyRequest = copyRequest;
/**
 *  A **Block** represents the data associated with a full block on
 *  Ethereum.
 */
var _transactions = /*#__PURE__*/new WeakMap();
var Block = /*#__PURE__*/function () {
  /**
   *  Create a new **Block** object.
   *
   *  This should generally not be necessary as the unless implementing a
   *  low-level library.
   */
  function Block(block, provider) {
    _classCallCheck(this, Block);
    /**
     *  The provider connected to the block used to fetch additional details
     *  if necessary.
     */
    _defineProperty(this, "provider", void 0);
    /**
     *  The block number, sometimes called the block height. This is a
     *  sequential number that is one higher than the parent block.
     */
    _defineProperty(this, "number", void 0);
    /**
     *  The block hash.
     *
     *  This hash includes all properties, so can be safely used to identify
     *  an exact set of block properties.
     */
    _defineProperty(this, "hash", void 0);
    /**
     *  The timestamp for this block, which is the number of seconds since
     *  epoch that this block was included.
     */
    _defineProperty(this, "timestamp", void 0);
    /**
     *  The block hash of the parent block.
     */
    _defineProperty(this, "parentHash", void 0);
    /**
     *  The hash tree root of the parent beacon block for the given
     *  execution block. See [[link-eip-4788]].
     */
    _defineProperty(this, "parentBeaconBlockRoot", void 0);
    /**
     *  The nonce.
     *
     *  On legacy networks, this is the random number inserted which
     *  permitted the difficulty target to be reached.
     */
    _defineProperty(this, "nonce", void 0);
    /**
     *  The difficulty target.
     *
     *  On legacy networks, this is the proof-of-work target required
     *  for a block to meet the protocol rules to be included.
     *
     *  On modern networks, this is a random number arrived at using
     *  randao.  @TODO: Find links?
     */
    _defineProperty(this, "difficulty", void 0);
    /**
     *  The total gas limit for this block.
     */
    _defineProperty(this, "gasLimit", void 0);
    /**
     *  The total gas used in this block.
     */
    _defineProperty(this, "gasUsed", void 0);
    /**
     *  The root hash for the global state after applying changes
     *  in this block.
     */
    _defineProperty(this, "stateRoot", void 0);
    /**
     *  The hash of the transaction receipts trie.
     */
    _defineProperty(this, "receiptsRoot", void 0);
    /**
     *  The total amount of blob gas consumed by the transactions
     *  within the block. See [[link-eip-4844]].
     */
    _defineProperty(this, "blobGasUsed", void 0);
    /**
     *  The running total of blob gas consumed in excess of the
     *  target, prior to the block. See [[link-eip-4844]].
     */
    _defineProperty(this, "excessBlobGas", void 0);
    /**
     *  The miner coinbase address, wihch receives any subsidies for
     *  including this block.
     */
    _defineProperty(this, "miner", void 0);
    /**
     *  The latest RANDAO mix of the post beacon state of
     *  the previous block.
     */
    _defineProperty(this, "prevRandao", void 0);
    /**
     *  Any extra data the validator wished to include.
     */
    _defineProperty(this, "extraData", void 0);
    /**
     *  The base fee per gas that all transactions in this block were
     *  charged.
     *
     *  This adjusts after each block, depending on how congested the network
     *  is.
     */
    _defineProperty(this, "baseFeePerGas", void 0);
    _classPrivateFieldInitSpec(this, _transactions, void 0);
    _classPrivateFieldSet(_transactions, this, block.transactions.map(function (tx) {
      if (typeof tx !== "string") {
        return new TransactionResponse(tx, provider);
      }
      return tx;
    }));
    (0, index_js_1.defineProperties)(this, {
      provider: provider,
      hash: getValue(block.hash),
      number: block.number,
      timestamp: block.timestamp,
      parentHash: block.parentHash,
      parentBeaconBlockRoot: block.parentBeaconBlockRoot,
      nonce: block.nonce,
      difficulty: block.difficulty,
      gasLimit: block.gasLimit,
      gasUsed: block.gasUsed,
      blobGasUsed: block.blobGasUsed,
      excessBlobGas: block.excessBlobGas,
      miner: block.miner,
      prevRandao: getValue(block.prevRandao),
      extraData: block.extraData,
      baseFeePerGas: getValue(block.baseFeePerGas),
      stateRoot: block.stateRoot,
      receiptsRoot: block.receiptsRoot
    });
  }
  /**
   *  Returns the list of transaction hashes, in the order
   *  they were executed within the block.
   */
  return _createClass(Block, [{
    key: "transactions",
    get: function get() {
      return _classPrivateFieldGet(_transactions, this).map(function (tx) {
        if (typeof tx === "string") {
          return tx;
        }
        return tx.hash;
      });
    }
    /**
     *  Returns the complete transactions, in the order they
     *  were executed within the block.
     *
     *  This is only available for blocks which prefetched
     *  transactions, by passing ``true`` to %%prefetchTxs%%
     *  into [[Provider-getBlock]].
     */
  }, {
    key: "prefetchedTransactions",
    get: function get() {
      var txs = _classPrivateFieldGet(_transactions, this).slice();
      // Doesn't matter...
      if (txs.length === 0) {
        return [];
      }
      // Make sure we prefetched the transactions
      (0, index_js_1.assert)(_typeof(txs[0]) === "object", "transactions were not prefetched with block request", "UNSUPPORTED_OPERATION", {
        operation: "transactionResponses()"
      });
      return txs;
    }
    /**
     *  Returns a JSON-friendly value.
     */
  }, {
    key: "toJSON",
    value: function toJSON() {
      var baseFeePerGas = this.baseFeePerGas,
        difficulty = this.difficulty,
        extraData = this.extraData,
        gasLimit = this.gasLimit,
        gasUsed = this.gasUsed,
        hash = this.hash,
        miner = this.miner,
        prevRandao = this.prevRandao,
        nonce = this.nonce,
        number = this.number,
        parentHash = this.parentHash,
        parentBeaconBlockRoot = this.parentBeaconBlockRoot,
        stateRoot = this.stateRoot,
        receiptsRoot = this.receiptsRoot,
        timestamp = this.timestamp,
        transactions = this.transactions;
      return {
        _type: "Block",
        baseFeePerGas: toJson(baseFeePerGas),
        difficulty: toJson(difficulty),
        extraData: extraData,
        gasLimit: toJson(gasLimit),
        gasUsed: toJson(gasUsed),
        blobGasUsed: toJson(this.blobGasUsed),
        excessBlobGas: toJson(this.excessBlobGas),
        hash: hash,
        miner: miner,
        prevRandao: prevRandao,
        nonce: nonce,
        number: number,
        parentHash: parentHash,
        timestamp: timestamp,
        parentBeaconBlockRoot: parentBeaconBlockRoot,
        stateRoot: stateRoot,
        receiptsRoot: receiptsRoot,
        transactions: transactions
      };
    }
  }, {
    key: Symbol.iterator,
    value: function value() {
      var _this = this;
      var index = 0;
      var txs = this.transactions;
      return {
        next: function next() {
          if (index < _this.length) {
            return {
              value: txs[index++],
              done: false
            };
          }
          return {
            value: undefined,
            done: true
          };
        }
      };
    }
    /**
     *  The number of transactions in this block.
     */
  }, {
    key: "length",
    get: function get() {
      return _classPrivateFieldGet(_transactions, this).length;
    }
    /**
     *  The [[link-js-date]] this block was included at.
     */
  }, {
    key: "date",
    get: function get() {
      if (this.timestamp == null) {
        return null;
      }
      return new Date(this.timestamp * 1000);
    }
    /**
     *  Get the transaction at %%indexe%% within this block.
     */
  }, {
    key: "getTransaction",
    value: (function () {
      var _getTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(indexOrHash) {
        var tx, hash, _iterator3, _step3, v;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              // Find the internal value by its index or hash
              tx = undefined;
              if (!(typeof indexOrHash === "number")) {
                _context.next = 5;
                break;
              }
              tx = _classPrivateFieldGet(_transactions, this)[indexOrHash];
              _context.next = 32;
              break;
            case 5:
              hash = indexOrHash.toLowerCase();
              _iterator3 = _createForOfIteratorHelper(_classPrivateFieldGet(_transactions, this));
              _context.prev = 7;
              _iterator3.s();
            case 9:
              if ((_step3 = _iterator3.n()).done) {
                _context.next = 24;
                break;
              }
              v = _step3.value;
              if (!(typeof v === "string")) {
                _context.next = 18;
                break;
              }
              if (!(v !== hash)) {
                _context.next = 14;
                break;
              }
              return _context.abrupt("continue", 22);
            case 14:
              tx = v;
              return _context.abrupt("break", 24);
            case 18:
              if (!(v.hash === hash)) {
                _context.next = 20;
                break;
              }
              return _context.abrupt("continue", 22);
            case 20:
              tx = v;
              return _context.abrupt("break", 24);
            case 22:
              _context.next = 9;
              break;
            case 24:
              _context.next = 29;
              break;
            case 26:
              _context.prev = 26;
              _context.t0 = _context["catch"](7);
              _iterator3.e(_context.t0);
            case 29:
              _context.prev = 29;
              _iterator3.f();
              return _context.finish(29);
            case 32:
              if (!(tx == null)) {
                _context.next = 34;
                break;
              }
              throw new Error("no such tx");
            case 34:
              if (!(typeof tx === "string")) {
                _context.next = 40;
                break;
              }
              _context.next = 37;
              return this.provider.getTransaction(tx);
            case 37:
              return _context.abrupt("return", _context.sent);
            case 40:
              return _context.abrupt("return", tx);
            case 41:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[7, 26, 29, 32]]);
      }));
      function getTransaction(_x) {
        return _getTransaction.apply(this, arguments);
      }
      return getTransaction;
    }()
    /**
     *  If a **Block** was fetched with a request to include the transactions
     *  this will allow synchronous access to those transactions.
     *
     *  If the transactions were not prefetched, this will throw.
     */
    )
  }, {
    key: "getPrefetchedTransaction",
    value: function getPrefetchedTransaction(indexOrHash) {
      var txs = this.prefetchedTransactions;
      if (typeof indexOrHash === "number") {
        return txs[indexOrHash];
      }
      indexOrHash = indexOrHash.toLowerCase();
      var _iterator4 = _createForOfIteratorHelper(txs),
        _step4;
      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var tx = _step4.value;
          if (tx.hash === indexOrHash) {
            return tx;
          }
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
      (0, index_js_1.assertArgument)(false, "no matching transaction", "indexOrHash", indexOrHash);
    }
    /**
     *  Returns true if this block been mined. This provides a type guard
     *  for all properties on a [[MinedBlock]].
     */
  }, {
    key: "isMined",
    value: function isMined() {
      return !!this.hash;
    }
    /**
     *  Returns true if this block is an [[link-eip-2930]] block.
     */
  }, {
    key: "isLondon",
    value: function isLondon() {
      return !!this.baseFeePerGas;
    }
    /**
     *  @_ignore:
     */
  }, {
    key: "orphanedEvent",
    value: function orphanedEvent() {
      if (!this.isMined()) {
        throw new Error("");
      }
      return createOrphanedBlockFilter(this);
    }
  }]);
}();
exports.Block = Block;
//////////////////////
// Log
/**
 *  A **Log** in Ethereum represents an event that has been included in a
 *  transaction using the ``LOG*`` opcodes, which are most commonly used by
 *  Solidity's emit for announcing events.
 */
var Log = /*#__PURE__*/function () {
  /**
   *  @_ignore:
   */
  function Log(log, provider) {
    _classCallCheck(this, Log);
    /**
     *  The provider connected to the log used to fetch additional details
     *  if necessary.
     */
    _defineProperty(this, "provider", void 0);
    /**
     *  The transaction hash of the transaction this log occurred in. Use the
     *  [[Log-getTransaction]] to get the [[TransactionResponse]].
     */
    _defineProperty(this, "transactionHash", void 0);
    /**
     *  The block hash of the block this log occurred in. Use the
     *  [[Log-getBlock]] to get the [[Block]].
     */
    _defineProperty(this, "blockHash", void 0);
    /**
     *  The block number of the block this log occurred in. It is preferred
     *  to use the [[Block-hash]] when fetching the related [[Block]],
     *  since in the case of an orphaned block, the block at that height may
     *  have changed.
     */
    _defineProperty(this, "blockNumber", void 0);
    /**
     *  If the **Log** represents a block that was removed due to an orphaned
     *  block, this will be true.
     *
     *  This can only happen within an orphan event listener.
     */
    _defineProperty(this, "removed", void 0);
    /**
     *  The address of the contract that emitted this log.
     */
    _defineProperty(this, "address", void 0);
    /**
     *  The data included in this log when it was emitted.
     */
    _defineProperty(this, "data", void 0);
    /**
     *  The indexed topics included in this log when it was emitted.
     *
     *  All topics are included in the bloom filters, so they can be
     *  efficiently filtered using the [[Provider-getLogs]] method.
     */
    _defineProperty(this, "topics", void 0);
    /**
     *  The index within the block this log occurred at. This is generally
     *  not useful to developers, but can be used with the various roots
     *  to proof inclusion within a block.
     */
    _defineProperty(this, "index", void 0);
    /**
     *  The index within the transaction of this log.
     */
    _defineProperty(this, "transactionIndex", void 0);
    this.provider = provider;
    var topics = Object.freeze(log.topics.slice());
    (0, index_js_1.defineProperties)(this, {
      transactionHash: log.transactionHash,
      blockHash: log.blockHash,
      blockNumber: log.blockNumber,
      removed: log.removed,
      address: log.address,
      data: log.data,
      topics: topics,
      index: log.index,
      transactionIndex: log.transactionIndex
    });
  }
  /**
   *  Returns a JSON-compatible object.
   */
  return _createClass(Log, [{
    key: "toJSON",
    value: function toJSON() {
      var address = this.address,
        blockHash = this.blockHash,
        blockNumber = this.blockNumber,
        data = this.data,
        index = this.index,
        removed = this.removed,
        topics = this.topics,
        transactionHash = this.transactionHash,
        transactionIndex = this.transactionIndex;
      return {
        _type: "log",
        address: address,
        blockHash: blockHash,
        blockNumber: blockNumber,
        data: data,
        index: index,
        removed: removed,
        topics: topics,
        transactionHash: transactionHash,
        transactionIndex: transactionIndex
      };
    }
    /**
     *  Returns the block that this log occurred in.
     */
  }, {
    key: "getBlock",
    value: (function () {
      var _getBlock = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        var block;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return this.provider.getBlock(this.blockHash);
            case 2:
              block = _context2.sent;
              (0, index_js_1.assert)(!!block, "failed to find transaction", "UNKNOWN_ERROR", {});
              return _context2.abrupt("return", block);
            case 5:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function getBlock() {
        return _getBlock.apply(this, arguments);
      }
      return getBlock;
    }()
    /**
     *  Returns the transaction that this log occurred in.
     */
    )
  }, {
    key: "getTransaction",
    value: (function () {
      var _getTransaction2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
        var tx;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _context3.next = 2;
              return this.provider.getTransaction(this.transactionHash);
            case 2:
              tx = _context3.sent;
              (0, index_js_1.assert)(!!tx, "failed to find transaction", "UNKNOWN_ERROR", {});
              return _context3.abrupt("return", tx);
            case 5:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function getTransaction() {
        return _getTransaction2.apply(this, arguments);
      }
      return getTransaction;
    }()
    /**
     *  Returns the transaction receipt fot the transaction that this
     *  log occurred in.
     */
    )
  }, {
    key: "getTransactionReceipt",
    value: (function () {
      var _getTransactionReceipt = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
        var receipt;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              _context4.next = 2;
              return this.provider.getTransactionReceipt(this.transactionHash);
            case 2:
              receipt = _context4.sent;
              (0, index_js_1.assert)(!!receipt, "failed to find transaction receipt", "UNKNOWN_ERROR", {});
              return _context4.abrupt("return", receipt);
            case 5:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));
      function getTransactionReceipt() {
        return _getTransactionReceipt.apply(this, arguments);
      }
      return getTransactionReceipt;
    }()
    /**
     *  @_ignore:
     */
    )
  }, {
    key: "removedEvent",
    value: function removedEvent() {
      return createRemovedLogFilter(this);
    }
  }]);
}();
exports.Log = Log;
//////////////////////
// Transaction Receipt
/*
export interface LegacyTransactionReceipt {
    byzantium: false;
    status: null;
    root: string;
}

export interface ByzantiumTransactionReceipt {
    byzantium: true;
    status: number;
    root: null;
}
*/
/**
 *  A **TransactionReceipt** includes additional information about a
 *  transaction that is only available after it has been mined.
 */
var _logs = /*#__PURE__*/new WeakMap();
var TransactionReceipt = /*#__PURE__*/function () {
  /**
   *  @_ignore:
   */
  function TransactionReceipt(tx, provider) {
    _classCallCheck(this, TransactionReceipt);
    /**
     *  The provider connected to the log used to fetch additional details
     *  if necessary.
     */
    _defineProperty(this, "provider", void 0);
    /**
     *  The address the transaction was sent to.
     */
    _defineProperty(this, "to", void 0);
    /**
     *  The sender of the transaction.
     */
    _defineProperty(this, "from", void 0);
    /**
     *  The address of the contract if the transaction was directly
     *  responsible for deploying one.
     *
     *  This is non-null **only** if the ``to`` is empty and the ``data``
     *  was successfully executed as initcode.
     */
    _defineProperty(this, "contractAddress", void 0);
    /**
     *  The transaction hash.
     */
    _defineProperty(this, "hash", void 0);
    /**
     *  The index of this transaction within the block transactions.
     */
    _defineProperty(this, "index", void 0);
    /**
     *  The block hash of the [[Block]] this transaction was included in.
     */
    _defineProperty(this, "blockHash", void 0);
    /**
     *  The block number of the [[Block]] this transaction was included in.
     */
    _defineProperty(this, "blockNumber", void 0);
    /**
     *  The bloom filter bytes that represent all logs that occurred within
     *  this transaction. This is generally not useful for most developers,
     *  but can be used to validate the included logs.
     */
    _defineProperty(this, "logsBloom", void 0);
    /**
     *  The actual amount of gas used by this transaction.
     *
     *  When creating a transaction, the amount of gas that will be used can
     *  only be approximated, but the sender must pay the gas fee for the
     *  entire gas limit. After the transaction, the difference is refunded.
     */
    _defineProperty(this, "gasUsed", void 0);
    /**
     *  The gas used for BLObs. See [[link-eip-4844]].
     */
    _defineProperty(this, "blobGasUsed", void 0);
    /**
     *  The amount of gas used by all transactions within the block for this
     *  and all transactions with a lower ``index``.
     *
     *  This is generally not useful for developers but can be used to
     *  validate certain aspects of execution.
     */
    _defineProperty(this, "cumulativeGasUsed", void 0);
    /**
     *  The actual gas price used during execution.
     *
     *  Due to the complexity of [[link-eip-1559]] this value can only
     *  be caluclated after the transaction has been mined, snce the base
     *  fee is protocol-enforced.
     */
    _defineProperty(this, "gasPrice", void 0);
    /**
     *  The price paid per BLOB in gas. See [[link-eip-4844]].
     */
    _defineProperty(this, "blobGasPrice", void 0);
    /**
     *  The [[link-eip-2718]] transaction type.
     */
    _defineProperty(this, "type", void 0);
    //readonly byzantium!: boolean;
    /**
     *  The status of this transaction, indicating success (i.e. ``1``) or
     *  a revert (i.e. ``0``).
     *
     *  This is available in post-byzantium blocks, but some backends may
     *  backfill this value.
     */
    _defineProperty(this, "status", void 0);
    /**
     *  The root hash of this transaction.
     *
     *  This is no present and was only included in pre-byzantium blocks, but
     *  could be used to validate certain parts of the receipt.
     */
    _defineProperty(this, "root", void 0);
    _classPrivateFieldInitSpec(this, _logs, void 0);
    _classPrivateFieldSet(_logs, this, Object.freeze(tx.logs.map(function (log) {
      return new Log(log, provider);
    })));
    var gasPrice = BN_0;
    if (tx.effectiveGasPrice != null) {
      gasPrice = tx.effectiveGasPrice;
    } else if (tx.gasPrice != null) {
      gasPrice = tx.gasPrice;
    }
    (0, index_js_1.defineProperties)(this, {
      provider: provider,
      to: tx.to,
      from: tx.from,
      contractAddress: tx.contractAddress,
      hash: tx.hash,
      index: tx.index,
      blockHash: tx.blockHash,
      blockNumber: tx.blockNumber,
      logsBloom: tx.logsBloom,
      gasUsed: tx.gasUsed,
      cumulativeGasUsed: tx.cumulativeGasUsed,
      blobGasUsed: tx.blobGasUsed,
      gasPrice: gasPrice,
      blobGasPrice: tx.blobGasPrice,
      type: tx.type,
      //byzantium: tx.byzantium,
      status: tx.status,
      root: tx.root
    });
  }
  /**
   *  The logs for this transaction.
   */
  return _createClass(TransactionReceipt, [{
    key: "logs",
    get: function get() {
      return _classPrivateFieldGet(_logs, this);
    }
    /**
     *  Returns a JSON-compatible representation.
     */
  }, {
    key: "toJSON",
    value: function toJSON() {
      var to = this.to,
        from = this.from,
        contractAddress = this.contractAddress,
        hash = this.hash,
        index = this.index,
        blockHash = this.blockHash,
        blockNumber = this.blockNumber,
        logsBloom = this.logsBloom,
        logs = this.logs,
        status = this.status,
        root = this.root;
      return {
        _type: "TransactionReceipt",
        blockHash: blockHash,
        blockNumber: blockNumber,
        //byzantium, 
        contractAddress: contractAddress,
        cumulativeGasUsed: toJson(this.cumulativeGasUsed),
        from: from,
        gasPrice: toJson(this.gasPrice),
        blobGasUsed: toJson(this.blobGasUsed),
        blobGasPrice: toJson(this.blobGasPrice),
        gasUsed: toJson(this.gasUsed),
        hash: hash,
        index: index,
        logs: logs,
        logsBloom: logsBloom,
        root: root,
        status: status,
        to: to
      };
    }
    /**
     *  @_ignore:
     */
  }, {
    key: "length",
    get: function get() {
      return this.logs.length;
    }
  }, {
    key: Symbol.iterator,
    value: function value() {
      var _this2 = this;
      var index = 0;
      return {
        next: function next() {
          if (index < _this2.length) {
            return {
              value: _this2.logs[index++],
              done: false
            };
          }
          return {
            value: undefined,
            done: true
          };
        }
      };
    }
    /**
     *  The total fee for this transaction, in wei.
     */
  }, {
    key: "fee",
    get: function get() {
      return this.gasUsed * this.gasPrice;
    }
    /**
     *  Resolves to the block this transaction occurred in.
     */
  }, {
    key: "getBlock",
    value: (function () {
      var _getBlock2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
        var block;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              _context5.next = 2;
              return this.provider.getBlock(this.blockHash);
            case 2:
              block = _context5.sent;
              if (!(block == null)) {
                _context5.next = 5;
                break;
              }
              throw new Error("TODO");
            case 5:
              return _context5.abrupt("return", block);
            case 6:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this);
      }));
      function getBlock() {
        return _getBlock2.apply(this, arguments);
      }
      return getBlock;
    }()
    /**
     *  Resolves to the transaction this transaction occurred in.
     */
    )
  }, {
    key: "getTransaction",
    value: (function () {
      var _getTransaction3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
        var tx;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              _context6.next = 2;
              return this.provider.getTransaction(this.hash);
            case 2:
              tx = _context6.sent;
              if (!(tx == null)) {
                _context6.next = 5;
                break;
              }
              throw new Error("TODO");
            case 5:
              return _context6.abrupt("return", tx);
            case 6:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this);
      }));
      function getTransaction() {
        return _getTransaction3.apply(this, arguments);
      }
      return getTransaction;
    }()
    /**
     *  Resolves to the return value of the execution of this transaction.
     *
     *  Support for this feature is limited, as it requires an archive node
     *  with the ``debug_`` or ``trace_`` API enabled.
     */
    )
  }, {
    key: "getResult",
    value: (function () {
      var _getResult = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              _context7.next = 2;
              return this.provider.getTransactionResult(this.hash);
            case 2:
              return _context7.abrupt("return", _context7.sent);
            case 3:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this);
      }));
      function getResult() {
        return _getResult.apply(this, arguments);
      }
      return getResult;
    }()
    /**
     *  Resolves to the number of confirmations this transaction has.
     */
    )
  }, {
    key: "confirmations",
    value: (function () {
      var _confirmations = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {
        return _regeneratorRuntime().wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              _context8.next = 2;
              return this.provider.getBlockNumber();
            case 2:
              _context8.t0 = _context8.sent;
              _context8.t1 = this.blockNumber;
              _context8.t2 = _context8.t0 - _context8.t1;
              return _context8.abrupt("return", _context8.t2 + 1);
            case 6:
            case "end":
              return _context8.stop();
          }
        }, _callee8, this);
      }));
      function confirmations() {
        return _confirmations.apply(this, arguments);
      }
      return confirmations;
    }()
    /**
     *  @_ignore:
     */
    )
  }, {
    key: "removedEvent",
    value: function removedEvent() {
      return createRemovedTransactionFilter(this);
    }
    /**
     *  @_ignore:
     */
  }, {
    key: "reorderedEvent",
    value: function reorderedEvent(other) {
      (0, index_js_1.assert)(!other || other.isMined(), "unmined 'other' transction cannot be orphaned", "UNSUPPORTED_OPERATION", {
        operation: "reorderedEvent(other)"
      });
      return createReorderedTransactionFilter(this, other);
    }
  }]);
}();
exports.TransactionReceipt = TransactionReceipt;
/**
 *  A **TransactionResponse** includes all properties about a transaction
 *  that was sent to the network, which may or may not be included in a
 *  block.
 *
 *  The [[TransactionResponse-isMined]] can be used to check if the
 *  transaction has been mined as well as type guard that the otherwise
 *  possibly ``null`` properties are defined.
 */
var _startBlock = /*#__PURE__*/new WeakMap();
var TransactionResponse = /*#__PURE__*/function () {
  /**
   *  @_ignore:
   */
  function TransactionResponse(tx, provider) {
    _classCallCheck(this, TransactionResponse);
    /**
     *  The provider this is connected to, which will influence how its
     *  methods will resolve its async inspection methods.
     */
    _defineProperty(this, "provider", void 0);
    /**
     *  The block number of the block that this transaction was included in.
     *
     *  This is ``null`` for pending transactions.
     */
    _defineProperty(this, "blockNumber", void 0);
    /**
     *  The blockHash of the block that this transaction was included in.
     *
     *  This is ``null`` for pending transactions.
     */
    _defineProperty(this, "blockHash", void 0);
    /**
     *  The index within the block that this transaction resides at.
     */
    _defineProperty(this, "index", void 0);
    /**
     *  The transaction hash.
     */
    _defineProperty(this, "hash", void 0);
    /**
     *  The [[link-eip-2718]] transaction envelope type. This is
     *  ``0`` for legacy transactions types.
     */
    _defineProperty(this, "type", void 0);
    /**
     *  The receiver of this transaction.
     *
     *  If ``null``, then the transaction is an initcode transaction.
     *  This means the result of executing the [[data]] will be deployed
     *  as a new contract on chain (assuming it does not revert) and the
     *  address may be computed using [[getCreateAddress]].
     */
    _defineProperty(this, "to", void 0);
    /**
     *  The sender of this transaction. It is implicitly computed
     *  from the transaction pre-image hash (as the digest) and the
     *  [[signature]] using ecrecover.
     */
    _defineProperty(this, "from", void 0);
    /**
     *  The nonce, which is used to prevent replay attacks and offer
     *  a method to ensure transactions from a given sender are explicitly
     *  ordered.
     *
     *  When sending a transaction, this must be equal to the number of
     *  transactions ever sent by [[from]].
     */
    _defineProperty(this, "nonce", void 0);
    /**
     *  The maximum units of gas this transaction can consume. If execution
     *  exceeds this, the entries transaction is reverted and the sender
     *  is charged for the full amount, despite not state changes being made.
     */
    _defineProperty(this, "gasLimit", void 0);
    /**
     *  The gas price can have various values, depending on the network.
     *
     *  In modern networks, for transactions that are included this is
     *  the //effective gas price// (the fee per gas that was actually
     *  charged), while for transactions that have not been included yet
     *  is the [[maxFeePerGas]].
     *
     *  For legacy transactions, or transactions on legacy networks, this
     *  is the fee that will be charged per unit of gas the transaction
     *  consumes.
     */
    _defineProperty(this, "gasPrice", void 0);
    /**
     *  The maximum priority fee (per unit of gas) to allow a
     *  validator to charge the sender. This is inclusive of the
     *  [[maxFeeFeePerGas]].
     */
    _defineProperty(this, "maxPriorityFeePerGas", void 0);
    /**
     *  The maximum fee (per unit of gas) to allow this transaction
     *  to charge the sender.
     */
    _defineProperty(this, "maxFeePerGas", void 0);
    /**
     *  The [[link-eip-4844]] max fee per BLOb gas.
     */
    _defineProperty(this, "maxFeePerBlobGas", void 0);
    /**
     *  The data.
     */
    _defineProperty(this, "data", void 0);
    /**
     *  The value, in wei. Use [[formatEther]] to format this value
     *  as ether.
     */
    _defineProperty(this, "value", void 0);
    /**
     *  The chain ID.
     */
    _defineProperty(this, "chainId", void 0);
    /**
     *  The signature.
     */
    _defineProperty(this, "signature", void 0);
    /**
     *  The [[link-eip-2930]] access list for transaction types that
     *  support it, otherwise ``null``.
     */
    _defineProperty(this, "accessList", void 0);
    /**
     *  The [[link-eip-4844]] BLOb versioned hashes.
     */
    _defineProperty(this, "blobVersionedHashes", void 0);
    _classPrivateFieldInitSpec(this, _startBlock, void 0);
    this.provider = provider;
    this.blockNumber = tx.blockNumber != null ? tx.blockNumber : null;
    this.blockHash = tx.blockHash != null ? tx.blockHash : null;
    this.hash = tx.hash;
    this.index = tx.index;
    this.type = tx.type;
    this.from = tx.from;
    this.to = tx.to || null;
    this.gasLimit = tx.gasLimit;
    this.nonce = tx.nonce;
    this.data = tx.data;
    this.value = tx.value;
    this.gasPrice = tx.gasPrice;
    this.maxPriorityFeePerGas = tx.maxPriorityFeePerGas != null ? tx.maxPriorityFeePerGas : null;
    this.maxFeePerGas = tx.maxFeePerGas != null ? tx.maxFeePerGas : null;
    this.maxFeePerBlobGas = tx.maxFeePerBlobGas != null ? tx.maxFeePerBlobGas : null;
    this.chainId = tx.chainId;
    this.signature = tx.signature;
    this.accessList = tx.accessList != null ? tx.accessList : null;
    this.blobVersionedHashes = tx.blobVersionedHashes != null ? tx.blobVersionedHashes : null;
    _classPrivateFieldSet(_startBlock, this, -1);
  }
  /**
   *  Returns a JSON-compatible representation of this transaction.
   */
  return _createClass(TransactionResponse, [{
    key: "toJSON",
    value: function toJSON() {
      var blockNumber = this.blockNumber,
        blockHash = this.blockHash,
        index = this.index,
        hash = this.hash,
        type = this.type,
        to = this.to,
        from = this.from,
        nonce = this.nonce,
        data = this.data,
        signature = this.signature,
        accessList = this.accessList,
        blobVersionedHashes = this.blobVersionedHashes;
      return {
        _type: "TransactionResponse",
        accessList: accessList,
        blockNumber: blockNumber,
        blockHash: blockHash,
        blobVersionedHashes: blobVersionedHashes,
        chainId: toJson(this.chainId),
        data: data,
        from: from,
        gasLimit: toJson(this.gasLimit),
        gasPrice: toJson(this.gasPrice),
        hash: hash,
        maxFeePerGas: toJson(this.maxFeePerGas),
        maxPriorityFeePerGas: toJson(this.maxPriorityFeePerGas),
        maxFeePerBlobGas: toJson(this.maxFeePerBlobGas),
        nonce: nonce,
        signature: signature,
        to: to,
        index: index,
        type: type,
        value: toJson(this.value)
      };
    }
    /**
     *  Resolves to the Block that this transaction was included in.
     *
     *  This will return null if the transaction has not been included yet.
     */
  }, {
    key: "getBlock",
    value: (function () {
      var _getBlock3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {
        var blockNumber, tx, block;
        return _regeneratorRuntime().wrap(function _callee9$(_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
              blockNumber = this.blockNumber;
              if (!(blockNumber == null)) {
                _context9.next = 6;
                break;
              }
              _context9.next = 4;
              return this.getTransaction();
            case 4:
              tx = _context9.sent;
              if (tx) {
                blockNumber = tx.blockNumber;
              }
            case 6:
              if (!(blockNumber == null)) {
                _context9.next = 8;
                break;
              }
              return _context9.abrupt("return", null);
            case 8:
              block = this.provider.getBlock(blockNumber);
              if (!(block == null)) {
                _context9.next = 11;
                break;
              }
              throw new Error("TODO");
            case 11:
              return _context9.abrupt("return", block);
            case 12:
            case "end":
              return _context9.stop();
          }
        }, _callee9, this);
      }));
      function getBlock() {
        return _getBlock3.apply(this, arguments);
      }
      return getBlock;
    }()
    /**
     *  Resolves to this transaction being re-requested from the
     *  provider. This can be used if you have an unmined transaction
     *  and wish to get an up-to-date populated instance.
     */
    )
  }, {
    key: "getTransaction",
    value: (function () {
      var _getTransaction4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {
        return _regeneratorRuntime().wrap(function _callee10$(_context10) {
          while (1) switch (_context10.prev = _context10.next) {
            case 0:
              return _context10.abrupt("return", this.provider.getTransaction(this.hash));
            case 1:
            case "end":
              return _context10.stop();
          }
        }, _callee10, this);
      }));
      function getTransaction() {
        return _getTransaction4.apply(this, arguments);
      }
      return getTransaction;
    }()
    /**
     *  Resolve to the number of confirmations this transaction has.
     */
    )
  }, {
    key: "confirmations",
    value: (function () {
      var _confirmations2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {
        var _yield, tx, _blockNumber, blockNumber;
        return _regeneratorRuntime().wrap(function _callee11$(_context11) {
          while (1) switch (_context11.prev = _context11.next) {
            case 0:
              if (!(this.blockNumber == null)) {
                _context11.next = 9;
                break;
              }
              _context11.next = 3;
              return (0, index_js_1.resolveProperties)({
                tx: this.getTransaction(),
                blockNumber: this.provider.getBlockNumber()
              });
            case 3:
              _yield = _context11.sent;
              tx = _yield.tx;
              _blockNumber = _yield.blockNumber;
              if (!(tx == null || tx.blockNumber == null)) {
                _context11.next = 8;
                break;
              }
              return _context11.abrupt("return", 0);
            case 8:
              return _context11.abrupt("return", _blockNumber - tx.blockNumber + 1);
            case 9:
              _context11.next = 11;
              return this.provider.getBlockNumber();
            case 11:
              blockNumber = _context11.sent;
              return _context11.abrupt("return", blockNumber - this.blockNumber + 1);
            case 13:
            case "end":
              return _context11.stop();
          }
        }, _callee11, this);
      }));
      function confirmations() {
        return _confirmations2.apply(this, arguments);
      }
      return confirmations;
    }()
    /**
     *  Resolves once this transaction has been mined and has
     *  %%confirms%% blocks including it (default: ``1``) with an
     *  optional %%timeout%%.
     *
     *  This can resolve to ``null`` only if %%confirms%% is ``0``
     *  and the transaction has not been mined, otherwise this will
     *  wait until enough confirmations have completed.
     */
    )
  }, {
    key: "wait",
    value: (function () {
      var _wait = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15(_confirms, _timeout) {
        var _this3 = this;
        var confirms, timeout, startBlock, nextScan, stopScanning, checkReplacement, checkReceipt, receipt, waiter;
        return _regeneratorRuntime().wrap(function _callee15$(_context15) {
          while (1) switch (_context15.prev = _context15.next) {
            case 0:
              confirms = _confirms == null ? 1 : _confirms;
              timeout = _timeout == null ? 0 : _timeout;
              startBlock = _classPrivateFieldGet(_startBlock, this);
              nextScan = -1;
              stopScanning = startBlock === -1 ? true : false;
              checkReplacement = /*#__PURE__*/function () {
                var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {
                  var _yield2, blockNumber, nonce, mined, block, _iterator5, _step5, hash, i, tx, _receipt, reason;
                  return _regeneratorRuntime().wrap(function _callee12$(_context12) {
                    while (1) switch (_context12.prev = _context12.next) {
                      case 0:
                        if (!stopScanning) {
                          _context12.next = 2;
                          break;
                        }
                        return _context12.abrupt("return", null);
                      case 2:
                        _context12.next = 4;
                        return (0, index_js_1.resolveProperties)({
                          blockNumber: _this3.provider.getBlockNumber(),
                          nonce: _this3.provider.getTransactionCount(_this3.from)
                        });
                      case 4:
                        _yield2 = _context12.sent;
                        blockNumber = _yield2.blockNumber;
                        nonce = _yield2.nonce;
                        if (!(nonce < _this3.nonce)) {
                          _context12.next = 10;
                          break;
                        }
                        startBlock = blockNumber;
                        return _context12.abrupt("return");
                      case 10:
                        if (!stopScanning) {
                          _context12.next = 12;
                          break;
                        }
                        return _context12.abrupt("return", null);
                      case 12:
                        _context12.next = 14;
                        return _this3.getTransaction();
                      case 14:
                        mined = _context12.sent;
                        if (!(mined && mined.blockNumber != null)) {
                          _context12.next = 17;
                          break;
                        }
                        return _context12.abrupt("return");
                      case 17:
                        // We were replaced; start scanning for that transaction
                        // Starting to scan; look back a few extra blocks for safety
                        if (nextScan === -1) {
                          nextScan = startBlock - 3;
                          if (nextScan < _classPrivateFieldGet(_startBlock, _this3)) {
                            nextScan = _classPrivateFieldGet(_startBlock, _this3);
                          }
                        }
                      case 18:
                        if (!(nextScan <= blockNumber)) {
                          _context12.next = 67;
                          break;
                        }
                        if (!stopScanning) {
                          _context12.next = 21;
                          break;
                        }
                        return _context12.abrupt("return", null);
                      case 21:
                        _context12.next = 23;
                        return _this3.provider.getBlock(nextScan, true);
                      case 23:
                        block = _context12.sent;
                        if (!(block == null)) {
                          _context12.next = 26;
                          break;
                        }
                        return _context12.abrupt("return");
                      case 26:
                        // We were mined; no replacement
                        _iterator5 = _createForOfIteratorHelper(block);
                        _context12.prev = 27;
                        _iterator5.s();
                      case 29:
                        if ((_step5 = _iterator5.n()).done) {
                          _context12.next = 35;
                          break;
                        }
                        hash = _step5.value;
                        if (!(hash === _this3.hash)) {
                          _context12.next = 33;
                          break;
                        }
                        return _context12.abrupt("return");
                      case 33:
                        _context12.next = 29;
                        break;
                      case 35:
                        _context12.next = 40;
                        break;
                      case 37:
                        _context12.prev = 37;
                        _context12.t0 = _context12["catch"](27);
                        _iterator5.e(_context12.t0);
                      case 40:
                        _context12.prev = 40;
                        _iterator5.f();
                        return _context12.finish(40);
                      case 43:
                        i = 0;
                      case 44:
                        if (!(i < block.length)) {
                          _context12.next = 64;
                          break;
                        }
                        _context12.next = 47;
                        return block.getTransaction(i);
                      case 47:
                        tx = _context12.sent;
                        if (!(tx.from === _this3.from && tx.nonce === _this3.nonce)) {
                          _context12.next = 61;
                          break;
                        }
                        if (!stopScanning) {
                          _context12.next = 51;
                          break;
                        }
                        return _context12.abrupt("return", null);
                      case 51:
                        _context12.next = 53;
                        return _this3.provider.getTransactionReceipt(tx.hash);
                      case 53:
                        _receipt = _context12.sent;
                        if (!(_receipt == null)) {
                          _context12.next = 56;
                          break;
                        }
                        return _context12.abrupt("return");
                      case 56:
                        if (!(blockNumber - _receipt.blockNumber + 1 < confirms)) {
                          _context12.next = 58;
                          break;
                        }
                        return _context12.abrupt("return");
                      case 58:
                        // The reason we were replaced
                        reason = "replaced";
                        if (tx.data === _this3.data && tx.to === _this3.to && tx.value === _this3.value) {
                          reason = "repriced";
                        } else if (tx.data === "0x" && tx.from === tx.to && tx.value === BN_0) {
                          reason = "cancelled";
                        }
                        (0, index_js_1.assert)(false, "transaction was replaced", "TRANSACTION_REPLACED", {
                          cancelled: reason === "replaced" || reason === "cancelled",
                          reason: reason,
                          replacement: tx.replaceableTransaction(startBlock),
                          hash: tx.hash,
                          receipt: _receipt
                        });
                      case 61:
                        i++;
                        _context12.next = 44;
                        break;
                      case 64:
                        nextScan++;
                        _context12.next = 18;
                        break;
                      case 67:
                        return _context12.abrupt("return");
                      case 68:
                      case "end":
                        return _context12.stop();
                    }
                  }, _callee12, null, [[27, 37, 40, 43]]);
                }));
                return function checkReplacement() {
                  return _ref.apply(this, arguments);
                };
              }();
              checkReceipt = function checkReceipt(receipt) {
                if (receipt == null || receipt.status !== 0) {
                  return receipt;
                }
                (0, index_js_1.assert)(false, "transaction execution reverted", "CALL_EXCEPTION", {
                  action: "sendTransaction",
                  data: null,
                  reason: null,
                  invocation: null,
                  revert: null,
                  transaction: {
                    to: receipt.to,
                    from: receipt.from,
                    data: "" // @TODO: in v7, split out sendTransaction properties
                  },
                  receipt: receipt
                });
              };
              _context15.next = 9;
              return this.provider.getTransactionReceipt(this.hash);
            case 9:
              receipt = _context15.sent;
              if (!(confirms === 0)) {
                _context15.next = 12;
                break;
              }
              return _context15.abrupt("return", checkReceipt(receipt));
            case 12:
              if (!receipt) {
                _context15.next = 21;
                break;
              }
              _context15.next = 15;
              return receipt.confirmations();
            case 15:
              _context15.t0 = _context15.sent;
              _context15.t1 = confirms;
              if (!(_context15.t0 >= _context15.t1)) {
                _context15.next = 19;
                break;
              }
              return _context15.abrupt("return", checkReceipt(receipt));
            case 19:
              _context15.next = 25;
              break;
            case 21:
              _context15.next = 23;
              return checkReplacement();
            case 23:
              if (!(confirms === 0)) {
                _context15.next = 25;
                break;
              }
              return _context15.abrupt("return", null);
            case 25:
              waiter = new Promise(function (resolve, reject) {
                // List of things to cancel when we have a result (one way or the other)
                var cancellers = [];
                var cancel = function cancel() {
                  cancellers.forEach(function (c) {
                    return c();
                  });
                };
                // On cancel, stop scanning for replacements
                cancellers.push(function () {
                  stopScanning = true;
                });
                // Set up any timeout requested
                if (timeout > 0) {
                  var timer = setTimeout(function () {
                    cancel();
                    reject((0, index_js_1.makeError)("wait for transaction timeout", "TIMEOUT"));
                  }, timeout);
                  cancellers.push(function () {
                    clearTimeout(timer);
                  });
                }
                var txListener = /*#__PURE__*/function () {
                  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(receipt) {
                    return _regeneratorRuntime().wrap(function _callee13$(_context13) {
                      while (1) switch (_context13.prev = _context13.next) {
                        case 0:
                          _context13.next = 2;
                          return receipt.confirmations();
                        case 2:
                          _context13.t0 = _context13.sent;
                          _context13.t1 = confirms;
                          if (!(_context13.t0 >= _context13.t1)) {
                            _context13.next = 7;
                            break;
                          }
                          cancel();
                          try {
                            resolve(checkReceipt(receipt));
                          } catch (error) {
                            reject(error);
                          }
                        case 7:
                        case "end":
                          return _context13.stop();
                      }
                    }, _callee13);
                  }));
                  return function txListener(_x4) {
                    return _ref2.apply(this, arguments);
                  };
                }();
                cancellers.push(function () {
                  _this3.provider.off(_this3.hash, txListener);
                });
                _this3.provider.on(_this3.hash, txListener);
                // We support replacement detection; start checking
                if (startBlock >= 0) {
                  var replaceListener = /*#__PURE__*/function () {
                    var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14() {
                      return _regeneratorRuntime().wrap(function _callee14$(_context14) {
                        while (1) switch (_context14.prev = _context14.next) {
                          case 0:
                            _context14.prev = 0;
                            _context14.next = 3;
                            return checkReplacement();
                          case 3:
                            _context14.next = 11;
                            break;
                          case 5:
                            _context14.prev = 5;
                            _context14.t0 = _context14["catch"](0);
                            if (!(0, index_js_1.isError)(_context14.t0, "TRANSACTION_REPLACED")) {
                              _context14.next = 11;
                              break;
                            }
                            cancel();
                            reject(_context14.t0);
                            return _context14.abrupt("return");
                          case 11:
                            // Rescheudle a check on the next block
                            if (!stopScanning) {
                              _this3.provider.once("block", replaceListener);
                            }
                          case 12:
                          case "end":
                            return _context14.stop();
                        }
                      }, _callee14, null, [[0, 5]]);
                    }));
                    return function replaceListener() {
                      return _ref3.apply(this, arguments);
                    };
                  }();
                  cancellers.push(function () {
                    _this3.provider.off("block", replaceListener);
                  });
                  _this3.provider.once("block", replaceListener);
                }
              });
              _context15.next = 28;
              return waiter;
            case 28:
              return _context15.abrupt("return", _context15.sent);
            case 29:
            case "end":
              return _context15.stop();
          }
        }, _callee15, this);
      }));
      function wait(_x2, _x3) {
        return _wait.apply(this, arguments);
      }
      return wait;
    }()
    /**
     *  Returns ``true`` if this transaction has been included.
     *
     *  This is effective only as of the time the TransactionResponse
     *  was instantiated. To get up-to-date information, use
     *  [[getTransaction]].
     *
     *  This provides a Type Guard that this transaction will have
     *  non-null property values for properties that are null for
     *  unmined transactions.
     */
    )
  }, {
    key: "isMined",
    value: function isMined() {
      return this.blockHash != null;
    }
    /**
     *  Returns true if the transaction is a legacy (i.e. ``type == 0``)
     *  transaction.
     *
     *  This provides a Type Guard that this transaction will have
     *  the ``null``-ness for hardfork-specific properties set correctly.
     */
  }, {
    key: "isLegacy",
    value: function isLegacy() {
      return this.type === 0;
    }
    /**
     *  Returns true if the transaction is a Berlin (i.e. ``type == 1``)
     *  transaction. See [[link-eip-2070]].
     *
     *  This provides a Type Guard that this transaction will have
     *  the ``null``-ness for hardfork-specific properties set correctly.
     */
  }, {
    key: "isBerlin",
    value: function isBerlin() {
      return this.type === 1;
    }
    /**
     *  Returns true if the transaction is a London (i.e. ``type == 2``)
     *  transaction. See [[link-eip-1559]].
     *
     *  This provides a Type Guard that this transaction will have
     *  the ``null``-ness for hardfork-specific properties set correctly.
     */
  }, {
    key: "isLondon",
    value: function isLondon() {
      return this.type === 2;
    }
    /**
     *  Returns true if hte transaction is a Cancun (i.e. ``type == 3``)
     *  transaction. See [[link-eip-4844]].
     */
  }, {
    key: "isCancun",
    value: function isCancun() {
      return this.type === 3;
    }
    /**
     *  Returns a filter which can be used to listen for orphan events
     *  that evict this transaction.
     */
  }, {
    key: "removedEvent",
    value: function removedEvent() {
      (0, index_js_1.assert)(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", {
        operation: "removeEvent()"
      });
      return createRemovedTransactionFilter(this);
    }
    /**
     *  Returns a filter which can be used to listen for orphan events
     *  that re-order this event against %%other%%.
     */
  }, {
    key: "reorderedEvent",
    value: function reorderedEvent(other) {
      (0, index_js_1.assert)(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", {
        operation: "removeEvent()"
      });
      (0, index_js_1.assert)(!other || other.isMined(), "unmined 'other' transaction canot be orphaned", "UNSUPPORTED_OPERATION", {
        operation: "removeEvent()"
      });
      return createReorderedTransactionFilter(this, other);
    }
    /**
     *  Returns a new TransactionResponse instance which has the ability to
     *  detect (and throw an error) if the transaction is replaced, which
     *  will begin scanning at %%startBlock%%.
     *
     *  This should generally not be used by developers and is intended
     *  primarily for internal use. Setting an incorrect %%startBlock%% can
     *  have devastating performance consequences if used incorrectly.
     */
  }, {
    key: "replaceableTransaction",
    value: function replaceableTransaction(startBlock) {
      (0, index_js_1.assertArgument)(Number.isInteger(startBlock) && startBlock >= 0, "invalid startBlock", "startBlock", startBlock);
      var tx = new TransactionResponse(this, this.provider);
      _classPrivateFieldSet(_startBlock, tx, startBlock);
      return tx;
    }
  }]);
}();
exports.TransactionResponse = TransactionResponse;
function createOrphanedBlockFilter(block) {
  return {
    orphan: "drop-block",
    hash: block.hash,
    number: block.number
  };
}
function createReorderedTransactionFilter(tx, other) {
  return {
    orphan: "reorder-transaction",
    tx: tx,
    other: other
  };
}
function createRemovedTransactionFilter(tx) {
  return {
    orphan: "drop-transaction",
    tx: tx
  };
}
function createRemovedLogFilter(log) {
  return {
    orphan: "drop-log",
    log: {
      transactionHash: log.transactionHash,
      blockHash: log.blockHash,
      blockNumber: log.blockNumber,
      address: log.address,
      data: log.data,
      topics: Object.freeze(log.topics.slice()),
      index: log.index
    }
  };
}

},{"../transaction/index.js":266,"../utils/index.js":276}],260:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _get() { return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }
function _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NonceManager = void 0;
var index_js_1 = require("../utils/index.js");
var abstract_signer_js_1 = require("./abstract-signer.js");
/**
 *  A **NonceManager** wraps another [[Signer]] and automatically manages
 *  the nonce, ensuring serialized and sequential nonces are used during
 *  transaction.
 */
var _noncePromise = /*#__PURE__*/new WeakMap();
var _delta = /*#__PURE__*/new WeakMap();
var NonceManager = /*#__PURE__*/function (_abstract_signer_js_) {
  /**
   *  Creates a new **NonceManager** to manage %%signer%%.
   */
  function NonceManager(signer) {
    var _this;
    _classCallCheck(this, NonceManager);
    _this = _callSuper(this, NonceManager, [signer.provider]);
    /**
     *  The Signer being managed.
     */
    _defineProperty(_this, "signer", void 0);
    _classPrivateFieldInitSpec(_this, _noncePromise, void 0);
    _classPrivateFieldInitSpec(_this, _delta, void 0);
    (0, index_js_1.defineProperties)(_this, {
      signer: signer
    });
    _classPrivateFieldSet(_noncePromise, _this, null);
    _classPrivateFieldSet(_delta, _this, 0);
    return _this;
  }
  _inherits(NonceManager, _abstract_signer_js_);
  return _createClass(NonceManager, [{
    key: "getAddress",
    value: function () {
      var _getAddress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", this.signer.getAddress());
            case 1:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function getAddress() {
        return _getAddress.apply(this, arguments);
      }
      return getAddress;
    }()
  }, {
    key: "connect",
    value: function connect(provider) {
      return new NonceManager(this.signer.connect(provider));
    }
  }, {
    key: "getNonce",
    value: function () {
      var _getNonce = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(blockTag) {
        var delta;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              if (!(blockTag === "pending")) {
                _context2.next = 8;
                break;
              }
              if (_classPrivateFieldGet(_noncePromise, this) == null) {
                _classPrivateFieldSet(_noncePromise, this, _get(_getPrototypeOf(NonceManager.prototype), "getNonce", this).call(this, "pending"));
              }
              delta = _classPrivateFieldGet(_delta, this);
              _context2.next = 5;
              return _classPrivateFieldGet(_noncePromise, this);
            case 5:
              _context2.t0 = _context2.sent;
              _context2.t1 = delta;
              return _context2.abrupt("return", _context2.t0 + _context2.t1);
            case 8:
              return _context2.abrupt("return", _get(_getPrototypeOf(NonceManager.prototype), "getNonce", this).call(this, blockTag));
            case 9:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function getNonce(_x) {
        return _getNonce.apply(this, arguments);
      }
      return getNonce;
    }()
    /**
     *  Manually increment the nonce. This may be useful when managng
     *  offline transactions.
     */
  }, {
    key: "increment",
    value: function increment() {
      var _this$delta, _this$delta2;
      _classPrivateFieldSet(_delta, this, (_this$delta = _classPrivateFieldGet(_delta, this), _this$delta2 = _this$delta++, _this$delta)), _this$delta2;
    }
    /**
     *  Resets the nonce, causing the **NonceManager** to reload the current
     *  nonce from the blockchain on the next transaction.
     */
  }, {
    key: "reset",
    value: function reset() {
      _classPrivateFieldSet(_delta, this, 0);
      _classPrivateFieldSet(_noncePromise, this, null);
    }
  }, {
    key: "sendTransaction",
    value: function () {
      var _sendTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(tx) {
        var noncePromise;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              noncePromise = this.getNonce("pending");
              this.increment();
              _context3.next = 4;
              return this.signer.populateTransaction(tx);
            case 4:
              tx = _context3.sent;
              _context3.next = 7;
              return noncePromise;
            case 7:
              tx.nonce = _context3.sent;
              _context3.next = 10;
              return this.signer.sendTransaction(tx);
            case 10:
              return _context3.abrupt("return", _context3.sent);
            case 11:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function sendTransaction(_x2) {
        return _sendTransaction.apply(this, arguments);
      }
      return sendTransaction;
    }()
  }, {
    key: "signTransaction",
    value: function signTransaction(tx) {
      return this.signer.signTransaction(tx);
    }
  }, {
    key: "signMessage",
    value: function signMessage(message) {
      return this.signer.signMessage(message);
    }
  }, {
    key: "signTypedData",
    value: function signTypedData(domain, types, value) {
      return this.signer.signTypedData(domain, types, value);
    }
  }]);
}(abstract_signer_js_1.AbstractSigner);
exports.NonceManager = NonceManager;

},{"../utils/index.js":276,"./abstract-signer.js":237}],261:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FilterIdPendingSubscriber = exports.FilterIdEventSubscriber = exports.FilterIdSubscriber = void 0;
var index_js_1 = require("../utils/index.js");
var subscriber_polling_js_1 = require("./subscriber-polling.js");
function copy(obj) {
  return JSON.parse(JSON.stringify(obj));
}
/**
 *  Some backends support subscribing to events using a Filter ID.
 *
 *  When subscribing with this technique, the node issues a unique
 *  //Filter ID//. At this point the node dedicates resources to
 *  the filter, so that periodic calls to follow up on the //Filter ID//
 *  will receive any events since the last call.
 *
 *  @_docloc: api/providers/abstract-provider
 */
var _provider = /*#__PURE__*/new WeakMap();
var _filterIdPromise = /*#__PURE__*/new WeakMap();
var _poller = /*#__PURE__*/new WeakMap();
var _running = /*#__PURE__*/new WeakMap();
var _network = /*#__PURE__*/new WeakMap();
var _hault = /*#__PURE__*/new WeakMap();
var _FilterIdSubscriber_brand = /*#__PURE__*/new WeakSet();
var FilterIdSubscriber = /*#__PURE__*/function () {
  /**
   *  Creates a new **FilterIdSubscriber** which will used [[_subscribe]]
   *  and [[_emitResults]] to setup the subscription and provide the event
   *  to the %%provider%%.
   */
  function FilterIdSubscriber(provider) {
    _classCallCheck(this, FilterIdSubscriber);
    _classPrivateMethodInitSpec(this, _FilterIdSubscriber_brand);
    _classPrivateFieldInitSpec(this, _provider, void 0);
    _classPrivateFieldInitSpec(this, _filterIdPromise, void 0);
    _classPrivateFieldInitSpec(this, _poller, void 0);
    _classPrivateFieldInitSpec(this, _running, void 0);
    _classPrivateFieldInitSpec(this, _network, void 0);
    _classPrivateFieldInitSpec(this, _hault, void 0);
    _classPrivateFieldSet(_provider, this, provider);
    _classPrivateFieldSet(_filterIdPromise, this, null);
    _classPrivateFieldSet(_poller, this, _assertClassBrand(_FilterIdSubscriber_brand, this, _poll).bind(this));
    _classPrivateFieldSet(_running, this, false);
    _classPrivateFieldSet(_network, this, null);
    _classPrivateFieldSet(_hault, this, false);
  }
  /**
   *  Sub-classes **must** override this to begin the subscription.
   */
  return _createClass(FilterIdSubscriber, [{
    key: "_subscribe",
    value: function _subscribe(provider) {
      throw new Error("subclasses must override this");
    }
    /**
     *  Sub-classes **must** override this handle the events.
     */
  }, {
    key: "_emitResults",
    value: function _emitResults(provider, result) {
      throw new Error("subclasses must override this");
    }
    /**
     *  Sub-classes **must** override this handle recovery on errors.
     */
  }, {
    key: "_recover",
    value: function _recover(provider) {
      throw new Error("subclasses must override this");
    }
  }, {
    key: "start",
    value: function start() {
      if (_classPrivateFieldGet(_running, this)) {
        return;
      }
      _classPrivateFieldSet(_running, this, true);
      _assertClassBrand(_FilterIdSubscriber_brand, this, _poll).call(this, -2);
    }
  }, {
    key: "stop",
    value: function stop() {
      if (!_classPrivateFieldGet(_running, this)) {
        return;
      }
      _classPrivateFieldSet(_running, this, false);
      _classPrivateFieldSet(_hault, this, true);
      _assertClassBrand(_FilterIdSubscriber_brand, this, _teardown).call(this);
      _classPrivateFieldGet(_provider, this).off("block", _classPrivateFieldGet(_poller, this));
    }
  }, {
    key: "pause",
    value: function pause(dropWhilePaused) {
      if (dropWhilePaused) {
        _assertClassBrand(_FilterIdSubscriber_brand, this, _teardown).call(this);
      }
      _classPrivateFieldGet(_provider, this).off("block", _classPrivateFieldGet(_poller, this));
    }
  }, {
    key: "resume",
    value: function resume() {
      this.start();
    }
  }]);
}();
function _poll(_x7) {
  return _poll2.apply(this, arguments);
}
function _poll2() {
  _poll2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(blockNumber) {
    var filterId, network, result;
    return _regeneratorRuntime().wrap(function _callee5$(_context5) {
      while (1) switch (_context5.prev = _context5.next) {
        case 0:
          _context5.prev = 0;
          // Subscribe if necessary
          if (_classPrivateFieldGet(_filterIdPromise, this) == null) {
            _classPrivateFieldSet(_filterIdPromise, this, this._subscribe(_classPrivateFieldGet(_provider, this)));
          }
          // Get the Filter ID
          filterId = null;
          _context5.prev = 3;
          _context5.next = 6;
          return _classPrivateFieldGet(_filterIdPromise, this);
        case 6:
          filterId = _context5.sent;
          _context5.next = 13;
          break;
        case 9:
          _context5.prev = 9;
          _context5.t0 = _context5["catch"](3);
          if (!(!(0, index_js_1.isError)(_context5.t0, "UNSUPPORTED_OPERATION") || _context5.t0.operation !== "eth_newFilter")) {
            _context5.next = 13;
            break;
          }
          throw _context5.t0;
        case 13:
          if (!(filterId == null)) {
            _context5.next = 17;
            break;
          }
          _classPrivateFieldSet(_filterIdPromise, this, null);
          _classPrivateFieldGet(_provider, this)._recoverSubscriber(this, this._recover(_classPrivateFieldGet(_provider, this)));
          return _context5.abrupt("return");
        case 17:
          _context5.next = 19;
          return _classPrivateFieldGet(_provider, this).getNetwork();
        case 19:
          network = _context5.sent;
          if (!_classPrivateFieldGet(_network, this)) {
            _classPrivateFieldSet(_network, this, network);
          }
          if (!(_classPrivateFieldGet(_network, this).chainId !== network.chainId)) {
            _context5.next = 23;
            break;
          }
          throw new Error("chaid changed");
        case 23:
          if (!_classPrivateFieldGet(_hault, this)) {
            _context5.next = 25;
            break;
          }
          return _context5.abrupt("return");
        case 25:
          _context5.next = 27;
          return _classPrivateFieldGet(_provider, this).send("eth_getFilterChanges", [filterId]);
        case 27:
          result = _context5.sent;
          _context5.next = 30;
          return this._emitResults(_classPrivateFieldGet(_provider, this), result);
        case 30:
          _context5.next = 35;
          break;
        case 32:
          _context5.prev = 32;
          _context5.t1 = _context5["catch"](0);
          console.log("@TODO", _context5.t1);
        case 35:
          _classPrivateFieldGet(_provider, this).once("block", _classPrivateFieldGet(_poller, this));
        case 36:
        case "end":
          return _context5.stop();
      }
    }, _callee5, this, [[0, 32], [3, 9]]);
  }));
  return _poll2.apply(this, arguments);
}
function _teardown() {
  var _this2 = this;
  var filterIdPromise = _classPrivateFieldGet(_filterIdPromise, this);
  if (filterIdPromise) {
    _classPrivateFieldSet(_filterIdPromise, this, null);
    filterIdPromise.then(function (filterId) {
      if (_classPrivateFieldGet(_provider, _this2).destroyed) {
        return;
      }
      _classPrivateFieldGet(_provider, _this2).send("eth_uninstallFilter", [filterId]);
    });
  }
}
exports.FilterIdSubscriber = FilterIdSubscriber;
/**
 *  A **FilterIdSubscriber** for receiving contract events.
 *
 *  @_docloc: api/providers/abstract-provider
 */
var _event = /*#__PURE__*/new WeakMap();
var FilterIdEventSubscriber = /*#__PURE__*/function (_FilterIdSubscriber2) {
  /**
   *  Creates a new **FilterIdEventSubscriber** attached to %%provider%%
   *  listening for %%filter%%.
   */
  function FilterIdEventSubscriber(provider, filter) {
    var _this;
    _classCallCheck(this, FilterIdEventSubscriber);
    _this = _callSuper(this, FilterIdEventSubscriber, [provider]);
    _classPrivateFieldInitSpec(_this, _event, void 0);
    _classPrivateFieldSet(_event, _this, copy(filter));
    return _this;
  }
  _inherits(FilterIdEventSubscriber, _FilterIdSubscriber2);
  return _createClass(FilterIdEventSubscriber, [{
    key: "_recover",
    value: function _recover(provider) {
      return new subscriber_polling_js_1.PollingEventSubscriber(provider, _classPrivateFieldGet(_event, this));
    }
  }, {
    key: "_subscribe",
    value: function () {
      var _subscribe2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(provider) {
        var filterId;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return provider.send("eth_newFilter", [_classPrivateFieldGet(_event, this)]);
            case 2:
              filterId = _context.sent;
              return _context.abrupt("return", filterId);
            case 4:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function _subscribe(_x) {
        return _subscribe2.apply(this, arguments);
      }
      return _subscribe;
    }()
  }, {
    key: "_emitResults",
    value: function () {
      var _emitResults2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(provider, results) {
        var _iterator, _step, result;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _iterator = _createForOfIteratorHelper(results);
              try {
                for (_iterator.s(); !(_step = _iterator.n()).done;) {
                  result = _step.value;
                  provider.emit(_classPrivateFieldGet(_event, this), provider._wrapLog(result, provider._network));
                }
              } catch (err) {
                _iterator.e(err);
              } finally {
                _iterator.f();
              }
            case 2:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function _emitResults(_x2, _x3) {
        return _emitResults2.apply(this, arguments);
      }
      return _emitResults;
    }()
  }]);
}(FilterIdSubscriber);
exports.FilterIdEventSubscriber = FilterIdEventSubscriber;
/**
 *  A **FilterIdSubscriber** for receiving pending transactions events.
 *
 *  @_docloc: api/providers/abstract-provider
 */
var FilterIdPendingSubscriber = /*#__PURE__*/function (_FilterIdSubscriber3) {
  function FilterIdPendingSubscriber() {
    _classCallCheck(this, FilterIdPendingSubscriber);
    return _callSuper(this, FilterIdPendingSubscriber, arguments);
  }
  _inherits(FilterIdPendingSubscriber, _FilterIdSubscriber3);
  return _createClass(FilterIdPendingSubscriber, [{
    key: "_subscribe",
    value: function () {
      var _subscribe3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(provider) {
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _context3.next = 2;
              return provider.send("eth_newPendingTransactionFilter", []);
            case 2:
              return _context3.abrupt("return", _context3.sent);
            case 3:
            case "end":
              return _context3.stop();
          }
        }, _callee3);
      }));
      function _subscribe(_x4) {
        return _subscribe3.apply(this, arguments);
      }
      return _subscribe;
    }()
  }, {
    key: "_emitResults",
    value: function () {
      var _emitResults3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(provider, results) {
        var _iterator2, _step2, result;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              _iterator2 = _createForOfIteratorHelper(results);
              try {
                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                  result = _step2.value;
                  provider.emit("pending", result);
                }
              } catch (err) {
                _iterator2.e(err);
              } finally {
                _iterator2.f();
              }
            case 2:
            case "end":
              return _context4.stop();
          }
        }, _callee4);
      }));
      function _emitResults(_x5, _x6) {
        return _emitResults3.apply(this, arguments);
      }
      return _emitResults;
    }()
  }]);
}(FilterIdSubscriber);
exports.FilterIdPendingSubscriber = FilterIdPendingSubscriber;

},{"../utils/index.js":276,"./subscriber-polling.js":262}],262:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _get() { return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }
function _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PollingEventSubscriber = exports.PollingTransactionSubscriber = exports.PollingOrphanSubscriber = exports.PollingBlockTagSubscriber = exports.OnBlockSubscriber = exports.PollingBlockSubscriber = exports.getPollingSubscriber = void 0;
var index_js_1 = require("../utils/index.js");
function copy(obj) {
  return JSON.parse(JSON.stringify(obj));
}
/**
 *  Return the polling subscriber for common events.
 *
 *  @_docloc: api/providers/abstract-provider
 */
function getPollingSubscriber(provider, event) {
  if (event === "block") {
    return new PollingBlockSubscriber(provider);
  }
  if ((0, index_js_1.isHexString)(event, 32)) {
    return new PollingTransactionSubscriber(provider, event);
  }
  (0, index_js_1.assert)(false, "unsupported polling event", "UNSUPPORTED_OPERATION", {
    operation: "getPollingSubscriber",
    info: {
      event: event
    }
  });
}
exports.getPollingSubscriber = getPollingSubscriber;
// @TODO: refactor this
/**
 *  A **PollingBlockSubscriber** polls at a regular interval for a change
 *  in the block number.
 *
 *  @_docloc: api/providers/abstract-provider
 */
var _provider = /*#__PURE__*/new WeakMap();
var _poller = /*#__PURE__*/new WeakMap();
var _interval = /*#__PURE__*/new WeakMap();
var _blockNumber = /*#__PURE__*/new WeakMap();
var _PollingBlockSubscriber_brand = /*#__PURE__*/new WeakSet();
var PollingBlockSubscriber = /*#__PURE__*/function () {
  /**
   *  Create a new **PollingBlockSubscriber** attached to %%provider%%.
   */
  function PollingBlockSubscriber(provider) {
    _classCallCheck(this, PollingBlockSubscriber);
    _classPrivateMethodInitSpec(this, _PollingBlockSubscriber_brand);
    _classPrivateFieldInitSpec(this, _provider, void 0);
    _classPrivateFieldInitSpec(this, _poller, void 0);
    _classPrivateFieldInitSpec(this, _interval, void 0);
    // The most recent block we have scanned for events. The value -2
    // indicates we still need to fetch an initial block number
    _classPrivateFieldInitSpec(this, _blockNumber, void 0);
    _classPrivateFieldSet(_provider, this, provider);
    _classPrivateFieldSet(_poller, this, null);
    _classPrivateFieldSet(_interval, this, 4000);
    _classPrivateFieldSet(_blockNumber, this, -2);
  }
  /**
   *  The polling interval.
   */
  return _createClass(PollingBlockSubscriber, [{
    key: "pollingInterval",
    get: function get() {
      return _classPrivateFieldGet(_interval, this);
    },
    set: function set(value) {
      _classPrivateFieldSet(_interval, this, value);
    }
  }, {
    key: "start",
    value: function start() {
      if (_classPrivateFieldGet(_poller, this)) {
        return;
      }
      _classPrivateFieldSet(_poller, this, _classPrivateFieldGet(_provider, this)._setTimeout(_assertClassBrand(_PollingBlockSubscriber_brand, this, _poll).bind(this), _classPrivateFieldGet(_interval, this)));
      _assertClassBrand(_PollingBlockSubscriber_brand, this, _poll).call(this);
    }
  }, {
    key: "stop",
    value: function stop() {
      if (!_classPrivateFieldGet(_poller, this)) {
        return;
      }
      _classPrivateFieldGet(_provider, this)._clearTimeout(_classPrivateFieldGet(_poller, this));
      _classPrivateFieldSet(_poller, this, null);
    }
  }, {
    key: "pause",
    value: function pause(dropWhilePaused) {
      this.stop();
      if (dropWhilePaused) {
        _classPrivateFieldSet(_blockNumber, this, -2);
      }
    }
  }, {
    key: "resume",
    value: function resume() {
      this.start();
    }
  }]);
}();
function _poll() {
  return _poll8.apply(this, arguments);
}
function _poll8() {
  _poll8 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
    var blockNumber, b;
    return _regeneratorRuntime().wrap(function _callee5$(_context5) {
      while (1) switch (_context5.prev = _context5.next) {
        case 0:
          _context5.prev = 0;
          _context5.next = 3;
          return _classPrivateFieldGet(_provider, this).getBlockNumber();
        case 3:
          blockNumber = _context5.sent;
          if (!(_classPrivateFieldGet(_blockNumber, this) === -2)) {
            _context5.next = 7;
            break;
          }
          _classPrivateFieldSet(_blockNumber, this, blockNumber);
          return _context5.abrupt("return");
        case 7:
          if (!(blockNumber !== _classPrivateFieldGet(_blockNumber, this))) {
            _context5.next = 18;
            break;
          }
          b = _classPrivateFieldGet(_blockNumber, this) + 1;
        case 9:
          if (!(b <= blockNumber)) {
            _context5.next = 17;
            break;
          }
          if (!(_classPrivateFieldGet(_poller, this) == null)) {
            _context5.next = 12;
            break;
          }
          return _context5.abrupt("return");
        case 12:
          _context5.next = 14;
          return _classPrivateFieldGet(_provider, this).emit("block", b);
        case 14:
          b++;
          _context5.next = 9;
          break;
        case 17:
          _classPrivateFieldSet(_blockNumber, this, blockNumber);
        case 18:
          _context5.next = 22;
          break;
        case 20:
          _context5.prev = 20;
          _context5.t0 = _context5["catch"](0);
        case 22:
          if (!(_classPrivateFieldGet(_poller, this) == null)) {
            _context5.next = 24;
            break;
          }
          return _context5.abrupt("return");
        case 24:
          _classPrivateFieldSet(_poller, this, _classPrivateFieldGet(_provider, this)._setTimeout(_assertClassBrand(_PollingBlockSubscriber_brand, this, _poll).bind(this), _classPrivateFieldGet(_interval, this)));
        case 25:
        case "end":
          return _context5.stop();
      }
    }, _callee5, this, [[0, 20]]);
  }));
  return _poll8.apply(this, arguments);
}
exports.PollingBlockSubscriber = PollingBlockSubscriber;
/**
 *  An **OnBlockSubscriber** can be sub-classed, with a [[_poll]]
 *  implmentation which will be called on every new block.
 *
 *  @_docloc: api/providers/abstract-provider
 */
var _provider2 = /*#__PURE__*/new WeakMap();
var _poll2 = /*#__PURE__*/new WeakMap();
var _running = /*#__PURE__*/new WeakMap();
var OnBlockSubscriber = /*#__PURE__*/function () {
  /**
   *  Create a new **OnBlockSubscriber** attached to %%provider%%.
   */
  function OnBlockSubscriber(provider) {
    var _this = this;
    _classCallCheck(this, OnBlockSubscriber);
    _classPrivateFieldInitSpec(this, _provider2, void 0);
    _classPrivateFieldInitSpec(this, _poll2, void 0);
    _classPrivateFieldInitSpec(this, _running, void 0);
    _classPrivateFieldSet(_provider2, this, provider);
    _classPrivateFieldSet(_running, this, false);
    _classPrivateFieldSet(_poll2, this, function (blockNumber) {
      _this._poll(blockNumber, _classPrivateFieldGet(_provider2, _this));
    });
  }
  /**
   *  Called on every new block.
   */
  return _createClass(OnBlockSubscriber, [{
    key: "_poll",
    value: (function () {
      var _poll3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(blockNumber, provider) {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              throw new Error("sub-classes must override this");
            case 1:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));
      function _poll(_x, _x2) {
        return _poll3.apply(this, arguments);
      }
      return _poll;
    }())
  }, {
    key: "start",
    value: function start() {
      if (_classPrivateFieldGet(_running, this)) {
        return;
      }
      _classPrivateFieldSet(_running, this, true);
      _classPrivateFieldGet(_poll2, this).call(this, -2);
      _classPrivateFieldGet(_provider2, this).on("block", _classPrivateFieldGet(_poll2, this));
    }
  }, {
    key: "stop",
    value: function stop() {
      if (!_classPrivateFieldGet(_running, this)) {
        return;
      }
      _classPrivateFieldSet(_running, this, false);
      _classPrivateFieldGet(_provider2, this).off("block", _classPrivateFieldGet(_poll2, this));
    }
  }, {
    key: "pause",
    value: function pause(dropWhilePaused) {
      this.stop();
    }
  }, {
    key: "resume",
    value: function resume() {
      this.start();
    }
  }]);
}();
exports.OnBlockSubscriber = OnBlockSubscriber;
var _tag = /*#__PURE__*/new WeakMap();
var _lastBlock = /*#__PURE__*/new WeakMap();
var PollingBlockTagSubscriber = /*#__PURE__*/function (_OnBlockSubscriber2) {
  function PollingBlockTagSubscriber(provider, tag) {
    var _this2;
    _classCallCheck(this, PollingBlockTagSubscriber);
    _this2 = _callSuper(this, PollingBlockTagSubscriber, [provider]);
    _classPrivateFieldInitSpec(_this2, _tag, void 0);
    _classPrivateFieldInitSpec(_this2, _lastBlock, void 0);
    _classPrivateFieldSet(_tag, _this2, tag);
    _classPrivateFieldSet(_lastBlock, _this2, -2);
    return _this2;
  }
  _inherits(PollingBlockTagSubscriber, _OnBlockSubscriber2);
  return _createClass(PollingBlockTagSubscriber, [{
    key: "pause",
    value: function pause(dropWhilePaused) {
      if (dropWhilePaused) {
        _classPrivateFieldSet(_lastBlock, this, -2);
      }
      _get(_getPrototypeOf(PollingBlockTagSubscriber.prototype), "pause", this).call(this, dropWhilePaused);
    }
  }, {
    key: "_poll",
    value: function () {
      var _poll4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(blockNumber, provider) {
        var block;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return provider.getBlock(_classPrivateFieldGet(_tag, this));
            case 2:
              block = _context2.sent;
              if (!(block == null)) {
                _context2.next = 5;
                break;
              }
              return _context2.abrupt("return");
            case 5:
              if (_classPrivateFieldGet(_lastBlock, this) === -2) {
                _classPrivateFieldSet(_lastBlock, this, block.number);
              } else if (block.number > _classPrivateFieldGet(_lastBlock, this)) {
                provider.emit(_classPrivateFieldGet(_tag, this), block.number);
                _classPrivateFieldSet(_lastBlock, this, block.number);
              }
            case 6:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function _poll(_x3, _x4) {
        return _poll4.apply(this, arguments);
      }
      return _poll;
    }()
  }]);
}(OnBlockSubscriber);
exports.PollingBlockTagSubscriber = PollingBlockTagSubscriber;
/**
 *  @_ignore:
 *
 *  @_docloc: api/providers/abstract-provider
 */
var _filter = /*#__PURE__*/new WeakMap();
var PollingOrphanSubscriber = /*#__PURE__*/function (_OnBlockSubscriber3) {
  function PollingOrphanSubscriber(provider, filter) {
    var _this3;
    _classCallCheck(this, PollingOrphanSubscriber);
    _this3 = _callSuper(this, PollingOrphanSubscriber, [provider]);
    _classPrivateFieldInitSpec(_this3, _filter, void 0);
    _classPrivateFieldSet(_filter, _this3, copy(filter));
    return _this3;
  }
  _inherits(PollingOrphanSubscriber, _OnBlockSubscriber3);
  return _createClass(PollingOrphanSubscriber, [{
    key: "_poll",
    value: function () {
      var _poll5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(blockNumber, provider) {
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              throw new Error("@TODO");
            case 2:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function _poll(_x5, _x6) {
        return _poll5.apply(this, arguments);
      }
      return _poll;
    }()
  }]);
}(OnBlockSubscriber);
exports.PollingOrphanSubscriber = PollingOrphanSubscriber;
/**
 *  A **PollingTransactionSubscriber** will poll for a given transaction
 *  hash for its receipt.
 *
 *  @_docloc: api/providers/abstract-provider
 */
var _hash = /*#__PURE__*/new WeakMap();
var PollingTransactionSubscriber = /*#__PURE__*/function (_OnBlockSubscriber4) {
  /**
   *  Create a new **PollingTransactionSubscriber** attached to
   *  %%provider%%, listening for %%hash%%.
   */
  function PollingTransactionSubscriber(provider, hash) {
    var _this4;
    _classCallCheck(this, PollingTransactionSubscriber);
    _this4 = _callSuper(this, PollingTransactionSubscriber, [provider]);
    _classPrivateFieldInitSpec(_this4, _hash, void 0);
    _classPrivateFieldSet(_hash, _this4, hash);
    return _this4;
  }
  _inherits(PollingTransactionSubscriber, _OnBlockSubscriber4);
  return _createClass(PollingTransactionSubscriber, [{
    key: "_poll",
    value: function () {
      var _poll6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(blockNumber, provider) {
        var tx;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              _context4.next = 2;
              return provider.getTransactionReceipt(_classPrivateFieldGet(_hash, this));
            case 2:
              tx = _context4.sent;
              if (tx) {
                provider.emit(_classPrivateFieldGet(_hash, this), tx);
              }
            case 4:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));
      function _poll(_x7, _x8) {
        return _poll6.apply(this, arguments);
      }
      return _poll;
    }()
  }]);
}(OnBlockSubscriber);
exports.PollingTransactionSubscriber = PollingTransactionSubscriber;
/**
 *  A **PollingEventSubscriber** will poll for a given filter for its logs.
 *
 *  @_docloc: api/providers/abstract-provider
 */
var _provider3 = /*#__PURE__*/new WeakMap();
var _filter2 = /*#__PURE__*/new WeakMap();
var _poller2 = /*#__PURE__*/new WeakMap();
var _running2 = /*#__PURE__*/new WeakMap();
var _blockNumber2 = /*#__PURE__*/new WeakMap();
var _PollingEventSubscriber_brand = /*#__PURE__*/new WeakSet();
var PollingEventSubscriber = /*#__PURE__*/function () {
  /**
   *  Create a new **PollingTransactionSubscriber** attached to
   *  %%provider%%, listening for %%filter%%.
   */
  function PollingEventSubscriber(provider, _filter3) {
    _classCallCheck(this, PollingEventSubscriber);
    _classPrivateMethodInitSpec(this, _PollingEventSubscriber_brand);
    _classPrivateFieldInitSpec(this, _provider3, void 0);
    _classPrivateFieldInitSpec(this, _filter2, void 0);
    _classPrivateFieldInitSpec(this, _poller2, void 0);
    _classPrivateFieldInitSpec(this, _running2, void 0);
    // The most recent block we have scanned for events. The value -2
    // indicates we still need to fetch an initial block number
    _classPrivateFieldInitSpec(this, _blockNumber2, void 0);
    _classPrivateFieldSet(_provider3, this, provider);
    _classPrivateFieldSet(_filter2, this, copy(_filter3));
    _classPrivateFieldSet(_poller2, this, _assertClassBrand(_PollingEventSubscriber_brand, this, _poll7).bind(this));
    _classPrivateFieldSet(_running2, this, false);
    _classPrivateFieldSet(_blockNumber2, this, -2);
  }
  return _createClass(PollingEventSubscriber, [{
    key: "start",
    value: function start() {
      var _this5 = this;
      if (_classPrivateFieldGet(_running2, this)) {
        return;
      }
      _classPrivateFieldSet(_running2, this, true);
      if (_classPrivateFieldGet(_blockNumber2, this) === -2) {
        _classPrivateFieldGet(_provider3, this).getBlockNumber().then(function (blockNumber) {
          _classPrivateFieldSet(_blockNumber2, _this5, blockNumber);
        });
      }
      _classPrivateFieldGet(_provider3, this).on("block", _classPrivateFieldGet(_poller2, this));
    }
  }, {
    key: "stop",
    value: function stop() {
      if (!_classPrivateFieldGet(_running2, this)) {
        return;
      }
      _classPrivateFieldSet(_running2, this, false);
      _classPrivateFieldGet(_provider3, this).off("block", _classPrivateFieldGet(_poller2, this));
    }
  }, {
    key: "pause",
    value: function pause(dropWhilePaused) {
      this.stop();
      if (dropWhilePaused) {
        _classPrivateFieldSet(_blockNumber2, this, -2);
      }
    }
  }, {
    key: "resume",
    value: function resume() {
      this.start();
    }
  }]);
}();
function _poll7(_x9) {
  return _poll9.apply(this, arguments);
}
function _poll9() {
  _poll9 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(blockNumber) {
    var filter, logs, _iterator, _step, log;
    return _regeneratorRuntime().wrap(function _callee6$(_context6) {
      while (1) switch (_context6.prev = _context6.next) {
        case 0:
          if (!(_classPrivateFieldGet(_blockNumber2, this) === -2)) {
            _context6.next = 2;
            break;
          }
          return _context6.abrupt("return");
        case 2:
          filter = copy(_classPrivateFieldGet(_filter2, this));
          filter.fromBlock = _classPrivateFieldGet(_blockNumber2, this) + 1;
          filter.toBlock = blockNumber;
          _context6.next = 7;
          return _classPrivateFieldGet(_provider3, this).getLogs(filter);
        case 7:
          logs = _context6.sent;
          if (!(logs.length === 0)) {
            _context6.next = 11;
            break;
          }
          if (_classPrivateFieldGet(_blockNumber2, this) < blockNumber - 60) {
            _classPrivateFieldSet(_blockNumber2, this, blockNumber - 60);
          }
          return _context6.abrupt("return");
        case 11:
          _iterator = _createForOfIteratorHelper(logs);
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              log = _step.value;
              _classPrivateFieldGet(_provider3, this).emit(_classPrivateFieldGet(_filter2, this), log);
              // Only advance the block number when logs were found to
              // account for networks (like BNB and Polygon) which may
              // sacrifice event consistency for block event speed
              _classPrivateFieldSet(_blockNumber2, this, log.blockNumber);
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        case 13:
        case "end":
          return _context6.stop();
      }
    }, _callee6, this);
  }));
  return _poll9.apply(this, arguments);
}
exports.PollingEventSubscriber = PollingEventSubscriber;

},{"../utils/index.js":276}],263:[function(require,module,exports){
(function (global){(function (){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WebSocket = void 0;
function getGlobal() {
  if (typeof self !== 'undefined') {
    return self;
  }
  if (typeof window !== 'undefined') {
    return window;
  }
  if (typeof global !== 'undefined') {
    return global;
  }
  throw new Error('unable to locate global object');
}
;
var _WebSocket = getGlobal().WebSocket;
exports.WebSocket = _WebSocket;

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],264:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.accessListify = void 0;
var index_js_1 = require("../address/index.js");
var index_js_2 = require("../utils/index.js");
function accessSetify(addr, storageKeys) {
  return {
    address: (0, index_js_1.getAddress)(addr),
    storageKeys: storageKeys.map(function (storageKey, index) {
      (0, index_js_2.assertArgument)((0, index_js_2.isHexString)(storageKey, 32), "invalid slot", "storageKeys[".concat(index, "]"), storageKey);
      return storageKey.toLowerCase();
    })
  };
}
/**
 *  Returns a [[AccessList]] from any ethers-supported access-list structure.
 */
function accessListify(value) {
  if (Array.isArray(value)) {
    return value.map(function (set, index) {
      if (Array.isArray(set)) {
        (0, index_js_2.assertArgument)(set.length === 2, "invalid slot set", "value[".concat(index, "]"), set);
        return accessSetify(set[0], set[1]);
      }
      (0, index_js_2.assertArgument)(set != null && _typeof(set) === "object", "invalid address-slot set", "value", value);
      return accessSetify(set.address, set.storageKeys);
    });
  }
  (0, index_js_2.assertArgument)(value != null && _typeof(value) === "object", "invalid access list", "value", value);
  var result = Object.keys(value).map(function (addr) {
    var storageKeys = value[addr].reduce(function (accum, storageKey) {
      accum[storageKey] = true;
      return accum;
    }, {});
    return accessSetify(addr, Object.keys(storageKeys).sort());
  });
  result.sort(function (a, b) {
    return a.address.localeCompare(b.address);
  });
  return result;
}
exports.accessListify = accessListify;

},{"../address/index.js":207,"../utils/index.js":276}],265:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.recoverAddress = exports.computeAddress = void 0;
var index_js_1 = require("../address/index.js");
var index_js_2 = require("../crypto/index.js");
/**
 *  Returns the address for the %%key%%.
 *
 *  The key may be any standard form of public key or a private key.
 */
function computeAddress(key) {
  var pubkey;
  if (typeof key === "string") {
    pubkey = index_js_2.SigningKey.computePublicKey(key, false);
  } else {
    pubkey = key.publicKey;
  }
  return (0, index_js_1.getAddress)((0, index_js_2.keccak256)("0x" + pubkey.substring(4)).substring(26));
}
exports.computeAddress = computeAddress;
/**
 *  Returns the recovered address for the private key that was
 *  used to sign %%digest%% that resulted in %%signature%%.
 */
function recoverAddress(digest, signature) {
  return computeAddress(index_js_2.SigningKey.recoverPublicKey(digest, signature));
}
exports.recoverAddress = recoverAddress;

},{"../address/index.js":207,"../crypto/index.js":219}],266:[function(require,module,exports){
"use strict";

/**
 *  Each state-changing operation on Ethereum requires a transaction.
 *
 *  @_section api/transaction:Transactions  [about-transactions]
 */
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Transaction = exports.recoverAddress = exports.computeAddress = exports.accessListify = void 0;
null;
var accesslist_js_1 = require("./accesslist.js");
Object.defineProperty(exports, "accessListify", {
  enumerable: true,
  get: function get() {
    return accesslist_js_1.accessListify;
  }
});
var address_js_1 = require("./address.js");
Object.defineProperty(exports, "computeAddress", {
  enumerable: true,
  get: function get() {
    return address_js_1.computeAddress;
  }
});
Object.defineProperty(exports, "recoverAddress", {
  enumerable: true,
  get: function get() {
    return address_js_1.recoverAddress;
  }
});
var transaction_js_1 = require("./transaction.js");
Object.defineProperty(exports, "Transaction", {
  enumerable: true,
  get: function get() {
    return transaction_js_1.Transaction;
  }
});

},{"./accesslist.js":264,"./address.js":265,"./transaction.js":267}],267:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Transaction = void 0;
var index_js_1 = require("../address/index.js");
var addresses_js_1 = require("../constants/addresses.js");
var index_js_2 = require("../crypto/index.js");
var index_js_3 = require("../utils/index.js");
var accesslist_js_1 = require("./accesslist.js");
var address_js_1 = require("./address.js");
var BN_0 = BigInt(0);
var BN_2 = BigInt(2);
var BN_27 = BigInt(27);
var BN_28 = BigInt(28);
var BN_35 = BigInt(35);
var BN_MAX_UINT = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var BLOB_SIZE = 4096 * 32;
function getVersionedHash(version, hash) {
  var versioned = version.toString(16);
  while (versioned.length < 2) {
    versioned = "0" + versioned;
  }
  versioned += (0, index_js_2.sha256)(hash).substring(4);
  return "0x" + versioned;
}
function handleAddress(value) {
  if (value === "0x") {
    return null;
  }
  return (0, index_js_1.getAddress)(value);
}
function handleAccessList(value, param) {
  try {
    return (0, accesslist_js_1.accessListify)(value);
  } catch (error) {
    (0, index_js_3.assertArgument)(false, error.message, param, value);
  }
}
function handleNumber(_value, param) {
  if (_value === "0x") {
    return 0;
  }
  return (0, index_js_3.getNumber)(_value, param);
}
function handleUint(_value, param) {
  if (_value === "0x") {
    return BN_0;
  }
  var value = (0, index_js_3.getBigInt)(_value, param);
  (0, index_js_3.assertArgument)(value <= BN_MAX_UINT, "value exceeds uint size", param, value);
  return value;
}
function formatNumber(_value, name) {
  var value = (0, index_js_3.getBigInt)(_value, "value");
  var result = (0, index_js_3.toBeArray)(value);
  (0, index_js_3.assertArgument)(result.length <= 32, "value too large", "tx.".concat(name), value);
  return result;
}
function formatAccessList(value) {
  return (0, accesslist_js_1.accessListify)(value).map(function (set) {
    return [set.address, set.storageKeys];
  });
}
function formatHashes(value, param) {
  (0, index_js_3.assertArgument)(Array.isArray(value), "invalid ".concat(param), "value", value);
  for (var i = 0; i < value.length; i++) {
    (0, index_js_3.assertArgument)((0, index_js_3.isHexString)(value[i], 32), "invalid ${ param } hash", "value[".concat(i, "]"), value[i]);
  }
  return value;
}
function _parseLegacy(data) {
  var fields = (0, index_js_3.decodeRlp)(data);
  (0, index_js_3.assertArgument)(Array.isArray(fields) && (fields.length === 9 || fields.length === 6), "invalid field count for legacy transaction", "data", data);
  var tx = {
    type: 0,
    nonce: handleNumber(fields[0], "nonce"),
    gasPrice: handleUint(fields[1], "gasPrice"),
    gasLimit: handleUint(fields[2], "gasLimit"),
    to: handleAddress(fields[3]),
    value: handleUint(fields[4], "value"),
    data: (0, index_js_3.hexlify)(fields[5]),
    chainId: BN_0
  };
  // Legacy unsigned transaction
  if (fields.length === 6) {
    return tx;
  }
  var v = handleUint(fields[6], "v");
  var r = handleUint(fields[7], "r");
  var s = handleUint(fields[8], "s");
  if (r === BN_0 && s === BN_0) {
    // EIP-155 unsigned transaction
    tx.chainId = v;
  } else {
    // Compute the EIP-155 chain ID (or 0 for legacy)
    var chainId = (v - BN_35) / BN_2;
    if (chainId < BN_0) {
      chainId = BN_0;
    }
    tx.chainId = chainId;
    // Signed Legacy Transaction
    (0, index_js_3.assertArgument)(chainId !== BN_0 || v === BN_27 || v === BN_28, "non-canonical legacy v", "v", fields[6]);
    tx.signature = index_js_2.Signature.from({
      r: (0, index_js_3.zeroPadValue)(fields[7], 32),
      s: (0, index_js_3.zeroPadValue)(fields[8], 32),
      v: v
    });
    //tx.hash = keccak256(data);
  }
  return tx;
}
function _serializeLegacy(tx, sig) {
  var fields = [formatNumber(tx.nonce, "nonce"), formatNumber(tx.gasPrice || 0, "gasPrice"), formatNumber(tx.gasLimit, "gasLimit"), tx.to || "0x", formatNumber(tx.value, "value"), tx.data];
  var chainId = BN_0;
  if (tx.chainId != BN_0) {
    // A chainId was provided; if non-zero we'll use EIP-155
    chainId = (0, index_js_3.getBigInt)(tx.chainId, "tx.chainId");
    // We have a chainId in the tx and an EIP-155 v in the signature,
    // make sure they agree with each other
    (0, index_js_3.assertArgument)(!sig || sig.networkV == null || sig.legacyChainId === chainId, "tx.chainId/sig.v mismatch", "sig", sig);
  } else if (tx.signature) {
    // No explicit chainId, but EIP-155 have a derived implicit chainId
    var legacy = tx.signature.legacyChainId;
    if (legacy != null) {
      chainId = legacy;
    }
  }
  // Requesting an unsigned transaction
  if (!sig) {
    // We have an EIP-155 transaction (chainId was specified and non-zero)
    if (chainId !== BN_0) {
      fields.push((0, index_js_3.toBeArray)(chainId));
      fields.push("0x");
      fields.push("0x");
    }
    return (0, index_js_3.encodeRlp)(fields);
  }
  // @TODO: We should probably check that tx.signature, chainId, and sig
  //        match but that logic could break existing code, so schedule
  //        this for the next major bump.
  // Compute the EIP-155 v
  var v = BigInt(27 + sig.yParity);
  if (chainId !== BN_0) {
    v = index_js_2.Signature.getChainIdV(chainId, sig.v);
  } else if (BigInt(sig.v) !== v) {
    (0, index_js_3.assertArgument)(false, "tx.chainId/sig.v mismatch", "sig", sig);
  }
  // Add the signature
  fields.push((0, index_js_3.toBeArray)(v));
  fields.push((0, index_js_3.toBeArray)(sig.r));
  fields.push((0, index_js_3.toBeArray)(sig.s));
  return (0, index_js_3.encodeRlp)(fields);
}
function _parseEipSignature(tx, fields) {
  var yParity;
  try {
    yParity = handleNumber(fields[0], "yParity");
    if (yParity !== 0 && yParity !== 1) {
      throw new Error("bad yParity");
    }
  } catch (error) {
    (0, index_js_3.assertArgument)(false, "invalid yParity", "yParity", fields[0]);
  }
  var r = (0, index_js_3.zeroPadValue)(fields[1], 32);
  var s = (0, index_js_3.zeroPadValue)(fields[2], 32);
  var signature = index_js_2.Signature.from({
    r: r,
    s: s,
    yParity: yParity
  });
  tx.signature = signature;
}
function _parseEip1559(data) {
  var fields = (0, index_js_3.decodeRlp)((0, index_js_3.getBytes)(data).slice(1));
  (0, index_js_3.assertArgument)(Array.isArray(fields) && (fields.length === 9 || fields.length === 12), "invalid field count for transaction type: 2", "data", (0, index_js_3.hexlify)(data));
  var tx = {
    type: 2,
    chainId: handleUint(fields[0], "chainId"),
    nonce: handleNumber(fields[1], "nonce"),
    maxPriorityFeePerGas: handleUint(fields[2], "maxPriorityFeePerGas"),
    maxFeePerGas: handleUint(fields[3], "maxFeePerGas"),
    gasPrice: null,
    gasLimit: handleUint(fields[4], "gasLimit"),
    to: handleAddress(fields[5]),
    value: handleUint(fields[6], "value"),
    data: (0, index_js_3.hexlify)(fields[7]),
    accessList: handleAccessList(fields[8], "accessList")
  };
  // Unsigned EIP-1559 Transaction
  if (fields.length === 9) {
    return tx;
  }
  //tx.hash = keccak256(data);
  _parseEipSignature(tx, fields.slice(9));
  return tx;
}
function _serializeEip1559(tx, sig) {
  var fields = [formatNumber(tx.chainId, "chainId"), formatNumber(tx.nonce, "nonce"), formatNumber(tx.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"), formatNumber(tx.maxFeePerGas || 0, "maxFeePerGas"), formatNumber(tx.gasLimit, "gasLimit"), tx.to || "0x", formatNumber(tx.value, "value"), tx.data, formatAccessList(tx.accessList || [])];
  if (sig) {
    fields.push(formatNumber(sig.yParity, "yParity"));
    fields.push((0, index_js_3.toBeArray)(sig.r));
    fields.push((0, index_js_3.toBeArray)(sig.s));
  }
  return (0, index_js_3.concat)(["0x02", (0, index_js_3.encodeRlp)(fields)]);
}
function _parseEip2930(data) {
  var fields = (0, index_js_3.decodeRlp)((0, index_js_3.getBytes)(data).slice(1));
  (0, index_js_3.assertArgument)(Array.isArray(fields) && (fields.length === 8 || fields.length === 11), "invalid field count for transaction type: 1", "data", (0, index_js_3.hexlify)(data));
  var tx = {
    type: 1,
    chainId: handleUint(fields[0], "chainId"),
    nonce: handleNumber(fields[1], "nonce"),
    gasPrice: handleUint(fields[2], "gasPrice"),
    gasLimit: handleUint(fields[3], "gasLimit"),
    to: handleAddress(fields[4]),
    value: handleUint(fields[5], "value"),
    data: (0, index_js_3.hexlify)(fields[6]),
    accessList: handleAccessList(fields[7], "accessList")
  };
  // Unsigned EIP-2930 Transaction
  if (fields.length === 8) {
    return tx;
  }
  //tx.hash = keccak256(data);
  _parseEipSignature(tx, fields.slice(8));
  return tx;
}
function _serializeEip2930(tx, sig) {
  var fields = [formatNumber(tx.chainId, "chainId"), formatNumber(tx.nonce, "nonce"), formatNumber(tx.gasPrice || 0, "gasPrice"), formatNumber(tx.gasLimit, "gasLimit"), tx.to || "0x", formatNumber(tx.value, "value"), tx.data, formatAccessList(tx.accessList || [])];
  if (sig) {
    fields.push(formatNumber(sig.yParity, "recoveryParam"));
    fields.push((0, index_js_3.toBeArray)(sig.r));
    fields.push((0, index_js_3.toBeArray)(sig.s));
  }
  return (0, index_js_3.concat)(["0x01", (0, index_js_3.encodeRlp)(fields)]);
}
function _parseEip4844(data) {
  var fields = (0, index_js_3.decodeRlp)((0, index_js_3.getBytes)(data).slice(1));
  var typeName = "3";
  var blobs = null;
  // Parse the network format
  if (fields.length === 4 && Array.isArray(fields[0])) {
    typeName = "3 (network format)";
    var fBlobs = fields[1],
      fCommits = fields[2],
      fProofs = fields[3];
    (0, index_js_3.assertArgument)(Array.isArray(fBlobs), "invalid network format: blobs not an array", "fields[1]", fBlobs);
    (0, index_js_3.assertArgument)(Array.isArray(fCommits), "invalid network format: commitments not an array", "fields[2]", fCommits);
    (0, index_js_3.assertArgument)(Array.isArray(fProofs), "invalid network format: proofs not an array", "fields[3]", fProofs);
    (0, index_js_3.assertArgument)(fBlobs.length === fCommits.length, "invalid network format: blobs/commitments length mismatch", "fields", fields);
    (0, index_js_3.assertArgument)(fBlobs.length === fProofs.length, "invalid network format: blobs/proofs length mismatch", "fields", fields);
    blobs = [];
    for (var i = 0; i < fields[1].length; i++) {
      blobs.push({
        data: fBlobs[i],
        commitment: fCommits[i],
        proof: fProofs[i]
      });
    }
    fields = fields[0];
  }
  (0, index_js_3.assertArgument)(Array.isArray(fields) && (fields.length === 11 || fields.length === 14), "invalid field count for transaction type: ".concat(typeName), "data", (0, index_js_3.hexlify)(data));
  var tx = {
    type: 3,
    chainId: handleUint(fields[0], "chainId"),
    nonce: handleNumber(fields[1], "nonce"),
    maxPriorityFeePerGas: handleUint(fields[2], "maxPriorityFeePerGas"),
    maxFeePerGas: handleUint(fields[3], "maxFeePerGas"),
    gasPrice: null,
    gasLimit: handleUint(fields[4], "gasLimit"),
    to: handleAddress(fields[5]),
    value: handleUint(fields[6], "value"),
    data: (0, index_js_3.hexlify)(fields[7]),
    accessList: handleAccessList(fields[8], "accessList"),
    maxFeePerBlobGas: handleUint(fields[9], "maxFeePerBlobGas"),
    blobVersionedHashes: fields[10]
  };
  if (blobs) {
    tx.blobs = blobs;
  }
  (0, index_js_3.assertArgument)(tx.to != null, "invalid address for transaction type: ".concat(typeName), "data", data);
  (0, index_js_3.assertArgument)(Array.isArray(tx.blobVersionedHashes), "invalid blobVersionedHashes: must be an array", "data", data);
  for (var _i = 0; _i < tx.blobVersionedHashes.length; _i++) {
    (0, index_js_3.assertArgument)((0, index_js_3.isHexString)(tx.blobVersionedHashes[_i], 32), "invalid blobVersionedHash at index ".concat(_i, ": must be length 32"), "data", data);
  }
  // Unsigned EIP-4844 Transaction
  if (fields.length === 11) {
    return tx;
  }
  // @TODO: Do we need to do this? This is only called internally
  // and used to verify hashes; it might save time to not do this
  //tx.hash = keccak256(concat([ "0x03", encodeRlp(fields) ]));
  _parseEipSignature(tx, fields.slice(11));
  return tx;
}
function _serializeEip4844(tx, sig, blobs) {
  var fields = [formatNumber(tx.chainId, "chainId"), formatNumber(tx.nonce, "nonce"), formatNumber(tx.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"), formatNumber(tx.maxFeePerGas || 0, "maxFeePerGas"), formatNumber(tx.gasLimit, "gasLimit"), tx.to || addresses_js_1.ZeroAddress, formatNumber(tx.value, "value"), tx.data, formatAccessList(tx.accessList || []), formatNumber(tx.maxFeePerBlobGas || 0, "maxFeePerBlobGas"), formatHashes(tx.blobVersionedHashes || [], "blobVersionedHashes")];
  if (sig) {
    fields.push(formatNumber(sig.yParity, "yParity"));
    fields.push((0, index_js_3.toBeArray)(sig.r));
    fields.push((0, index_js_3.toBeArray)(sig.s));
    // We have blobs; return the network wrapped format
    if (blobs) {
      return (0, index_js_3.concat)(["0x03", (0, index_js_3.encodeRlp)([fields, blobs.map(function (b) {
        return b.data;
      }), blobs.map(function (b) {
        return b.commitment;
      }), blobs.map(function (b) {
        return b.proof;
      })])]);
    }
  }
  return (0, index_js_3.concat)(["0x03", (0, index_js_3.encodeRlp)(fields)]);
}
/**
 *  A **Transaction** describes an operation to be executed on
 *  Ethereum by an Externally Owned Account (EOA). It includes
 *  who (the [[to]] address), what (the [[data]]) and how much (the
 *  [[value]] in ether) the operation should entail.
 *
 *  @example:
 *    tx = new Transaction()
 *    //_result:
 *
 *    tx.data = "0x1234";
 *    //_result:
 */
var _type = /*#__PURE__*/new WeakMap();
var _to = /*#__PURE__*/new WeakMap();
var _data = /*#__PURE__*/new WeakMap();
var _nonce = /*#__PURE__*/new WeakMap();
var _gasLimit = /*#__PURE__*/new WeakMap();
var _gasPrice = /*#__PURE__*/new WeakMap();
var _maxPriorityFeePerGas = /*#__PURE__*/new WeakMap();
var _maxFeePerGas = /*#__PURE__*/new WeakMap();
var _value2 = /*#__PURE__*/new WeakMap();
var _chainId = /*#__PURE__*/new WeakMap();
var _sig = /*#__PURE__*/new WeakMap();
var _accessList = /*#__PURE__*/new WeakMap();
var _maxFeePerBlobGas = /*#__PURE__*/new WeakMap();
var _blobVersionedHashes = /*#__PURE__*/new WeakMap();
var _kzg = /*#__PURE__*/new WeakMap();
var _blobs2 = /*#__PURE__*/new WeakMap();
var _Transaction_brand = /*#__PURE__*/new WeakSet();
var Transaction = /*#__PURE__*/function () {
  /**
   *  Creates a new Transaction with default values.
   */
  function Transaction() {
    _classCallCheck(this, Transaction);
    _classPrivateMethodInitSpec(this, _Transaction_brand);
    _classPrivateFieldInitSpec(this, _type, void 0);
    _classPrivateFieldInitSpec(this, _to, void 0);
    _classPrivateFieldInitSpec(this, _data, void 0);
    _classPrivateFieldInitSpec(this, _nonce, void 0);
    _classPrivateFieldInitSpec(this, _gasLimit, void 0);
    _classPrivateFieldInitSpec(this, _gasPrice, void 0);
    _classPrivateFieldInitSpec(this, _maxPriorityFeePerGas, void 0);
    _classPrivateFieldInitSpec(this, _maxFeePerGas, void 0);
    _classPrivateFieldInitSpec(this, _value2, void 0);
    _classPrivateFieldInitSpec(this, _chainId, void 0);
    _classPrivateFieldInitSpec(this, _sig, void 0);
    _classPrivateFieldInitSpec(this, _accessList, void 0);
    _classPrivateFieldInitSpec(this, _maxFeePerBlobGas, void 0);
    _classPrivateFieldInitSpec(this, _blobVersionedHashes, void 0);
    _classPrivateFieldInitSpec(this, _kzg, void 0);
    _classPrivateFieldInitSpec(this, _blobs2, void 0);
    _classPrivateFieldSet(_type, this, null);
    _classPrivateFieldSet(_to, this, null);
    _classPrivateFieldSet(_nonce, this, 0);
    _classPrivateFieldSet(_gasLimit, this, BN_0);
    _classPrivateFieldSet(_gasPrice, this, null);
    _classPrivateFieldSet(_maxPriorityFeePerGas, this, null);
    _classPrivateFieldSet(_maxFeePerGas, this, null);
    _classPrivateFieldSet(_data, this, "0x");
    _classPrivateFieldSet(_value2, this, BN_0);
    _classPrivateFieldSet(_chainId, this, BN_0);
    _classPrivateFieldSet(_sig, this, null);
    _classPrivateFieldSet(_accessList, this, null);
    _classPrivateFieldSet(_maxFeePerBlobGas, this, null);
    _classPrivateFieldSet(_blobVersionedHashes, this, null);
    _classPrivateFieldSet(_blobs2, this, null);
    _classPrivateFieldSet(_kzg, this, null);
  }
  /**
   *  The transaction hash, if signed. Otherwise, ``null``.
   */
  return _createClass(Transaction, [{
    key: "type",
    get:
    /**
     *  The transaction type.
     *
     *  If null, the type will be automatically inferred based on
     *  explicit properties.
     */
    function get() {
      return _classPrivateFieldGet(_type, this);
    },
    set: function set(value) {
      switch (value) {
        case null:
          _classPrivateFieldSet(_type, this, null);
          break;
        case 0:
        case "legacy":
          _classPrivateFieldSet(_type, this, 0);
          break;
        case 1:
        case "berlin":
        case "eip-2930":
          _classPrivateFieldSet(_type, this, 1);
          break;
        case 2:
        case "london":
        case "eip-1559":
          _classPrivateFieldSet(_type, this, 2);
          break;
        case 3:
        case "cancun":
        case "eip-4844":
          _classPrivateFieldSet(_type, this, 3);
          break;
        default:
          (0, index_js_3.assertArgument)(false, "unsupported transaction type", "type", value);
      }
    }
    /**
     *  The name of the transaction type.
     */
  }, {
    key: "typeName",
    get: function get() {
      switch (this.type) {
        case 0:
          return "legacy";
        case 1:
          return "eip-2930";
        case 2:
          return "eip-1559";
        case 3:
          return "eip-4844";
      }
      return null;
    }
    /**
     *  The ``to`` address for the transaction or ``null`` if the
     *  transaction is an ``init`` transaction.
     */
  }, {
    key: "to",
    get: function get() {
      var value = _classPrivateFieldGet(_to, this);
      if (value == null && this.type === 3) {
        return addresses_js_1.ZeroAddress;
      }
      return value;
    },
    set: function set(value) {
      _classPrivateFieldSet(_to, this, value == null ? null : (0, index_js_1.getAddress)(value));
    }
    /**
     *  The transaction nonce.
     */
  }, {
    key: "nonce",
    get: function get() {
      return _classPrivateFieldGet(_nonce, this);
    },
    set: function set(value) {
      _classPrivateFieldSet(_nonce, this, (0, index_js_3.getNumber)(value, "value"));
    }
    /**
     *  The gas limit.
     */
  }, {
    key: "gasLimit",
    get: function get() {
      return _classPrivateFieldGet(_gasLimit, this);
    },
    set: function set(value) {
      _classPrivateFieldSet(_gasLimit, this, (0, index_js_3.getBigInt)(value));
    }
    /**
     *  The gas price.
     *
     *  On legacy networks this defines the fee that will be paid. On
     *  EIP-1559 networks, this should be ``null``.
     */
  }, {
    key: "gasPrice",
    get: function get() {
      var value = _classPrivateFieldGet(_gasPrice, this);
      if (value == null && (this.type === 0 || this.type === 1)) {
        return BN_0;
      }
      return value;
    },
    set: function set(value) {
      _classPrivateFieldSet(_gasPrice, this, value == null ? null : (0, index_js_3.getBigInt)(value, "gasPrice"));
    }
    /**
     *  The maximum priority fee per unit of gas to pay. On legacy
     *  networks this should be ``null``.
     */
  }, {
    key: "maxPriorityFeePerGas",
    get: function get() {
      var value = _classPrivateFieldGet(_maxPriorityFeePerGas, this);
      if (value == null) {
        if (this.type === 2 || this.type === 3) {
          return BN_0;
        }
        return null;
      }
      return value;
    },
    set: function set(value) {
      _classPrivateFieldSet(_maxPriorityFeePerGas, this, value == null ? null : (0, index_js_3.getBigInt)(value, "maxPriorityFeePerGas"));
    }
    /**
     *  The maximum total fee per unit of gas to pay. On legacy
     *  networks this should be ``null``.
     */
  }, {
    key: "maxFeePerGas",
    get: function get() {
      var value = _classPrivateFieldGet(_maxFeePerGas, this);
      if (value == null) {
        if (this.type === 2 || this.type === 3) {
          return BN_0;
        }
        return null;
      }
      return value;
    },
    set: function set(value) {
      _classPrivateFieldSet(_maxFeePerGas, this, value == null ? null : (0, index_js_3.getBigInt)(value, "maxFeePerGas"));
    }
    /**
     *  The transaction data. For ``init`` transactions this is the
     *  deployment code.
     */
  }, {
    key: "data",
    get: function get() {
      return _classPrivateFieldGet(_data, this);
    },
    set: function set(value) {
      _classPrivateFieldSet(_data, this, (0, index_js_3.hexlify)(value));
    }
    /**
     *  The amount of ether (in wei) to send in this transactions.
     */
  }, {
    key: "value",
    get: function get() {
      return _classPrivateFieldGet(_value2, this);
    },
    set: function set(value) {
      _classPrivateFieldSet(_value2, this, (0, index_js_3.getBigInt)(value, "value"));
    }
    /**
     *  The chain ID this transaction is valid on.
     */
  }, {
    key: "chainId",
    get: function get() {
      return _classPrivateFieldGet(_chainId, this);
    },
    set: function set(value) {
      _classPrivateFieldSet(_chainId, this, (0, index_js_3.getBigInt)(value));
    }
    /**
     *  If signed, the signature for this transaction.
     */
  }, {
    key: "signature",
    get: function get() {
      return _classPrivateFieldGet(_sig, this) || null;
    },
    set: function set(value) {
      _classPrivateFieldSet(_sig, this, value == null ? null : index_js_2.Signature.from(value));
    }
    /**
     *  The access list.
     *
     *  An access list permits discounted (but pre-paid) access to
     *  bytecode and state variable access within contract execution.
     */
  }, {
    key: "accessList",
    get: function get() {
      var value = _classPrivateFieldGet(_accessList, this) || null;
      if (value == null) {
        if (this.type === 1 || this.type === 2 || this.type === 3) {
          // @TODO: in v7, this should assign the value or become
          // a live object itself, otherwise mutation is inconsistent
          return [];
        }
        return null;
      }
      return value;
    },
    set: function set(value) {
      _classPrivateFieldSet(_accessList, this, value == null ? null : (0, accesslist_js_1.accessListify)(value));
    }
    /**
     *  The max fee per blob gas for Cancun transactions.
     */
  }, {
    key: "maxFeePerBlobGas",
    get: function get() {
      var value = _classPrivateFieldGet(_maxFeePerBlobGas, this);
      if (value == null && this.type === 3) {
        return BN_0;
      }
      return value;
    },
    set: function set(value) {
      _classPrivateFieldSet(_maxFeePerBlobGas, this, value == null ? null : (0, index_js_3.getBigInt)(value, "maxFeePerBlobGas"));
    }
    /**
     *  The BLOb versioned hashes for Cancun transactions.
     */
  }, {
    key: "blobVersionedHashes",
    get: function get() {
      // @TODO: Mutation is inconsistent; if unset, the returned value
      // cannot mutate the object, if set it can
      var value = _classPrivateFieldGet(_blobVersionedHashes, this);
      if (value == null && this.type === 3) {
        return [];
      }
      return value;
    },
    set: function set(value) {
      if (value != null) {
        (0, index_js_3.assertArgument)(Array.isArray(value), "blobVersionedHashes must be an Array", "value", value);
        value = value.slice();
        for (var i = 0; i < value.length; i++) {
          (0, index_js_3.assertArgument)((0, index_js_3.isHexString)(value[i], 32), "invalid blobVersionedHash", "value[".concat(i, "]"), value[i]);
        }
      }
      _classPrivateFieldSet(_blobVersionedHashes, this, value);
    }
    /**
     *  The BLObs for the Transaction, if any.
     *
     *  If ``blobs`` is non-``null``, then the [[seriailized]]
     *  will return the network formatted sidecar, otherwise it
     *  will return the standard [[link-eip-2718]] payload. The
     *  [[unsignedSerialized]] is unaffected regardless.
     *
     *  When setting ``blobs``, either fully valid [[Blob]] objects
     *  may be specified (i.e. correctly padded, with correct
     *  committments and proofs) or a raw [[BytesLike]] may
     *  be provided.
     *
     *  If raw [[BytesLike]] are provided, the [[kzg]] property **must**
     *  be already set. The blob will be correctly padded and the
     *  [[KzgLibrary]] will be used to compute the committment and
     *  proof for the blob.
     *
     *  A BLOb is a sequence of field elements, each of which must
     *  be within the BLS field modulo, so some additional processing
     *  may be required to encode arbitrary data to ensure each 32 byte
     *  field is within the valid range.
     *
     *  Setting this automatically populates [[blobVersionedHashes]],
     *  overwriting any existing values. Setting this to ``null``
     *  does **not** remove the [[blobVersionedHashes]], leaving them
     *  present.
     */
  }, {
    key: "blobs",
    get: function get() {
      if (_classPrivateFieldGet(_blobs2, this) == null) {
        return null;
      }
      return _classPrivateFieldGet(_blobs2, this).map(function (b) {
        return Object.assign({}, b);
      });
    },
    set: function set(_blobs) {
      if (_blobs == null) {
        _classPrivateFieldSet(_blobs2, this, null);
        return;
      }
      var blobs = [];
      var versionedHashes = [];
      for (var i = 0; i < _blobs.length; i++) {
        var blob = _blobs[i];
        if ((0, index_js_3.isBytesLike)(blob)) {
          (0, index_js_3.assert)(_classPrivateFieldGet(_kzg, this), "adding a raw blob requires a KZG library", "UNSUPPORTED_OPERATION", {
            operation: "set blobs()"
          });
          var data = (0, index_js_3.getBytes)(blob);
          (0, index_js_3.assertArgument)(data.length <= BLOB_SIZE, "blob is too large", "blobs[".concat(i, "]"), blob);
          // Pad blob if necessary
          if (data.length !== BLOB_SIZE) {
            var padded = new Uint8Array(BLOB_SIZE);
            padded.set(data);
            data = padded;
          }
          var commit = _classPrivateFieldGet(_kzg, this).blobToKzgCommitment(data);
          var proof = (0, index_js_3.hexlify)(_classPrivateFieldGet(_kzg, this).computeBlobKzgProof(data, commit));
          blobs.push({
            data: (0, index_js_3.hexlify)(data),
            commitment: (0, index_js_3.hexlify)(commit),
            proof: proof
          });
          versionedHashes.push(getVersionedHash(1, commit));
        } else {
          var _commit = (0, index_js_3.hexlify)(blob.commitment);
          blobs.push({
            data: (0, index_js_3.hexlify)(blob.data),
            commitment: _commit,
            proof: (0, index_js_3.hexlify)(blob.proof)
          });
          versionedHashes.push(getVersionedHash(1, _commit));
        }
      }
      _classPrivateFieldSet(_blobs2, this, blobs);
      _classPrivateFieldSet(_blobVersionedHashes, this, versionedHashes);
    }
  }, {
    key: "kzg",
    get: function get() {
      return _classPrivateFieldGet(_kzg, this);
    },
    set: function set(kzg) {
      _classPrivateFieldSet(_kzg, this, kzg);
    }
  }, {
    key: "hash",
    get: function get() {
      if (this.signature == null) {
        return null;
      }
      return (0, index_js_2.keccak256)(_assertClassBrand(_Transaction_brand, this, _getSerialized).call(this, true, false));
    }
    /**
     *  The pre-image hash of this transaction.
     *
     *  This is the digest that a [[Signer]] must sign to authorize
     *  this transaction.
     */
  }, {
    key: "unsignedHash",
    get: function get() {
      return (0, index_js_2.keccak256)(this.unsignedSerialized);
    }
    /**
     *  The sending address, if signed. Otherwise, ``null``.
     */
  }, {
    key: "from",
    get: function get() {
      if (this.signature == null) {
        return null;
      }
      return (0, address_js_1.recoverAddress)(this.unsignedHash, this.signature);
    }
    /**
     *  The public key of the sender, if signed. Otherwise, ``null``.
     */
  }, {
    key: "fromPublicKey",
    get: function get() {
      if (this.signature == null) {
        return null;
      }
      return index_js_2.SigningKey.recoverPublicKey(this.unsignedHash, this.signature);
    }
    /**
     *  Returns true if signed.
     *
     *  This provides a Type Guard that properties requiring a signed
     *  transaction are non-null.
     */
  }, {
    key: "isSigned",
    value: function isSigned() {
      return this.signature != null;
    }
  }, {
    key: "serialized",
    get:
    /**
     *  The serialized transaction.
     *
     *  This throws if the transaction is unsigned. For the pre-image,
     *  use [[unsignedSerialized]].
     */
    function get() {
      return _assertClassBrand(_Transaction_brand, this, _getSerialized).call(this, true, true);
    }
    /**
     *  The transaction pre-image.
     *
     *  The hash of this is the digest which needs to be signed to
     *  authorize this transaction.
     */
  }, {
    key: "unsignedSerialized",
    get: function get() {
      return _assertClassBrand(_Transaction_brand, this, _getSerialized).call(this, false, false);
    }
    /**
     *  Return the most "likely" type; currently the highest
     *  supported transaction type.
     */
  }, {
    key: "inferType",
    value: function inferType() {
      var types = this.inferTypes();
      // Prefer London (EIP-1559) over Cancun (BLOb)
      if (types.indexOf(2) >= 0) {
        return 2;
      }
      // Return the highest inferred type
      return types.pop();
    }
    /**
     *  Validates the explicit properties and returns a list of compatible
     *  transaction types.
     */
  }, {
    key: "inferTypes",
    value: function inferTypes() {
      // Checks that there are no conflicting properties set
      var hasGasPrice = this.gasPrice != null;
      var hasFee = this.maxFeePerGas != null || this.maxPriorityFeePerGas != null;
      var hasAccessList = this.accessList != null;
      var hasBlob = _classPrivateFieldGet(_maxFeePerBlobGas, this) != null || _classPrivateFieldGet(_blobVersionedHashes, this);
      //if (hasGasPrice && hasFee) {
      //    throw new Error("transaction cannot have gasPrice and maxFeePerGas");
      //}
      if (this.maxFeePerGas != null && this.maxPriorityFeePerGas != null) {
        (0, index_js_3.assert)(this.maxFeePerGas >= this.maxPriorityFeePerGas, "priorityFee cannot be more than maxFee", "BAD_DATA", {
          value: this
        });
      }
      //if (this.type === 2 && hasGasPrice) {
      //    throw new Error("eip-1559 transaction cannot have gasPrice");
      //}
      (0, index_js_3.assert)(!hasFee || this.type !== 0 && this.type !== 1, "transaction type cannot have maxFeePerGas or maxPriorityFeePerGas", "BAD_DATA", {
        value: this
      });
      (0, index_js_3.assert)(this.type !== 0 || !hasAccessList, "legacy transaction cannot have accessList", "BAD_DATA", {
        value: this
      });
      var types = [];
      // Explicit type
      if (this.type != null) {
        types.push(this.type);
      } else {
        if (hasFee) {
          types.push(2);
        } else if (hasGasPrice) {
          types.push(1);
          if (!hasAccessList) {
            types.push(0);
          }
        } else if (hasAccessList) {
          types.push(1);
          types.push(2);
        } else if (hasBlob && this.to) {
          types.push(3);
        } else {
          types.push(0);
          types.push(1);
          types.push(2);
          types.push(3);
        }
      }
      types.sort();
      return types;
    }
    /**
     *  Returns true if this transaction is a legacy transaction (i.e.
     *  ``type === 0``).
     *
     *  This provides a Type Guard that the related properties are
     *  non-null.
     */
  }, {
    key: "isLegacy",
    value: function isLegacy() {
      return this.type === 0;
    }
    /**
     *  Returns true if this transaction is berlin hardform transaction (i.e.
     *  ``type === 1``).
     *
     *  This provides a Type Guard that the related properties are
     *  non-null.
     */
  }, {
    key: "isBerlin",
    value: function isBerlin() {
      return this.type === 1;
    }
    /**
     *  Returns true if this transaction is london hardform transaction (i.e.
     *  ``type === 2``).
     *
     *  This provides a Type Guard that the related properties are
     *  non-null.
     */
  }, {
    key: "isLondon",
    value: function isLondon() {
      return this.type === 2;
    }
    /**
     *  Returns true if this transaction is an [[link-eip-4844]] BLOB
     *  transaction.
     *
     *  This provides a Type Guard that the related properties are
     *  non-null.
     */
  }, {
    key: "isCancun",
    value: function isCancun() {
      return this.type === 3;
    }
    /**
     *  Create a copy of this transaciton.
     */
  }, {
    key: "clone",
    value: function clone() {
      return Transaction.from(this);
    }
    /**
     *  Return a JSON-friendly object.
     */
  }, {
    key: "toJSON",
    value: function toJSON() {
      var s = function s(v) {
        if (v == null) {
          return null;
        }
        return v.toString();
      };
      return {
        type: this.type,
        to: this.to,
        //            from: this.from,
        data: this.data,
        nonce: this.nonce,
        gasLimit: s(this.gasLimit),
        gasPrice: s(this.gasPrice),
        maxPriorityFeePerGas: s(this.maxPriorityFeePerGas),
        maxFeePerGas: s(this.maxFeePerGas),
        value: s(this.value),
        chainId: s(this.chainId),
        sig: this.signature ? this.signature.toJSON() : null,
        accessList: this.accessList
      };
    }
    /**
     *  Create a **Transaction** from a serialized transaction or a
     *  Transaction-like object.
     */
  }], [{
    key: "from",
    value: function from(tx) {
      if (tx == null) {
        return new Transaction();
      }
      if (typeof tx === "string") {
        var payload = (0, index_js_3.getBytes)(tx);
        if (payload[0] >= 0x7f) {
          // @TODO: > vs >= ??
          return Transaction.from(_parseLegacy(payload));
        }
        switch (payload[0]) {
          case 1:
            return Transaction.from(_parseEip2930(payload));
          case 2:
            return Transaction.from(_parseEip1559(payload));
          case 3:
            return Transaction.from(_parseEip4844(payload));
        }
        (0, index_js_3.assert)(false, "unsupported transaction type", "UNSUPPORTED_OPERATION", {
          operation: "from"
        });
      }
      var result = new Transaction();
      if (tx.type != null) {
        result.type = tx.type;
      }
      if (tx.to != null) {
        result.to = tx.to;
      }
      if (tx.nonce != null) {
        result.nonce = tx.nonce;
      }
      if (tx.gasLimit != null) {
        result.gasLimit = tx.gasLimit;
      }
      if (tx.gasPrice != null) {
        result.gasPrice = tx.gasPrice;
      }
      if (tx.maxPriorityFeePerGas != null) {
        result.maxPriorityFeePerGas = tx.maxPriorityFeePerGas;
      }
      if (tx.maxFeePerGas != null) {
        result.maxFeePerGas = tx.maxFeePerGas;
      }
      if (tx.maxFeePerBlobGas != null) {
        result.maxFeePerBlobGas = tx.maxFeePerBlobGas;
      }
      if (tx.data != null) {
        result.data = tx.data;
      }
      if (tx.value != null) {
        result.value = tx.value;
      }
      if (tx.chainId != null) {
        result.chainId = tx.chainId;
      }
      if (tx.signature != null) {
        result.signature = index_js_2.Signature.from(tx.signature);
      }
      if (tx.accessList != null) {
        result.accessList = tx.accessList;
      }
      // This will get overwritten by blobs, if present
      if (tx.blobVersionedHashes != null) {
        result.blobVersionedHashes = tx.blobVersionedHashes;
      }
      // Make sure we assign the kzg before assigning blobs, which
      // require the library in the event raw blob data is provided.
      if (tx.kzg != null) {
        result.kzg = tx.kzg;
      }
      if (tx.blobs != null) {
        result.blobs = tx.blobs;
      }
      if (tx.hash != null) {
        (0, index_js_3.assertArgument)(result.isSigned(), "unsigned transaction cannot define '.hash'", "tx", tx);
        (0, index_js_3.assertArgument)(result.hash === tx.hash, "hash mismatch", "tx", tx);
      }
      if (tx.from != null) {
        (0, index_js_3.assertArgument)(result.isSigned(), "unsigned transaction cannot define '.from'", "tx", tx);
        (0, index_js_3.assertArgument)(result.from.toLowerCase() === (tx.from || "").toLowerCase(), "from mismatch", "tx", tx);
      }
      return result;
    }
  }]);
}();
function _getSerialized(signed, sidecar) {
  (0, index_js_3.assert)(!signed || this.signature != null, "cannot serialize unsigned transaction; maybe you meant .unsignedSerialized", "UNSUPPORTED_OPERATION", {
    operation: ".serialized"
  });
  var sig = signed ? this.signature : null;
  switch (this.inferType()) {
    case 0:
      return _serializeLegacy(this, sig);
    case 1:
      return _serializeEip2930(this, sig);
    case 2:
      return _serializeEip1559(this, sig);
    case 3:
      return _serializeEip4844(this, sig, sidecar ? this.blobs : null);
  }
  (0, index_js_3.assert)(false, "unsupported transaction type", "UNSUPPORTED_OPERATION", {
    operation: ".serialized"
  });
}
exports.Transaction = Transaction;

},{"../address/index.js":207,"../constants/addresses.js":208,"../crypto/index.js":219,"../utils/index.js":276,"./accesslist.js":264,"./address.js":265}],268:[function(require,module,exports){
"use strict";

/**
 *  The [Base58 Encoding](link-base58) scheme allows a **numeric** value
 *  to be encoded as a compact string using a radix of 58 using only
 *  alpha-numeric characters. Confusingly similar characters are omitted
 *  (i.e. ``"l0O"``).
 *
 *  Note that Base58 encodes a **numeric** value, not arbitrary bytes,
 *  since any zero-bytes on the left would get removed. To mitigate this
 *  issue most schemes that use Base58 choose specific high-order values
 *  to ensure non-zero prefixes.
 *
 *  @_subsection: api/utils:Base58 Encoding [about-base58]
 */
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.decodeBase58 = exports.encodeBase58 = void 0;
var data_js_1 = require("./data.js");
var errors_js_1 = require("./errors.js");
var maths_js_1 = require("./maths.js");
var Alphabet = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var Lookup = null;
function getAlpha(letter) {
  if (Lookup == null) {
    Lookup = {};
    for (var i = 0; i < Alphabet.length; i++) {
      Lookup[Alphabet[i]] = BigInt(i);
    }
  }
  var result = Lookup[letter];
  (0, errors_js_1.assertArgument)(result != null, "invalid base58 value", "letter", letter);
  return result;
}
var BN_0 = BigInt(0);
var BN_58 = BigInt(58);
/**
 *  Encode %%value%% as a Base58-encoded string.
 */
function encodeBase58(_value) {
  var bytes = (0, data_js_1.getBytes)(_value);
  var value = (0, maths_js_1.toBigInt)(bytes);
  var result = "";
  while (value) {
    result = Alphabet[Number(value % BN_58)] + result;
    value /= BN_58;
  }
  // Account for leading padding zeros
  for (var i = 0; i < bytes.length; i++) {
    if (bytes[i]) {
      break;
    }
    result = Alphabet[0] + result;
  }
  return result;
}
exports.encodeBase58 = encodeBase58;
/**
 *  Decode the Base58-encoded %%value%%.
 */
function decodeBase58(value) {
  var result = BN_0;
  for (var i = 0; i < value.length; i++) {
    result *= BN_58;
    result += getAlpha(value[i]);
  }
  return result;
}
exports.decodeBase58 = decodeBase58;

},{"./data.js":270,"./errors.js":271,"./maths.js":277}],269:[function(require,module,exports){
"use strict";

// utils/base64-browser
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.encodeBase64 = exports.decodeBase64 = void 0;
var data_js_1 = require("./data.js");
function decodeBase64(textData) {
  textData = atob(textData);
  var data = new Uint8Array(textData.length);
  for (var i = 0; i < textData.length; i++) {
    data[i] = textData.charCodeAt(i);
  }
  return (0, data_js_1.getBytes)(data);
}
exports.decodeBase64 = decodeBase64;
function encodeBase64(_data) {
  var data = (0, data_js_1.getBytes)(_data);
  var textData = "";
  for (var i = 0; i < data.length; i++) {
    textData += String.fromCharCode(data[i]);
  }
  return btoa(textData);
}
exports.encodeBase64 = encodeBase64;

},{"./data.js":270}],270:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.zeroPadBytes = exports.zeroPadValue = exports.stripZerosLeft = exports.dataSlice = exports.dataLength = exports.concat = exports.hexlify = exports.isBytesLike = exports.isHexString = exports.getBytesCopy = exports.getBytes = void 0;
/**
 *  Some data helpers.
 *
 *
 *  @_subsection api/utils:Data Helpers  [about-data]
 */
var errors_js_1 = require("./errors.js");
function _getBytes(value, name, copy) {
  if (value instanceof Uint8Array) {
    if (copy) {
      return new Uint8Array(value);
    }
    return value;
  }
  if (typeof value === "string" && value.match(/^0x(?:[0-9a-f][0-9a-f])*$/i)) {
    var result = new Uint8Array((value.length - 2) / 2);
    var offset = 2;
    for (var i = 0; i < result.length; i++) {
      result[i] = parseInt(value.substring(offset, offset + 2), 16);
      offset += 2;
    }
    return result;
  }
  (0, errors_js_1.assertArgument)(false, "invalid BytesLike value", name || "value", value);
}
/**
 *  Get a typed Uint8Array for %%value%%. If already a Uint8Array
 *  the original %%value%% is returned; if a copy is required use
 *  [[getBytesCopy]].
 *
 *  @see: getBytesCopy
 */
function getBytes(value, name) {
  return _getBytes(value, name, false);
}
exports.getBytes = getBytes;
/**
 *  Get a typed Uint8Array for %%value%%, creating a copy if necessary
 *  to prevent any modifications of the returned value from being
 *  reflected elsewhere.
 *
 *  @see: getBytes
 */
function getBytesCopy(value, name) {
  return _getBytes(value, name, true);
}
exports.getBytesCopy = getBytesCopy;
/**
 *  Returns true if %%value%% is a valid [[HexString]].
 *
 *  If %%length%% is ``true`` or a //number//, it also checks that
 *  %%value%% is a valid [[DataHexString]] of %%length%% (if a //number//)
 *  bytes of data (e.g. ``0x1234`` is 2 bytes).
 */
function isHexString(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (typeof length === "number" && value.length !== 2 + 2 * length) {
    return false;
  }
  if (length === true && value.length % 2 !== 0) {
    return false;
  }
  return true;
}
exports.isHexString = isHexString;
/**
 *  Returns true if %%value%% is a valid representation of arbitrary
 *  data (i.e. a valid [[DataHexString]] or a Uint8Array).
 */
function isBytesLike(value) {
  return isHexString(value, true) || value instanceof Uint8Array;
}
exports.isBytesLike = isBytesLike;
var HexCharacters = "0123456789abcdef";
/**
 *  Returns a [[DataHexString]] representation of %%data%%.
 */
function hexlify(data) {
  var bytes = getBytes(data);
  var result = "0x";
  for (var i = 0; i < bytes.length; i++) {
    var v = bytes[i];
    result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];
  }
  return result;
}
exports.hexlify = hexlify;
/**
 *  Returns a [[DataHexString]] by concatenating all values
 *  within %%data%%.
 */
function concat(datas) {
  return "0x" + datas.map(function (d) {
    return hexlify(d).substring(2);
  }).join("");
}
exports.concat = concat;
/**
 *  Returns the length of %%data%%, in bytes.
 */
function dataLength(data) {
  if (isHexString(data, true)) {
    return (data.length - 2) / 2;
  }
  return getBytes(data).length;
}
exports.dataLength = dataLength;
/**
 *  Returns a [[DataHexString]] by slicing %%data%% from the %%start%%
 *  offset to the %%end%% offset.
 *
 *  By default %%start%% is 0 and %%end%% is the length of %%data%%.
 */
function dataSlice(data, start, end) {
  var bytes = getBytes(data);
  if (end != null && end > bytes.length) {
    (0, errors_js_1.assert)(false, "cannot slice beyond data bounds", "BUFFER_OVERRUN", {
      buffer: bytes,
      length: bytes.length,
      offset: end
    });
  }
  return hexlify(bytes.slice(start == null ? 0 : start, end == null ? bytes.length : end));
}
exports.dataSlice = dataSlice;
/**
 *  Return the [[DataHexString]] result by stripping all **leading**
 ** zero bytes from %%data%%.
 */
function stripZerosLeft(data) {
  var bytes = hexlify(data).substring(2);
  while (bytes.startsWith("00")) {
    bytes = bytes.substring(2);
  }
  return "0x" + bytes;
}
exports.stripZerosLeft = stripZerosLeft;
function zeroPad(data, length, left) {
  var bytes = getBytes(data);
  (0, errors_js_1.assert)(length >= bytes.length, "padding exceeds data length", "BUFFER_OVERRUN", {
    buffer: new Uint8Array(bytes),
    length: length,
    offset: length + 1
  });
  var result = new Uint8Array(length);
  result.fill(0);
  if (left) {
    result.set(bytes, length - bytes.length);
  } else {
    result.set(bytes, 0);
  }
  return hexlify(result);
}
/**
 *  Return the [[DataHexString]] of %%data%% padded on the **left**
 *  to %%length%% bytes.
 *
 *  If %%data%% already exceeds %%length%%, a [[BufferOverrunError]] is
 *  thrown.
 *
 *  This pads data the same as **values** are in Solidity
 *  (e.g. ``uint128``).
 */
function zeroPadValue(data, length) {
  return zeroPad(data, length, true);
}
exports.zeroPadValue = zeroPadValue;
/**
 *  Return the [[DataHexString]] of %%data%% padded on the **right**
 *  to %%length%% bytes.
 *
 *  If %%data%% already exceeds %%length%%, a [[BufferOverrunError]] is
 *  thrown.
 *
 *  This pads data the same as **bytes** are in Solidity
 *  (e.g. ``bytes16``).
 */
function zeroPadBytes(data, length) {
  return zeroPad(data, length, false);
}
exports.zeroPadBytes = zeroPadBytes;

},{"./errors.js":271}],271:[function(require,module,exports){
"use strict";

/**
 *  All errors in ethers include properties to ensure they are both
 *  human-readable (i.e. ``.message``) and machine-readable (i.e. ``.code``).
 *
 *  The [[isError]] function can be used to check the error ``code`` and
 *  provide a type guard for the properties present on that error interface.
 *
 *  @_section: api/utils/errors:Errors  [about-errors]
 */
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.assertPrivate = exports.assertNormalize = exports.assertArgumentCount = exports.assertArgument = exports.assert = exports.makeError = exports.isCallException = exports.isError = void 0;
var _version_js_1 = require("../_version.js");
var properties_js_1 = require("./properties.js");
function stringify(value) {
  if (value == null) {
    return "null";
  }
  if (Array.isArray(value)) {
    return "[ " + value.map(stringify).join(", ") + " ]";
  }
  if (value instanceof Uint8Array) {
    var HEX = "0123456789abcdef";
    var result = "0x";
    for (var i = 0; i < value.length; i++) {
      result += HEX[value[i] >> 4];
      result += HEX[value[i] & 0xf];
    }
    return result;
  }
  if (_typeof(value) === "object" && typeof value.toJSON === "function") {
    return stringify(value.toJSON());
  }
  switch (_typeof(value)) {
    case "boolean":
    case "symbol":
      return value.toString();
    case "bigint":
      return BigInt(value).toString();
    case "number":
      return value.toString();
    case "string":
      return JSON.stringify(value);
    case "object":
      {
        var keys = Object.keys(value);
        keys.sort();
        return "{ " + keys.map(function (k) {
          return "".concat(stringify(k), ": ").concat(stringify(value[k]));
        }).join(", ") + " }";
      }
  }
  return "[ COULD NOT SERIALIZE ]";
}
/**
 *  Returns true if the %%error%% matches an error thrown by ethers
 *  that matches the error %%code%%.
 *
 *  In TypeScript environments, this can be used to check that %%error%%
 *  matches an EthersError type, which means the expected properties will
 *  be set.
 *
 *  @See [ErrorCodes](api:ErrorCode)
 *  @example
 *    try {
 *      // code....
 *    } catch (e) {
 *      if (isError(e, "CALL_EXCEPTION")) {
 *          // The Type Guard has validated this object
 *          console.log(e.data);
 *      }
 *    }
 */
function isError(error, code) {
  return error && error.code === code;
}
exports.isError = isError;
/**
 *  Returns true if %%error%% is a [[CallExceptionError].
 */
function isCallException(error) {
  return isError(error, "CALL_EXCEPTION");
}
exports.isCallException = isCallException;
/**
 *  Returns a new Error configured to the format ethers emits errors, with
 *  the %%message%%, [[api:ErrorCode]] %%code%% and additional properties
 *  for the corresponding EthersError.
 *
 *  Each error in ethers includes the version of ethers, a
 *  machine-readable [[ErrorCode]], and depending on %%code%%, additional
 *  required properties. The error message will also include the %%message%%,
 *  ethers version, %%code%% and all additional properties, serialized.
 */
function makeError(message, code, info) {
  var shortMessage = message;
  {
    var details = [];
    if (info) {
      if ("message" in info || "code" in info || "name" in info) {
        throw new Error("value will overwrite populated values: ".concat(stringify(info)));
      }
      for (var key in info) {
        if (key === "shortMessage") {
          continue;
        }
        var value = info[key];
        //                try {
        details.push(key + "=" + stringify(value));
        //                } catch (error: any) {
        //                console.log("MMM", error.message);
        //                    details.push(key + "=[could not serialize object]");
        //                }
      }
    }
    details.push("code=".concat(code));
    details.push("version=".concat(_version_js_1.version));
    if (details.length) {
      message += " (" + details.join(", ") + ")";
    }
  }
  var error;
  switch (code) {
    case "INVALID_ARGUMENT":
      error = new TypeError(message);
      break;
    case "NUMERIC_FAULT":
    case "BUFFER_OVERRUN":
      error = new RangeError(message);
      break;
    default:
      error = new Error(message);
  }
  (0, properties_js_1.defineProperties)(error, {
    code: code
  });
  if (info) {
    Object.assign(error, info);
  }
  if (error.shortMessage == null) {
    (0, properties_js_1.defineProperties)(error, {
      shortMessage: shortMessage
    });
  }
  return error;
}
exports.makeError = makeError;
/**
 *  Throws an EthersError with %%message%%, %%code%% and additional error
 *  %%info%% when %%check%% is falsish..
 *
 *  @see [[api:makeError]]
 */
function assert(check, message, code, info) {
  if (!check) {
    throw makeError(message, code, info);
  }
}
exports.assert = assert;
/**
 *  A simple helper to simply ensuring provided arguments match expected
 *  constraints, throwing if not.
 *
 *  In TypeScript environments, the %%check%% has been asserted true, so
 *  any further code does not need additional compile-time checks.
 */
function assertArgument(check, message, name, value) {
  assert(check, message, "INVALID_ARGUMENT", {
    argument: name,
    value: value
  });
}
exports.assertArgument = assertArgument;
function assertArgumentCount(count, expectedCount, message) {
  if (message == null) {
    message = "";
  }
  if (message) {
    message = ": " + message;
  }
  assert(count >= expectedCount, "missing arguemnt" + message, "MISSING_ARGUMENT", {
    count: count,
    expectedCount: expectedCount
  });
  assert(count <= expectedCount, "too many arguments" + message, "UNEXPECTED_ARGUMENT", {
    count: count,
    expectedCount: expectedCount
  });
}
exports.assertArgumentCount = assertArgumentCount;
var _normalizeForms = ["NFD", "NFC", "NFKD", "NFKC"].reduce(function (accum, form) {
  try {
    // General test for normalize
    /* c8 ignore start */
    if ("test".normalize(form) !== "test") {
      throw new Error("bad");
    }
    ;
    /* c8 ignore stop */
    if (form === "NFD") {
      var check = String.fromCharCode(0xe9).normalize("NFD");
      var expected = String.fromCharCode(0x65, 0x0301);
      /* c8 ignore start */
      if (check !== expected) {
        throw new Error("broken");
      }
      /* c8 ignore stop */
    }
    accum.push(form);
  } catch (error) {}
  return accum;
}, []);
/**
 *  Throws if the normalization %%form%% is not supported.
 */
function assertNormalize(form) {
  assert(_normalizeForms.indexOf(form) >= 0, "platform missing String.prototype.normalize", "UNSUPPORTED_OPERATION", {
    operation: "String.prototype.normalize",
    info: {
      form: form
    }
  });
}
exports.assertNormalize = assertNormalize;
/**
 *  Many classes use file-scoped values to guard the constructor,
 *  making it effectively private. This facilitates that pattern
 *  by ensuring the %%givenGaurd%% matches the file-scoped %%guard%%,
 *  throwing if not, indicating the %%className%% if provided.
 */
function assertPrivate(givenGuard, guard, className) {
  if (className == null) {
    className = "";
  }
  if (givenGuard !== guard) {
    var method = className,
      operation = "new";
    if (className) {
      method += ".";
      operation += " " + className;
    }
    assert(false, "private constructor; use ".concat(method, "from* methods"), "UNSUPPORTED_OPERATION", {
      operation: operation
    });
  }
}
exports.assertPrivate = assertPrivate;

},{"../_version.js":186,"./properties.js":278}],272:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EventPayload = void 0;
/**
 *  Events allow for applications to use the observer pattern, which
 *  allows subscribing and publishing events, outside the normal
 *  execution paths.
 *
 *  @_section api/utils/events:Events  [about-events]
 */
var properties_js_1 = require("./properties.js");
/**
 *  When an [[EventEmitterable]] triggers a [[Listener]], the
 *  callback always ahas one additional argument passed, which is
 *  an **EventPayload**.
 */
var _listener = /*#__PURE__*/new WeakMap();
var EventPayload = /*#__PURE__*/function () {
  /**
   *  Create a new **EventPayload** for %%emitter%% with
   *  the %%listener%% and for %%filter%%.
   */
  function EventPayload(emitter, listener, filter) {
    _classCallCheck(this, EventPayload);
    /**
     *  The event filter.
     */
    _defineProperty(this, "filter", void 0);
    /**
     *  The **EventEmitterable**.
     */
    _defineProperty(this, "emitter", void 0);
    _classPrivateFieldInitSpec(this, _listener, void 0);
    _classPrivateFieldSet(_listener, this, listener);
    (0, properties_js_1.defineProperties)(this, {
      emitter: emitter,
      filter: filter
    });
  }
  /**
   *  Unregister the triggered listener for future events.
   */
  return _createClass(EventPayload, [{
    key: "removeListener",
    value: (function () {
      var _removeListener = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              if (!(_classPrivateFieldGet(_listener, this) == null)) {
                _context.next = 2;
                break;
              }
              return _context.abrupt("return");
            case 2:
              _context.next = 4;
              return this.emitter.off(this.filter, _classPrivateFieldGet(_listener, this));
            case 4:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function removeListener() {
        return _removeListener.apply(this, arguments);
      }
      return removeListener;
    }())
  }]);
}();
exports.EventPayload = EventPayload;

},{"./properties.js":278}],273:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FetchResponse = exports.FetchRequest = exports.FetchCancelSignal = void 0;
/**
 *  Fetching content from the web is environment-specific, so Ethers
 *  provides an abstraction that each environment can implement to provide
 *  this service.
 *
 *  On [Node.js](link-node), the ``http`` and ``https`` libs are used to
 *  create a request object, register event listeners and process data
 *  and populate the [[FetchResponse]].
 *
 *  In a browser, the [DOM fetch](link-js-fetch) is used, and the resulting
 *  ``Promise`` is waited on to retrieve the payload.
 *
 *  The [[FetchRequest]] is responsible for handling many common situations,
 *  such as redirects, server throttling, authentication, etc.
 *
 *  It also handles common gateways, such as IPFS and data URIs.
 *
 *  @_section api/utils/fetching:Fetching Web Content  [about-fetch]
 */
var base64_js_1 = require("./base64.js");
var data_js_1 = require("./data.js");
var errors_js_1 = require("./errors.js");
var properties_js_1 = require("./properties.js");
var utf8_js_1 = require("./utf8.js");
var geturl_js_1 = require("./geturl.js");
var MAX_ATTEMPTS = 12;
var SLOT_INTERVAL = 250;
// The global FetchGetUrlFunc implementation.
var defaultGetUrlFunc = (0, geturl_js_1.createGetUrl)();
var reData = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i");
var reIpfs = new RegExp("^ipfs:/\/(ipfs/)?(.*)$", "i");
// If locked, new Gateways cannot be added
var locked = false;
// https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URLs
function dataGatewayFunc(_x, _x2) {
  return _dataGatewayFunc.apply(this, arguments);
}
/**
 *  Returns a [[FetchGatewayFunc]] for fetching content from a standard
 *  IPFS gateway hosted at %%baseUrl%%.
 */
function _dataGatewayFunc() {
  _dataGatewayFunc = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(url, signal) {
    var match;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          _context2.prev = 0;
          match = url.match(reData);
          if (match) {
            _context2.next = 4;
            break;
          }
          throw new Error("invalid data");
        case 4:
          return _context2.abrupt("return", new FetchResponse(200, "OK", {
            "content-type": match[1] || "text/plain"
          }, match[2] ? (0, base64_js_1.decodeBase64)(match[3]) : unpercent(match[3])));
        case 7:
          _context2.prev = 7;
          _context2.t0 = _context2["catch"](0);
          return _context2.abrupt("return", new FetchResponse(599, "BAD REQUEST (invalid data: URI)", {}, null, new FetchRequest(url)));
        case 10:
        case "end":
          return _context2.stop();
      }
    }, _callee2, null, [[0, 7]]);
  }));
  return _dataGatewayFunc.apply(this, arguments);
}
function getIpfsGatewayFunc(baseUrl) {
  function gatewayIpfs(_x3, _x4) {
    return _gatewayIpfs.apply(this, arguments);
  }
  function _gatewayIpfs() {
    _gatewayIpfs = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(url, signal) {
      var match;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            _context.prev = 0;
            match = url.match(reIpfs);
            if (match) {
              _context.next = 4;
              break;
            }
            throw new Error("invalid link");
          case 4:
            return _context.abrupt("return", new FetchRequest("".concat(baseUrl).concat(match[2])));
          case 7:
            _context.prev = 7;
            _context.t0 = _context["catch"](0);
            return _context.abrupt("return", new FetchResponse(599, "BAD REQUEST (invalid IPFS URI)", {}, null, new FetchRequest(url)));
          case 10:
          case "end":
            return _context.stop();
        }
      }, _callee, null, [[0, 7]]);
    }));
    return _gatewayIpfs.apply(this, arguments);
  }
  return gatewayIpfs;
}
var Gateways = {
  "data": dataGatewayFunc,
  "ipfs": getIpfsGatewayFunc("https:/\/gateway.ipfs.io/ipfs/")
};
var fetchSignals = new WeakMap();
/**
 *  @_ignore
 */
var _listeners = /*#__PURE__*/new WeakMap();
var _cancelled = /*#__PURE__*/new WeakMap();
var FetchCancelSignal = /*#__PURE__*/function () {
  function FetchCancelSignal(request) {
    var _this = this;
    _classCallCheck(this, FetchCancelSignal);
    _classPrivateFieldInitSpec(this, _listeners, void 0);
    _classPrivateFieldInitSpec(this, _cancelled, void 0);
    _classPrivateFieldSet(_listeners, this, []);
    _classPrivateFieldSet(_cancelled, this, false);
    fetchSignals.set(request, function () {
      if (_classPrivateFieldGet(_cancelled, _this)) {
        return;
      }
      _classPrivateFieldSet(_cancelled, _this, true);
      var _iterator = _createForOfIteratorHelper(_classPrivateFieldGet(_listeners, _this)),
        _step;
      try {
        var _loop = function _loop() {
          var listener = _step.value;
          setTimeout(function () {
            listener();
          }, 0);
        };
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          _loop();
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      _classPrivateFieldSet(_listeners, _this, []);
    });
  }
  return _createClass(FetchCancelSignal, [{
    key: "addListener",
    value: function addListener(listener) {
      (0, errors_js_1.assert)(!_classPrivateFieldGet(_cancelled, this), "singal already cancelled", "UNSUPPORTED_OPERATION", {
        operation: "fetchCancelSignal.addCancelListener"
      });
      _classPrivateFieldGet(_listeners, this).push(listener);
    }
  }, {
    key: "cancelled",
    get: function get() {
      return _classPrivateFieldGet(_cancelled, this);
    }
  }, {
    key: "checkSignal",
    value: function checkSignal() {
      (0, errors_js_1.assert)(!this.cancelled, "cancelled", "CANCELLED", {});
    }
  }]);
}();
exports.FetchCancelSignal = FetchCancelSignal;
// Check the signal, throwing if it is cancelled
function checkSignal(signal) {
  if (signal == null) {
    throw new Error("missing signal; should not happen");
  }
  signal.checkSignal();
  return signal;
}
/**
 *  Represents a request for a resource using a URI.
 *
 *  By default, the supported schemes are ``HTTP``, ``HTTPS``, ``data:``,
 *  and ``IPFS:``.
 *
 *  Additional schemes can be added globally using [[registerGateway]].
 *
 *  @example:
 *    req = new FetchRequest("https://www.ricmoo.com")
 *    resp = await req.send()
 *    resp.body.length
 *    //_result:
 */
var _allowInsecure = /*#__PURE__*/new WeakMap();
var _gzip = /*#__PURE__*/new WeakMap();
var _headers = /*#__PURE__*/new WeakMap();
var _method = /*#__PURE__*/new WeakMap();
var _timeout = /*#__PURE__*/new WeakMap();
var _url = /*#__PURE__*/new WeakMap();
var _body = /*#__PURE__*/new WeakMap();
var _bodyType = /*#__PURE__*/new WeakMap();
var _creds = /*#__PURE__*/new WeakMap();
var _preflight = /*#__PURE__*/new WeakMap();
var _process = /*#__PURE__*/new WeakMap();
var _retry = /*#__PURE__*/new WeakMap();
var _signal = /*#__PURE__*/new WeakMap();
var _throttle = /*#__PURE__*/new WeakMap();
var _getUrlFunc = /*#__PURE__*/new WeakMap();
var _FetchRequest_brand = /*#__PURE__*/new WeakSet();
var FetchRequest = /*#__PURE__*/function () {
  /**
   *  Create a new FetchRequest instance with default values.
   *
   *  Once created, each property may be set before issuing a
   *  ``.send()`` to make the request.
   */
  function FetchRequest(url) {
    _classCallCheck(this, FetchRequest);
    _classPrivateMethodInitSpec(this, _FetchRequest_brand);
    _classPrivateFieldInitSpec(this, _allowInsecure, void 0);
    _classPrivateFieldInitSpec(this, _gzip, void 0);
    _classPrivateFieldInitSpec(this, _headers, void 0);
    _classPrivateFieldInitSpec(this, _method, void 0);
    _classPrivateFieldInitSpec(this, _timeout, void 0);
    _classPrivateFieldInitSpec(this, _url, void 0);
    _classPrivateFieldInitSpec(this, _body, void 0);
    _classPrivateFieldInitSpec(this, _bodyType, void 0);
    _classPrivateFieldInitSpec(this, _creds, void 0);
    // Hooks
    _classPrivateFieldInitSpec(this, _preflight, void 0);
    _classPrivateFieldInitSpec(this, _process, void 0);
    _classPrivateFieldInitSpec(this, _retry, void 0);
    _classPrivateFieldInitSpec(this, _signal, void 0);
    _classPrivateFieldInitSpec(this, _throttle, void 0);
    _classPrivateFieldInitSpec(this, _getUrlFunc, void 0);
    _classPrivateFieldSet(_url, this, String(url));
    _classPrivateFieldSet(_allowInsecure, this, false);
    _classPrivateFieldSet(_gzip, this, true);
    _classPrivateFieldSet(_headers, this, {});
    _classPrivateFieldSet(_method, this, "");
    _classPrivateFieldSet(_timeout, this, 300000);
    _classPrivateFieldSet(_throttle, this, {
      slotInterval: SLOT_INTERVAL,
      maxAttempts: MAX_ATTEMPTS
    });
    _classPrivateFieldSet(_getUrlFunc, this, null);
  }
  return _createClass(FetchRequest, [{
    key: "url",
    get:
    /**
     *  The fetch URL to request.
     */
    function get() {
      return _classPrivateFieldGet(_url, this);
    },
    set: function set(url) {
      _classPrivateFieldSet(_url, this, String(url));
    }
    /**
     *  The fetch body, if any, to send as the request body. //(default: null)//
     *
     *  When setting a body, the intrinsic ``Content-Type`` is automatically
     *  set and will be used if **not overridden** by setting a custom
     *  header.
     *
     *  If %%body%% is null, the body is cleared (along with the
     *  intrinsic ``Content-Type``).
     *
     *  If %%body%% is a string, the intrinsic ``Content-Type`` is set to
     *  ``text/plain``.
     *
     *  If %%body%% is a Uint8Array, the intrinsic ``Content-Type`` is set to
     *  ``application/octet-stream``.
     *
     *  If %%body%% is any other object, the intrinsic ``Content-Type`` is
     *  set to ``application/json``.
     */
  }, {
    key: "body",
    get: function get() {
      if (_classPrivateFieldGet(_body, this) == null) {
        return null;
      }
      return new Uint8Array(_classPrivateFieldGet(_body, this));
    },
    set: function set(body) {
      if (body == null) {
        _classPrivateFieldSet(_body, this, undefined);
        _classPrivateFieldSet(_bodyType, this, undefined);
      } else if (typeof body === "string") {
        _classPrivateFieldSet(_body, this, (0, utf8_js_1.toUtf8Bytes)(body));
        _classPrivateFieldSet(_bodyType, this, "text/plain");
      } else if (body instanceof Uint8Array) {
        _classPrivateFieldSet(_body, this, body);
        _classPrivateFieldSet(_bodyType, this, "application/octet-stream");
      } else if (_typeof(body) === "object") {
        _classPrivateFieldSet(_body, this, (0, utf8_js_1.toUtf8Bytes)(JSON.stringify(body)));
        _classPrivateFieldSet(_bodyType, this, "application/json");
      } else {
        throw new Error("invalid body");
      }
    }
    /**
     *  Returns true if the request has a body.
     */
  }, {
    key: "hasBody",
    value: function hasBody() {
      return _classPrivateFieldGet(_body, this) != null;
    }
    /**
     *  The HTTP method to use when requesting the URI. If no method
     *  has been explicitly set, then ``GET`` is used if the body is
     *  null and ``POST`` otherwise.
     */
  }, {
    key: "method",
    get: function get() {
      if (_classPrivateFieldGet(_method, this)) {
        return _classPrivateFieldGet(_method, this);
      }
      if (this.hasBody()) {
        return "POST";
      }
      return "GET";
    },
    set: function set(method) {
      if (method == null) {
        method = "";
      }
      _classPrivateFieldSet(_method, this, String(method).toUpperCase());
    }
    /**
     *  The headers that will be used when requesting the URI. All
     *  keys are lower-case.
     *
     *  This object is a copy, so any changes will **NOT** be reflected
     *  in the ``FetchRequest``.
     *
     *  To set a header entry, use the ``setHeader`` method.
     */
  }, {
    key: "headers",
    get: function get() {
      var headers = Object.assign({}, _classPrivateFieldGet(_headers, this));
      if (_classPrivateFieldGet(_creds, this)) {
        headers["authorization"] = "Basic ".concat((0, base64_js_1.encodeBase64)((0, utf8_js_1.toUtf8Bytes)(_classPrivateFieldGet(_creds, this))));
      }
      ;
      if (this.allowGzip) {
        headers["accept-encoding"] = "gzip";
      }
      if (headers["content-type"] == null && _classPrivateFieldGet(_bodyType, this)) {
        headers["content-type"] = _classPrivateFieldGet(_bodyType, this);
      }
      if (this.body) {
        headers["content-length"] = String(this.body.length);
      }
      return headers;
    }
    /**
     *  Get the header for %%key%%, ignoring case.
     */
  }, {
    key: "getHeader",
    value: function getHeader(key) {
      return this.headers[key.toLowerCase()];
    }
    /**
     *  Set the header for %%key%% to %%value%%. All values are coerced
     *  to a string.
     */
  }, {
    key: "setHeader",
    value: function setHeader(key, value) {
      _classPrivateFieldGet(_headers, this)[String(key).toLowerCase()] = String(value);
    }
    /**
     *  Clear all headers, resetting all intrinsic headers.
     */
  }, {
    key: "clearHeaders",
    value: function clearHeaders() {
      _classPrivateFieldSet(_headers, this, {});
    }
  }, {
    key: Symbol.iterator,
    value: function value() {
      var headers = this.headers;
      var keys = Object.keys(headers);
      var index = 0;
      return {
        next: function next() {
          if (index < keys.length) {
            var key = keys[index++];
            return {
              value: [key, headers[key]],
              done: false
            };
          }
          return {
            value: undefined,
            done: true
          };
        }
      };
    }
    /**
     *  The value that will be sent for the ``Authorization`` header.
     *
     *  To set the credentials, use the ``setCredentials`` method.
     */
  }, {
    key: "credentials",
    get: function get() {
      return _classPrivateFieldGet(_creds, this) || null;
    }
    /**
     *  Sets an ``Authorization`` for %%username%% with %%password%%.
     */
  }, {
    key: "setCredentials",
    value: function setCredentials(username, password) {
      (0, errors_js_1.assertArgument)(!username.match(/:/), "invalid basic authentication username", "username", "[REDACTED]");
      _classPrivateFieldSet(_creds, this, "".concat(username, ":").concat(password));
    }
    /**
     *  Enable and request gzip-encoded responses. The response will
     *  automatically be decompressed. //(default: true)//
     */
  }, {
    key: "allowGzip",
    get: function get() {
      return _classPrivateFieldGet(_gzip, this);
    }
  }, {
    key: "allowGzip",
    set: function set(value) {
      _classPrivateFieldSet(_gzip, this, !!value);
    }
    /**
     *  Allow ``Authentication`` credentials to be sent over insecure
     *  channels. //(default: false)//
     */
  }, {
    key: "allowInsecureAuthentication",
    get: function get() {
      return !!_classPrivateFieldGet(_allowInsecure, this);
    }
  }, {
    key: "allowInsecureAuthentication",
    set: function set(value) {
      _classPrivateFieldSet(_allowInsecure, this, !!value);
    }
    /**
     *  The timeout (in milliseconds) to wait for a complete response.
     *  //(default: 5 minutes)//
     */
  }, {
    key: "timeout",
    get: function get() {
      return _classPrivateFieldGet(_timeout, this);
    }
  }, {
    key: "timeout",
    set: function set(timeout) {
      (0, errors_js_1.assertArgument)(timeout >= 0, "timeout must be non-zero", "timeout", timeout);
      _classPrivateFieldSet(_timeout, this, timeout);
    }
    /**
     *  This function is called prior to each request, for example
     *  during a redirection or retry in case of server throttling.
     *
     *  This offers an opportunity to populate headers or update
     *  content before sending a request.
     */
  }, {
    key: "preflightFunc",
    get: function get() {
      return _classPrivateFieldGet(_preflight, this) || null;
    }
  }, {
    key: "preflightFunc",
    set: function set(preflight) {
      _classPrivateFieldSet(_preflight, this, preflight);
    }
    /**
     *  This function is called after each response, offering an
     *  opportunity to provide client-level throttling or updating
     *  response data.
     *
     *  Any error thrown in this causes the ``send()`` to throw.
     *
     *  To schedule a retry attempt (assuming the maximum retry limit
     *  has not been reached), use [[response.throwThrottleError]].
     */
  }, {
    key: "processFunc",
    get: function get() {
      return _classPrivateFieldGet(_process, this) || null;
    }
  }, {
    key: "processFunc",
    set: function set(process) {
      _classPrivateFieldSet(_process, this, process);
    }
    /**
     *  This function is called on each retry attempt.
     */
  }, {
    key: "retryFunc",
    get: function get() {
      return _classPrivateFieldGet(_retry, this) || null;
    }
  }, {
    key: "retryFunc",
    set: function set(retry) {
      _classPrivateFieldSet(_retry, this, retry);
    }
    /**
     *  This function is called to fetch content from HTTP and
     *  HTTPS URLs and is platform specific (e.g. nodejs vs
     *  browsers).
     *
     *  This is by default the currently registered global getUrl
     *  function, which can be changed using [[registerGetUrl]].
     *  If this has been set, setting is to ``null`` will cause
     *  this FetchRequest (and any future clones) to revert back to
     *  using the currently registered global getUrl function.
     *
     *  Setting this is generally not necessary, but may be useful
     *  for developers that wish to intercept requests or to
     *  configurege a proxy or other agent.
     */
  }, {
    key: "getUrlFunc",
    get: function get() {
      return _classPrivateFieldGet(_getUrlFunc, this) || defaultGetUrlFunc;
    }
  }, {
    key: "getUrlFunc",
    set: function set(value) {
      _classPrivateFieldSet(_getUrlFunc, this, value);
    }
  }, {
    key: "toString",
    value: function toString() {
      return "<FetchRequest method=".concat(JSON.stringify(this.method), " url=").concat(JSON.stringify(this.url), " headers=").concat(JSON.stringify(this.headers), " body=").concat(_classPrivateFieldGet(_body, this) ? (0, data_js_1.hexlify)(_classPrivateFieldGet(_body, this)) : "null", ">");
    }
    /**
     *  Update the throttle parameters used to determine maximum
     *  attempts and exponential-backoff properties.
     */
  }, {
    key: "setThrottleParams",
    value: function setThrottleParams(params) {
      if (params.slotInterval != null) {
        _classPrivateFieldGet(_throttle, this).slotInterval = params.slotInterval;
      }
      if (params.maxAttempts != null) {
        _classPrivateFieldGet(_throttle, this).maxAttempts = params.maxAttempts;
      }
    }
  }, {
    key: "send",
    value:
    /**
     *  Resolves to the response by sending the request.
     */
    function send() {
      (0, errors_js_1.assert)(_classPrivateFieldGet(_signal, this) == null, "request already sent", "UNSUPPORTED_OPERATION", {
        operation: "fetchRequest.send"
      });
      _classPrivateFieldSet(_signal, this, new FetchCancelSignal(this));
      return _assertClassBrand(_FetchRequest_brand, this, _send).call(this, 0, getTime() + this.timeout, 0, this, new FetchResponse(0, "", {}, null, this));
    }
    /**
     *  Cancels the inflight response, causing a ``CANCELLED``
     *  error to be rejected from the [[send]].
     */
  }, {
    key: "cancel",
    value: function cancel() {
      (0, errors_js_1.assert)(_classPrivateFieldGet(_signal, this) != null, "request has not been sent", "UNSUPPORTED_OPERATION", {
        operation: "fetchRequest.cancel"
      });
      var signal = fetchSignals.get(this);
      if (!signal) {
        throw new Error("missing signal; should not happen");
      }
      signal();
    }
    /**
     *  Returns a new [[FetchRequest]] that represents the redirection
     *  to %%location%%.
     */
  }, {
    key: "redirect",
    value: function redirect(location) {
      // Redirection; for now we only support absolute locations
      var current = this.url.split(":")[0].toLowerCase();
      var target = location.split(":")[0].toLowerCase();
      // Don't allow redirecting:
      // - non-GET requests
      // - downgrading the security (e.g. https => http)
      // - to non-HTTP (or non-HTTPS) protocols [this could be relaxed?]
      (0, errors_js_1.assert)(this.method === "GET" && (current !== "https" || target !== "http") && location.match(/^https?:/), "unsupported redirect", "UNSUPPORTED_OPERATION", {
        operation: "redirect(".concat(this.method, " ").concat(JSON.stringify(this.url), " => ").concat(JSON.stringify(location), ")")
      });
      // Create a copy of this request, with a new URL
      var req = new FetchRequest(location);
      req.method = "GET";
      req.allowGzip = this.allowGzip;
      req.timeout = this.timeout;
      _classPrivateFieldSet(_headers, req, Object.assign({}, _classPrivateFieldGet(_headers, this)));
      if (_classPrivateFieldGet(_body, this)) {
        _classPrivateFieldSet(_body, req, new Uint8Array(_classPrivateFieldGet(_body, this)));
      }
      _classPrivateFieldSet(_bodyType, req, _classPrivateFieldGet(_bodyType, this));
      // Do not forward credentials unless on the same domain; only absolute
      //req.allowInsecure = false;
      // paths are currently supported; may want a way to specify to forward?
      //setStore(req.#props, "creds", getStore(this.#pros, "creds"));
      return req;
    }
    /**
     *  Create a new copy of this request.
     */
  }, {
    key: "clone",
    value: function clone() {
      var clone = new FetchRequest(this.url);
      // Preserve "default method" (i.e. null)
      _classPrivateFieldSet(_method, clone, _classPrivateFieldGet(_method, this));
      // Preserve "default body" with type, copying the Uint8Array is present
      if (_classPrivateFieldGet(_body, this)) {
        _classPrivateFieldSet(_body, clone, _classPrivateFieldGet(_body, this));
      }
      _classPrivateFieldSet(_bodyType, clone, _classPrivateFieldGet(_bodyType, this));
      // Preserve "default headers"
      _classPrivateFieldSet(_headers, clone, Object.assign({}, _classPrivateFieldGet(_headers, this)));
      // Credentials is readonly, so we copy internally
      _classPrivateFieldSet(_creds, clone, _classPrivateFieldGet(_creds, this));
      if (this.allowGzip) {
        clone.allowGzip = true;
      }
      clone.timeout = this.timeout;
      if (this.allowInsecureAuthentication) {
        clone.allowInsecureAuthentication = true;
      }
      _classPrivateFieldSet(_preflight, clone, _classPrivateFieldGet(_preflight, this));
      _classPrivateFieldSet(_process, clone, _classPrivateFieldGet(_process, this));
      _classPrivateFieldSet(_retry, clone, _classPrivateFieldGet(_retry, this));
      _classPrivateFieldSet(_throttle, clone, Object.assign({}, _classPrivateFieldGet(_throttle, this)));
      _classPrivateFieldSet(_getUrlFunc, clone, _classPrivateFieldGet(_getUrlFunc, this));
      return clone;
    }
    /**
     *  Locks all static configuration for gateways and FetchGetUrlFunc
     *  registration.
     */
  }], [{
    key: "lockConfig",
    value: function lockConfig() {
      locked = true;
    }
    /**
     *  Get the current Gateway function for %%scheme%%.
     */
  }, {
    key: "getGateway",
    value: function getGateway(scheme) {
      return Gateways[scheme.toLowerCase()] || null;
    }
    /**
     *  Use the %%func%% when fetching URIs using %%scheme%%.
     *
     *  This method affects all requests globally.
     *
     *  If [[lockConfig]] has been called, no change is made and this
     *  throws.
     */
  }, {
    key: "registerGateway",
    value: function registerGateway(scheme, func) {
      scheme = scheme.toLowerCase();
      if (scheme === "http" || scheme === "https") {
        throw new Error("cannot intercept ".concat(scheme, "; use registerGetUrl"));
      }
      if (locked) {
        throw new Error("gateways locked");
      }
      Gateways[scheme] = func;
    }
    /**
     *  Use %%getUrl%% when fetching URIs over HTTP and HTTPS requests.
     *
     *  This method affects all requests globally.
     *
     *  If [[lockConfig]] has been called, no change is made and this
     *  throws.
     */
  }, {
    key: "registerGetUrl",
    value: function registerGetUrl(getUrl) {
      if (locked) {
        throw new Error("gateways locked");
      }
      defaultGetUrlFunc = getUrl;
    }
    /**
     *  Creates a getUrl function that fetches content from HTTP and
     *  HTTPS URLs.
     *
     *  The available %%options%% are dependent on the platform
     *  implementation of the default getUrl function.
     *
     *  This is not generally something that is needed, but is useful
     *  when trying to customize simple behaviour when fetching HTTP
     *  content.
     */
  }, {
    key: "createGetUrlFunc",
    value: function createGetUrlFunc(options) {
      return (0, geturl_js_1.createGetUrl)(options);
    }
    /**
     *  Creates a function that can "fetch" data URIs.
     *
     *  Note that this is automatically done internally to support
     *  data URIs, so it is not necessary to register it.
     *
     *  This is not generally something that is needed, but may
     *  be useful in a wrapper to perfom custom data URI functionality.
     */
  }, {
    key: "createDataGateway",
    value: function createDataGateway() {
      return dataGatewayFunc;
    }
    /**
     *  Creates a function that will fetch IPFS (unvalidated) from
     *  a custom gateway baseUrl.
     *
     *  The default IPFS gateway used internally is
     *  ``"https:/\/gateway.ipfs.io/ipfs/"``.
     */
  }, {
    key: "createIpfsGatewayFunc",
    value: function createIpfsGatewayFunc(baseUrl) {
      return getIpfsGatewayFunc(baseUrl);
    }
  }]);
}();
function _send(_x5, _x6, _x7, _x8, _x9) {
  return _send2.apply(this, arguments);
}
function _send2() {
  _send2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(attempt, expires, delay, _request, _response) {
    var req, scheme, result, _response2, resp, response, _req$redirect, location, _req$clone, retryAfter, _delay, _req$clone2, _delay2;
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) switch (_context3.prev = _context3.next) {
        case 0:
          if (!(attempt >= _classPrivateFieldGet(_throttle, this).maxAttempts)) {
            _context3.next = 2;
            break;
          }
          return _context3.abrupt("return", _response.makeServerError("exceeded maximum retry limit"));
        case 2:
          (0, errors_js_1.assert)(getTime() <= expires, "timeout", "TIMEOUT", {
            operation: "request.send",
            reason: "timeout",
            request: _request
          });
          if (!(delay > 0)) {
            _context3.next = 6;
            break;
          }
          _context3.next = 6;
          return wait(delay);
        case 6:
          req = this.clone();
          scheme = (req.url.split(":")[0] || "").toLowerCase(); // Process any Gateways
          if (!(scheme in Gateways)) {
            _context3.next = 27;
            break;
          }
          _context3.next = 11;
          return Gateways[scheme](req.url, checkSignal(_classPrivateFieldGet(_signal, _request)));
        case 11:
          result = _context3.sent;
          if (!(result instanceof FetchResponse)) {
            _context3.next = 26;
            break;
          }
          _response2 = result;
          if (!this.processFunc) {
            _context3.next = 25;
            break;
          }
          checkSignal(_classPrivateFieldGet(_signal, _request));
          _context3.prev = 16;
          _context3.next = 19;
          return this.processFunc(req, _response2);
        case 19:
          _response2 = _context3.sent;
          _context3.next = 25;
          break;
        case 22:
          _context3.prev = 22;
          _context3.t0 = _context3["catch"](16);
          // Something went wrong during processing; throw a 5xx server error
          if (_context3.t0.throttle == null || typeof _context3.t0.stall !== "number") {
            _response2.makeServerError("error in post-processing function", _context3.t0).assertOk();
          }
          // Ignore throttling
        case 25:
          return _context3.abrupt("return", _response2);
        case 26:
          req = result;
        case 27:
          if (!this.preflightFunc) {
            _context3.next = 31;
            break;
          }
          _context3.next = 30;
          return this.preflightFunc(req);
        case 30:
          req = _context3.sent;
        case 31:
          _context3.next = 33;
          return this.getUrlFunc(req, checkSignal(_classPrivateFieldGet(_signal, _request)));
        case 33:
          resp = _context3.sent;
          response = new FetchResponse(resp.statusCode, resp.statusMessage, resp.headers, resp.body, _request);
          if (!(response.statusCode === 301 || response.statusCode === 302)) {
            _context3.next = 46;
            break;
          }
          _context3.prev = 36;
          location = response.headers.location || "";
          return _context3.abrupt("return", _assertClassBrand(_FetchRequest_brand, _req$redirect = req.redirect(location), _send).call(_req$redirect, attempt + 1, expires, 0, _request, response));
        case 41:
          _context3.prev = 41;
          _context3.t1 = _context3["catch"](36);
        case 43:
          return _context3.abrupt("return", response);
        case 46:
          if (!(response.statusCode === 429)) {
            _context3.next = 57;
            break;
          }
          _context3.t2 = this.retryFunc == null;
          if (_context3.t2) {
            _context3.next = 52;
            break;
          }
          _context3.next = 51;
          return this.retryFunc(req, response, attempt);
        case 51:
          _context3.t2 = _context3.sent;
        case 52:
          if (!_context3.t2) {
            _context3.next = 57;
            break;
          }
          retryAfter = response.headers["retry-after"];
          _delay = _classPrivateFieldGet(_throttle, this).slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));
          if (typeof retryAfter === "string" && retryAfter.match(/^[1-9][0-9]*$/)) {
            _delay = parseInt(retryAfter);
          }
          return _context3.abrupt("return", _assertClassBrand(_FetchRequest_brand, _req$clone = req.clone(), _send).call(_req$clone, attempt + 1, expires, _delay, _request, response));
        case 57:
          if (!this.processFunc) {
            _context3.next = 72;
            break;
          }
          checkSignal(_classPrivateFieldGet(_signal, _request));
          _context3.prev = 59;
          _context3.next = 62;
          return this.processFunc(req, response);
        case 62:
          response = _context3.sent;
          _context3.next = 72;
          break;
        case 65:
          _context3.prev = 65;
          _context3.t3 = _context3["catch"](59);
          // Something went wrong during processing; throw a 5xx server error
          if (_context3.t3.throttle == null || typeof _context3.t3.stall !== "number") {
            response.makeServerError("error in post-processing function", _context3.t3).assertOk();
          }
          // Throttle
          _delay2 = _classPrivateFieldGet(_throttle, this).slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));
          ;
          if (_context3.t3.stall >= 0) {
            _delay2 = _context3.t3.stall;
          }
          return _context3.abrupt("return", _assertClassBrand(_FetchRequest_brand, _req$clone2 = req.clone(), _send).call(_req$clone2, attempt + 1, expires, _delay2, _request, response));
        case 72:
          return _context3.abrupt("return", response);
        case 73:
        case "end":
          return _context3.stop();
      }
    }, _callee3, this, [[16, 22], [36, 41], [59, 65]]);
  }));
  return _send2.apply(this, arguments);
}
exports.FetchRequest = FetchRequest;
;
/**
 *  The response for a FetchRequest.
 */
var _statusCode = /*#__PURE__*/new WeakMap();
var _statusMessage = /*#__PURE__*/new WeakMap();
var _headers2 = /*#__PURE__*/new WeakMap();
var _body2 = /*#__PURE__*/new WeakMap();
var _request2 = /*#__PURE__*/new WeakMap();
var _error = /*#__PURE__*/new WeakMap();
var FetchResponse = /*#__PURE__*/function () {
  function FetchResponse(statusCode, statusMessage, headers, body, request) {
    _classCallCheck(this, FetchResponse);
    _classPrivateFieldInitSpec(this, _statusCode, void 0);
    _classPrivateFieldInitSpec(this, _statusMessage, void 0);
    _classPrivateFieldInitSpec(this, _headers2, void 0);
    _classPrivateFieldInitSpec(this, _body2, void 0);
    _classPrivateFieldInitSpec(this, _request2, void 0);
    _classPrivateFieldInitSpec(this, _error, void 0);
    _classPrivateFieldSet(_statusCode, this, statusCode);
    _classPrivateFieldSet(_statusMessage, this, statusMessage);
    _classPrivateFieldSet(_headers2, this, Object.keys(headers).reduce(function (accum, k) {
      accum[k.toLowerCase()] = String(headers[k]);
      return accum;
    }, {}));
    _classPrivateFieldSet(_body2, this, body == null ? null : new Uint8Array(body));
    _classPrivateFieldSet(_request2, this, request || null);
    _classPrivateFieldSet(_error, this, {
      message: ""
    });
  }
  /**
   *  Return a Response with matching headers and body, but with
   *  an error status code (i.e. 599) and %%message%% with an
   *  optional %%error%%.
   */
  return _createClass(FetchResponse, [{
    key: "toString",
    value: function toString() {
      return "<FetchResponse status=".concat(this.statusCode, " body=").concat(_classPrivateFieldGet(_body2, this) ? (0, data_js_1.hexlify)(_classPrivateFieldGet(_body2, this)) : "null", ">");
    }
    /**
     *  The response status code.
     */
  }, {
    key: "statusCode",
    get: function get() {
      return _classPrivateFieldGet(_statusCode, this);
    }
    /**
     *  The response status message.
     */
  }, {
    key: "statusMessage",
    get: function get() {
      return _classPrivateFieldGet(_statusMessage, this);
    }
    /**
     *  The response headers. All keys are lower-case.
     */
  }, {
    key: "headers",
    get: function get() {
      return Object.assign({}, _classPrivateFieldGet(_headers2, this));
    }
    /**
     *  The response body, or ``null`` if there was no body.
     */
  }, {
    key: "body",
    get: function get() {
      return _classPrivateFieldGet(_body2, this) == null ? null : new Uint8Array(_classPrivateFieldGet(_body2, this));
    }
    /**
     *  The response body as a UTF-8 encoded string, or the empty
     *  string (i.e. ``""``) if there was no body.
     *
     *  An error is thrown if the body is invalid UTF-8 data.
     */
  }, {
    key: "bodyText",
    get: function get() {
      try {
        return _classPrivateFieldGet(_body2, this) == null ? "" : (0, utf8_js_1.toUtf8String)(_classPrivateFieldGet(_body2, this));
      } catch (error) {
        (0, errors_js_1.assert)(false, "response body is not valid UTF-8 data", "UNSUPPORTED_OPERATION", {
          operation: "bodyText",
          info: {
            response: this
          }
        });
      }
    }
    /**
     *  The response body, decoded as JSON.
     *
     *  An error is thrown if the body is invalid JSON-encoded data
     *  or if there was no body.
     */
  }, {
    key: "bodyJson",
    get: function get() {
      try {
        return JSON.parse(this.bodyText);
      } catch (error) {
        (0, errors_js_1.assert)(false, "response body is not valid JSON", "UNSUPPORTED_OPERATION", {
          operation: "bodyJson",
          info: {
            response: this
          }
        });
      }
    }
  }, {
    key: Symbol.iterator,
    value: function value() {
      var headers = this.headers;
      var keys = Object.keys(headers);
      var index = 0;
      return {
        next: function next() {
          if (index < keys.length) {
            var key = keys[index++];
            return {
              value: [key, headers[key]],
              done: false
            };
          }
          return {
            value: undefined,
            done: true
          };
        }
      };
    }
  }, {
    key: "makeServerError",
    value: function makeServerError(message, error) {
      var statusMessage;
      if (!message) {
        message = "".concat(this.statusCode, " ").concat(this.statusMessage);
        statusMessage = "CLIENT ESCALATED SERVER ERROR (".concat(message, ")");
      } else {
        statusMessage = "CLIENT ESCALATED SERVER ERROR (".concat(this.statusCode, " ").concat(this.statusMessage, "; ").concat(message, ")");
      }
      var response = new FetchResponse(599, statusMessage, this.headers, this.body, _classPrivateFieldGet(_request2, this) || undefined);
      _classPrivateFieldSet(_error, response, {
        message: message,
        error: error
      });
      return response;
    }
    /**
     *  If called within a [request.processFunc](FetchRequest-processFunc)
     *  call, causes the request to retry as if throttled for %%stall%%
     *  milliseconds.
     */
  }, {
    key: "throwThrottleError",
    value: function throwThrottleError(message, stall) {
      if (stall == null) {
        stall = -1;
      } else {
        (0, errors_js_1.assertArgument)(Number.isInteger(stall) && stall >= 0, "invalid stall timeout", "stall", stall);
      }
      var error = new Error(message || "throttling requests");
      (0, properties_js_1.defineProperties)(error, {
        stall: stall,
        throttle: true
      });
      throw error;
    }
    /**
     *  Get the header value for %%key%%, ignoring case.
     */
  }, {
    key: "getHeader",
    value: function getHeader(key) {
      return this.headers[key.toLowerCase()];
    }
    /**
     *  Returns true if the response has a body.
     */
  }, {
    key: "hasBody",
    value: function hasBody() {
      return _classPrivateFieldGet(_body2, this) != null;
    }
    /**
     *  The request made for this response.
     */
  }, {
    key: "request",
    get: function get() {
      return _classPrivateFieldGet(_request2, this);
    }
    /**
     *  Returns true if this response was a success statusCode.
     */
  }, {
    key: "ok",
    value: function ok() {
      return _classPrivateFieldGet(_error, this).message === "" && this.statusCode >= 200 && this.statusCode < 300;
    }
    /**
     *  Throws a ``SERVER_ERROR`` if this response is not ok.
     */
  }, {
    key: "assertOk",
    value: function assertOk() {
      if (this.ok()) {
        return;
      }
      var _classPrivateFieldGet2 = _classPrivateFieldGet(_error, this),
        message = _classPrivateFieldGet2.message,
        error = _classPrivateFieldGet2.error;
      if (message === "") {
        message = "server response ".concat(this.statusCode, " ").concat(this.statusMessage);
      }
      var requestUrl = null;
      if (this.request) {
        requestUrl = this.request.url;
      }
      var responseBody = null;
      try {
        if (_classPrivateFieldGet(_body2, this)) {
          responseBody = (0, utf8_js_1.toUtf8String)(_classPrivateFieldGet(_body2, this));
        }
      } catch (e) {}
      (0, errors_js_1.assert)(false, message, "SERVER_ERROR", {
        request: this.request || "unknown request",
        response: this,
        error: error,
        info: {
          requestUrl: requestUrl,
          responseBody: responseBody,
          responseStatus: "".concat(this.statusCode, " ").concat(this.statusMessage)
        }
      });
    }
  }]);
}();
exports.FetchResponse = FetchResponse;
function getTime() {
  return new Date().getTime();
}
function unpercent(value) {
  return (0, utf8_js_1.toUtf8Bytes)(value.replace(/%([0-9a-f][0-9a-f])/gi, function (all, code) {
    return String.fromCharCode(parseInt(code, 16));
  }));
}
function wait(delay) {
  return new Promise(function (resolve) {
    return setTimeout(resolve, delay);
  });
}

},{"./base64.js":269,"./data.js":270,"./errors.js":271,"./geturl.js":275,"./properties.js":278,"./utf8.js":282}],274:[function(require,module,exports){
"use strict";

var _FixedNumber;
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FixedNumber = void 0;
/**
 *  The **FixedNumber** class permits using values with decimal places,
 *  using fixed-pont math.
 *
 *  Fixed-point math is still based on integers under-the-hood, but uses an
 *  internal offset to store fractional components below, and each operation
 *  corrects for this after each operation.
 *
 *  @_section: api/utils/fixed-point-math:Fixed-Point Maths  [about-fixed-point-math]
 */
var data_js_1 = require("./data.js");
var errors_js_1 = require("./errors.js");
var maths_js_1 = require("./maths.js");
var properties_js_1 = require("./properties.js");
var BN_N1 = BigInt(-1);
var BN_0 = BigInt(0);
var BN_1 = BigInt(1);
var BN_5 = BigInt(5);
var _guard = {};
// Constant to pull zeros from for multipliers
var Zeros = "0000";
while (Zeros.length < 80) {
  Zeros += Zeros;
}
// Returns a string "1" followed by decimal "0"s
function getTens(decimals) {
  var result = Zeros;
  while (result.length < decimals) {
    result += result;
  }
  return BigInt("1" + result.substring(0, decimals));
}
function checkValue(val, format, safeOp) {
  var width = BigInt(format.width);
  if (format.signed) {
    var limit = BN_1 << width - BN_1;
    (0, errors_js_1.assert)(safeOp == null || val >= -limit && val < limit, "overflow", "NUMERIC_FAULT", {
      operation: safeOp,
      fault: "overflow",
      value: val
    });
    if (val > BN_0) {
      val = (0, maths_js_1.fromTwos)((0, maths_js_1.mask)(val, width), width);
    } else {
      val = -(0, maths_js_1.fromTwos)((0, maths_js_1.mask)(-val, width), width);
    }
  } else {
    var _limit = BN_1 << width;
    (0, errors_js_1.assert)(safeOp == null || val >= 0 && val < _limit, "overflow", "NUMERIC_FAULT", {
      operation: safeOp,
      fault: "overflow",
      value: val
    });
    val = (val % _limit + _limit) % _limit & _limit - BN_1;
  }
  return val;
}
function getFormat(value) {
  if (typeof value === "number") {
    value = "fixed128x".concat(value);
  }
  var signed = true;
  var width = 128;
  var decimals = 18;
  if (typeof value === "string") {
    // Parse the format string
    if (value === "fixed") {
      // defaults...
    } else if (value === "ufixed") {
      signed = false;
    } else {
      var match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
      (0, errors_js_1.assertArgument)(match, "invalid fixed format", "format", value);
      signed = match[1] !== "u";
      width = parseInt(match[2]);
      decimals = parseInt(match[3]);
    }
  } else if (value) {
    // Extract the values from the object
    var v = value;
    var check = function check(key, type, defaultValue) {
      if (v[key] == null) {
        return defaultValue;
      }
      (0, errors_js_1.assertArgument)(_typeof(v[key]) === type, "invalid fixed format (" + key + " not " + type + ")", "format." + key, v[key]);
      return v[key];
    };
    signed = check("signed", "boolean", signed);
    width = check("width", "number", width);
    decimals = check("decimals", "number", decimals);
  }
  (0, errors_js_1.assertArgument)(width % 8 === 0, "invalid FixedNumber width (not byte aligned)", "format.width", width);
  (0, errors_js_1.assertArgument)(decimals <= 80, "invalid FixedNumber decimals (too large)", "format.decimals", decimals);
  var name = (signed ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
  return {
    signed: signed,
    width: width,
    decimals: decimals,
    name: name
  };
}
function toString(val, decimals) {
  var negative = "";
  if (val < BN_0) {
    negative = "-";
    val *= BN_N1;
  }
  var str = val.toString();
  // No decimal point for whole values
  if (decimals === 0) {
    return negative + str;
  }
  // Pad out to the whole component (including a whole digit)
  while (str.length <= decimals) {
    str = Zeros + str;
  }
  // Insert the decimal point
  var index = str.length - decimals;
  str = str.substring(0, index) + "." + str.substring(index);
  // Trim the whole component (leaving at least one 0)
  while (str[0] === "0" && str[1] !== ".") {
    str = str.substring(1);
  }
  // Trim the decimal component (leaving at least one 0)
  while (str[str.length - 1] === "0" && str[str.length - 2] !== ".") {
    str = str.substring(0, str.length - 1);
  }
  return negative + str;
}
/**
 *  A FixedNumber represents a value over its [[FixedFormat]]
 *  arithmetic field.
 *
 *  A FixedNumber can be used to perform math, losslessly, on
 *  values which have decmial places.
 *
 *  A FixedNumber has a fixed bit-width to store values in, and stores all
 *  values internally by multiplying the value by 10 raised to the power of
 *  %%decimals%%.
 *
 *  If operations are performed that cause a value to grow too high (close to
 *  positive infinity) or too low (close to negative infinity), the value
 *  is said to //overflow//.
 *
 *  For example, an 8-bit signed value, with 0 decimals may only be within
 *  the range ``-128`` to ``127``; so ``-128 - 1`` will overflow and become
 *  ``127``. Likewise, ``127 + 1`` will overflow and become ``-127``.
 *
 *  Many operation have a normal and //unsafe// variant. The normal variant
 *  will throw a [[NumericFaultError]] on any overflow, while the //unsafe//
 *  variant will silently allow overflow, corrupting its value value.
 *
 *  If operations are performed that cause a value to become too small
 *  (close to zero), the value loses precison and is said to //underflow//.
 *
 *  For example, an value with 1 decimal place may store a number as small
 *  as ``0.1``, but the value of ``0.1 / 2`` is ``0.05``, which cannot fit
 *  into 1 decimal place, so underflow occurs which means precision is lost
 *  and the value becomes ``0``.
 *
 *  Some operations have a normal and //signalling// variant. The normal
 *  variant will silently ignore underflow, while the //signalling// variant
 *  will thow a [[NumericFaultError]] on underflow.
 */
var _format2 = /*#__PURE__*/new WeakMap();
var _val = /*#__PURE__*/new WeakMap();
var _tens = /*#__PURE__*/new WeakMap();
var _FixedNumber_brand = /*#__PURE__*/new WeakSet();
var FixedNumber = /*#__PURE__*/function () {
  // Use this when changing this file to get some typing info,
  // but then switch to any to mask the internal type
  //constructor(guard: any, value: bigint, format: _FixedFormat) {
  /**
   *  @private
   */
  function FixedNumber(guard, value, format) {
    _classCallCheck(this, FixedNumber);
    _classPrivateMethodInitSpec(this, _FixedNumber_brand);
    /**
     *  The specific fixed-point arithmetic field for this value.
     */
    _defineProperty(this, "format", void 0);
    _classPrivateFieldInitSpec(this, _format2, void 0);
    // The actual value (accounting for decimals)
    _classPrivateFieldInitSpec(this, _val, void 0);
    // A base-10 value to multiple values by to maintain the magnitude
    _classPrivateFieldInitSpec(this, _tens, void 0);
    /**
     *  This is a property so console.log shows a human-meaningful value.
     *
     *  @private
     */
    _defineProperty(this, "_value", void 0);
    (0, errors_js_1.assertPrivate)(guard, _guard, "FixedNumber");
    _classPrivateFieldSet(_val, this, value);
    _classPrivateFieldSet(_format2, this, format);
    var _value = toString(value, format.decimals);
    (0, properties_js_1.defineProperties)(this, {
      format: format.name,
      _value: _value
    });
    _classPrivateFieldSet(_tens, this, getTens(format.decimals));
  }
  /**
   *  If true, negative values are permitted, otherwise only
   *  positive values and zero are allowed.
   */
  return _createClass(FixedNumber, [{
    key: "signed",
    get: function get() {
      return _classPrivateFieldGet(_format2, this).signed;
    }
    /**
     *  The number of bits available to store the value.
     */
  }, {
    key: "width",
    get: function get() {
      return _classPrivateFieldGet(_format2, this).width;
    }
    /**
     *  The number of decimal places in the fixed-point arithment field.
     */
  }, {
    key: "decimals",
    get: function get() {
      return _classPrivateFieldGet(_format2, this).decimals;
    }
    /**
     *  The value as an integer, based on the smallest unit the
     *  [[decimals]] allow.
     */
  }, {
    key: "value",
    get: function get() {
      return _classPrivateFieldGet(_val, this);
    }
  }, {
    key: "addUnsafe",
    value:
    /**
     *  Returns a new [[FixedNumber]] with the result of %%this%% added
     *  to %%other%%, ignoring overflow.
     */
    function addUnsafe(other) {
      return _assertClassBrand(_FixedNumber_brand, this, _add).call(this, other);
    }
    /**
     *  Returns a new [[FixedNumber]] with the result of %%this%% added
     *  to %%other%%. A [[NumericFaultError]] is thrown if overflow
     *  occurs.
     */
  }, {
    key: "add",
    value: function add(other) {
      return _assertClassBrand(_FixedNumber_brand, this, _add).call(this, other, "add");
    }
  }, {
    key: "subUnsafe",
    value:
    /**
     *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted
     *  from %%this%%, ignoring overflow.
     */
    function subUnsafe(other) {
      return _assertClassBrand(_FixedNumber_brand, this, _sub).call(this, other);
    }
    /**
     *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted
     *  from %%this%%. A [[NumericFaultError]] is thrown if overflow
     *  occurs.
     */
  }, {
    key: "sub",
    value: function sub(other) {
      return _assertClassBrand(_FixedNumber_brand, this, _sub).call(this, other, "sub");
    }
  }, {
    key: "mulUnsafe",
    value:
    /**
     *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied
     *  by %%other%%, ignoring overflow and underflow (precision loss).
     */
    function mulUnsafe(other) {
      return _assertClassBrand(_FixedNumber_brand, this, _mul).call(this, other);
    }
    /**
     *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied
     *  by %%other%%. A [[NumericFaultError]] is thrown if overflow
     *  occurs.
     */
  }, {
    key: "mul",
    value: function mul(other) {
      return _assertClassBrand(_FixedNumber_brand, this, _mul).call(this, other, "mul");
    }
    /**
     *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied
     *  by %%other%%. A [[NumericFaultError]] is thrown if overflow
     *  occurs or if underflow (precision loss) occurs.
     */
  }, {
    key: "mulSignal",
    value: function mulSignal(other) {
      _assertClassBrand(_FixedNumber_brand, this, _checkFormat).call(this, other);
      var value = _classPrivateFieldGet(_val, this) * _classPrivateFieldGet(_val, other);
      (0, errors_js_1.assert)(value % _classPrivateFieldGet(_tens, this) === BN_0, "precision lost during signalling mul", "NUMERIC_FAULT", {
        operation: "mulSignal",
        fault: "underflow",
        value: this
      });
      return _assertClassBrand(_FixedNumber_brand, this, _checkValue).call(this, value / _classPrivateFieldGet(_tens, this), "mulSignal");
    }
  }, {
    key: "divUnsafe",
    value:
    /**
     *  Returns a new [[FixedNumber]] with the result of %%this%% divided
     *  by %%other%%, ignoring underflow (precision loss). A
     *  [[NumericFaultError]] is thrown if overflow occurs.
     */
    function divUnsafe(other) {
      return _assertClassBrand(_FixedNumber_brand, this, _div).call(this, other);
    }
    /**
     *  Returns a new [[FixedNumber]] with the result of %%this%% divided
     *  by %%other%%, ignoring underflow (precision loss). A
     *  [[NumericFaultError]] is thrown if overflow occurs.
     */
  }, {
    key: "div",
    value: function div(other) {
      return _assertClassBrand(_FixedNumber_brand, this, _div).call(this, other, "div");
    }
    /**
     *  Returns a new [[FixedNumber]] with the result of %%this%% divided
     *  by %%other%%. A [[NumericFaultError]] is thrown if underflow
     *  (precision loss) occurs.
     */
  }, {
    key: "divSignal",
    value: function divSignal(other) {
      (0, errors_js_1.assert)(_classPrivateFieldGet(_val, other) !== BN_0, "division by zero", "NUMERIC_FAULT", {
        operation: "div",
        fault: "divide-by-zero",
        value: this
      });
      _assertClassBrand(_FixedNumber_brand, this, _checkFormat).call(this, other);
      var value = _classPrivateFieldGet(_val, this) * _classPrivateFieldGet(_tens, this);
      (0, errors_js_1.assert)(value % _classPrivateFieldGet(_val, other) === BN_0, "precision lost during signalling div", "NUMERIC_FAULT", {
        operation: "divSignal",
        fault: "underflow",
        value: this
      });
      return _assertClassBrand(_FixedNumber_brand, this, _checkValue).call(this, value / _classPrivateFieldGet(_val, other), "divSignal");
    }
    /**
     *  Returns a comparison result between %%this%% and %%other%%.
     *
     *  This is suitable for use in sorting, where ``-1`` implies %%this%%
     *  is smaller, ``1`` implies %%this%% is larger and ``0`` implies
     *  both are equal.
     */
  }, {
    key: "cmp",
    value: function cmp(other) {
      var a = this.value,
        b = other.value;
      // Coerce a and b to the same magnitude
      var delta = this.decimals - other.decimals;
      if (delta > 0) {
        b *= getTens(delta);
      } else if (delta < 0) {
        a *= getTens(-delta);
      }
      // Comnpare
      if (a < b) {
        return -1;
      }
      if (a > b) {
        return 1;
      }
      return 0;
    }
    /**
     *  Returns true if %%other%% is equal to %%this%%.
     */
  }, {
    key: "eq",
    value: function eq(other) {
      return this.cmp(other) === 0;
    }
    /**
     *  Returns true if %%other%% is less than to %%this%%.
     */
  }, {
    key: "lt",
    value: function lt(other) {
      return this.cmp(other) < 0;
    }
    /**
     *  Returns true if %%other%% is less than or equal to %%this%%.
     */
  }, {
    key: "lte",
    value: function lte(other) {
      return this.cmp(other) <= 0;
    }
    /**
     *  Returns true if %%other%% is greater than to %%this%%.
     */
  }, {
    key: "gt",
    value: function gt(other) {
      return this.cmp(other) > 0;
    }
    /**
     *  Returns true if %%other%% is greater than or equal to %%this%%.
     */
  }, {
    key: "gte",
    value: function gte(other) {
      return this.cmp(other) >= 0;
    }
    /**
     *  Returns a new [[FixedNumber]] which is the largest **integer**
     *  that is less than or equal to %%this%%.
     *
     *  The decimal component of the result will always be ``0``.
     */
  }, {
    key: "floor",
    value: function floor() {
      var val = _classPrivateFieldGet(_val, this);
      if (_classPrivateFieldGet(_val, this) < BN_0) {
        val -= _classPrivateFieldGet(_tens, this) - BN_1;
      }
      val = _classPrivateFieldGet(_val, this) / _classPrivateFieldGet(_tens, this) * _classPrivateFieldGet(_tens, this);
      return _assertClassBrand(_FixedNumber_brand, this, _checkValue).call(this, val, "floor");
    }
    /**
     *  Returns a new [[FixedNumber]] which is the smallest **integer**
     *  that is greater than or equal to %%this%%.
     *
     *  The decimal component of the result will always be ``0``.
     */
  }, {
    key: "ceiling",
    value: function ceiling() {
      var val = _classPrivateFieldGet(_val, this);
      if (_classPrivateFieldGet(_val, this) > BN_0) {
        val += _classPrivateFieldGet(_tens, this) - BN_1;
      }
      val = _classPrivateFieldGet(_val, this) / _classPrivateFieldGet(_tens, this) * _classPrivateFieldGet(_tens, this);
      return _assertClassBrand(_FixedNumber_brand, this, _checkValue).call(this, val, "ceiling");
    }
    /**
     *  Returns a new [[FixedNumber]] with the decimal component
     *  rounded up on ties at %%decimals%% places.
     */
  }, {
    key: "round",
    value: function round(decimals) {
      if (decimals == null) {
        decimals = 0;
      }
      // Not enough precision to not already be rounded
      if (decimals >= this.decimals) {
        return this;
      }
      var delta = this.decimals - decimals;
      var bump = BN_5 * getTens(delta - 1);
      var value = this.value + bump;
      var tens = getTens(delta);
      value = value / tens * tens;
      checkValue(value, _classPrivateFieldGet(_format2, this), "round");
      return new FixedNumber(_guard, value, _classPrivateFieldGet(_format2, this));
    }
    /**
     *  Returns true if %%this%% is equal to ``0``.
     */
  }, {
    key: "isZero",
    value: function isZero() {
      return _classPrivateFieldGet(_val, this) === BN_0;
    }
    /**
     *  Returns true if %%this%% is less than ``0``.
     */
  }, {
    key: "isNegative",
    value: function isNegative() {
      return _classPrivateFieldGet(_val, this) < BN_0;
    }
    /**
     *  Returns the string representation of %%this%%.
     */
  }, {
    key: "toString",
    value: function toString() {
      return this._value;
    }
    /**
     *  Returns a float approximation.
     *
     *  Due to IEEE 754 precission (or lack thereof), this function
     *  can only return an approximation and most values will contain
     *  rounding errors.
     */
  }, {
    key: "toUnsafeFloat",
    value: function toUnsafeFloat() {
      return parseFloat(this.toString());
    }
    /**
     *  Return a new [[FixedNumber]] with the same value but has had
     *  its field set to %%format%%.
     *
     *  This will throw if the value cannot fit into %%format%%.
     */
  }, {
    key: "toFormat",
    value: function toFormat(format) {
      return FixedNumber.fromString(this.toString(), format);
    }
    /**
     *  Creates a new [[FixedNumber]] for %%value%% divided by
     *  %%decimal%% places with %%format%%.
     *
     *  This will throw a [[NumericFaultError]] if %%value%% (once adjusted
     *  for %%decimals%%) cannot fit in %%format%%, either due to overflow
     *  or underflow (precision loss).
     */
  }], [{
    key: "fromValue",
    value: function fromValue(_value, _decimals, _format) {
      var decimals = _decimals == null ? 0 : (0, maths_js_1.getNumber)(_decimals);
      var format = getFormat(_format);
      var value = (0, maths_js_1.getBigInt)(_value, "value");
      var delta = decimals - format.decimals;
      if (delta > 0) {
        var tens = getTens(delta);
        (0, errors_js_1.assert)(value % tens === BN_0, "value loses precision for format", "NUMERIC_FAULT", {
          operation: "fromValue",
          fault: "underflow",
          value: _value
        });
        value /= tens;
      } else if (delta < 0) {
        value *= getTens(-delta);
      }
      checkValue(value, format, "fromValue");
      return new FixedNumber(_guard, value, format);
    }
    /**
     *  Creates a new [[FixedNumber]] for %%value%% with %%format%%.
     *
     *  This will throw a [[NumericFaultError]] if %%value%% cannot fit
     *  in %%format%%, either due to overflow or underflow (precision loss).
     */
  }, {
    key: "fromString",
    value: function fromString(_value, _format) {
      var match = _value.match(/^(-?)([0-9]*)\.?([0-9]*)$/);
      (0, errors_js_1.assertArgument)(match && match[2].length + match[3].length > 0, "invalid FixedNumber string value", "value", _value);
      var format = getFormat(_format);
      var whole = match[2] || "0",
        decimal = match[3] || "";
      // Pad out the decimals
      while (decimal.length < format.decimals) {
        decimal += Zeros;
      }
      // Check precision is safe
      (0, errors_js_1.assert)(decimal.substring(format.decimals).match(/^0*$/), "too many decimals for format", "NUMERIC_FAULT", {
        operation: "fromString",
        fault: "underflow",
        value: _value
      });
      // Remove extra padding
      decimal = decimal.substring(0, format.decimals);
      var value = BigInt(match[1] + whole + decimal);
      checkValue(value, format, "fromString");
      return new FixedNumber(_guard, value, format);
    }
    /**
     *  Creates a new [[FixedNumber]] with the big-endian representation
     *  %%value%% with %%format%%.
     *
     *  This will throw a [[NumericFaultError]] if %%value%% cannot fit
     *  in %%format%% due to overflow.
     */
  }, {
    key: "fromBytes",
    value: function fromBytes(_value, _format) {
      var value = (0, maths_js_1.toBigInt)((0, data_js_1.getBytes)(_value, "value"));
      var format = getFormat(_format);
      if (format.signed) {
        value = (0, maths_js_1.fromTwos)(value, format.width);
      }
      checkValue(value, format, "fromBytes");
      return new FixedNumber(_guard, value, format);
    }
  }]);
}();
_FixedNumber = FixedNumber;
function _checkFormat(other) {
  (0, errors_js_1.assertArgument)(this.format === other.format, "incompatible format; use fixedNumber.toFormat", "other", other);
}
function _checkValue(val, safeOp) {
  /*
          const width = BigInt(this.width);
          if (this.signed) {
              const limit = (BN_1 << (width - BN_1));
              assert(safeOp == null || (val >= -limit  && val < limit), "overflow", "NUMERIC_FAULT", {
                  operation: <string>safeOp, fault: "overflow", value: val
              });
  
              if (val > BN_0) {
                  val = fromTwos(mask(val, width), width);
              } else {
                  val = -fromTwos(mask(-val, width), width);
              }
  
          } else {
              const masked = mask(val, width);
              assert(safeOp == null || (val >= 0 && val === masked), "overflow", "NUMERIC_FAULT", {
                  operation: <string>safeOp, fault: "overflow", value: val
              });
              val = masked;
          }
  */
  val = checkValue(val, _classPrivateFieldGet(_format2, this), safeOp);
  return new _FixedNumber(_guard, val, _classPrivateFieldGet(_format2, this));
}
function _add(o, safeOp) {
  _assertClassBrand(_FixedNumber_brand, this, _checkFormat).call(this, o);
  return _assertClassBrand(_FixedNumber_brand, this, _checkValue).call(this, _classPrivateFieldGet(_val, this) + _classPrivateFieldGet(_val, o), safeOp);
}
function _sub(o, safeOp) {
  _assertClassBrand(_FixedNumber_brand, this, _checkFormat).call(this, o);
  return _assertClassBrand(_FixedNumber_brand, this, _checkValue).call(this, _classPrivateFieldGet(_val, this) - _classPrivateFieldGet(_val, o), safeOp);
}
function _mul(o, safeOp) {
  _assertClassBrand(_FixedNumber_brand, this, _checkFormat).call(this, o);
  return _assertClassBrand(_FixedNumber_brand, this, _checkValue).call(this, _classPrivateFieldGet(_val, this) * _classPrivateFieldGet(_val, o) / _classPrivateFieldGet(_tens, this), safeOp);
}
function _div(o, safeOp) {
  (0, errors_js_1.assert)(_classPrivateFieldGet(_val, o) !== BN_0, "division by zero", "NUMERIC_FAULT", {
    operation: "div",
    fault: "divide-by-zero",
    value: this
  });
  _assertClassBrand(_FixedNumber_brand, this, _checkFormat).call(this, o);
  return _assertClassBrand(_FixedNumber_brand, this, _checkValue).call(this, _classPrivateFieldGet(_val, this) * _classPrivateFieldGet(_tens, this) / _classPrivateFieldGet(_val, o), safeOp);
}
exports.FixedNumber = FixedNumber;
//const f1 = FixedNumber.fromString("12.56", "fixed16x2");
//const f2 = FixedNumber.fromString("0.3", "fixed16x2");
//console.log(f1.divSignal(f2));
//const BUMP = FixedNumber.from("0.5");

},{"./data.js":270,"./errors.js":271,"./maths.js":277,"./properties.js":278}],275:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getUrl = exports.createGetUrl = void 0;
var errors_js_1 = require("./errors.js");
function createGetUrl(options) {
  function getUrl(_x, _x2) {
    return _getUrl.apply(this, arguments);
  }
  function _getUrl() {
    _getUrl = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(req, _signal) {
      var protocol, error, controller, timer, init, resp, headers, respBody, body;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            (0, errors_js_1.assert)(_signal == null || !_signal.cancelled, "request cancelled before sending", "CANCELLED");
            protocol = req.url.split(":")[0].toLowerCase();
            (0, errors_js_1.assert)(protocol === "http" || protocol === "https", "unsupported protocol ".concat(protocol), "UNSUPPORTED_OPERATION", {
              info: {
                protocol: protocol
              },
              operation: "request"
            });
            (0, errors_js_1.assert)(protocol === "https" || !req.credentials || req.allowInsecureAuthentication, "insecure authorized connections unsupported", "UNSUPPORTED_OPERATION", {
              operation: "request"
            });
            error = null;
            controller = new AbortController();
            timer = setTimeout(function () {
              error = (0, errors_js_1.makeError)("request timeout", "TIMEOUT");
              controller.abort();
            }, req.timeout);
            if (_signal) {
              _signal.addListener(function () {
                error = (0, errors_js_1.makeError)("request cancelled", "CANCELLED");
                controller.abort();
              });
            }
            init = {
              method: req.method,
              headers: new Headers(Array.from(req)),
              body: req.body || undefined,
              signal: controller.signal
            };
            _context.prev = 9;
            _context.next = 12;
            return fetch(req.url, init);
          case 12:
            resp = _context.sent;
            _context.next = 21;
            break;
          case 15:
            _context.prev = 15;
            _context.t0 = _context["catch"](9);
            clearTimeout(timer);
            if (!error) {
              _context.next = 20;
              break;
            }
            throw error;
          case 20:
            throw _context.t0;
          case 21:
            clearTimeout(timer);
            headers = {};
            resp.headers.forEach(function (value, key) {
              headers[key.toLowerCase()] = value;
            });
            _context.next = 26;
            return resp.arrayBuffer();
          case 26:
            respBody = _context.sent;
            body = respBody == null ? null : new Uint8Array(respBody);
            return _context.abrupt("return", {
              statusCode: resp.status,
              statusMessage: resp.statusText,
              headers: headers,
              body: body
            });
          case 29:
          case "end":
            return _context.stop();
        }
      }, _callee, null, [[9, 15]]);
    }));
    return _getUrl.apply(this, arguments);
  }
  return getUrl;
}
exports.createGetUrl = createGetUrl;
// @TODO: remove in v7; provided for backwards compat
var defaultGetUrl = createGetUrl({});
function getUrl(_x3, _x4) {
  return _getUrl2.apply(this, arguments);
}
function _getUrl2() {
  _getUrl2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(req, _signal) {
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          return _context2.abrupt("return", defaultGetUrl(req, _signal));
        case 1:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
  return _getUrl2.apply(this, arguments);
}
exports.getUrl = getUrl;

},{"./errors.js":271}],276:[function(require,module,exports){
"use strict";

/**
 *  There are many simple utilities required to interact with
 *  Ethereum and to simplify the library, without increasing
 *  the library dependencies for simple functions.
 *
 *  @_section api/utils:Utilities  [about-utils]
 */
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toUtf8String = exports.toUtf8CodePoints = exports.toUtf8Bytes = exports.parseUnits = exports.formatUnits = exports.parseEther = exports.formatEther = exports.encodeRlp = exports.decodeRlp = exports.defineProperties = exports.resolveProperties = exports.toQuantity = exports.toBeArray = exports.toBeHex = exports.toNumber = exports.toBigInt = exports.getUint = exports.getNumber = exports.getBigInt = exports.mask = exports.toTwos = exports.fromTwos = exports.FixedNumber = exports.FetchCancelSignal = exports.FetchResponse = exports.FetchRequest = exports.EventPayload = exports.makeError = exports.assertNormalize = exports.assertPrivate = exports.assertArgumentCount = exports.assertArgument = exports.assert = exports.isError = exports.isCallException = exports.zeroPadBytes = exports.zeroPadValue = exports.stripZerosLeft = exports.dataSlice = exports.dataLength = exports.concat = exports.hexlify = exports.isBytesLike = exports.isHexString = exports.getBytesCopy = exports.getBytes = exports.encodeBase64 = exports.decodeBase64 = exports.encodeBase58 = exports.decodeBase58 = void 0;
exports.uuidV4 = exports.Utf8ErrorFuncs = void 0;
var base58_js_1 = require("./base58.js");
Object.defineProperty(exports, "decodeBase58", {
  enumerable: true,
  get: function get() {
    return base58_js_1.decodeBase58;
  }
});
Object.defineProperty(exports, "encodeBase58", {
  enumerable: true,
  get: function get() {
    return base58_js_1.encodeBase58;
  }
});
var base64_js_1 = require("./base64.js");
Object.defineProperty(exports, "decodeBase64", {
  enumerable: true,
  get: function get() {
    return base64_js_1.decodeBase64;
  }
});
Object.defineProperty(exports, "encodeBase64", {
  enumerable: true,
  get: function get() {
    return base64_js_1.encodeBase64;
  }
});
var data_js_1 = require("./data.js");
Object.defineProperty(exports, "getBytes", {
  enumerable: true,
  get: function get() {
    return data_js_1.getBytes;
  }
});
Object.defineProperty(exports, "getBytesCopy", {
  enumerable: true,
  get: function get() {
    return data_js_1.getBytesCopy;
  }
});
Object.defineProperty(exports, "isHexString", {
  enumerable: true,
  get: function get() {
    return data_js_1.isHexString;
  }
});
Object.defineProperty(exports, "isBytesLike", {
  enumerable: true,
  get: function get() {
    return data_js_1.isBytesLike;
  }
});
Object.defineProperty(exports, "hexlify", {
  enumerable: true,
  get: function get() {
    return data_js_1.hexlify;
  }
});
Object.defineProperty(exports, "concat", {
  enumerable: true,
  get: function get() {
    return data_js_1.concat;
  }
});
Object.defineProperty(exports, "dataLength", {
  enumerable: true,
  get: function get() {
    return data_js_1.dataLength;
  }
});
Object.defineProperty(exports, "dataSlice", {
  enumerable: true,
  get: function get() {
    return data_js_1.dataSlice;
  }
});
Object.defineProperty(exports, "stripZerosLeft", {
  enumerable: true,
  get: function get() {
    return data_js_1.stripZerosLeft;
  }
});
Object.defineProperty(exports, "zeroPadValue", {
  enumerable: true,
  get: function get() {
    return data_js_1.zeroPadValue;
  }
});
Object.defineProperty(exports, "zeroPadBytes", {
  enumerable: true,
  get: function get() {
    return data_js_1.zeroPadBytes;
  }
});
var errors_js_1 = require("./errors.js");
Object.defineProperty(exports, "isCallException", {
  enumerable: true,
  get: function get() {
    return errors_js_1.isCallException;
  }
});
Object.defineProperty(exports, "isError", {
  enumerable: true,
  get: function get() {
    return errors_js_1.isError;
  }
});
Object.defineProperty(exports, "assert", {
  enumerable: true,
  get: function get() {
    return errors_js_1.assert;
  }
});
Object.defineProperty(exports, "assertArgument", {
  enumerable: true,
  get: function get() {
    return errors_js_1.assertArgument;
  }
});
Object.defineProperty(exports, "assertArgumentCount", {
  enumerable: true,
  get: function get() {
    return errors_js_1.assertArgumentCount;
  }
});
Object.defineProperty(exports, "assertPrivate", {
  enumerable: true,
  get: function get() {
    return errors_js_1.assertPrivate;
  }
});
Object.defineProperty(exports, "assertNormalize", {
  enumerable: true,
  get: function get() {
    return errors_js_1.assertNormalize;
  }
});
Object.defineProperty(exports, "makeError", {
  enumerable: true,
  get: function get() {
    return errors_js_1.makeError;
  }
});
var events_js_1 = require("./events.js");
Object.defineProperty(exports, "EventPayload", {
  enumerable: true,
  get: function get() {
    return events_js_1.EventPayload;
  }
});
var fetch_js_1 = require("./fetch.js");
Object.defineProperty(exports, "FetchRequest", {
  enumerable: true,
  get: function get() {
    return fetch_js_1.FetchRequest;
  }
});
Object.defineProperty(exports, "FetchResponse", {
  enumerable: true,
  get: function get() {
    return fetch_js_1.FetchResponse;
  }
});
Object.defineProperty(exports, "FetchCancelSignal", {
  enumerable: true,
  get: function get() {
    return fetch_js_1.FetchCancelSignal;
  }
});
var fixednumber_js_1 = require("./fixednumber.js");
Object.defineProperty(exports, "FixedNumber", {
  enumerable: true,
  get: function get() {
    return fixednumber_js_1.FixedNumber;
  }
});
var maths_js_1 = require("./maths.js");
Object.defineProperty(exports, "fromTwos", {
  enumerable: true,
  get: function get() {
    return maths_js_1.fromTwos;
  }
});
Object.defineProperty(exports, "toTwos", {
  enumerable: true,
  get: function get() {
    return maths_js_1.toTwos;
  }
});
Object.defineProperty(exports, "mask", {
  enumerable: true,
  get: function get() {
    return maths_js_1.mask;
  }
});
Object.defineProperty(exports, "getBigInt", {
  enumerable: true,
  get: function get() {
    return maths_js_1.getBigInt;
  }
});
Object.defineProperty(exports, "getNumber", {
  enumerable: true,
  get: function get() {
    return maths_js_1.getNumber;
  }
});
Object.defineProperty(exports, "getUint", {
  enumerable: true,
  get: function get() {
    return maths_js_1.getUint;
  }
});
Object.defineProperty(exports, "toBigInt", {
  enumerable: true,
  get: function get() {
    return maths_js_1.toBigInt;
  }
});
Object.defineProperty(exports, "toNumber", {
  enumerable: true,
  get: function get() {
    return maths_js_1.toNumber;
  }
});
Object.defineProperty(exports, "toBeHex", {
  enumerable: true,
  get: function get() {
    return maths_js_1.toBeHex;
  }
});
Object.defineProperty(exports, "toBeArray", {
  enumerable: true,
  get: function get() {
    return maths_js_1.toBeArray;
  }
});
Object.defineProperty(exports, "toQuantity", {
  enumerable: true,
  get: function get() {
    return maths_js_1.toQuantity;
  }
});
var properties_js_1 = require("./properties.js");
Object.defineProperty(exports, "resolveProperties", {
  enumerable: true,
  get: function get() {
    return properties_js_1.resolveProperties;
  }
});
Object.defineProperty(exports, "defineProperties", {
  enumerable: true,
  get: function get() {
    return properties_js_1.defineProperties;
  }
});
var rlp_decode_js_1 = require("./rlp-decode.js");
Object.defineProperty(exports, "decodeRlp", {
  enumerable: true,
  get: function get() {
    return rlp_decode_js_1.decodeRlp;
  }
});
var rlp_encode_js_1 = require("./rlp-encode.js");
Object.defineProperty(exports, "encodeRlp", {
  enumerable: true,
  get: function get() {
    return rlp_encode_js_1.encodeRlp;
  }
});
var units_js_1 = require("./units.js");
Object.defineProperty(exports, "formatEther", {
  enumerable: true,
  get: function get() {
    return units_js_1.formatEther;
  }
});
Object.defineProperty(exports, "parseEther", {
  enumerable: true,
  get: function get() {
    return units_js_1.parseEther;
  }
});
Object.defineProperty(exports, "formatUnits", {
  enumerable: true,
  get: function get() {
    return units_js_1.formatUnits;
  }
});
Object.defineProperty(exports, "parseUnits", {
  enumerable: true,
  get: function get() {
    return units_js_1.parseUnits;
  }
});
var utf8_js_1 = require("./utf8.js");
Object.defineProperty(exports, "toUtf8Bytes", {
  enumerable: true,
  get: function get() {
    return utf8_js_1.toUtf8Bytes;
  }
});
Object.defineProperty(exports, "toUtf8CodePoints", {
  enumerable: true,
  get: function get() {
    return utf8_js_1.toUtf8CodePoints;
  }
});
Object.defineProperty(exports, "toUtf8String", {
  enumerable: true,
  get: function get() {
    return utf8_js_1.toUtf8String;
  }
});
Object.defineProperty(exports, "Utf8ErrorFuncs", {
  enumerable: true,
  get: function get() {
    return utf8_js_1.Utf8ErrorFuncs;
  }
});
var uuid_js_1 = require("./uuid.js");
Object.defineProperty(exports, "uuidV4", {
  enumerable: true,
  get: function get() {
    return uuid_js_1.uuidV4;
  }
});

},{"./base58.js":268,"./base64.js":269,"./data.js":270,"./errors.js":271,"./events.js":272,"./fetch.js":273,"./fixednumber.js":274,"./maths.js":277,"./properties.js":278,"./rlp-decode.js":279,"./rlp-encode.js":280,"./units.js":281,"./utf8.js":282,"./uuid.js":283}],277:[function(require,module,exports){
"use strict";

function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toQuantity = exports.toBeArray = exports.toBeHex = exports.toNumber = exports.getNumber = exports.toBigInt = exports.getUint = exports.getBigInt = exports.mask = exports.toTwos = exports.fromTwos = void 0;
/**
 *  Some mathematic operations.
 *
 *  @_subsection: api/utils:Math Helpers  [about-maths]
 */
var data_js_1 = require("./data.js");
var errors_js_1 = require("./errors.js");
var BN_0 = BigInt(0);
var BN_1 = BigInt(1);
//const BN_Max256 = (BN_1 << BigInt(256)) - BN_1;
// IEEE 754 support 53-bits of mantissa
var maxValue = 0x1fffffffffffff;
/**
 *  Convert %%value%% from a twos-compliment representation of %%width%%
 *  bits to its value.
 *
 *  If the highest bit is ``1``, the result will be negative.
 */
function fromTwos(_value, _width) {
  var value = getUint(_value, "value");
  var width = BigInt(getNumber(_width, "width"));
  (0, errors_js_1.assert)(value >> width === BN_0, "overflow", "NUMERIC_FAULT", {
    operation: "fromTwos",
    fault: "overflow",
    value: _value
  });
  // Top bit set; treat as a negative value
  if (value >> width - BN_1) {
    var _mask = (BN_1 << width) - BN_1;
    return -((~value & _mask) + BN_1);
  }
  return value;
}
exports.fromTwos = fromTwos;
/**
 *  Convert %%value%% to a twos-compliment representation of
 *  %%width%% bits.
 *
 *  The result will always be positive.
 */
function toTwos(_value, _width) {
  var value = getBigInt(_value, "value");
  var width = BigInt(getNumber(_width, "width"));
  var limit = BN_1 << width - BN_1;
  if (value < BN_0) {
    value = -value;
    (0, errors_js_1.assert)(value <= limit, "too low", "NUMERIC_FAULT", {
      operation: "toTwos",
      fault: "overflow",
      value: _value
    });
    var _mask2 = (BN_1 << width) - BN_1;
    return (~value & _mask2) + BN_1;
  } else {
    (0, errors_js_1.assert)(value < limit, "too high", "NUMERIC_FAULT", {
      operation: "toTwos",
      fault: "overflow",
      value: _value
    });
  }
  return value;
}
exports.toTwos = toTwos;
/**
 *  Mask %%value%% with a bitmask of %%bits%% ones.
 */
function mask(_value, _bits) {
  var value = getUint(_value, "value");
  var bits = BigInt(getNumber(_bits, "bits"));
  return value & (BN_1 << bits) - BN_1;
}
exports.mask = mask;
/**
 *  Gets a BigInt from %%value%%. If it is an invalid value for
 *  a BigInt, then an ArgumentError will be thrown for %%name%%.
 */
function getBigInt(value, name) {
  switch (_typeof(value)) {
    case "bigint":
      return value;
    case "number":
      (0, errors_js_1.assertArgument)(Number.isInteger(value), "underflow", name || "value", value);
      (0, errors_js_1.assertArgument)(value >= -maxValue && value <= maxValue, "overflow", name || "value", value);
      return BigInt(value);
    case "string":
      try {
        if (value === "") {
          throw new Error("empty string");
        }
        if (value[0] === "-" && value[1] !== "-") {
          return -BigInt(value.substring(1));
        }
        return BigInt(value);
      } catch (e) {
        (0, errors_js_1.assertArgument)(false, "invalid BigNumberish string: ".concat(e.message), name || "value", value);
      }
  }
  (0, errors_js_1.assertArgument)(false, "invalid BigNumberish value", name || "value", value);
}
exports.getBigInt = getBigInt;
/**
 *  Returns %%value%% as a bigint, validating it is valid as a bigint
 *  value and that it is positive.
 */
function getUint(value, name) {
  var result = getBigInt(value, name);
  (0, errors_js_1.assert)(result >= BN_0, "unsigned value cannot be negative", "NUMERIC_FAULT", {
    fault: "overflow",
    operation: "getUint",
    value: value
  });
  return result;
}
exports.getUint = getUint;
var Nibbles = "0123456789abcdef";
/*
 * Converts %%value%% to a BigInt. If %%value%% is a Uint8Array, it
 * is treated as Big Endian data.
 */
function toBigInt(value) {
  if (value instanceof Uint8Array) {
    var result = "0x0";
    var _iterator = _createForOfIteratorHelper(value),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var v = _step.value;
        result += Nibbles[v >> 4];
        result += Nibbles[v & 0x0f];
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    return BigInt(result);
  }
  return getBigInt(value);
}
exports.toBigInt = toBigInt;
/**
 *  Gets a //number// from %%value%%. If it is an invalid value for
 *  a //number//, then an ArgumentError will be thrown for %%name%%.
 */
function getNumber(value, name) {
  switch (_typeof(value)) {
    case "bigint":
      (0, errors_js_1.assertArgument)(value >= -maxValue && value <= maxValue, "overflow", name || "value", value);
      return Number(value);
    case "number":
      (0, errors_js_1.assertArgument)(Number.isInteger(value), "underflow", name || "value", value);
      (0, errors_js_1.assertArgument)(value >= -maxValue && value <= maxValue, "overflow", name || "value", value);
      return value;
    case "string":
      try {
        if (value === "") {
          throw new Error("empty string");
        }
        return getNumber(BigInt(value), name);
      } catch (e) {
        (0, errors_js_1.assertArgument)(false, "invalid numeric string: ".concat(e.message), name || "value", value);
      }
  }
  (0, errors_js_1.assertArgument)(false, "invalid numeric value", name || "value", value);
}
exports.getNumber = getNumber;
/**
 *  Converts %%value%% to a number. If %%value%% is a Uint8Array, it
 *  is treated as Big Endian data. Throws if the value is not safe.
 */
function toNumber(value) {
  return getNumber(toBigInt(value));
}
exports.toNumber = toNumber;
/**
 *  Converts %%value%% to a Big Endian hexstring, optionally padded to
 *  %%width%% bytes.
 */
function toBeHex(_value, _width) {
  var value = getUint(_value, "value");
  var result = value.toString(16);
  if (_width == null) {
    // Ensure the value is of even length
    if (result.length % 2) {
      result = "0" + result;
    }
  } else {
    var width = getNumber(_width, "width");
    (0, errors_js_1.assert)(width * 2 >= result.length, "value exceeds width (".concat(width, " bytes)"), "NUMERIC_FAULT", {
      operation: "toBeHex",
      fault: "overflow",
      value: _value
    });
    // Pad the value to the required width
    while (result.length < width * 2) {
      result = "0" + result;
    }
  }
  return "0x" + result;
}
exports.toBeHex = toBeHex;
/**
 *  Converts %%value%% to a Big Endian Uint8Array.
 */
function toBeArray(_value) {
  var value = getUint(_value, "value");
  if (value === BN_0) {
    return new Uint8Array([]);
  }
  var hex = value.toString(16);
  if (hex.length % 2) {
    hex = "0" + hex;
  }
  var result = new Uint8Array(hex.length / 2);
  for (var i = 0; i < result.length; i++) {
    var offset = i * 2;
    result[i] = parseInt(hex.substring(offset, offset + 2), 16);
  }
  return result;
}
exports.toBeArray = toBeArray;
/**
 *  Returns a [[HexString]] for %%value%% safe to use as a //Quantity//.
 *
 *  A //Quantity// does not have and leading 0 values unless the value is
 *  the literal value `0x0`. This is most commonly used for JSSON-RPC
 *  numeric values.
 */
function toQuantity(value) {
  var result = (0, data_js_1.hexlify)((0, data_js_1.isBytesLike)(value) ? value : toBeArray(value)).substring(2);
  while (result.startsWith("0")) {
    result = result.substring(1);
  }
  if (result === "") {
    result = "0";
  }
  return "0x" + result;
}
exports.toQuantity = toQuantity;

},{"./data.js":270,"./errors.js":271}],278:[function(require,module,exports){
"use strict";

/**
 *  Property helper functions.
 *
 *  @_subsection api/utils:Properties  [about-properties]
 */
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.defineProperties = exports.resolveProperties = void 0;
function checkType(value, type, name) {
  var types = type.split("|").map(function (t) {
    return t.trim();
  });
  for (var i = 0; i < types.length; i++) {
    switch (type) {
      case "any":
        return;
      case "bigint":
      case "boolean":
      case "number":
      case "string":
        if (_typeof(value) === type) {
          return;
        }
    }
  }
  var error = new Error("invalid value for type ".concat(type));
  error.code = "INVALID_ARGUMENT";
  error.argument = "value.".concat(name);
  error.value = value;
  throw error;
}
/**
 *  Resolves to a new object that is a copy of %%value%%, but with all
 *  values resolved.
 */
function resolveProperties(_x) {
  return _resolveProperties.apply(this, arguments);
}
function _resolveProperties() {
  _resolveProperties = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(value) {
    var keys, results;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          keys = Object.keys(value);
          _context.next = 3;
          return Promise.all(keys.map(function (k) {
            return Promise.resolve(value[k]);
          }));
        case 3:
          results = _context.sent;
          return _context.abrupt("return", results.reduce(function (accum, v, index) {
            accum[keys[index]] = v;
            return accum;
          }, {}));
        case 5:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return _resolveProperties.apply(this, arguments);
}
exports.resolveProperties = resolveProperties;
/**
 *  Assigns the %%values%% to %%target%% as read-only values.
 *
 *  It %%types%% is specified, the values are checked.
 */
function defineProperties(target, values, types) {
  for (var key in values) {
    var value = values[key];
    var type = types ? types[key] : null;
    if (type) {
      checkType(value, type, key);
    }
    Object.defineProperty(target, key, {
      enumerable: true,
      value: value,
      writable: false
    });
  }
}
exports.defineProperties = defineProperties;

},{}],279:[function(require,module,exports){
"use strict";

//See: https://github.com/ethereum/wiki/wiki/RLP
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.decodeRlp = void 0;
var data_js_1 = require("./data.js");
var errors_js_1 = require("./errors.js");
var data_js_2 = require("./data.js");
function hexlifyByte(value) {
  var result = value.toString(16);
  while (result.length < 2) {
    result = "0" + result;
  }
  return "0x" + result;
}
function unarrayifyInteger(data, offset, length) {
  var result = 0;
  for (var i = 0; i < length; i++) {
    result = result * 256 + data[offset + i];
  }
  return result;
}
function _decodeChildren(data, offset, childOffset, length) {
  var result = [];
  while (childOffset < offset + 1 + length) {
    var decoded = _decode(data, childOffset);
    result.push(decoded.result);
    childOffset += decoded.consumed;
    (0, errors_js_1.assert)(childOffset <= offset + 1 + length, "child data too short", "BUFFER_OVERRUN", {
      buffer: data,
      length: length,
      offset: offset
    });
  }
  return {
    consumed: 1 + length,
    result: result
  };
}
// returns { consumed: number, result: Object }
function _decode(data, offset) {
  (0, errors_js_1.assert)(data.length !== 0, "data too short", "BUFFER_OVERRUN", {
    buffer: data,
    length: 0,
    offset: 1
  });
  var checkOffset = function checkOffset(offset) {
    (0, errors_js_1.assert)(offset <= data.length, "data short segment too short", "BUFFER_OVERRUN", {
      buffer: data,
      length: data.length,
      offset: offset
    });
  };
  // Array with extra length prefix
  if (data[offset] >= 0xf8) {
    var lengthLength = data[offset] - 0xf7;
    checkOffset(offset + 1 + lengthLength);
    var length = unarrayifyInteger(data, offset + 1, lengthLength);
    checkOffset(offset + 1 + lengthLength + length);
    return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);
  } else if (data[offset] >= 0xc0) {
    var _length = data[offset] - 0xc0;
    checkOffset(offset + 1 + _length);
    return _decodeChildren(data, offset, offset + 1, _length);
  } else if (data[offset] >= 0xb8) {
    var _lengthLength = data[offset] - 0xb7;
    checkOffset(offset + 1 + _lengthLength);
    var _length2 = unarrayifyInteger(data, offset + 1, _lengthLength);
    checkOffset(offset + 1 + _lengthLength + _length2);
    var result = (0, data_js_1.hexlify)(data.slice(offset + 1 + _lengthLength, offset + 1 + _lengthLength + _length2));
    return {
      consumed: 1 + _lengthLength + _length2,
      result: result
    };
  } else if (data[offset] >= 0x80) {
    var _length3 = data[offset] - 0x80;
    checkOffset(offset + 1 + _length3);
    var _result = (0, data_js_1.hexlify)(data.slice(offset + 1, offset + 1 + _length3));
    return {
      consumed: 1 + _length3,
      result: _result
    };
  }
  return {
    consumed: 1,
    result: hexlifyByte(data[offset])
  };
}
/**
 *  Decodes %%data%% into the structured data it represents.
 */
function decodeRlp(_data) {
  var data = (0, data_js_2.getBytes)(_data, "data");
  var decoded = _decode(data, 0);
  (0, errors_js_1.assertArgument)(decoded.consumed === data.length, "unexpected junk after rlp payload", "data", _data);
  return decoded.result;
}
exports.decodeRlp = decodeRlp;

},{"./data.js":270,"./errors.js":271}],280:[function(require,module,exports){
"use strict";

//See: https://github.com/ethereum/wiki/wiki/RLP
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.encodeRlp = void 0;
var data_js_1 = require("./data.js");
function arrayifyInteger(value) {
  var result = [];
  while (value) {
    result.unshift(value & 0xff);
    value >>= 8;
  }
  return result;
}
function _encode(object) {
  if (Array.isArray(object)) {
    var payload = [];
    object.forEach(function (child) {
      payload = payload.concat(_encode(child));
    });
    if (payload.length <= 55) {
      payload.unshift(0xc0 + payload.length);
      return payload;
    }
    var _length = arrayifyInteger(payload.length);
    _length.unshift(0xf7 + _length.length);
    return _length.concat(payload);
  }
  var data = Array.prototype.slice.call((0, data_js_1.getBytes)(object, "object"));
  if (data.length === 1 && data[0] <= 0x7f) {
    return data;
  } else if (data.length <= 55) {
    data.unshift(0x80 + data.length);
    return data;
  }
  var length = arrayifyInteger(data.length);
  length.unshift(0xb7 + length.length);
  return length.concat(data);
}
var nibbles = "0123456789abcdef";
/**
 *  Encodes %%object%% as an RLP-encoded [[DataHexString]].
 */
function encodeRlp(object) {
  var result = "0x";
  var _iterator = _createForOfIteratorHelper(_encode(object)),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var v = _step.value;
      result += nibbles[v >> 4];
      result += nibbles[v & 0xf];
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return result;
}
exports.encodeRlp = encodeRlp;

},{"./data.js":270}],281:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseEther = exports.formatEther = exports.parseUnits = exports.formatUnits = void 0;
/**
 *  Most interactions with Ethereum requires integer values, which use
 *  the smallest magnitude unit.
 *
 *  For example, imagine dealing with dollars and cents. Since dollars
 *  are divisible, non-integer values are possible, such as ``$10.77``.
 *  By using the smallest indivisible unit (i.e. cents), the value can
 *  be kept as the integer ``1077``.
 *
 *  When receiving decimal input from the user (as a decimal string),
 *  the value should be converted to an integer and when showing a user
 *  a value, the integer value should be converted to a decimal string.
 *
 *  This creates a clear distinction, between values to be used by code
 *  (integers) and values used for display logic to users (decimals).
 *
 *  The native unit in Ethereum, //ether// is divisible to 18 decimal places,
 *  where each individual unit is called a //wei//.
 *
 *  @_subsection api/utils:Unit Conversion  [about-units]
 */
var errors_js_1 = require("./errors.js");
var fixednumber_js_1 = require("./fixednumber.js");
var maths_js_1 = require("./maths.js");
var names = ["wei", "kwei", "mwei", "gwei", "szabo", "finney", "ether"];
/**
 *  Converts %%value%% into a //decimal string//, assuming %%unit%% decimal
 *  places. The %%unit%% may be the number of decimal places or the name of
 *  a unit (e.g. ``"gwei"`` for 9 decimal places).
 *
 */
function formatUnits(value, unit) {
  var decimals = 18;
  if (typeof unit === "string") {
    var index = names.indexOf(unit);
    (0, errors_js_1.assertArgument)(index >= 0, "invalid unit", "unit", unit);
    decimals = 3 * index;
  } else if (unit != null) {
    decimals = (0, maths_js_1.getNumber)(unit, "unit");
  }
  return fixednumber_js_1.FixedNumber.fromValue(value, decimals, {
    decimals: decimals,
    width: 512
  }).toString();
}
exports.formatUnits = formatUnits;
/**
 *  Converts the //decimal string// %%value%% to a BigInt, assuming
 *  %%unit%% decimal places. The %%unit%% may the number of decimal places
 *  or the name of a unit (e.g. ``"gwei"`` for 9 decimal places).
 */
function parseUnits(value, unit) {
  (0, errors_js_1.assertArgument)(typeof value === "string", "value must be a string", "value", value);
  var decimals = 18;
  if (typeof unit === "string") {
    var index = names.indexOf(unit);
    (0, errors_js_1.assertArgument)(index >= 0, "invalid unit", "unit", unit);
    decimals = 3 * index;
  } else if (unit != null) {
    decimals = (0, maths_js_1.getNumber)(unit, "unit");
  }
  return fixednumber_js_1.FixedNumber.fromString(value, {
    decimals: decimals,
    width: 512
  }).value;
}
exports.parseUnits = parseUnits;
/**
 *  Converts %%value%% into a //decimal string// using 18 decimal places.
 */
function formatEther(wei) {
  return formatUnits(wei, 18);
}
exports.formatEther = formatEther;
/**
 *  Converts the //decimal string// %%ether%% to a BigInt, using 18
 *  decimal places.
 */
function parseEther(ether) {
  return parseUnits(ether, 18);
}
exports.parseEther = parseEther;

},{"./errors.js":271,"./fixednumber.js":274,"./maths.js":277}],282:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toUtf8CodePoints = exports.toUtf8String = exports.toUtf8Bytes = exports.Utf8ErrorFuncs = void 0;
/**
 *  Using strings in Ethereum (or any security-basd system) requires
 *  additional care. These utilities attempt to mitigate some of the
 *  safety issues as well as provide the ability to recover and analyse
 *  strings.
 *
 *  @_subsection api/utils:Strings and UTF-8  [about-strings]
 */
var data_js_1 = require("./data.js");
var errors_js_1 = require("./errors.js");
function errorFunc(reason, offset, bytes, output, badCodepoint) {
  (0, errors_js_1.assertArgument)(false, "invalid codepoint at offset ".concat(offset, "; ").concat(reason), "bytes", bytes);
}
function ignoreFunc(reason, offset, bytes, output, badCodepoint) {
  // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes
  if (reason === "BAD_PREFIX" || reason === "UNEXPECTED_CONTINUE") {
    var i = 0;
    for (var o = offset + 1; o < bytes.length; o++) {
      if (bytes[o] >> 6 !== 0x02) {
        break;
      }
      i++;
    }
    return i;
  }
  // This byte runs us past the end of the string, so just jump to the end
  // (but the first byte was read already read and therefore skipped)
  if (reason === "OVERRUN") {
    return bytes.length - offset - 1;
  }
  // Nothing to skip
  return 0;
}
function replaceFunc(reason, offset, bytes, output, badCodepoint) {
  // Overlong representations are otherwise "valid" code points; just non-deistingtished
  if (reason === "OVERLONG") {
    (0, errors_js_1.assertArgument)(typeof badCodepoint === "number", "invalid bad code point for replacement", "badCodepoint", badCodepoint);
    output.push(badCodepoint);
    return 0;
  }
  // Put the replacement character into the output
  output.push(0xfffd);
  // Otherwise, process as if ignoring errors
  return ignoreFunc(reason, offset, bytes, output, badCodepoint);
}
/**
 *  A handful of popular, built-in UTF-8 error handling strategies.
 *
 *  **``"error"``** - throws on ANY illegal UTF-8 sequence or
 *  non-canonical (overlong) codepoints (this is the default)
 *
 *  **``"ignore"``** - silently drops any illegal UTF-8 sequence
 *  and accepts non-canonical (overlong) codepoints
 *
 *  **``"replace"``** - replace any illegal UTF-8 sequence with the
 *  UTF-8 replacement character (i.e. ``"\\ufffd"``) and accepts
 *  non-canonical (overlong) codepoints
 *
 *  @returns: Record<"error" | "ignore" | "replace", Utf8ErrorFunc>
 */
exports.Utf8ErrorFuncs = Object.freeze({
  error: errorFunc,
  ignore: ignoreFunc,
  replace: replaceFunc
});
// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499
function getUtf8CodePoints(_bytes, onError) {
  if (onError == null) {
    onError = exports.Utf8ErrorFuncs.error;
  }
  var bytes = (0, data_js_1.getBytes)(_bytes, "bytes");
  var result = [];
  var i = 0;
  // Invalid bytes are ignored
  while (i < bytes.length) {
    var c = bytes[i++];
    // 0xxx xxxx
    if (c >> 7 === 0) {
      result.push(c);
      continue;
    }
    // Multibyte; how many bytes left for this character?
    var extraLength = null;
    var overlongMask = null;
    // 110x xxxx 10xx xxxx
    if ((c & 0xe0) === 0xc0) {
      extraLength = 1;
      overlongMask = 0x7f;
      // 1110 xxxx 10xx xxxx 10xx xxxx
    } else if ((c & 0xf0) === 0xe0) {
      extraLength = 2;
      overlongMask = 0x7ff;
      // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx
    } else if ((c & 0xf8) === 0xf0) {
      extraLength = 3;
      overlongMask = 0xffff;
    } else {
      if ((c & 0xc0) === 0x80) {
        i += onError("UNEXPECTED_CONTINUE", i - 1, bytes, result);
      } else {
        i += onError("BAD_PREFIX", i - 1, bytes, result);
      }
      continue;
    }
    // Do we have enough bytes in our data?
    if (i - 1 + extraLength >= bytes.length) {
      i += onError("OVERRUN", i - 1, bytes, result);
      continue;
    }
    // Remove the length prefix from the char
    var res = c & (1 << 8 - extraLength - 1) - 1;
    for (var j = 0; j < extraLength; j++) {
      var nextChar = bytes[i];
      // Invalid continuation byte
      if ((nextChar & 0xc0) != 0x80) {
        i += onError("MISSING_CONTINUE", i, bytes, result);
        res = null;
        break;
      }
      ;
      res = res << 6 | nextChar & 0x3f;
      i++;
    }
    // See above loop for invalid continuation byte
    if (res === null) {
      continue;
    }
    // Maximum code point
    if (res > 0x10ffff) {
      i += onError("OUT_OF_RANGE", i - 1 - extraLength, bytes, result, res);
      continue;
    }
    // Reserved for UTF-16 surrogate halves
    if (res >= 0xd800 && res <= 0xdfff) {
      i += onError("UTF16_SURROGATE", i - 1 - extraLength, bytes, result, res);
      continue;
    }
    // Check for overlong sequences (more bytes than needed)
    if (res <= overlongMask) {
      i += onError("OVERLONG", i - 1 - extraLength, bytes, result, res);
      continue;
    }
    result.push(res);
  }
  return result;
}
// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array
/**
 *  Returns the UTF-8 byte representation of %%str%%.
 *
 *  If %%form%% is specified, the string is normalized.
 */
function toUtf8Bytes(str, form) {
  (0, errors_js_1.assertArgument)(typeof str === "string", "invalid string value", "str", str);
  if (form != null) {
    (0, errors_js_1.assertNormalize)(form);
    str = str.normalize(form);
  }
  var result = [];
  for (var i = 0; i < str.length; i++) {
    var c = str.charCodeAt(i);
    if (c < 0x80) {
      result.push(c);
    } else if (c < 0x800) {
      result.push(c >> 6 | 0xc0);
      result.push(c & 0x3f | 0x80);
    } else if ((c & 0xfc00) == 0xd800) {
      i++;
      var c2 = str.charCodeAt(i);
      (0, errors_js_1.assertArgument)(i < str.length && (c2 & 0xfc00) === 0xdc00, "invalid surrogate pair", "str", str);
      // Surrogate Pair
      var pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);
      result.push(pair >> 18 | 0xf0);
      result.push(pair >> 12 & 0x3f | 0x80);
      result.push(pair >> 6 & 0x3f | 0x80);
      result.push(pair & 0x3f | 0x80);
    } else {
      result.push(c >> 12 | 0xe0);
      result.push(c >> 6 & 0x3f | 0x80);
      result.push(c & 0x3f | 0x80);
    }
  }
  return new Uint8Array(result);
}
exports.toUtf8Bytes = toUtf8Bytes;
;
//export 
function _toUtf8String(codePoints) {
  return codePoints.map(function (codePoint) {
    if (codePoint <= 0xffff) {
      return String.fromCharCode(codePoint);
    }
    codePoint -= 0x10000;
    return String.fromCharCode((codePoint >> 10 & 0x3ff) + 0xd800, (codePoint & 0x3ff) + 0xdc00);
  }).join("");
}
/**
 *  Returns the string represented by the UTF-8 data %%bytes%%.
 *
 *  When %%onError%% function is specified, it is called on UTF-8
 *  errors allowing recovery using the [[Utf8ErrorFunc]] API.
 *  (default: [error](Utf8ErrorFuncs))
 */
function toUtf8String(bytes, onError) {
  return _toUtf8String(getUtf8CodePoints(bytes, onError));
}
exports.toUtf8String = toUtf8String;
/**
 *  Returns the UTF-8 code-points for %%str%%.
 *
 *  If %%form%% is specified, the string is normalized.
 */
function toUtf8CodePoints(str, form) {
  return getUtf8CodePoints(toUtf8Bytes(str, form));
}
exports.toUtf8CodePoints = toUtf8CodePoints;

},{"./data.js":270,"./errors.js":271}],283:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.uuidV4 = void 0;
/**
 *  Explain UUID and link to RFC here.
 *
 *  @_subsection: api/utils:UUID  [about-uuid]
 */
var data_js_1 = require("./data.js");
/**
 *  Returns the version 4 [[link-uuid]] for the %%randomBytes%%.
 *
 *  @see: https://www.ietf.org/rfc/rfc4122.txt (Section 4.4)
 */
function uuidV4(randomBytes) {
  var bytes = (0, data_js_1.getBytes)(randomBytes, "randomBytes");
  // Section: 4.1.3:
  // - time_hi_and_version[12:16] = 0b0100
  bytes[6] = bytes[6] & 0x0f | 0x40;
  // Section 4.4
  // - clock_seq_hi_and_reserved[6] = 0b0
  // - clock_seq_hi_and_reserved[7] = 0b1
  bytes[8] = bytes[8] & 0x3f | 0x80;
  var value = (0, data_js_1.hexlify)(bytes);
  return [value.substring(2, 10), value.substring(10, 14), value.substring(14, 18), value.substring(18, 22), value.substring(22, 34)].join("-");
}
exports.uuidV4 = uuidV4;

},{"./data.js":270}],284:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BaseWallet = void 0;
var index_js_1 = require("../address/index.js");
var index_js_2 = require("../hash/index.js");
var index_js_3 = require("../providers/index.js");
var index_js_4 = require("../transaction/index.js");
var index_js_5 = require("../utils/index.js");
/**
 *  The **BaseWallet** is a stream-lined implementation of a
 *  [[Signer]] that operates with a private key.
 *
 *  It is preferred to use the [[Wallet]] class, as it offers
 *  additional functionality and simplifies loading a variety
 *  of JSON formats, Mnemonic Phrases, etc.
 *
 *  This class may be of use for those attempting to implement
 *  a minimal Signer.
 */
var _signingKey = /*#__PURE__*/new WeakMap();
var BaseWallet = /*#__PURE__*/function (_index_js_3$AbstractS) {
  /**
   *  Creates a new BaseWallet for %%privateKey%%, optionally
   *  connected to %%provider%%.
   *
   *  If %%provider%% is not specified, only offline methods can
   *  be used.
   */
  function BaseWallet(privateKey, provider) {
    var _this;
    _classCallCheck(this, BaseWallet);
    _this = _callSuper(this, BaseWallet, [provider]);
    /**
     *  The wallet address.
     */
    _defineProperty(_this, "address", void 0);
    _classPrivateFieldInitSpec(_this, _signingKey, void 0);
    (0, index_js_5.assertArgument)(privateKey && typeof privateKey.sign === "function", "invalid private key", "privateKey", "[ REDACTED ]");
    _classPrivateFieldSet(_signingKey, _this, privateKey);
    var address = (0, index_js_4.computeAddress)(_this.signingKey.publicKey);
    (0, index_js_5.defineProperties)(_this, {
      address: address
    });
    return _this;
  }
  // Store private values behind getters to reduce visibility
  // in console.log
  /**
   *  The [[SigningKey]] used for signing payloads.
   */
  _inherits(BaseWallet, _index_js_3$AbstractS);
  return _createClass(BaseWallet, [{
    key: "signingKey",
    get: function get() {
      return _classPrivateFieldGet(_signingKey, this);
    }
    /**
     *  The private key for this wallet.
     */
  }, {
    key: "privateKey",
    get: function get() {
      return this.signingKey.privateKey;
    }
  }, {
    key: "getAddress",
    value: function () {
      var _getAddress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", this.address);
            case 1:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function getAddress() {
        return _getAddress.apply(this, arguments);
      }
      return getAddress;
    }()
  }, {
    key: "connect",
    value: function connect(provider) {
      return new BaseWallet(_classPrivateFieldGet(_signingKey, this), provider);
    }
  }, {
    key: "signTransaction",
    value: function () {
      var _signTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(tx) {
        var _yield, to, from, btx;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return (0, index_js_5.resolveProperties)({
                to: tx.to ? (0, index_js_1.resolveAddress)(tx.to, this.provider) : undefined,
                from: tx.from ? (0, index_js_1.resolveAddress)(tx.from, this.provider) : undefined
              });
            case 2:
              _yield = _context2.sent;
              to = _yield.to;
              from = _yield.from;
              if (to != null) {
                tx.to = to;
              }
              if (from != null) {
                tx.from = from;
              }
              if (tx.from != null) {
                (0, index_js_5.assertArgument)((0, index_js_1.getAddress)(tx.from) === this.address, "transaction from address mismatch", "tx.from", tx.from);
                delete tx.from;
              }
              // Build the transaction
              btx = index_js_4.Transaction.from(tx);
              btx.signature = this.signingKey.sign(btx.unsignedHash);
              return _context2.abrupt("return", btx.serialized);
            case 11:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function signTransaction(_x) {
        return _signTransaction.apply(this, arguments);
      }
      return signTransaction;
    }()
  }, {
    key: "signMessage",
    value: function () {
      var _signMessage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(message) {
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              return _context3.abrupt("return", this.signMessageSync(message));
            case 1:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function signMessage(_x2) {
        return _signMessage.apply(this, arguments);
      }
      return signMessage;
    }() // @TODO: Add a secialized signTx and signTyped sync that enforces
    // all parameters are known?
    /**
     *  Returns the signature for %%message%% signed with this wallet.
     */
  }, {
    key: "signMessageSync",
    value: function signMessageSync(message) {
      return this.signingKey.sign((0, index_js_2.hashMessage)(message)).serialized;
    }
  }, {
    key: "signTypedData",
    value: function () {
      var _signTypedData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(domain, types, value) {
        var _this2 = this;
        var populated;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              _context5.next = 2;
              return index_js_2.TypedDataEncoder.resolveNames(domain, types, value, /*#__PURE__*/function () {
                var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(name) {
                  var address;
                  return _regeneratorRuntime().wrap(function _callee4$(_context4) {
                    while (1) switch (_context4.prev = _context4.next) {
                      case 0:
                        // @TODO: this should use resolveName; addresses don't
                        //        need a provider
                        (0, index_js_5.assert)(_this2.provider != null, "cannot resolve ENS names without a provider", "UNSUPPORTED_OPERATION", {
                          operation: "resolveName",
                          info: {
                            name: name
                          }
                        });
                        _context4.next = 3;
                        return _this2.provider.resolveName(name);
                      case 3:
                        address = _context4.sent;
                        (0, index_js_5.assert)(address != null, "unconfigured ENS name", "UNCONFIGURED_NAME", {
                          value: name
                        });
                        return _context4.abrupt("return", address);
                      case 6:
                      case "end":
                        return _context4.stop();
                    }
                  }, _callee4);
                }));
                return function (_x6) {
                  return _ref.apply(this, arguments);
                };
              }());
            case 2:
              populated = _context5.sent;
              return _context5.abrupt("return", this.signingKey.sign(index_js_2.TypedDataEncoder.hash(populated.domain, types, populated.value)).serialized);
            case 4:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this);
      }));
      function signTypedData(_x3, _x4, _x5) {
        return _signTypedData.apply(this, arguments);
      }
      return signTypedData;
    }()
  }]);
}(index_js_3.AbstractSigner);
exports.BaseWallet = BaseWallet;

},{"../address/index.js":207,"../hash/index.js":230,"../providers/index.js":242,"../transaction/index.js":266,"../utils/index.js":276}],285:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var _HDNodeWallet;
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getIndexedAccountPath = exports.getAccountPath = exports.HDNodeVoidWallet = exports.HDNodeWallet = exports.defaultPath = void 0;
/**
 *  Explain HD Wallets..
 *
 *  @_subsection: api/wallet:HD Wallets  [hd-wallets]
 */
var index_js_1 = require("../crypto/index.js");
var index_js_2 = require("../providers/index.js");
var index_js_3 = require("../transaction/index.js");
var index_js_4 = require("../utils/index.js");
var lang_en_js_1 = require("../wordlists/lang-en.js");
var base_wallet_js_1 = require("./base-wallet.js");
var mnemonic_js_1 = require("./mnemonic.js");
var json_keystore_js_1 = require("./json-keystore.js");
/**
 *  The default derivation path for Ethereum HD Nodes. (i.e. ``"m/44'/60'/0'/0/0"``)
 */
exports.defaultPath = "m/44'/60'/0'/0/0";
// "Bitcoin seed"
var MasterSecret = new Uint8Array([66, 105, 116, 99, 111, 105, 110, 32, 115, 101, 101, 100]);
var HardenedBit = 0x80000000;
var N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
var Nibbles = "0123456789abcdef";
function zpad(value, length) {
  var result = "";
  while (value) {
    result = Nibbles[value % 16] + result;
    value = Math.trunc(value / 16);
  }
  while (result.length < length * 2) {
    result = "0" + result;
  }
  return "0x" + result;
}
function encodeBase58Check(_value) {
  var value = (0, index_js_4.getBytes)(_value);
  var check = (0, index_js_4.dataSlice)((0, index_js_1.sha256)((0, index_js_1.sha256)(value)), 0, 4);
  var bytes = (0, index_js_4.concat)([value, check]);
  return (0, index_js_4.encodeBase58)(bytes);
}
var _guard = {};
function ser_I(index, chainCode, publicKey, privateKey) {
  var data = new Uint8Array(37);
  if (index & HardenedBit) {
    (0, index_js_4.assert)(privateKey != null, "cannot derive child of neutered node", "UNSUPPORTED_OPERATION", {
      operation: "deriveChild"
    });
    // Data = 0x00 || ser_256(k_par)
    data.set((0, index_js_4.getBytes)(privateKey), 1);
  } else {
    // Data = ser_p(point(k_par))
    data.set((0, index_js_4.getBytes)(publicKey));
  }
  // Data += ser_32(i)
  for (var i = 24; i >= 0; i -= 8) {
    data[33 + (i >> 3)] = index >> 24 - i & 0xff;
  }
  var I = (0, index_js_4.getBytes)((0, index_js_1.computeHmac)("sha512", chainCode, data));
  return {
    IL: I.slice(0, 32),
    IR: I.slice(32)
  };
}
function _derivePath(node, path) {
  var components = path.split("/");
  (0, index_js_4.assertArgument)(components.length > 0, "invalid path", "path", path);
  if (components[0] === "m") {
    (0, index_js_4.assertArgument)(node.depth === 0, "cannot derive root path (i.e. path starting with \"m/\") for a node at non-zero depth ".concat(node.depth), "path", path);
    components.shift();
  }
  var result = node;
  for (var i = 0; i < components.length; i++) {
    var component = components[i];
    if (component.match(/^[0-9]+'$/)) {
      var index = parseInt(component.substring(0, component.length - 1));
      (0, index_js_4.assertArgument)(index < HardenedBit, "invalid path index", "path[".concat(i, "]"), component);
      result = result.deriveChild(HardenedBit + index);
    } else if (component.match(/^[0-9]+$/)) {
      var _index2 = parseInt(component);
      (0, index_js_4.assertArgument)(_index2 < HardenedBit, "invalid path index", "path[".concat(i, "]"), component);
      result = result.deriveChild(_index2);
    } else {
      (0, index_js_4.assertArgument)(false, "invalid path component", "path[".concat(i, "]"), component);
    }
  }
  return result;
}
/**
 *  An **HDNodeWallet** is a [[Signer]] backed by the private key derived
 *  from an HD Node using the [[link-bip-32]] stantard.
 *
 *  An HD Node forms a hierarchal structure with each HD Node having a
 *  private key and the ability to derive child HD Nodes, defined by
 *  a path indicating the index of each child.
 */
var _HDNodeWallet_brand = /*#__PURE__*/new WeakSet();
var HDNodeWallet = /*#__PURE__*/function (_base_wallet_js_1$Bas) {
  /**
   *  @private
   */
  function HDNodeWallet(guard, signingKey, parentFingerprint, chainCode, path, index, depth, mnemonic, provider) {
    var _this;
    _classCallCheck(this, HDNodeWallet);
    _this = _callSuper(this, HDNodeWallet, [signingKey, provider]);
    _classPrivateMethodInitSpec(_this, _HDNodeWallet_brand);
    /**
     *  The compressed public key.
     */
    _defineProperty(_this, "publicKey", void 0);
    /**
     *  The fingerprint.
     *
     *  A fingerprint allows quick qay to detect parent and child nodes,
     *  but developers should be prepared to deal with collisions as it
     *  is only 4 bytes.
     */
    _defineProperty(_this, "fingerprint", void 0);
    /**
     *  The parent fingerprint.
     */
    _defineProperty(_this, "parentFingerprint", void 0);
    /**
     *  The mnemonic used to create this HD Node, if available.
     *
     *  Sources such as extended keys do not encode the mnemonic, in
     *  which case this will be ``null``.
     */
    _defineProperty(_this, "mnemonic", void 0);
    /**
     *  The chaincode, which is effectively a public key used
     *  to derive children.
     */
    _defineProperty(_this, "chainCode", void 0);
    /**
     *  The derivation path of this wallet.
     *
     *  Since extended keys do not provide full path details, this
     *  may be ``null``, if instantiated from a source that does not
     *  encode it.
     */
    _defineProperty(_this, "path", void 0);
    /**
     *  The child index of this wallet. Values over ``2 *\* 31`` indicate
     *  the node is hardened.
     */
    _defineProperty(_this, "index", void 0);
    /**
     *  The depth of this wallet, which is the number of components
     *  in its path.
     */
    _defineProperty(_this, "depth", void 0);
    (0, index_js_4.assertPrivate)(guard, _guard, "HDNodeWallet");
    (0, index_js_4.defineProperties)(_this, {
      publicKey: signingKey.compressedPublicKey
    });
    var fingerprint = (0, index_js_4.dataSlice)((0, index_js_1.ripemd160)((0, index_js_1.sha256)(_this.publicKey)), 0, 4);
    (0, index_js_4.defineProperties)(_this, {
      parentFingerprint: parentFingerprint,
      fingerprint: fingerprint,
      chainCode: chainCode,
      path: path,
      index: index,
      depth: depth
    });
    (0, index_js_4.defineProperties)(_this, {
      mnemonic: mnemonic
    });
    return _this;
  }
  _inherits(HDNodeWallet, _base_wallet_js_1$Bas);
  return _createClass(HDNodeWallet, [{
    key: "connect",
    value: function connect(provider) {
      return new HDNodeWallet(_guard, this.signingKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, this.mnemonic, provider);
    }
  }, {
    key: "encrypt",
    value: (
    /**
     *  Resolves to a [JSON Keystore Wallet](json-wallets) encrypted with
     *  %%password%%.
     *
     *  If %%progressCallback%% is specified, it will receive periodic
     *  updates as the encryption process progreses.
     */
    function () {
      var _encrypt = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(password, progressCallback) {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return (0, json_keystore_js_1.encryptKeystoreJson)(_assertClassBrand(_HDNodeWallet_brand, this, _account).call(this), password, {
                progressCallback: progressCallback
              });
            case 2:
              return _context.abrupt("return", _context.sent);
            case 3:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function encrypt(_x, _x2) {
        return _encrypt.apply(this, arguments);
      }
      return encrypt;
    }()
    /**
     *  Returns a [JSON Keystore Wallet](json-wallets) encryped with
     *  %%password%%.
     *
     *  It is preferred to use the [async version](encrypt) instead,
     *  which allows a [[ProgressCallback]] to keep the user informed.
     *
     *  This method will block the event loop (freezing all UI) until
     *  it is complete, which may be a non-trivial duration.
     */
    )
  }, {
    key: "encryptSync",
    value: function encryptSync(password) {
      return (0, json_keystore_js_1.encryptKeystoreJsonSync)(_assertClassBrand(_HDNodeWallet_brand, this, _account).call(this), password);
    }
    /**
     *  The extended key.
     *
     *  This key will begin with the prefix ``xpriv`` and can be used to
     *  reconstruct this HD Node to derive its children.
     */
  }, {
    key: "extendedKey",
    get: function get() {
      // We only support the mainnet values for now, but if anyone needs
      // testnet values, let me know. I believe current sentiment is that
      // we should always use mainnet, and use BIP-44 to derive the network
      //   - Mainnet: public=0x0488B21E, private=0x0488ADE4
      //   - Testnet: public=0x043587CF, private=0x04358394
      (0, index_js_4.assert)(this.depth < 256, "Depth too deep", "UNSUPPORTED_OPERATION", {
        operation: "extendedKey"
      });
      return encodeBase58Check((0, index_js_4.concat)(["0x0488ADE4", zpad(this.depth, 1), this.parentFingerprint, zpad(this.index, 4), this.chainCode, (0, index_js_4.concat)(["0x00", this.privateKey])]));
    }
    /**
     *  Returns true if this wallet has a path, providing a Type Guard
     *  that the path is non-null.
     */
  }, {
    key: "hasPath",
    value: function hasPath() {
      return this.path != null;
    }
    /**
     *  Returns a neutered HD Node, which removes the private details
     *  of an HD Node.
     *
     *  A neutered node has no private key, but can be used to derive
     *  child addresses and other public data about the HD Node.
     */
  }, {
    key: "neuter",
    value: function neuter() {
      return new HDNodeVoidWallet(_guard, this.address, this.publicKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, this.provider);
    }
    /**
     *  Return the child for %%index%%.
     */
  }, {
    key: "deriveChild",
    value: function deriveChild(_index) {
      var index = (0, index_js_4.getNumber)(_index, "index");
      (0, index_js_4.assertArgument)(index <= 0xffffffff, "invalid index", "index", index);
      // Base path
      var path = this.path;
      if (path) {
        path += "/" + (index & ~HardenedBit);
        if (index & HardenedBit) {
          path += "'";
        }
      }
      var _ser_I = ser_I(index, this.chainCode, this.publicKey, this.privateKey),
        IR = _ser_I.IR,
        IL = _ser_I.IL;
      var ki = new index_js_1.SigningKey((0, index_js_4.toBeHex)(((0, index_js_4.toBigInt)(IL) + BigInt(this.privateKey)) % N, 32));
      return new HDNodeWallet(_guard, ki, this.fingerprint, (0, index_js_4.hexlify)(IR), path, index, this.depth + 1, this.mnemonic, this.provider);
    }
    /**
     *  Return the HDNode for %%path%% from this node.
     */
  }, {
    key: "derivePath",
    value: function derivePath(path) {
      return _derivePath(this, path);
    }
  }], [{
    key: "fromExtendedKey",
    value:
    /**
     *  Creates a new HD Node from %%extendedKey%%.
     *
     *  If the %%extendedKey%% will either have a prefix or ``xpub`` or
     *  ``xpriv``, returning a neutered HD Node ([[HDNodeVoidWallet]])
     *  or full HD Node ([[HDNodeWallet) respectively.
     */
    function fromExtendedKey(extendedKey) {
      var bytes = (0, index_js_4.toBeArray)((0, index_js_4.decodeBase58)(extendedKey)); // @TODO: redact
      (0, index_js_4.assertArgument)(bytes.length === 82 || encodeBase58Check(bytes.slice(0, 78)) === extendedKey, "invalid extended key", "extendedKey", "[ REDACTED ]");
      var depth = bytes[4];
      var parentFingerprint = (0, index_js_4.hexlify)(bytes.slice(5, 9));
      var index = parseInt((0, index_js_4.hexlify)(bytes.slice(9, 13)).substring(2), 16);
      var chainCode = (0, index_js_4.hexlify)(bytes.slice(13, 45));
      var key = bytes.slice(45, 78);
      switch ((0, index_js_4.hexlify)(bytes.slice(0, 4))) {
        // Public Key
        case "0x0488b21e":
        case "0x043587cf":
          {
            var publicKey = (0, index_js_4.hexlify)(key);
            return new HDNodeVoidWallet(_guard, (0, index_js_3.computeAddress)(publicKey), publicKey, parentFingerprint, chainCode, null, index, depth, null);
          }
        // Private Key
        case "0x0488ade4":
        case "0x04358394 ":
          if (key[0] !== 0) {
            break;
          }
          return new HDNodeWallet(_guard, new index_js_1.SigningKey(key.slice(1)), parentFingerprint, chainCode, null, index, depth, null, null);
      }
      (0, index_js_4.assertArgument)(false, "invalid extended key prefix", "extendedKey", "[ REDACTED ]");
    }
    /**
     *  Creates a new random HDNode.
     */
  }, {
    key: "createRandom",
    value: function createRandom(password, path, wordlist) {
      if (password == null) {
        password = "";
      }
      if (path == null) {
        path = exports.defaultPath;
      }
      if (wordlist == null) {
        wordlist = lang_en_js_1.LangEn.wordlist();
      }
      var mnemonic = mnemonic_js_1.Mnemonic.fromEntropy((0, index_js_1.randomBytes)(16), password, wordlist);
      return _fromSeed.call(HDNodeWallet, mnemonic.computeSeed(), mnemonic).derivePath(path);
    }
    /**
     *  Create an HD Node from %%mnemonic%%.
     */
  }, {
    key: "fromMnemonic",
    value: function fromMnemonic(mnemonic, path) {
      if (!path) {
        path = exports.defaultPath;
      }
      return _fromSeed.call(HDNodeWallet, mnemonic.computeSeed(), mnemonic).derivePath(path);
    }
    /**
     *  Creates an HD Node from a mnemonic %%phrase%%.
     */
  }, {
    key: "fromPhrase",
    value: function fromPhrase(phrase, password, path, wordlist) {
      if (password == null) {
        password = "";
      }
      if (path == null) {
        path = exports.defaultPath;
      }
      if (wordlist == null) {
        wordlist = lang_en_js_1.LangEn.wordlist();
      }
      var mnemonic = mnemonic_js_1.Mnemonic.fromPhrase(phrase, password, wordlist);
      return _fromSeed.call(HDNodeWallet, mnemonic.computeSeed(), mnemonic).derivePath(path);
    }
    /**
     *  Creates an HD Node from a %%seed%%.
     */
  }, {
    key: "fromSeed",
    value: function fromSeed(seed) {
      return _fromSeed.call(HDNodeWallet, seed, null);
    }
  }]);
}(base_wallet_js_1.BaseWallet);
_HDNodeWallet = HDNodeWallet;
function _account() {
  var account = {
    address: this.address,
    privateKey: this.privateKey
  };
  var m = this.mnemonic;
  if (this.path && m && m.wordlist.locale === "en" && m.password === "") {
    account.mnemonic = {
      path: this.path,
      locale: "en",
      entropy: m.entropy
    };
  }
  return account;
}
function _fromSeed(_seed, mnemonic) {
  (0, index_js_4.assertArgument)((0, index_js_4.isBytesLike)(_seed), "invalid seed", "seed", "[REDACTED]");
  var seed = (0, index_js_4.getBytes)(_seed, "seed");
  (0, index_js_4.assertArgument)(seed.length >= 16 && seed.length <= 64, "invalid seed", "seed", "[REDACTED]");
  var I = (0, index_js_4.getBytes)((0, index_js_1.computeHmac)("sha512", MasterSecret, seed));
  var signingKey = new index_js_1.SigningKey((0, index_js_4.hexlify)(I.slice(0, 32)));
  return new _HDNodeWallet(_guard, signingKey, "0x00000000", (0, index_js_4.hexlify)(I.slice(32)), "m", 0, 0, mnemonic, null);
}
exports.HDNodeWallet = HDNodeWallet;
/**
 *  A **HDNodeVoidWallet** cannot sign, but provides access to
 *  the children nodes of a [[link-bip-32]] HD wallet addresses.
 *
 *  The can be created by using an extended ``xpub`` key to
 *  [[HDNodeWallet_fromExtendedKey]] or by
 *  [nuetering](HDNodeWallet-neuter) a [[HDNodeWallet]].
 */
var HDNodeVoidWallet = /*#__PURE__*/function (_index_js_2$VoidSigne) {
  /**
   *  @private
   */
  function HDNodeVoidWallet(guard, address, publicKey, parentFingerprint, chainCode, path, index, depth, provider) {
    var _this2;
    _classCallCheck(this, HDNodeVoidWallet);
    _this2 = _callSuper(this, HDNodeVoidWallet, [address, provider]);
    /**
     *  The compressed public key.
     */
    _defineProperty(_this2, "publicKey", void 0);
    /**
     *  The fingerprint.
     *
     *  A fingerprint allows quick qay to detect parent and child nodes,
     *  but developers should be prepared to deal with collisions as it
     *  is only 4 bytes.
     */
    _defineProperty(_this2, "fingerprint", void 0);
    /**
     *  The parent node fingerprint.
     */
    _defineProperty(_this2, "parentFingerprint", void 0);
    /**
     *  The chaincode, which is effectively a public key used
     *  to derive children.
     */
    _defineProperty(_this2, "chainCode", void 0);
    /**
     *  The derivation path of this wallet.
     *
     *  Since extended keys do not provider full path details, this
     *  may be ``null``, if instantiated from a source that does not
     *  enocde it.
     */
    _defineProperty(_this2, "path", void 0);
    /**
     *  The child index of this wallet. Values over ``2 *\* 31`` indicate
     *  the node is hardened.
     */
    _defineProperty(_this2, "index", void 0);
    /**
     *  The depth of this wallet, which is the number of components
     *  in its path.
     */
    _defineProperty(_this2, "depth", void 0);
    (0, index_js_4.assertPrivate)(guard, _guard, "HDNodeVoidWallet");
    (0, index_js_4.defineProperties)(_this2, {
      publicKey: publicKey
    });
    var fingerprint = (0, index_js_4.dataSlice)((0, index_js_1.ripemd160)((0, index_js_1.sha256)(publicKey)), 0, 4);
    (0, index_js_4.defineProperties)(_this2, {
      publicKey: publicKey,
      fingerprint: fingerprint,
      parentFingerprint: parentFingerprint,
      chainCode: chainCode,
      path: path,
      index: index,
      depth: depth
    });
    return _this2;
  }
  _inherits(HDNodeVoidWallet, _index_js_2$VoidSigne);
  return _createClass(HDNodeVoidWallet, [{
    key: "connect",
    value: function connect(provider) {
      return new HDNodeVoidWallet(_guard, this.address, this.publicKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, provider);
    }
    /**
     *  The extended key.
     *
     *  This key will begin with the prefix ``xpub`` and can be used to
     *  reconstruct this neutered key to derive its children addresses.
     */
  }, {
    key: "extendedKey",
    get: function get() {
      // We only support the mainnet values for now, but if anyone needs
      // testnet values, let me know. I believe current sentiment is that
      // we should always use mainnet, and use BIP-44 to derive the network
      //   - Mainnet: public=0x0488B21E, private=0x0488ADE4
      //   - Testnet: public=0x043587CF, private=0x04358394
      (0, index_js_4.assert)(this.depth < 256, "Depth too deep", "UNSUPPORTED_OPERATION", {
        operation: "extendedKey"
      });
      return encodeBase58Check((0, index_js_4.concat)(["0x0488B21E", zpad(this.depth, 1), this.parentFingerprint, zpad(this.index, 4), this.chainCode, this.publicKey]));
    }
    /**
     *  Returns true if this wallet has a path, providing a Type Guard
     *  that the path is non-null.
     */
  }, {
    key: "hasPath",
    value: function hasPath() {
      return this.path != null;
    }
    /**
     *  Return the child for %%index%%.
     */
  }, {
    key: "deriveChild",
    value: function deriveChild(_index) {
      var index = (0, index_js_4.getNumber)(_index, "index");
      (0, index_js_4.assertArgument)(index <= 0xffffffff, "invalid index", "index", index);
      // Base path
      var path = this.path;
      if (path) {
        path += "/" + (index & ~HardenedBit);
        if (index & HardenedBit) {
          path += "'";
        }
      }
      var _ser_I2 = ser_I(index, this.chainCode, this.publicKey, null),
        IR = _ser_I2.IR,
        IL = _ser_I2.IL;
      var Ki = index_js_1.SigningKey.addPoints(IL, this.publicKey, true);
      var address = (0, index_js_3.computeAddress)(Ki);
      return new HDNodeVoidWallet(_guard, address, Ki, this.fingerprint, (0, index_js_4.hexlify)(IR), path, index, this.depth + 1, this.provider);
    }
    /**
     *  Return the signer for %%path%% from this node.
     */
  }, {
    key: "derivePath",
    value: function derivePath(path) {
      return _derivePath(this, path);
    }
  }]);
}(index_js_2.VoidSigner);
exports.HDNodeVoidWallet = HDNodeVoidWallet;
/*
export class HDNodeWalletManager {
    #root: HDNodeWallet;

    constructor(phrase: string, password?: null | string, path?: null | string, locale?: null | Wordlist) {
        if (password == null) { password = ""; }
        if (path == null) { path = "m/44'/60'/0'/0"; }
        if (locale == null) { locale = LangEn.wordlist(); }
        this.#root = HDNodeWallet.fromPhrase(phrase, password, path, locale);
    }

    getSigner(index?: number): HDNodeWallet {
        return this.#root.deriveChild((index == null) ? 0: index);
    }
}
*/
/**
 *  Returns the [[link-bip-32]] path for the account at %%index%%.
 *
 *  This is the pattern used by wallets like Ledger.
 *
 *  There is also an [alternate pattern](getIndexedAccountPath) used by
 *  some software.
 */
function getAccountPath(_index) {
  var index = (0, index_js_4.getNumber)(_index, "index");
  (0, index_js_4.assertArgument)(index >= 0 && index < HardenedBit, "invalid account index", "index", index);
  return "m/44'/60'/".concat(index, "'/0/0");
}
exports.getAccountPath = getAccountPath;
/**
 *  Returns the path using an alternative pattern for deriving accounts,
 *  at %%index%%.
 *
 *  This derivation path uses the //index// component rather than the
 *  //account// component to derive sequential accounts.
 *
 *  This is the pattern used by wallets like MetaMask.
 */
function getIndexedAccountPath(_index) {
  var index = (0, index_js_4.getNumber)(_index, "index");
  (0, index_js_4.assertArgument)(index >= 0 && index < HardenedBit, "invalid account index", "index", index);
  return "m/44'/60'/0'/0/".concat(index);
}
exports.getIndexedAccountPath = getIndexedAccountPath;

},{"../crypto/index.js":219,"../providers/index.js":242,"../transaction/index.js":266,"../utils/index.js":276,"../wordlists/lang-en.js":296,"./base-wallet.js":284,"./json-keystore.js":288,"./mnemonic.js":289}],286:[function(require,module,exports){
"use strict";

/**
 *  When interacting with Ethereum, it is necessary to use a private
 *  key authenticate actions by signing a payload.
 *
 *  Wallets are the simplest way to expose the concept of an
 *  //Externally Owner Account// (EOA) as it wraps a private key
 *  and supports high-level methods to sign common types of interaction
 *  and send transactions.
 *
 *  The class most developers will want to use is [[Wallet]], which
 *  can load a private key directly or from any common wallet format.
 *
 *  The [[HDNodeWallet]] can be used when it is necessary to access
 *  low-level details of how an HD wallets are derived, exported
 *  or imported.
 *
 *  @_section: api/wallet:Wallets  [about-wallets]
 */
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Wallet = exports.Mnemonic = exports.encryptKeystoreJsonSync = exports.encryptKeystoreJson = exports.decryptKeystoreJson = exports.decryptKeystoreJsonSync = exports.isKeystoreJson = exports.decryptCrowdsaleJson = exports.isCrowdsaleJson = exports.HDNodeVoidWallet = exports.HDNodeWallet = exports.getIndexedAccountPath = exports.getAccountPath = exports.defaultPath = exports.BaseWallet = void 0;
var base_wallet_js_1 = require("./base-wallet.js");
Object.defineProperty(exports, "BaseWallet", {
  enumerable: true,
  get: function get() {
    return base_wallet_js_1.BaseWallet;
  }
});
var hdwallet_js_1 = require("./hdwallet.js");
Object.defineProperty(exports, "defaultPath", {
  enumerable: true,
  get: function get() {
    return hdwallet_js_1.defaultPath;
  }
});
Object.defineProperty(exports, "getAccountPath", {
  enumerable: true,
  get: function get() {
    return hdwallet_js_1.getAccountPath;
  }
});
Object.defineProperty(exports, "getIndexedAccountPath", {
  enumerable: true,
  get: function get() {
    return hdwallet_js_1.getIndexedAccountPath;
  }
});
Object.defineProperty(exports, "HDNodeWallet", {
  enumerable: true,
  get: function get() {
    return hdwallet_js_1.HDNodeWallet;
  }
});
Object.defineProperty(exports, "HDNodeVoidWallet", {
  enumerable: true,
  get: function get() {
    return hdwallet_js_1.HDNodeVoidWallet;
  }
});
var json_crowdsale_js_1 = require("./json-crowdsale.js");
Object.defineProperty(exports, "isCrowdsaleJson", {
  enumerable: true,
  get: function get() {
    return json_crowdsale_js_1.isCrowdsaleJson;
  }
});
Object.defineProperty(exports, "decryptCrowdsaleJson", {
  enumerable: true,
  get: function get() {
    return json_crowdsale_js_1.decryptCrowdsaleJson;
  }
});
var json_keystore_js_1 = require("./json-keystore.js");
Object.defineProperty(exports, "isKeystoreJson", {
  enumerable: true,
  get: function get() {
    return json_keystore_js_1.isKeystoreJson;
  }
});
Object.defineProperty(exports, "decryptKeystoreJsonSync", {
  enumerable: true,
  get: function get() {
    return json_keystore_js_1.decryptKeystoreJsonSync;
  }
});
Object.defineProperty(exports, "decryptKeystoreJson", {
  enumerable: true,
  get: function get() {
    return json_keystore_js_1.decryptKeystoreJson;
  }
});
Object.defineProperty(exports, "encryptKeystoreJson", {
  enumerable: true,
  get: function get() {
    return json_keystore_js_1.encryptKeystoreJson;
  }
});
Object.defineProperty(exports, "encryptKeystoreJsonSync", {
  enumerable: true,
  get: function get() {
    return json_keystore_js_1.encryptKeystoreJsonSync;
  }
});
var mnemonic_js_1 = require("./mnemonic.js");
Object.defineProperty(exports, "Mnemonic", {
  enumerable: true,
  get: function get() {
    return mnemonic_js_1.Mnemonic;
  }
});
var wallet_js_1 = require("./wallet.js");
Object.defineProperty(exports, "Wallet", {
  enumerable: true,
  get: function get() {
    return wallet_js_1.Wallet;
  }
});

},{"./base-wallet.js":284,"./hdwallet.js":285,"./json-crowdsale.js":287,"./json-keystore.js":288,"./mnemonic.js":289,"./wallet.js":291}],287:[function(require,module,exports){
"use strict";

/**
 *  @_subsection: api/wallet:JSON Wallets  [json-wallets]
 */
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.decryptCrowdsaleJson = exports.isCrowdsaleJson = void 0;
var aes_js_1 = require("aes-js");
var index_js_1 = require("../address/index.js");
var index_js_2 = require("../crypto/index.js");
var index_js_3 = require("../hash/index.js");
var index_js_4 = require("../utils/index.js");
var utils_js_1 = require("./utils.js");
/**
 *  Returns true if %%json%% is a valid JSON Crowdsale wallet.
 */
function isCrowdsaleJson(json) {
  try {
    var data = JSON.parse(json);
    if (data.encseed) {
      return true;
    }
  } catch (error) {}
  return false;
}
exports.isCrowdsaleJson = isCrowdsaleJson;
// See: https://github.com/ethereum/pyethsaletool
/**
 *  Before Ethereum launched, it was necessary to create a wallet
 *  format for backers to use, which would be used to receive ether
 *  as a reward for contributing to the project.
 *
 *  The [[link-crowdsale]] format is now obsolete, but it is still
 *  useful to support and the additional code is fairly trivial as
 *  all the primitives required are used through core portions of
 *  the library.
 */
function decryptCrowdsaleJson(json, _password) {
  var data = JSON.parse(json);
  var password = (0, utils_js_1.getPassword)(_password);
  // Ethereum Address
  var address = (0, index_js_1.getAddress)((0, utils_js_1.spelunk)(data, "ethaddr:string!"));
  // Encrypted Seed
  var encseed = (0, utils_js_1.looseArrayify)((0, utils_js_1.spelunk)(data, "encseed:string!"));
  (0, index_js_4.assertArgument)(encseed && encseed.length % 16 === 0, "invalid encseed", "json", json);
  var key = (0, index_js_4.getBytes)((0, index_js_2.pbkdf2)(password, password, 2000, 32, "sha256")).slice(0, 16);
  var iv = encseed.slice(0, 16);
  var encryptedSeed = encseed.slice(16);
  // Decrypt the seed
  var aesCbc = new aes_js_1.CBC(key, iv);
  var seed = (0, aes_js_1.pkcs7Strip)((0, index_js_4.getBytes)(aesCbc.decrypt(encryptedSeed)));
  // This wallet format is weird... Convert the binary encoded hex to a string.
  var seedHex = "";
  for (var i = 0; i < seed.length; i++) {
    seedHex += String.fromCharCode(seed[i]);
  }
  return {
    address: address,
    privateKey: (0, index_js_3.id)(seedHex)
  };
}
exports.decryptCrowdsaleJson = decryptCrowdsaleJson;

},{"../address/index.js":207,"../crypto/index.js":219,"../hash/index.js":230,"../utils/index.js":276,"./utils.js":290,"aes-js":75}],288:[function(require,module,exports){
"use strict";

/**
 *  The JSON Wallet formats allow a simple way to store the private
 *  keys needed in Ethereum along with related information and allows
 *  for extensible forms of encryption.
 *
 *  These utilities facilitate decrypting and encrypting the most common
 *  JSON Wallet formats.
 *
 *  @_subsection: api/wallet:JSON Wallets  [json-wallets]
 */
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.encryptKeystoreJson = exports.encryptKeystoreJsonSync = exports.decryptKeystoreJson = exports.decryptKeystoreJsonSync = exports.isKeystoreJson = void 0;
var aes_js_1 = require("aes-js");
var index_js_1 = require("../address/index.js");
var index_js_2 = require("../crypto/index.js");
var index_js_3 = require("../transaction/index.js");
var index_js_4 = require("../utils/index.js");
var utils_js_1 = require("./utils.js");
var _version_js_1 = require("../_version.js");
var defaultPath = "m/44'/60'/0'/0/0";
/**
 *  Returns true if %%json%% is a valid JSON Keystore Wallet.
 */
function isKeystoreJson(json) {
  try {
    var data = JSON.parse(json);
    var version = data.version != null ? parseInt(data.version) : 0;
    if (version === 3) {
      return true;
    }
  } catch (error) {}
  return false;
}
exports.isKeystoreJson = isKeystoreJson;
function decrypt(data, key, ciphertext) {
  var cipher = (0, utils_js_1.spelunk)(data, "crypto.cipher:string");
  if (cipher === "aes-128-ctr") {
    var iv = (0, utils_js_1.spelunk)(data, "crypto.cipherparams.iv:data!");
    var aesCtr = new aes_js_1.CTR(key, iv);
    return (0, index_js_4.hexlify)(aesCtr.decrypt(ciphertext));
  }
  (0, index_js_4.assert)(false, "unsupported cipher", "UNSUPPORTED_OPERATION", {
    operation: "decrypt"
  });
}
function getAccount(data, _key) {
  var key = (0, index_js_4.getBytes)(_key);
  var ciphertext = (0, utils_js_1.spelunk)(data, "crypto.ciphertext:data!");
  var computedMAC = (0, index_js_4.hexlify)((0, index_js_2.keccak256)((0, index_js_4.concat)([key.slice(16, 32), ciphertext]))).substring(2);
  (0, index_js_4.assertArgument)(computedMAC === (0, utils_js_1.spelunk)(data, "crypto.mac:string!").toLowerCase(), "incorrect password", "password", "[ REDACTED ]");
  var privateKey = decrypt(data, key.slice(0, 16), ciphertext);
  var address = (0, index_js_3.computeAddress)(privateKey);
  if (data.address) {
    var check = data.address.toLowerCase();
    if (!check.startsWith("0x")) {
      check = "0x" + check;
    }
    (0, index_js_4.assertArgument)((0, index_js_1.getAddress)(check) === address, "keystore address/privateKey mismatch", "address", data.address);
  }
  var account = {
    address: address,
    privateKey: privateKey
  };
  // Version 0.1 x-ethers metadata must contain an encrypted mnemonic phrase
  var version = (0, utils_js_1.spelunk)(data, "x-ethers.version:string");
  if (version === "0.1") {
    var mnemonicKey = key.slice(32, 64);
    var mnemonicCiphertext = (0, utils_js_1.spelunk)(data, "x-ethers.mnemonicCiphertext:data!");
    var mnemonicIv = (0, utils_js_1.spelunk)(data, "x-ethers.mnemonicCounter:data!");
    var mnemonicAesCtr = new aes_js_1.CTR(mnemonicKey, mnemonicIv);
    account.mnemonic = {
      path: (0, utils_js_1.spelunk)(data, "x-ethers.path:string") || defaultPath,
      locale: (0, utils_js_1.spelunk)(data, "x-ethers.locale:string") || "en",
      entropy: (0, index_js_4.hexlify)((0, index_js_4.getBytes)(mnemonicAesCtr.decrypt(mnemonicCiphertext)))
    };
  }
  return account;
}
function getDecryptKdfParams(data) {
  var kdf = (0, utils_js_1.spelunk)(data, "crypto.kdf:string");
  if (kdf && typeof kdf === "string") {
    if (kdf.toLowerCase() === "scrypt") {
      var salt = (0, utils_js_1.spelunk)(data, "crypto.kdfparams.salt:data!");
      var N = (0, utils_js_1.spelunk)(data, "crypto.kdfparams.n:int!");
      var r = (0, utils_js_1.spelunk)(data, "crypto.kdfparams.r:int!");
      var p = (0, utils_js_1.spelunk)(data, "crypto.kdfparams.p:int!");
      // Make sure N is a power of 2
      (0, index_js_4.assertArgument)(N > 0 && (N & N - 1) === 0, "invalid kdf.N", "kdf.N", N);
      (0, index_js_4.assertArgument)(r > 0 && p > 0, "invalid kdf", "kdf", kdf);
      var dkLen = (0, utils_js_1.spelunk)(data, "crypto.kdfparams.dklen:int!");
      (0, index_js_4.assertArgument)(dkLen === 32, "invalid kdf.dklen", "kdf.dflen", dkLen);
      return {
        name: "scrypt",
        salt: salt,
        N: N,
        r: r,
        p: p,
        dkLen: 64
      };
    } else if (kdf.toLowerCase() === "pbkdf2") {
      var _salt = (0, utils_js_1.spelunk)(data, "crypto.kdfparams.salt:data!");
      var prf = (0, utils_js_1.spelunk)(data, "crypto.kdfparams.prf:string!");
      var algorithm = prf.split("-").pop();
      (0, index_js_4.assertArgument)(algorithm === "sha256" || algorithm === "sha512", "invalid kdf.pdf", "kdf.pdf", prf);
      var count = (0, utils_js_1.spelunk)(data, "crypto.kdfparams.c:int!");
      var _dkLen = (0, utils_js_1.spelunk)(data, "crypto.kdfparams.dklen:int!");
      (0, index_js_4.assertArgument)(_dkLen === 32, "invalid kdf.dklen", "kdf.dklen", _dkLen);
      return {
        name: "pbkdf2",
        salt: _salt,
        count: count,
        dkLen: _dkLen,
        algorithm: algorithm
      };
    }
  }
  (0, index_js_4.assertArgument)(false, "unsupported key-derivation function", "kdf", kdf);
}
/**
 *  Returns the account details for the JSON Keystore Wallet %%json%%
 *  using %%password%%.
 *
 *  It is preferred to use the [async version](decryptKeystoreJson)
 *  instead, which allows a [[ProgressCallback]] to keep the user informed
 *  as to the decryption status.
 *
 *  This method will block the event loop (freezing all UI) until decryption
 *  is complete, which can take quite some time, depending on the wallet
 *  paramters and platform.
 */
function decryptKeystoreJsonSync(json, _password) {
  var data = JSON.parse(json);
  var password = (0, utils_js_1.getPassword)(_password);
  var params = getDecryptKdfParams(data);
  if (params.name === "pbkdf2") {
    var _salt2 = params.salt,
      count = params.count,
      _dkLen2 = params.dkLen,
      algorithm = params.algorithm;
    var _key2 = (0, index_js_2.pbkdf2)(password, _salt2, count, _dkLen2, algorithm);
    return getAccount(data, _key2);
  }
  (0, index_js_4.assert)(params.name === "scrypt", "cannot be reached", "UNKNOWN_ERROR", {
    params: params
  });
  var salt = params.salt,
    N = params.N,
    r = params.r,
    p = params.p,
    dkLen = params.dkLen;
  var key = (0, index_js_2.scryptSync)(password, salt, N, r, p, dkLen);
  return getAccount(data, key);
}
exports.decryptKeystoreJsonSync = decryptKeystoreJsonSync;
function stall(duration) {
  return new Promise(function (resolve) {
    setTimeout(function () {
      resolve();
    }, duration);
  });
}
/**
 *  Resolves to the decrypted JSON Keystore Wallet %%json%% using the
 *  %%password%%.
 *
 *  If provided, %%progress%% will be called periodically during the
 *  decrpytion to provide feedback, and if the function returns
 *  ``false`` will halt decryption.
 *
 *  The %%progressCallback%% will **always** receive ``0`` before
 *  decryption begins and ``1`` when complete.
 */
function decryptKeystoreJson(_x, _x2, _x3) {
  return _decryptKeystoreJson.apply(this, arguments);
}
function _decryptKeystoreJson() {
  _decryptKeystoreJson = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(json, _password, progress) {
    var data, password, params, _salt3, count, _dkLen3, algorithm, _key3, salt, N, r, p, dkLen, key;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          data = JSON.parse(json);
          password = (0, utils_js_1.getPassword)(_password);
          params = getDecryptKdfParams(data);
          if (!(params.name === "pbkdf2")) {
            _context.next = 15;
            break;
          }
          if (!progress) {
            _context.next = 8;
            break;
          }
          progress(0);
          _context.next = 8;
          return stall(0);
        case 8:
          _salt3 = params.salt, count = params.count, _dkLen3 = params.dkLen, algorithm = params.algorithm;
          _key3 = (0, index_js_2.pbkdf2)(password, _salt3, count, _dkLen3, algorithm);
          if (!progress) {
            _context.next = 14;
            break;
          }
          progress(1);
          _context.next = 14;
          return stall(0);
        case 14:
          return _context.abrupt("return", getAccount(data, _key3));
        case 15:
          (0, index_js_4.assert)(params.name === "scrypt", "cannot be reached", "UNKNOWN_ERROR", {
            params: params
          });
          salt = params.salt, N = params.N, r = params.r, p = params.p, dkLen = params.dkLen;
          _context.next = 19;
          return (0, index_js_2.scrypt)(password, salt, N, r, p, dkLen, progress);
        case 19:
          key = _context.sent;
          return _context.abrupt("return", getAccount(data, key));
        case 21:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return _decryptKeystoreJson.apply(this, arguments);
}
exports.decryptKeystoreJson = decryptKeystoreJson;
function getEncryptKdfParams(options) {
  // Check/generate the salt
  var salt = options.salt != null ? (0, index_js_4.getBytes)(options.salt, "options.salt") : (0, index_js_2.randomBytes)(32);
  // Override the scrypt password-based key derivation function parameters
  var N = 1 << 17,
    r = 8,
    p = 1;
  if (options.scrypt) {
    if (options.scrypt.N) {
      N = options.scrypt.N;
    }
    if (options.scrypt.r) {
      r = options.scrypt.r;
    }
    if (options.scrypt.p) {
      p = options.scrypt.p;
    }
  }
  (0, index_js_4.assertArgument)(typeof N === "number" && N > 0 && Number.isSafeInteger(N) && (BigInt(N) & BigInt(N - 1)) === BigInt(0), "invalid scrypt N parameter", "options.N", N);
  (0, index_js_4.assertArgument)(typeof r === "number" && r > 0 && Number.isSafeInteger(r), "invalid scrypt r parameter", "options.r", r);
  (0, index_js_4.assertArgument)(typeof p === "number" && p > 0 && Number.isSafeInteger(p), "invalid scrypt p parameter", "options.p", p);
  return {
    name: "scrypt",
    dkLen: 32,
    salt: salt,
    N: N,
    r: r,
    p: p
  };
}
function _encryptKeystore(key, kdf, account, options) {
  var privateKey = (0, index_js_4.getBytes)(account.privateKey, "privateKey");
  // Override initialization vector
  var iv = options.iv != null ? (0, index_js_4.getBytes)(options.iv, "options.iv") : (0, index_js_2.randomBytes)(16);
  (0, index_js_4.assertArgument)(iv.length === 16, "invalid options.iv length", "options.iv", options.iv);
  // Override the uuid
  var uuidRandom = options.uuid != null ? (0, index_js_4.getBytes)(options.uuid, "options.uuid") : (0, index_js_2.randomBytes)(16);
  (0, index_js_4.assertArgument)(uuidRandom.length === 16, "invalid options.uuid length", "options.uuid", options.iv);
  // This will be used to encrypt the wallet (as per Web3 secret storage)
  // - 32 bytes   As normal for the Web3 secret storage (derivedKey, macPrefix)
  // - 32 bytes   AES key to encrypt mnemonic with (required here to be Ethers Wallet)
  var derivedKey = key.slice(0, 16);
  var macPrefix = key.slice(16, 32);
  // Encrypt the private key
  var aesCtr = new aes_js_1.CTR(derivedKey, iv);
  var ciphertext = (0, index_js_4.getBytes)(aesCtr.encrypt(privateKey));
  // Compute the message authentication code, used to check the password
  var mac = (0, index_js_2.keccak256)((0, index_js_4.concat)([macPrefix, ciphertext]));
  // See: https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition
  var data = {
    address: account.address.substring(2).toLowerCase(),
    id: (0, index_js_4.uuidV4)(uuidRandom),
    version: 3,
    Crypto: {
      cipher: "aes-128-ctr",
      cipherparams: {
        iv: (0, index_js_4.hexlify)(iv).substring(2)
      },
      ciphertext: (0, index_js_4.hexlify)(ciphertext).substring(2),
      kdf: "scrypt",
      kdfparams: {
        salt: (0, index_js_4.hexlify)(kdf.salt).substring(2),
        n: kdf.N,
        dklen: 32,
        p: kdf.p,
        r: kdf.r
      },
      mac: mac.substring(2)
    }
  };
  // If we have a mnemonic, encrypt it into the JSON wallet
  if (account.mnemonic) {
    var client = options.client != null ? options.client : "ethers/".concat(_version_js_1.version);
    var path = account.mnemonic.path || defaultPath;
    var locale = account.mnemonic.locale || "en";
    var mnemonicKey = key.slice(32, 64);
    var entropy = (0, index_js_4.getBytes)(account.mnemonic.entropy, "account.mnemonic.entropy");
    var mnemonicIv = (0, index_js_2.randomBytes)(16);
    var mnemonicAesCtr = new aes_js_1.CTR(mnemonicKey, mnemonicIv);
    var mnemonicCiphertext = (0, index_js_4.getBytes)(mnemonicAesCtr.encrypt(entropy));
    var now = new Date();
    var timestamp = now.getUTCFullYear() + "-" + (0, utils_js_1.zpad)(now.getUTCMonth() + 1, 2) + "-" + (0, utils_js_1.zpad)(now.getUTCDate(), 2) + "T" + (0, utils_js_1.zpad)(now.getUTCHours(), 2) + "-" + (0, utils_js_1.zpad)(now.getUTCMinutes(), 2) + "-" + (0, utils_js_1.zpad)(now.getUTCSeconds(), 2) + ".0Z";
    var gethFilename = "UTC--" + timestamp + "--" + data.address;
    data["x-ethers"] = {
      client: client,
      gethFilename: gethFilename,
      path: path,
      locale: locale,
      mnemonicCounter: (0, index_js_4.hexlify)(mnemonicIv).substring(2),
      mnemonicCiphertext: (0, index_js_4.hexlify)(mnemonicCiphertext).substring(2),
      version: "0.1"
    };
  }
  return JSON.stringify(data);
}
/**
 *  Return the JSON Keystore Wallet for %%account%% encrypted with
 *  %%password%%.
 *
 *  The %%options%% can be used to tune the password-based key
 *  derivation function parameters, explicitly set the random values
 *  used. Any provided [[ProgressCallback]] is ignord.
 */
function encryptKeystoreJsonSync(account, password, options) {
  if (options == null) {
    options = {};
  }
  var passwordBytes = (0, utils_js_1.getPassword)(password);
  var kdf = getEncryptKdfParams(options);
  var key = (0, index_js_2.scryptSync)(passwordBytes, kdf.salt, kdf.N, kdf.r, kdf.p, 64);
  return _encryptKeystore((0, index_js_4.getBytes)(key), kdf, account, options);
}
exports.encryptKeystoreJsonSync = encryptKeystoreJsonSync;
/**
 *  Resolved to the JSON Keystore Wallet for %%account%% encrypted
 *  with %%password%%.
 *
 *  The %%options%% can be used to tune the password-based key
 *  derivation function parameters, explicitly set the random values
 *  used and provide a [[ProgressCallback]] to receive periodic updates
 *  on the completion status..
 */
function encryptKeystoreJson(_x4, _x5, _x6) {
  return _encryptKeystoreJson.apply(this, arguments);
}
function _encryptKeystoreJson() {
  _encryptKeystoreJson = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(account, password, options) {
    var passwordBytes, kdf, key;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          if (options == null) {
            options = {};
          }
          passwordBytes = (0, utils_js_1.getPassword)(password);
          kdf = getEncryptKdfParams(options);
          _context2.next = 5;
          return (0, index_js_2.scrypt)(passwordBytes, kdf.salt, kdf.N, kdf.r, kdf.p, 64, options.progressCallback);
        case 5:
          key = _context2.sent;
          return _context2.abrupt("return", _encryptKeystore((0, index_js_4.getBytes)(key), kdf, account, options));
        case 7:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
  return _encryptKeystoreJson.apply(this, arguments);
}
exports.encryptKeystoreJson = encryptKeystoreJson;

},{"../_version.js":186,"../address/index.js":207,"../crypto/index.js":219,"../transaction/index.js":266,"../utils/index.js":276,"./utils.js":290,"aes-js":75}],289:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Mnemonic = void 0;
var index_js_1 = require("../crypto/index.js");
var index_js_2 = require("../utils/index.js");
var lang_en_js_1 = require("../wordlists/lang-en.js");
// Returns a byte with the MSB bits set
function getUpperMask(bits) {
  return (1 << bits) - 1 << 8 - bits & 0xff;
}
// Returns a byte with the LSB bits set
function getLowerMask(bits) {
  return (1 << bits) - 1 & 0xff;
}
function mnemonicToEntropy(mnemonic, wordlist) {
  (0, index_js_2.assertNormalize)("NFKD");
  if (wordlist == null) {
    wordlist = lang_en_js_1.LangEn.wordlist();
  }
  var words = wordlist.split(mnemonic);
  (0, index_js_2.assertArgument)(words.length % 3 === 0 && words.length >= 12 && words.length <= 24, "invalid mnemonic length", "mnemonic", "[ REDACTED ]");
  var entropy = new Uint8Array(Math.ceil(11 * words.length / 8));
  var offset = 0;
  for (var i = 0; i < words.length; i++) {
    var index = wordlist.getWordIndex(words[i].normalize("NFKD"));
    (0, index_js_2.assertArgument)(index >= 0, "invalid mnemonic word at index ".concat(i), "mnemonic", "[ REDACTED ]");
    for (var bit = 0; bit < 11; bit++) {
      if (index & 1 << 10 - bit) {
        entropy[offset >> 3] |= 1 << 7 - offset % 8;
      }
      offset++;
    }
  }
  var entropyBits = 32 * words.length / 3;
  var checksumBits = words.length / 3;
  var checksumMask = getUpperMask(checksumBits);
  var checksum = (0, index_js_2.getBytes)((0, index_js_1.sha256)(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;
  (0, index_js_2.assertArgument)(checksum === (entropy[entropy.length - 1] & checksumMask), "invalid mnemonic checksum", "mnemonic", "[ REDACTED ]");
  return (0, index_js_2.hexlify)(entropy.slice(0, entropyBits / 8));
}
function entropyToMnemonic(entropy, wordlist) {
  (0, index_js_2.assertArgument)(entropy.length % 4 === 0 && entropy.length >= 16 && entropy.length <= 32, "invalid entropy size", "entropy", "[ REDACTED ]");
  if (wordlist == null) {
    wordlist = lang_en_js_1.LangEn.wordlist();
  }
  var indices = [0];
  var remainingBits = 11;
  for (var i = 0; i < entropy.length; i++) {
    // Consume the whole byte (with still more to go)
    if (remainingBits > 8) {
      indices[indices.length - 1] <<= 8;
      indices[indices.length - 1] |= entropy[i];
      remainingBits -= 8;
      // This byte will complete an 11-bit index
    } else {
      indices[indices.length - 1] <<= remainingBits;
      indices[indices.length - 1] |= entropy[i] >> 8 - remainingBits;
      // Start the next word
      indices.push(entropy[i] & getLowerMask(8 - remainingBits));
      remainingBits += 3;
    }
  }
  // Compute the checksum bits
  var checksumBits = entropy.length / 4;
  var checksum = parseInt((0, index_js_1.sha256)(entropy).substring(2, 4), 16) & getUpperMask(checksumBits);
  // Shift the checksum into the word indices
  indices[indices.length - 1] <<= checksumBits;
  indices[indices.length - 1] |= checksum >> 8 - checksumBits;
  return wordlist.join(indices.map(function (index) {
    return wordlist.getWord(index);
  }));
}
var _guard = {};
/**
 *  A **Mnemonic** wraps all properties required to compute [[link-bip-39]]
 *  seeds and convert between phrases and entropy.
 */
var Mnemonic = /*#__PURE__*/function () {
  /**
   *  @private
   */
  function Mnemonic(guard, entropy, phrase, password, wordlist) {
    _classCallCheck(this, Mnemonic);
    /**
     *  The mnemonic phrase of 12, 15, 18, 21 or 24 words.
     *
     *  Use the [[wordlist]] ``split`` method to get the individual words.
     */
    _defineProperty(this, "phrase", void 0);
    /**
     *  The password used for this mnemonic. If no password is used this
     *  is the empty string (i.e. ``""``) as per the specification.
     */
    _defineProperty(this, "password", void 0);
    /**
     *  The wordlist for this mnemonic.
     */
    _defineProperty(this, "wordlist", void 0);
    /**
     *  The underlying entropy which the mnemonic encodes.
     */
    _defineProperty(this, "entropy", void 0);
    if (password == null) {
      password = "";
    }
    if (wordlist == null) {
      wordlist = lang_en_js_1.LangEn.wordlist();
    }
    (0, index_js_2.assertPrivate)(guard, _guard, "Mnemonic");
    (0, index_js_2.defineProperties)(this, {
      phrase: phrase,
      password: password,
      wordlist: wordlist,
      entropy: entropy
    });
  }
  /**
   *  Returns the seed for the mnemonic.
   */
  return _createClass(Mnemonic, [{
    key: "computeSeed",
    value: function computeSeed() {
      var salt = (0, index_js_2.toUtf8Bytes)("mnemonic" + this.password, "NFKD");
      return (0, index_js_1.pbkdf2)((0, index_js_2.toUtf8Bytes)(this.phrase, "NFKD"), salt, 2048, 64, "sha512");
    }
    /**
     *  Creates a new Mnemonic for the %%phrase%%.
     *
     *  The default %%password%% is the empty string and the default
     *  wordlist is the [English wordlists](LangEn).
     */
  }], [{
    key: "fromPhrase",
    value: function fromPhrase(phrase, password, wordlist) {
      // Normalize the case and space; throws if invalid
      var entropy = mnemonicToEntropy(phrase, wordlist);
      phrase = entropyToMnemonic((0, index_js_2.getBytes)(entropy), wordlist);
      return new Mnemonic(_guard, entropy, phrase, password, wordlist);
    }
    /**
     *  Create a new **Mnemonic** from the %%entropy%%.
     *
     *  The default %%password%% is the empty string and the default
     *  wordlist is the [English wordlists](LangEn).
     */
  }, {
    key: "fromEntropy",
    value: function fromEntropy(_entropy, password, wordlist) {
      var entropy = (0, index_js_2.getBytes)(_entropy, "entropy");
      var phrase = entropyToMnemonic(entropy, wordlist);
      return new Mnemonic(_guard, (0, index_js_2.hexlify)(entropy), phrase, password, wordlist);
    }
    /**
     *  Returns the phrase for %%mnemonic%%.
     */
  }, {
    key: "entropyToPhrase",
    value: function entropyToPhrase(_entropy, wordlist) {
      var entropy = (0, index_js_2.getBytes)(_entropy, "entropy");
      return entropyToMnemonic(entropy, wordlist);
    }
    /**
     *  Returns the entropy for %%phrase%%.
     */
  }, {
    key: "phraseToEntropy",
    value: function phraseToEntropy(phrase, wordlist) {
      return mnemonicToEntropy(phrase, wordlist);
    }
    /**
     *  Returns true if %%phrase%% is a valid [[link-bip-39]] phrase.
     *
     *  This checks all the provided words belong to the %%wordlist%%,
     *  that the length is valid and the checksum is correct.
     */
  }, {
    key: "isValidMnemonic",
    value: function isValidMnemonic(phrase, wordlist) {
      try {
        mnemonicToEntropy(phrase, wordlist);
        return true;
      } catch (error) {}
      return false;
    }
  }]);
}();
exports.Mnemonic = Mnemonic;

},{"../crypto/index.js":219,"../utils/index.js":276,"../wordlists/lang-en.js":296}],290:[function(require,module,exports){
"use strict";

/**
 *  @_ignore
 */
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.spelunk = exports.getPassword = exports.zpad = exports.looseArrayify = void 0;
var index_js_1 = require("../utils/index.js");
function looseArrayify(hexString) {
  if (typeof hexString === "string" && !hexString.startsWith("0x")) {
    hexString = "0x" + hexString;
  }
  return (0, index_js_1.getBytesCopy)(hexString);
}
exports.looseArrayify = looseArrayify;
function zpad(value, length) {
  value = String(value);
  while (value.length < length) {
    value = '0' + value;
  }
  return value;
}
exports.zpad = zpad;
function getPassword(password) {
  if (typeof password === 'string') {
    return (0, index_js_1.toUtf8Bytes)(password, "NFKC");
  }
  return (0, index_js_1.getBytesCopy)(password);
}
exports.getPassword = getPassword;
function spelunk(object, _path) {
  var match = _path.match(/^([a-z0-9$_.-]*)(:([a-z]+))?(!)?$/i);
  (0, index_js_1.assertArgument)(match != null, "invalid path", "path", _path);
  var path = match[1];
  var type = match[3];
  var reqd = match[4] === "!";
  var cur = object;
  var _iterator = _createForOfIteratorHelper(path.toLowerCase().split('.')),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var comp = _step.value;
      // Search for a child object with a case-insensitive matching key
      if (Array.isArray(cur)) {
        if (!comp.match(/^[0-9]+$/)) {
          break;
        }
        cur = cur[parseInt(comp)];
      } else if (_typeof(cur) === "object") {
        var found = null;
        for (var key in cur) {
          if (key.toLowerCase() === comp) {
            found = cur[key];
            break;
          }
        }
        cur = found;
      } else {
        cur = null;
      }
      if (cur == null) {
        break;
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  (0, index_js_1.assertArgument)(!reqd || cur != null, "missing required value", "path", path);
  if (type && cur != null) {
    if (type === "int") {
      if (typeof cur === "string" && cur.match(/^-?[0-9]+$/)) {
        return parseInt(cur);
      } else if (Number.isSafeInteger(cur)) {
        return cur;
      }
    }
    if (type === "number") {
      if (typeof cur === "string" && cur.match(/^-?[0-9.]*$/)) {
        return parseFloat(cur);
      }
    }
    if (type === "data") {
      if (typeof cur === "string") {
        return looseArrayify(cur);
      }
    }
    if (type === "array" && Array.isArray(cur)) {
      return cur;
    }
    if (type === _typeof(cur)) {
      return cur;
    }
    (0, index_js_1.assertArgument)(false, "wrong type found for ".concat(type, " "), "path", path);
  }
  return cur;
}
exports.spelunk = spelunk;
/*
export function follow(object: any, path: string): null | string {
    let currentChild = object;

    for (const comp of path.toLowerCase().split('/')) {

        // Search for a child object with a case-insensitive matching key
        let matchingChild = null;
        for (const key in currentChild) {
             if (key.toLowerCase() === comp) {
                 matchingChild = currentChild[key];
                 break;
             }
        }

        if (matchingChild === null) { return null; }

        currentChild = matchingChild;
    }

    return currentChild;
}

// "path/to/something:type!"
export function followRequired(data: any, path: string): string {
    const value = follow(data, path);
    if (value != null) { return value; }
    return logger.throwArgumentError("invalid value", `data:${ path }`,
    JSON.stringify(data));
}
*/
// See: https://www.ietf.org/rfc/rfc4122.txt (Section 4.4)
/*
export function uuidV4(randomBytes: BytesLike): string {
    const bytes = getBytes(randomBytes, "randomBytes");

    // Section: 4.1.3:
    // - time_hi_and_version[12:16] = 0b0100
    bytes[6] = (bytes[6] & 0x0f) | 0x40;

    // Section 4.4
    // - clock_seq_hi_and_reserved[6] = 0b0
    // - clock_seq_hi_and_reserved[7] = 0b1
    bytes[8] = (bytes[8] & 0x3f) | 0x80;

    const value = hexlify(bytes);

    return [
       value.substring(2, 10),
       value.substring(10, 14),
       value.substring(14, 18),
       value.substring(18, 22),
       value.substring(22, 34),
    ].join("-");
}
*/

},{"../utils/index.js":276}],291:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var _Wallet;
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Wallet = void 0;
var index_js_1 = require("../crypto/index.js");
var index_js_2 = require("../utils/index.js");
var base_wallet_js_1 = require("./base-wallet.js");
var hdwallet_js_1 = require("./hdwallet.js");
var json_crowdsale_js_1 = require("./json-crowdsale.js");
var json_keystore_js_1 = require("./json-keystore.js");
var mnemonic_js_1 = require("./mnemonic.js");
function stall(duration) {
  return new Promise(function (resolve) {
    setTimeout(function () {
      resolve();
    }, duration);
  });
}
/**
 *  A **Wallet** manages a single private key which is used to sign
 *  transactions, messages and other common payloads.
 *
 *  This class is generally the main entry point for developers
 *  that wish to use a private key directly, as it can create
 *  instances from a large variety of common sources, including
 *  raw private key, [[link-bip-39]] mnemonics and encrypte JSON
 *  wallets.
 */
var Wallet = /*#__PURE__*/function (_base_wallet_js_1$Bas) {
  /**
   *  Create a new wallet for the private %%key%%, optionally connected
   *  to %%provider%%.
   */
  function Wallet(key, provider) {
    _classCallCheck(this, Wallet);
    if (typeof key === "string" && !key.startsWith("0x")) {
      key = "0x" + key;
    }
    var signingKey = typeof key === "string" ? new index_js_1.SigningKey(key) : key;
    return _callSuper(this, Wallet, [signingKey, provider]);
  }
  _inherits(Wallet, _base_wallet_js_1$Bas);
  return _createClass(Wallet, [{
    key: "connect",
    value: function connect(provider) {
      return new Wallet(this.signingKey, provider);
    }
    /**
     *  Resolves to a [JSON Keystore Wallet](json-wallets) encrypted with
     *  %%password%%.
     *
     *  If %%progressCallback%% is specified, it will receive periodic
     *  updates as the encryption process progreses.
     */
  }, {
    key: "encrypt",
    value: (function () {
      var _encrypt = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(password, progressCallback) {
        var account;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              account = {
                address: this.address,
                privateKey: this.privateKey
              };
              _context.next = 3;
              return (0, json_keystore_js_1.encryptKeystoreJson)(account, password, {
                progressCallback: progressCallback
              });
            case 3:
              return _context.abrupt("return", _context.sent);
            case 4:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function encrypt(_x, _x2) {
        return _encrypt.apply(this, arguments);
      }
      return encrypt;
    }()
    /**
     *  Returns a [JSON Keystore Wallet](json-wallets) encryped with
     *  %%password%%.
     *
     *  It is preferred to use the [async version](encrypt) instead,
     *  which allows a [[ProgressCallback]] to keep the user informed.
     *
     *  This method will block the event loop (freezing all UI) until
     *  it is complete, which may be a non-trivial duration.
     */
    )
  }, {
    key: "encryptSync",
    value: function encryptSync(password) {
      var account = {
        address: this.address,
        privateKey: this.privateKey
      };
      return (0, json_keystore_js_1.encryptKeystoreJsonSync)(account, password);
    }
  }], [{
    key: "fromEncryptedJson",
    value: (
    /**
     *  Creates (asynchronously) a **Wallet** by decrypting the %%json%%
     *  with %%password%%.
     *
     *  If %%progress%% is provided, it is called periodically during
     *  decryption so that any UI can be updated.
     */
    function () {
      var _fromEncryptedJson = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(json, password, progress) {
        var account;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              account = null;
              if (!(0, json_keystore_js_1.isKeystoreJson)(json)) {
                _context2.next = 7;
                break;
              }
              _context2.next = 4;
              return (0, json_keystore_js_1.decryptKeystoreJson)(json, password, progress);
            case 4:
              account = _context2.sent;
              _context2.next = 17;
              break;
            case 7:
              if (!(0, json_crowdsale_js_1.isCrowdsaleJson)(json)) {
                _context2.next = 17;
                break;
              }
              if (!progress) {
                _context2.next = 12;
                break;
              }
              progress(0);
              _context2.next = 12;
              return stall(0);
            case 12:
              account = (0, json_crowdsale_js_1.decryptCrowdsaleJson)(json, password);
              if (!progress) {
                _context2.next = 17;
                break;
              }
              progress(1);
              _context2.next = 17;
              return stall(0);
            case 17:
              return _context2.abrupt("return", _fromAccount.call(Wallet, account));
            case 18:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      }));
      function fromEncryptedJson(_x3, _x4, _x5) {
        return _fromEncryptedJson.apply(this, arguments);
      }
      return fromEncryptedJson;
    }()
    /**
     *  Creates a **Wallet** by decrypting the %%json%% with %%password%%.
     *
     *  The [[fromEncryptedJson]] method is preferred, as this method
     *  will lock up and freeze the UI during decryption, which may take
     *  some time.
     */
    )
  }, {
    key: "fromEncryptedJsonSync",
    value: function fromEncryptedJsonSync(json, password) {
      var account = null;
      if ((0, json_keystore_js_1.isKeystoreJson)(json)) {
        account = (0, json_keystore_js_1.decryptKeystoreJsonSync)(json, password);
      } else if ((0, json_crowdsale_js_1.isCrowdsaleJson)(json)) {
        account = (0, json_crowdsale_js_1.decryptCrowdsaleJson)(json, password);
      } else {
        (0, index_js_2.assertArgument)(false, "invalid JSON wallet", "json", "[ REDACTED ]");
      }
      return _fromAccount.call(Wallet, account);
    }
    /**
     *  Creates a new random [[HDNodeWallet]] using the available
     *  [cryptographic random source](randomBytes).
     *
     *  If there is no crytographic random source, this will throw.
     */
  }, {
    key: "createRandom",
    value: function createRandom(provider) {
      var wallet = hdwallet_js_1.HDNodeWallet.createRandom();
      if (provider) {
        return wallet.connect(provider);
      }
      return wallet;
    }
    /**
     *  Creates a [[HDNodeWallet]] for %%phrase%%.
     */
  }, {
    key: "fromPhrase",
    value: function fromPhrase(phrase, provider) {
      var wallet = hdwallet_js_1.HDNodeWallet.fromPhrase(phrase);
      if (provider) {
        return wallet.connect(provider);
      }
      return wallet;
    }
  }]);
}(base_wallet_js_1.BaseWallet);
_Wallet = Wallet;
function _fromAccount(account) {
  (0, index_js_2.assertArgument)(account, "invalid JSON wallet", "json", "[ REDACTED ]");
  if ("mnemonic" in account && account.mnemonic && account.mnemonic.locale === "en") {
    var mnemonic = mnemonic_js_1.Mnemonic.fromEntropy(account.mnemonic.entropy);
    var _wallet = hdwallet_js_1.HDNodeWallet.fromMnemonic(mnemonic, account.mnemonic.path);
    if (_wallet.address === account.address && _wallet.privateKey === account.privateKey) {
      return _wallet;
    }
    console.log("WARNING: JSON mismatch address/privateKey != mnemonic; fallback onto private key");
  }
  var wallet = new _Wallet(account.privateKey);
  (0, index_js_2.assertArgument)(wallet.address === account.address, "address/privateKey mismatch", "json", "[ REDACTED ]");
  return wallet;
}
exports.Wallet = Wallet;

},{"../crypto/index.js":219,"../utils/index.js":276,"./base-wallet.js":284,"./hdwallet.js":285,"./json-crowdsale.js":287,"./json-keystore.js":288,"./mnemonic.js":289}],292:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.decodeBits = void 0;
var Base64 = ")!@#$%^&*(ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_";
/**
 *  @_ignore
 */
function decodeBits(width, data) {
  var maxValue = (1 << width) - 1;
  var result = [];
  var accum = 0,
    bits = 0,
    flood = 0;
  for (var i = 0; i < data.length; i++) {
    // Accumulate 6 bits of data
    accum = accum << 6 | Base64.indexOf(data[i]);
    bits += 6;
    // While we have enough for a word...
    while (bits >= width) {
      // ...read the word
      var value = accum >> bits - width;
      accum &= (1 << bits - width) - 1;
      bits -= width;
      // A value of 0 indicates we exceeded maxValue, it
      // floods over into the next value
      if (value === 0) {
        flood += maxValue;
      } else {
        result.push(value + flood);
        flood = 0;
      }
    }
  }
  return result;
}
exports.decodeBits = decodeBits;

},{}],293:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.decodeOwl = exports.decode = void 0;
var index_js_1 = require("../utils/index.js");
var subsChrs = " !#$%&'()*+,-./<=>?@[]^_`{|}~";
var Word = /^[a-z]*$/i;
function unfold(words, sep) {
  var initial = 97;
  return words.reduce(function (accum, word) {
    if (word === sep) {
      initial++;
    } else if (word.match(Word)) {
      accum.push(String.fromCharCode(initial) + word);
    } else {
      initial = 97;
      accum.push(word);
    }
    return accum;
  }, []);
}
/**
 *  @_ignore
 */
function decode(data, subs) {
  // Replace all the substitutions with their expanded form
  for (var i = subsChrs.length - 1; i >= 0; i--) {
    data = data.split(subsChrs[i]).join(subs.substring(2 * i, 2 * i + 2));
  }
  // Get all tle clumps; each suffix, first-increment and second-increment
  var clumps = [];
  var leftover = data.replace(/(:|([0-9])|([A-Z][a-z]*))/g, function (all, item, semi, word) {
    if (semi) {
      for (var _i = parseInt(semi); _i >= 0; _i--) {
        clumps.push(";");
      }
    } else {
      clumps.push(item.toLowerCase());
    }
    return "";
  });
  /* c8 ignore start */
  if (leftover) {
    throw new Error("leftovers: ".concat(JSON.stringify(leftover)));
  }
  /* c8 ignore stop */
  return unfold(unfold(clumps, ";"), ":");
}
exports.decode = decode;
/**
 *  @_ignore
 */
function decodeOwl(data) {
  (0, index_js_1.assertArgument)(data[0] === "0", "unsupported auwl data", "data", data);
  return decode(data.substring(1 + 2 * subsChrs.length), data.substring(1, 1 + 2 * subsChrs.length));
}
exports.decodeOwl = decodeOwl;

},{"../utils/index.js":276}],294:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.decodeOwlA = void 0;
var index_js_1 = require("../utils/index.js");
var bit_reader_js_1 = require("./bit-reader.js");
var decode_owl_js_1 = require("./decode-owl.js");
/**
 *  @_ignore
 */
function decodeOwlA(data, accents) {
  var words = (0, decode_owl_js_1.decodeOwl)(data).join(",");
  // Inject the accents
  accents.split(/,/g).forEach(function (accent) {
    var match = accent.match(/^([a-z]*)([0-9]+)([0-9])(.*)$/);
    (0, index_js_1.assertArgument)(match !== null, "internal error parsing accents", "accents", accents);
    var posOffset = 0;
    var positions = (0, bit_reader_js_1.decodeBits)(parseInt(match[3]), match[4]);
    var charCode = parseInt(match[2]);
    var regex = new RegExp("([".concat(match[1], "])"), "g");
    words = words.replace(regex, function (all, letter) {
      var rem = --positions[posOffset];
      if (rem === 0) {
        letter = String.fromCharCode(letter.charCodeAt(0), charCode);
        posOffset++;
      }
      return letter;
    });
  });
  return words.split(",");
}
exports.decodeOwlA = decodeOwlA;

},{"../utils/index.js":276,"./bit-reader.js":292,"./decode-owl.js":293}],295:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.wordlists = exports.WordlistOwlA = exports.WordlistOwl = exports.LangEn = exports.Wordlist = void 0;
/**
 *  A Wordlist is a set of 2048 words used to encode private keys
 *  (or other binary data) that is easier for humans to write down,
 *  transcribe and dictate.
 *
 *  The [[link-bip-39]] standard includes several checksum bits,
 *  depending on the size of the mnemonic phrase.
 *
 *  A mnemonic phrase may be 12, 15, 18, 21 or 24 words long. For
 *  most purposes 12 word mnemonics should be used, as including
 *  additional words increases the difficulty and potential for
 *  mistakes and does not offer any effective improvement on security.
 *
 *  There are a variety of [[link-bip39-wordlists]] for different
 *  languages, but for maximal compatibility, the
 *  [English Wordlist](LangEn) is recommended.
 *
 *  @_section: api/wordlists:Wordlists [about-wordlists]
 */
var wordlist_js_1 = require("./wordlist.js");
Object.defineProperty(exports, "Wordlist", {
  enumerable: true,
  get: function get() {
    return wordlist_js_1.Wordlist;
  }
});
var lang_en_js_1 = require("./lang-en.js");
Object.defineProperty(exports, "LangEn", {
  enumerable: true,
  get: function get() {
    return lang_en_js_1.LangEn;
  }
});
var wordlist_owl_js_1 = require("./wordlist-owl.js");
Object.defineProperty(exports, "WordlistOwl", {
  enumerable: true,
  get: function get() {
    return wordlist_owl_js_1.WordlistOwl;
  }
});
var wordlist_owla_js_1 = require("./wordlist-owla.js");
Object.defineProperty(exports, "WordlistOwlA", {
  enumerable: true,
  get: function get() {
    return wordlist_owla_js_1.WordlistOwlA;
  }
});
var wordlists_js_1 = require("./wordlists.js");
Object.defineProperty(exports, "wordlists", {
  enumerable: true,
  get: function get() {
    return wordlists_js_1.wordlists;
  }
});

},{"./lang-en.js":296,"./wordlist-owl.js":297,"./wordlist-owla.js":298,"./wordlist.js":299,"./wordlists.js":300}],296:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LangEn = void 0;
var wordlist_owl_js_1 = require("./wordlist-owl.js");
var words = "0erleonalorenseinceregesticitStanvetearctssi#ch2Athck&tneLl0And#Il.yLeOutO=S|S%b/ra@SurdU'0Ce[Cid|CountCu'Hie=IdOu,-Qui*Ro[TT]T%T*[Tu$0AptDD-tD*[Ju,M.UltV<)Vi)0Rob-0FairF%dRaid0A(EEntRee0Ead0MRRp%tS!_rmBumCoholErtI&LLeyLowMo,O}PhaReadySoT Ways0A>urAz(gOngOuntU'd0Aly,Ch%Ci|G G!GryIm$K!Noun)Nu$O` Sw T&naTiqueXietyY1ArtOlogyPe?P!Pro=Ril1ChCt-EaEnaGueMMedM%MyOundR<+Re,Ri=RowTTefa@Ti,Tw%k0KPe@SaultSetSi,SumeThma0H!>OmTa{T&dT.udeTra@0Ct]D.Gu,NtTh%ToTumn0Era+OcadoOid0AkeA*AyEsomeFulKw?d0Is:ByChel%C#D+GL<)Lc#y~MbooN<aNn RRelyRga(R*lSeS-SketTt!3A^AnAutyCau'ComeEfF%eG(Ha=H(dLie=LowLtN^Nef./TrayTt Twe&Y#d3Cyc!DKeNdOlogyRdR`Tt _{AdeAmeAnketA,EakE[IndOodO[omOu'UeUrUsh_rdAtDyIlMbNeNusOkO,Rd R(gRrowSsTtomUn)XY_{etA(AndA[A=EadEezeI{Id+IefIghtIngIskOccoliOk&OnzeOomO` OwnUsh2Bb!DdyD+tFf$oIldLbLkL!tNd!Nk Rd&Rg R,SS(e[SyTt Y Zz:Bba+B(B!CtusGeKe~LmM aMpNN$N)lNdyNn#NoeNvasNy#Pab!P.$Pta(RRb#RdRgoRpetRryRtSeShS(o/!Su$TT$ogT^Teg%yTt!UghtU'Ut]Ve3Il(gL yM|NsusNturyRe$Rta(_irAlkAmp]An+AosApt Ar+A'AtEapE{Ee'EfErryE,I{&IefIldIm}yOi)Oo'R#-U{!UnkUrn0G?Nnam#Rc!Tiz&TyVil_imApArifyAwAyE<ErkEv I{I|IffImbIn-IpO{OgO'O`OudOwnUbUmpU, Ut^_^A,C#utDeFfeeIlInL!@L%LumnMb(eMeMf%tM-Mm#Mp<yNc tNdu@NfirmNg*[N}@Nsid NtrolNv()OkOlPp PyR$ReRnR*@/Tt#U^UntryUp!Ur'Us(V Yo>_{Ad!AftAmA}AshAt AwlAzyEamEd.EekEwI{etImeIspIt-OpO[Ou^OwdUci$UelUi'Umb!Un^UshYY,$2BeLtu*PPbo?dRiousRr|Rta(R=Sh]/omTe3C!:DMa+MpN)Ng R(gShUght WnY3AlBa>BrisCadeCemb CideCl(eC%a>C*a'ErF&'F(eFyG*eLayLiv M<dMi'Ni$Nti,NyP?tP&dPos.P`PutyRi=ScribeS tSignSkSpair/royTailTe@VelopVi)Vo>3AgramAlAm#dAryCeE'lEtFf G.$Gn.yLemmaNn NosaurRe@RtSag*eScov Sea'ShSmi[S%d Splay/<)V tVideV%)Zzy5Ct%Cum|G~Lph(Ma(Na>NkeyN%OrSeUb!Ve_ftAg#AmaA,-AwEamE[IftIllInkIpI=OpUmY2CkMbNeR(g/T^Ty1Arf1Nam-:G G!RlyRnR`Sily/Sy1HoOlogyOnomy0GeItUca>1F%t0G1GhtTh 2BowD E@r-Eg<tEm|Eph<tEvat%I>Se0B?kBodyBra)Er+Ot]PloyPow Pty0Ab!A@DD![D%'EmyErgyF%)Ga+G(eH<)JoyLi,OughR-hRollSu*T Ti*TryVelope1Isode0U$Uip0AA'OdeOs]R%Upt0CapeSayS&)Ta>0Ern$H-s1Id&)IlOkeOl=1A@Amp!Ce[Ch<+C.eCludeCu'Ecu>Erci'Hau,Hib.I!I,ItOt-P<dPe@Pi*Pla(Po'P*[T&dTra0EEbrow:Br-CeCultyDeIntI`~L'MeMilyMousNNcyNtasyRmSh]TT$Th TigueUltV%.e3Atu*Bru?yD $EEdElMa!N)/iv$T^V W3B Ct]EldGu*LeLmLt N$NdNeNg NishReRmR,Sc$ShTT}[X_gAmeAshAtAv%EeIghtIpOatO{O%Ow UidUshY_mCusGIlLd~owOdOtR)Re,R+tRkRtu}RumRw?dSsil/ UndX_gi!AmeEqu|EshI&dIn+OgOntO,OwnOz&U.2ElNNnyRna)RyTu*:D+tInLaxy~ yMePRa+Rba+Rd&Rl-Rm|SSpTeTh U+Ze3N $NiusN*Nt!Nu(e/u*2O,0AntFtGg!Ng RaffeRlVe_dAn)A*A[IdeImp'ObeOomOryO=OwUe_tDde[LdOdO'RillaSpelSsipV nWn_bA)A(AntApeA[Av.yEatE&IdIefItOc yOupOwUnt_rdE[IdeIltIt?N3M:B.IrLfMm M, NdPpyRb%RdRshR=,TVeWkZ?d3AdAl`ArtAvyD+hogIght~oLmetLpNRo3Dd&Gh~NtPRe/%y5BbyCkeyLdLeLiday~owMeNeyOdPeRnRr%R'Sp.$/TelUrV 5BGeM<Mb!M%Nd*dNgryNtRd!RryRtSb<d3Brid:1EOn0EaEntifyLe2N%e4LLeg$L}[0A+Ita>M&'Mu}Pa@Po'Pro=Pul'0ChCludeComeC*a'DexD-a>Do%Du,ryF<tFl-tF%mHa!H .Iti$Je@JuryMa>N Noc|PutQuiryS<eSe@SideSpi*/$lTa@T e,ToVe,V.eVol=3On0L<dOla>Sue0Em1Ory:CketGu?RZz3AlousAns~yWel9BInKeUr}yY5D+I)MpNg!Ni%Nk/:Ng?oo3EnEpT^upY3CkDD}yNdNgdomSsTT^&TeTt&Wi4EeIfeO{Ow:BBelB%Dd DyKeMpNgua+PtopR+T T(UghUndryVaWWnWsu.Y Zy3Ad AfArnA=Ctu*FtGG$G&dIsu*M#NdNg`NsOp?dSs#Tt Vel3ArB tyBr?yC&'FeFtGhtKeMbM.NkOnQuid/Tt!VeZ?d5AdAnB, C$CkG-NelyNgOpTt yUdUn+VeY$5CkyGga+Mb N?N^Xury3R-s:Ch(eDG-G}tIdIlInJ%KeMm$NNa+Nda>NgoNs]Nu$P!Rb!R^Rg(R(eRketRria+SkSs/ T^T i$ThTrixTt XimumZe3AdowAnAsu*AtCh<-D$DiaLodyLtMb M%yNt]NuRcyR+R.RryShSsa+T$Thod3Dd!DnightLk~]M-NdNimumN%Nu>Rac!Rr%S ySs/akeXXedXtu*5Bi!DelDifyMM|N.%NkeyN, N`OnR$ReRn(gSqu.oTh T]T%Unta(U'VeVie5ChFf(LeLtiplySc!SeumShroomS-/Tu$3Self/ yTh:I=MePk(Rrow/yT]Tu*3ArCkEdGati=G!@I` PhewR=/TTw%kUtr$V WsXt3CeGht5B!I'M(eeOd!Rm$R`SeTab!TeTh(gTi)VelW5C!?Mb R'T:K0EyJe@Li+Scu*S =Ta(Vious0CurE<Tob 0Or1FF Fi)T&2L1Ay0DI=Ymp-0It0CeEI#L(eLy1EnEraIn]Po'T]1An+B.Ch?dD D(?yG<I|Ig($Ph<0Tr-h0H 0Tdo%T TputTside0AlEnEr0NN 0Yg&0/ 0O}:CtDd!GeIrLa)LmNdaNelN-N` P RadeR|RkRrotRtySsT^ThTi|TrolTt nU'VeYm|3A)AnutArAs<tL-<NN$tyNcilOp!Pp Rfe@Rm.Rs#T2O}OtoRa'Ys-$0AnoCn-Ctu*E)GGe#~LotNkO} Pe/olT^Zza_)A}tA,-A>AyEa'Ed+U{UgUn+2EmEtIntL?LeLi)NdNyOlPul?Rt]S.]Ssib!/TatoTt yV tyWd W _@i)Ai'Ed-tEf Epa*Es|EttyEv|I)IdeIm?yIntI%.yIs#Iva>IzeOb!mO)[Odu)Of.OgramOje@Omo>OofOp tyOsp O>@OudOvide2Bl-Dd(g~LpL'Mpk(N^PilPpyR^a'R.yRpo'R'ShTZz!3Ramid:99Al.yAntumArt E,]I{ItIzO>:Bb.Cco#CeCkD?DioIlInI'~yMpN^NdomN+PidReTeTh V&WZ%3AdyAlAs#BelBuildC$lCei=CipeC%dCyc!Du)F!@F%mFu'G]G*tGul?Je@LaxLea'LiefLyMa(Memb M(dMo=Nd NewNtOp&PairPeatPla)P%tQui*ScueSemb!Si,Sour)Sp#'SultTi*T*atTurnUn]Ve$ViewW?d2Y`m0BBb#CeChDeD+F!GhtGidNgOtPp!SkTu$V$V 5AdA,BotBu,CketM<)OfOkieOmSeTa>UghUndU>Y$5Bb DeGLeNNwayR$:DDd!D}[FeIlLadLm#L#LtLu>MeMp!NdTisfyToshiU)Usa+VeY1A!AnA*Att E}HemeHoolI&)I[%sOrp]OutRapRe&RiptRub1AAr^As#AtC#dC*tCt]Cur.yEdEkGm|Le@~M(?Ni%N'Nt&)RiesRvi)Ss]Tt!TupV&_dowAftAllowA*EdEllEriffIeldIftI}IpIv O{OeOotOpOrtOuld O=RimpRugUff!Y0Bl(gCkDeE+GhtGnL|Lk~yLv Mil?Mp!N)NgR&/ Tua>XZe1A>Et^IIllInIrtUll0AbAmEepEnd I)IdeIghtImOg<OtOwUsh0AllArtI!OkeOo`0A{AkeApIffOw0ApCc Ci$CkDaFtL?Ldi LidLut]L=Me#eNgOnRryRtUlUndUpUr)U`0A)A*Ati$AwnEakEci$EedEllEndH eI)Id IkeInIr.L.OilOns%O#OrtOtRayReadR(gY0Ua*UeezeUir*l_b!AdiumAffA+AirsAmpAndArtA>AyEakEelEmEpE*oI{IllIngO{Oma^O}OolOryO=Ra>gyReetRikeR#gRugg!Ud|UffUmb!Y!0Bje@Bm.BwayC)[ChDd&Ff G?G+,ItMm NNnyN'tP PplyP*meReRfa)R+Rpri'RroundR=ySpe@/a(1AllowAmpApArmE?EetIftImIngIt^Ord1MbolMptomRup/em:B!Ck!GIlL|LkNkPeR+tSk/eTtooXi3A^Am~NN<tNnisNtRm/Xt_nkAtEmeEnE%yE*EyIngIsOughtReeRi=RowUmbUnd 0CketDeG LtMb MeNyPRedSsueT!5A,BaccoDayDdl EGe` I!tK&MatoM%rowNeNgueNightOlO`PP-Pp!R^RnadoRtoi'SsT$Uri,W?dW WnY_{AdeAff-Ag-A(Ansf ApAshA=lAyEatEeEndI$IbeI{Igg ImIpOphyOub!U{UeUlyUmpetU,U`Y2BeIt]Mb!NaN}lRkeyRnRt!1El=EntyI)InI,O1PeP-$:5Ly5B*lla0Ab!Awa*C!Cov D DoFairFoldHappyIf%mIqueItIv 'KnownLo{TilUsu$Veil1Da>GradeHoldOnP Set1B<Ge0A+EEdEfulE![U$0Il.y:C<tCuumGueLidL!yL=NNishP%Rious/Ult3H-!L=tNd%Ntu*NueRbRifyRs]RyS'lT <3Ab!Br<tCiousCt%yDeoEw~a+Nta+Ol(Rtu$RusSaS.Su$T$Vid5C$I)IdLc<oLumeTeYa+:GeG#ItLk~LnutNtRfa*RmRri%ShSp/eT VeY3Al`Ap#ArA'lA` BDd(gEk&dIrdLcome/T_!AtEatEelEnE*IpIsp 0DeD`FeLd~NNdowNeNgNkNn Nt ReSdomSeShT}[5LfM<Nd OdOlRdRkRldRryR`_pE{E,!I,I>Ong::Rd3Ar~ow9UUngU`:3BraRo9NeO";
var checksum = "0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60";
var _wordlist = null;
/**
 *  The [[link-bip39-en]] for [mnemonic phrases](link-bip-39).
 *
 *  @_docloc: api/wordlists
 */
var LangEn = /*#__PURE__*/function (_wordlist_owl_js_1$Wo) {
  /**
   *  Creates a new instance of the English language Wordlist.
   *
   *  This should be unnecessary most of the time as the exported
   *  [[langEn]] should suffice.
   *
   *  @_ignore:
   */
  function LangEn() {
    _classCallCheck(this, LangEn);
    return _callSuper(this, LangEn, ["en", words, checksum]);
  }
  /**
   *  Returns a singleton instance of a ``LangEn``, creating it
   *  if this is the first time being called.
   */
  _inherits(LangEn, _wordlist_owl_js_1$Wo);
  return _createClass(LangEn, null, [{
    key: "wordlist",
    value: function wordlist() {
      if (_wordlist == null) {
        _wordlist = new LangEn();
      }
      return _wordlist;
    }
  }]);
}(wordlist_owl_js_1.WordlistOwl);
exports.LangEn = LangEn;

},{"./wordlist-owl.js":297}],297:[function(require,module,exports){
"use strict";

// Use the encode-latin.js script to create the necessary
// data files to be consumed by this class
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WordlistOwl = void 0;
var index_js_1 = require("../hash/index.js");
var index_js_2 = require("../utils/index.js");
var decode_owl_js_1 = require("./decode-owl.js");
var wordlist_js_1 = require("./wordlist.js");
/**
 *  An OWL format Wordlist is an encoding method that exploits
 *  the general locality of alphabetically sorted words to
 *  achieve a simple but effective means of compression.
 *
 *  This class is generally not useful to most developers as
 *  it is used mainly internally to keep Wordlists for languages
 *  based on ASCII-7 small.
 *
 *  If necessary, there are tools within the ``generation/`` folder
 *  to create the necessary data.
 */
var _data = /*#__PURE__*/new WeakMap();
var _checksum = /*#__PURE__*/new WeakMap();
var _words = /*#__PURE__*/new WeakMap();
var _WordlistOwl_brand = /*#__PURE__*/new WeakSet();
var WordlistOwl = /*#__PURE__*/function (_wordlist_js_1$Wordli) {
  /**
   *  Creates a new Wordlist for %%locale%% using the OWL %%data%%
   *  and validated against the %%checksum%%.
   */
  function WordlistOwl(locale, data, _checksum2) {
    var _this;
    _classCallCheck(this, WordlistOwl);
    _this = _callSuper(this, WordlistOwl, [locale]);
    _classPrivateMethodInitSpec(_this, _WordlistOwl_brand);
    _classPrivateFieldInitSpec(_this, _data, void 0);
    _classPrivateFieldInitSpec(_this, _checksum, void 0);
    _classPrivateFieldInitSpec(_this, _words, void 0);
    _classPrivateFieldSet(_data, _this, data);
    _classPrivateFieldSet(_checksum, _this, _checksum2);
    _classPrivateFieldSet(_words, _this, null);
    return _this;
  }
  /**
   *  The OWL-encoded data.
   */
  _inherits(WordlistOwl, _wordlist_js_1$Wordli);
  return _createClass(WordlistOwl, [{
    key: "_data",
    get: function get() {
      return _classPrivateFieldGet(_data, this);
    }
    /**
     *  Decode all the words for the wordlist.
     */
  }, {
    key: "_decodeWords",
    value: function _decodeWords() {
      return (0, decode_owl_js_1.decodeOwl)(_classPrivateFieldGet(_data, this));
    }
  }, {
    key: "getWord",
    value: function getWord(index) {
      var words = _assertClassBrand(_WordlistOwl_brand, this, _loadWords).call(this);
      (0, index_js_2.assertArgument)(index >= 0 && index < words.length, "invalid word index: ".concat(index), "index", index);
      return words[index];
    }
  }, {
    key: "getWordIndex",
    value: function getWordIndex(word) {
      return _assertClassBrand(_WordlistOwl_brand, this, _loadWords).call(this).indexOf(word);
    }
  }]);
}(wordlist_js_1.Wordlist);
function _loadWords() {
  if (_classPrivateFieldGet(_words, this) == null) {
    var words = this._decodeWords();
    // Verify the computed list matches the official list
    var checksum = (0, index_js_1.id)(words.join("\n") + "\n");
    /* c8 ignore start */
    if (checksum !== _classPrivateFieldGet(_checksum, this)) {
      throw new Error("BIP39 Wordlist for ".concat(this.locale, " FAILED"));
    }
    /* c8 ignore stop */
    _classPrivateFieldSet(_words, this, words);
  }
  return _classPrivateFieldGet(_words, this);
}
exports.WordlistOwl = WordlistOwl;

},{"../hash/index.js":230,"../utils/index.js":276,"./decode-owl.js":293,"./wordlist.js":299}],298:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }
function _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }
function _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }
function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
function _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }
function _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }
function _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }
function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WordlistOwlA = void 0;
var wordlist_owl_js_1 = require("./wordlist-owl.js");
var decode_owla_js_1 = require("./decode-owla.js");
/**
 *  An OWL-A format Wordlist extends the OWL format to add an
 *  overlay onto an OWL format Wordlist to support diacritic
 *  marks.
 *
 *  This class is generally not useful to most developers as
 *  it is used mainly internally to keep Wordlists for languages
 *  based on latin-1 small.
 *
 *  If necessary, there are tools within the ``generation/`` folder
 *  to create the necessary data.
 */
var _accent = /*#__PURE__*/new WeakMap();
var WordlistOwlA = /*#__PURE__*/function (_wordlist_owl_js_1$Wo) {
  /**
   *  Creates a new Wordlist for %%locale%% using the OWLA %%data%%
   *  and %%accent%% data and validated against the %%checksum%%.
   */
  function WordlistOwlA(locale, data, accent, checksum) {
    var _this;
    _classCallCheck(this, WordlistOwlA);
    _this = _callSuper(this, WordlistOwlA, [locale, data, checksum]);
    _classPrivateFieldInitSpec(_this, _accent, void 0);
    _classPrivateFieldSet(_accent, _this, accent);
    return _this;
  }
  /**
   *  The OWLA-encoded accent data.
   */
  _inherits(WordlistOwlA, _wordlist_owl_js_1$Wo);
  return _createClass(WordlistOwlA, [{
    key: "_accent",
    get: function get() {
      return _classPrivateFieldGet(_accent, this);
    }
    /**
     *  Decode all the words for the wordlist.
     */
  }, {
    key: "_decodeWords",
    value: function _decodeWords() {
      return (0, decode_owla_js_1.decodeOwlA)(this._data, this._accent);
    }
  }]);
}(wordlist_owl_js_1.WordlistOwl);
exports.WordlistOwlA = WordlistOwlA;

},{"./decode-owla.js":294,"./wordlist-owl.js":297}],299:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Wordlist = void 0;
var index_js_1 = require("../utils/index.js");
/**
 *  A Wordlist represents a collection of language-specific
 *  words used to encode and devoce [[link-bip-39]] encoded data
 *  by mapping words to 11-bit values and vice versa.
 */
var Wordlist = /*#__PURE__*/function () {
  /**
   *  Creates a new Wordlist instance.
   *
   *  Sub-classes MUST call this if they provide their own constructor,
   *  passing in the locale string of the language.
   *
   *  Generally there is no need to create instances of a Wordlist,
   *  since each language-specific Wordlist creates an instance and
   *  there is no state kept internally, so they are safe to share.
   */
  function Wordlist(locale) {
    _classCallCheck(this, Wordlist);
    _defineProperty(this, "locale", void 0);
    (0, index_js_1.defineProperties)(this, {
      locale: locale
    });
  }
  /**
   *  Sub-classes may override this to provide a language-specific
   *  method for spliting %%phrase%% into individual words.
   *
   *  By default, %%phrase%% is split using any sequences of
   *  white-space as defined by regular expressions (i.e. ``/\s+/``).
   */
  return _createClass(Wordlist, [{
    key: "split",
    value: function split(phrase) {
      return phrase.toLowerCase().split(/\s+/g);
    }
    /**
     *  Sub-classes may override this to provider a language-specific
     *  method for joining %%words%% into a phrase.
     *
     *  By default, %%words%% are joined by a single space.
     */
  }, {
    key: "join",
    value: function join(words) {
      return words.join(" ");
    }
  }]);
}();
exports.Wordlist = Wordlist;

},{"../utils/index.js":276}],300:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.wordlists = void 0;
var lang_en_js_1 = require("./lang-en.js");
exports.wordlists = {
  en: lang_en_js_1.LangEn.wordlist()
};

},{"./lang-en.js":296}],301:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var R = (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === 'object' ? Reflect : null;
var ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {
  return Function.prototype.apply.call(target, receiver, args);
};
var ReflectOwnKeys;
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys;
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}
function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}
var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
};
function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;
function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + _typeof(listener));
  }
}
Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function get() {
    return defaultMaxListeners;
  },
  set: function set(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});
EventEmitter.init = function () {
  if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }
  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};
function _getMaxListeners(that) {
  if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}
EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};
EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = type === 'error';
  var events = this._events;
  if (events !== undefined) doError = doError && events.error === undefined;else if (!doError) return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0) er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }
  var handler = events[type];
  if (handler === undefined) return false;
  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i) ReflectApply(listeners[i], this, args);
  }
  return true;
};
function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;
  checkListener(listener);
  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type, listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }
  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] = prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }
  return target;
}
EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.prependListener = function prependListener(type, listener) {
  return _addListener(this, type, listener, true);
};
function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0) return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}
function _onceWrap(target, type, listener) {
  var state = {
    fired: false,
    wrapFn: undefined,
    target: target,
    type: type,
    listener: listener
  };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}
EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};
EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
  checkListener(listener);
  this.prependListener(type, _onceWrap(this, type, listener));
  return this;
};

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener = function removeListener(type, listener) {
  var list, events, position, i, originalListener;
  checkListener(listener);
  events = this._events;
  if (events === undefined) return this;
  list = events[type];
  if (list === undefined) return this;
  if (list === listener || list.listener === listener) {
    if (--this._eventsCount === 0) this._events = Object.create(null);else {
      delete events[type];
      if (events.removeListener) this.emit('removeListener', type, list.listener || listener);
    }
  } else if (typeof list !== 'function') {
    position = -1;
    for (i = list.length - 1; i >= 0; i--) {
      if (list[i] === listener || list[i].listener === listener) {
        originalListener = list[i].listener;
        position = i;
        break;
      }
    }
    if (position < 0) return this;
    if (position === 0) list.shift();else {
      spliceOne(list, position);
    }
    if (list.length === 1) events[type] = list[0];
    if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);
  }
  return this;
};
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
  var listeners, events, i;
  events = this._events;
  if (events === undefined) return this;

  // not listening for removeListener, no need to emit
  if (events.removeListener === undefined) {
    if (arguments.length === 0) {
      this._events = Object.create(null);
      this._eventsCount = 0;
    } else if (events[type] !== undefined) {
      if (--this._eventsCount === 0) this._events = Object.create(null);else delete events[type];
    }
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    var keys = Object.keys(events);
    var key;
    for (i = 0; i < keys.length; ++i) {
      key = keys[i];
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = Object.create(null);
    this._eventsCount = 0;
    return this;
  }
  listeners = events[type];
  if (typeof listeners === 'function') {
    this.removeListener(type, listeners);
  } else if (listeners !== undefined) {
    // LIFO order
    for (i = listeners.length - 1; i >= 0; i--) {
      this.removeListener(type, listeners[i]);
    }
  }
  return this;
};
function _listeners(target, type, unwrap) {
  var events = target._events;
  if (events === undefined) return [];
  var evlistener = events[type];
  if (evlistener === undefined) return [];
  if (typeof evlistener === 'function') return unwrap ? [evlistener.listener || evlistener] : [evlistener];
  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}
EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};
EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};
EventEmitter.listenerCount = function (emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};
EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;
  if (events !== undefined) {
    var evlistener = events[type];
    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }
  return 0;
}
EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};
function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i) copy[i] = arr[i];
  return copy;
}
function spliceOne(list, index) {
  for (; index + 1 < list.length; index++) list[index] = list[index + 1];
  list.pop();
}
function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}
function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }
    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    }
    ;
    eventTargetAgnosticAddListener(emitter, name, resolver, {
      once: true
    });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, {
        once: true
      });
    }
  });
}
function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}
function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + _typeof(emitter));
  }
}

},{}],302:[function(require,module,exports){
"use strict";

var Buffer = require('safe-buffer').Buffer;
var MD5 = require('md5.js');

/* eslint-disable camelcase */
function EVP_BytesToKey(password, salt, keyBits, ivLen) {
  if (!Buffer.isBuffer(password)) password = Buffer.from(password, 'binary');
  if (salt) {
    if (!Buffer.isBuffer(salt)) salt = Buffer.from(salt, 'binary');
    if (salt.length !== 8) throw new RangeError('salt should be Buffer with 8 byte length');
  }
  var keyLen = keyBits / 8;
  var key = Buffer.alloc(keyLen);
  var iv = Buffer.alloc(ivLen || 0);
  var tmp = Buffer.alloc(0);
  while (keyLen > 0 || ivLen > 0) {
    var hash = new MD5();
    hash.update(tmp);
    hash.update(password);
    if (salt) hash.update(salt);
    tmp = hash.digest();
    var used = 0;
    if (keyLen > 0) {
      var keyStart = key.length - keyLen;
      used = Math.min(keyLen, tmp.length);
      tmp.copy(key, keyStart, 0, used);
      keyLen -= used;
    }
    if (used < tmp.length && ivLen > 0) {
      var ivStart = iv.length - ivLen;
      var length = Math.min(ivLen, tmp.length - used);
      tmp.copy(iv, ivStart, used, used + length);
      ivLen -= length;
    }
  }
  tmp.fill(0);
  return {
    key: key,
    iv: iv
  };
}
module.exports = EVP_BytesToKey;

},{"md5.js":340,"safe-buffer":384}],303:[function(require,module,exports){
'use strict';

/* eslint no-invalid-this: 1 */
var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var toStr = Object.prototype.toString;
var max = Math.max;
var funcType = '[object Function]';
var concatty = function concatty(a, b) {
  var arr = [];
  for (var i = 0; i < a.length; i += 1) {
    arr[i] = a[i];
  }
  for (var j = 0; j < b.length; j += 1) {
    arr[j + a.length] = b[j];
  }
  return arr;
};
var slicy = function slicy(arrLike, offset) {
  var arr = [];
  for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
    arr[j] = arrLike[i];
  }
  return arr;
};
var joiny = function joiny(arr, joiner) {
  var str = '';
  for (var i = 0; i < arr.length; i += 1) {
    str += arr[i];
    if (i + 1 < arr.length) {
      str += joiner;
    }
  }
  return str;
};
module.exports = function bind(that) {
  var target = this;
  if (typeof target !== 'function' || toStr.apply(target) !== funcType) {
    throw new TypeError(ERROR_MESSAGE + target);
  }
  var args = slicy(arguments, 1);
  var bound;
  var binder = function binder() {
    if (this instanceof bound) {
      var result = target.apply(this, concatty(args, arguments));
      if (Object(result) === result) {
        return result;
      }
      return this;
    }
    return target.apply(that, concatty(args, arguments));
  };
  var boundLength = max(0, target.length - args.length);
  var boundArgs = [];
  for (var i = 0; i < boundLength; i++) {
    boundArgs[i] = '$' + i;
  }
  bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);
  if (target.prototype) {
    var Empty = function Empty() {};
    Empty.prototype = target.prototype;
    bound.prototype = new Empty();
    Empty.prototype = null;
  }
  return bound;
};

},{}],304:[function(require,module,exports){
'use strict';

var implementation = require('./implementation');
module.exports = Function.prototype.bind || implementation;

},{"./implementation":303}],305:[function(require,module,exports){
'use strict';

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var undefined;
var $Error = require('es-errors');
var $EvalError = require('es-errors/eval');
var $RangeError = require('es-errors/range');
var $ReferenceError = require('es-errors/ref');
var $SyntaxError = require('es-errors/syntax');
var $TypeError = require('es-errors/type');
var $URIError = require('es-errors/uri');
var $Function = Function;

// eslint-disable-next-line consistent-return
var getEvalledConstructor = function getEvalledConstructor(expressionSyntax) {
  try {
    return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
  } catch (e) {}
};
var $gOPD = Object.getOwnPropertyDescriptor;
if ($gOPD) {
  try {
    $gOPD({}, '');
  } catch (e) {
    $gOPD = null; // this is IE 8, which has a broken gOPD
  }
}
var throwTypeError = function throwTypeError() {
  throw new $TypeError();
};
var ThrowTypeError = $gOPD ? function () {
  try {
    // eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
    arguments.callee; // IE 8 does not throw here
    return throwTypeError;
  } catch (calleeThrows) {
    try {
      // IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
      return $gOPD(arguments, 'callee').get;
    } catch (gOPDthrows) {
      return throwTypeError;
    }
  }
}() : throwTypeError;
var hasSymbols = require('has-symbols')();
var hasProto = require('has-proto')();
var getProto = Object.getPrototypeOf || (hasProto ? function (x) {
  return x.__proto__;
} // eslint-disable-line no-proto
: null);
var needsEval = {};
var TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined : getProto(Uint8Array);
var INTRINSICS = {
  __proto__: null,
  '%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
  '%Array%': Array,
  '%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
  '%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined,
  '%AsyncFromSyncIteratorPrototype%': undefined,
  '%AsyncFunction%': needsEval,
  '%AsyncGenerator%': needsEval,
  '%AsyncGeneratorFunction%': needsEval,
  '%AsyncIteratorPrototype%': needsEval,
  '%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
  '%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
  '%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined : BigInt64Array,
  '%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined : BigUint64Array,
  '%Boolean%': Boolean,
  '%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
  '%Date%': Date,
  '%decodeURI%': decodeURI,
  '%decodeURIComponent%': decodeURIComponent,
  '%encodeURI%': encodeURI,
  '%encodeURIComponent%': encodeURIComponent,
  '%Error%': $Error,
  '%eval%': eval,
  // eslint-disable-line no-eval
  '%EvalError%': $EvalError,
  '%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
  '%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
  '%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
  '%Function%': $Function,
  '%GeneratorFunction%': needsEval,
  '%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
  '%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
  '%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
  '%isFinite%': isFinite,
  '%isNaN%': isNaN,
  '%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined,
  '%JSON%': (typeof JSON === "undefined" ? "undefined" : _typeof(JSON)) === 'object' ? JSON : undefined,
  '%Map%': typeof Map === 'undefined' ? undefined : Map,
  '%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Map()[Symbol.iterator]()),
  '%Math%': Math,
  '%Number%': Number,
  '%Object%': Object,
  '%parseFloat%': parseFloat,
  '%parseInt%': parseInt,
  '%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
  '%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
  '%RangeError%': $RangeError,
  '%ReferenceError%': $ReferenceError,
  '%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
  '%RegExp%': RegExp,
  '%Set%': typeof Set === 'undefined' ? undefined : Set,
  '%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Set()[Symbol.iterator]()),
  '%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
  '%String%': String,
  '%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined,
  '%Symbol%': hasSymbols ? Symbol : undefined,
  '%SyntaxError%': $SyntaxError,
  '%ThrowTypeError%': ThrowTypeError,
  '%TypedArray%': TypedArray,
  '%TypeError%': $TypeError,
  '%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
  '%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
  '%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
  '%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
  '%URIError%': $URIError,
  '%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
  '%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
  '%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet
};
if (getProto) {
  try {
    null.error; // eslint-disable-line no-unused-expressions
  } catch (e) {
    // https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
    var errorProto = getProto(getProto(e));
    INTRINSICS['%Error.prototype%'] = errorProto;
  }
}
var doEval = function doEval(name) {
  var value;
  if (name === '%AsyncFunction%') {
    value = getEvalledConstructor('async function () {}');
  } else if (name === '%GeneratorFunction%') {
    value = getEvalledConstructor('function* () {}');
  } else if (name === '%AsyncGeneratorFunction%') {
    value = getEvalledConstructor('async function* () {}');
  } else if (name === '%AsyncGenerator%') {
    var fn = doEval('%AsyncGeneratorFunction%');
    if (fn) {
      value = fn.prototype;
    }
  } else if (name === '%AsyncIteratorPrototype%') {
    var gen = doEval('%AsyncGenerator%');
    if (gen && getProto) {
      value = getProto(gen.prototype);
    }
  }
  INTRINSICS[name] = value;
  return value;
};
var LEGACY_ALIASES = {
  __proto__: null,
  '%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
  '%ArrayPrototype%': ['Array', 'prototype'],
  '%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
  '%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
  '%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
  '%ArrayProto_values%': ['Array', 'prototype', 'values'],
  '%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
  '%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
  '%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
  '%BooleanPrototype%': ['Boolean', 'prototype'],
  '%DataViewPrototype%': ['DataView', 'prototype'],
  '%DatePrototype%': ['Date', 'prototype'],
  '%ErrorPrototype%': ['Error', 'prototype'],
  '%EvalErrorPrototype%': ['EvalError', 'prototype'],
  '%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
  '%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
  '%FunctionPrototype%': ['Function', 'prototype'],
  '%Generator%': ['GeneratorFunction', 'prototype'],
  '%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
  '%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
  '%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
  '%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
  '%JSONParse%': ['JSON', 'parse'],
  '%JSONStringify%': ['JSON', 'stringify'],
  '%MapPrototype%': ['Map', 'prototype'],
  '%NumberPrototype%': ['Number', 'prototype'],
  '%ObjectPrototype%': ['Object', 'prototype'],
  '%ObjProto_toString%': ['Object', 'prototype', 'toString'],
  '%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
  '%PromisePrototype%': ['Promise', 'prototype'],
  '%PromiseProto_then%': ['Promise', 'prototype', 'then'],
  '%Promise_all%': ['Promise', 'all'],
  '%Promise_reject%': ['Promise', 'reject'],
  '%Promise_resolve%': ['Promise', 'resolve'],
  '%RangeErrorPrototype%': ['RangeError', 'prototype'],
  '%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
  '%RegExpPrototype%': ['RegExp', 'prototype'],
  '%SetPrototype%': ['Set', 'prototype'],
  '%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
  '%StringPrototype%': ['String', 'prototype'],
  '%SymbolPrototype%': ['Symbol', 'prototype'],
  '%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
  '%TypedArrayPrototype%': ['TypedArray', 'prototype'],
  '%TypeErrorPrototype%': ['TypeError', 'prototype'],
  '%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
  '%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
  '%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
  '%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
  '%URIErrorPrototype%': ['URIError', 'prototype'],
  '%WeakMapPrototype%': ['WeakMap', 'prototype'],
  '%WeakSetPrototype%': ['WeakSet', 'prototype']
};
var bind = require('function-bind');
var hasOwn = require('hasown');
var $concat = bind.call(Function.call, Array.prototype.concat);
var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
var $replace = bind.call(Function.call, String.prototype.replace);
var $strSlice = bind.call(Function.call, String.prototype.slice);
var $exec = bind.call(Function.call, RegExp.prototype.exec);

/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
var stringToPath = function stringToPath(string) {
  var first = $strSlice(string, 0, 1);
  var last = $strSlice(string, -1);
  if (first === '%' && last !== '%') {
    throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
  } else if (last === '%' && first !== '%') {
    throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
  }
  var result = [];
  $replace(string, rePropName, function (match, number, quote, subString) {
    result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
  });
  return result;
};
/* end adaptation */

var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
  var intrinsicName = name;
  var alias;
  if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
    alias = LEGACY_ALIASES[intrinsicName];
    intrinsicName = '%' + alias[0] + '%';
  }
  if (hasOwn(INTRINSICS, intrinsicName)) {
    var value = INTRINSICS[intrinsicName];
    if (value === needsEval) {
      value = doEval(intrinsicName);
    }
    if (typeof value === 'undefined' && !allowMissing) {
      throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
    }
    return {
      alias: alias,
      name: intrinsicName,
      value: value
    };
  }
  throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};
module.exports = function GetIntrinsic(name, allowMissing) {
  if (typeof name !== 'string' || name.length === 0) {
    throw new $TypeError('intrinsic name must be a non-empty string');
  }
  if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
    throw new $TypeError('"allowMissing" argument must be a boolean');
  }
  if ($exec(/^%?[^%]*%?$/, name) === null) {
    throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
  }
  var parts = stringToPath(name);
  var intrinsicBaseName = parts.length > 0 ? parts[0] : '';
  var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
  var intrinsicRealName = intrinsic.name;
  var value = intrinsic.value;
  var skipFurtherCaching = false;
  var alias = intrinsic.alias;
  if (alias) {
    intrinsicBaseName = alias[0];
    $spliceApply(parts, $concat([0, 1], alias));
  }
  for (var i = 1, isOwn = true; i < parts.length; i += 1) {
    var part = parts[i];
    var first = $strSlice(part, 0, 1);
    var last = $strSlice(part, -1);
    if ((first === '"' || first === "'" || first === '`' || last === '"' || last === "'" || last === '`') && first !== last) {
      throw new $SyntaxError('property names with quotes must have matching quotes');
    }
    if (part === 'constructor' || !isOwn) {
      skipFurtherCaching = true;
    }
    intrinsicBaseName += '.' + part;
    intrinsicRealName = '%' + intrinsicBaseName + '%';
    if (hasOwn(INTRINSICS, intrinsicRealName)) {
      value = INTRINSICS[intrinsicRealName];
    } else if (value != null) {
      if (!(part in value)) {
        if (!allowMissing) {
          throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
        }
        return void undefined;
      }
      if ($gOPD && i + 1 >= parts.length) {
        var desc = $gOPD(value, part);
        isOwn = !!desc;

        // By convention, when a data property is converted to an accessor
        // property to emulate a data property that does not suffer from
        // the override mistake, that accessor's getter is marked with
        // an `originalValue` property. Here, when we detect this, we
        // uphold the illusion by pretending to see that original data
        // property, i.e., returning the value rather than the getter
        // itself.
        if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
          value = desc.get;
        } else {
          value = value[part];
        }
      } else {
        isOwn = hasOwn(value, part);
        value = value[part];
      }
      if (isOwn && !skipFurtherCaching) {
        INTRINSICS[intrinsicRealName] = value;
      }
    }
  }
  return value;
};

},{"es-errors":180,"es-errors/eval":179,"es-errors/range":181,"es-errors/ref":182,"es-errors/syntax":183,"es-errors/type":184,"es-errors/uri":185,"function-bind":304,"has-proto":308,"has-symbols":309,"hasown":324}],306:[function(require,module,exports){
'use strict';

var GetIntrinsic = require('get-intrinsic');
var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);
if ($gOPD) {
  try {
    $gOPD([], 'length');
  } catch (e) {
    // IE 8 has a broken gOPD
    $gOPD = null;
  }
}
module.exports = $gOPD;

},{"get-intrinsic":305}],307:[function(require,module,exports){
'use strict';

var $defineProperty = require('es-define-property');
var hasPropertyDescriptors = function hasPropertyDescriptors() {
  return !!$defineProperty;
};
hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
  // node v0.6 has a bug where array lengths can be Set but not Defined
  if (!$defineProperty) {
    return null;
  }
  try {
    return $defineProperty([], 'length', {
      value: 1
    }).length !== 1;
  } catch (e) {
    // In Firefox 4-22, defining length on an array throws an exception.
    return true;
  }
};
module.exports = hasPropertyDescriptors;

},{"es-define-property":178}],308:[function(require,module,exports){
'use strict';

var test = {
  __proto__: null,
  foo: {}
};
var $Object = Object;

/** @type {import('.')} */
module.exports = function hasProto() {
  // @ts-expect-error: TS errors on an inherited property for some reason
  return {
    __proto__: test
  }.foo === test.foo && !(test instanceof $Object);
};

},{}],309:[function(require,module,exports){
'use strict';

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var origSymbol = typeof Symbol !== 'undefined' && Symbol;
var hasSymbolSham = require('./shams');
module.exports = function hasNativeSymbols() {
  if (typeof origSymbol !== 'function') {
    return false;
  }
  if (typeof Symbol !== 'function') {
    return false;
  }
  if (_typeof(origSymbol('foo')) !== 'symbol') {
    return false;
  }
  if (_typeof(Symbol('bar')) !== 'symbol') {
    return false;
  }
  return hasSymbolSham();
};

},{"./shams":310}],310:[function(require,module,exports){
'use strict';

/* eslint complexity: [2, 18], max-statements: [2, 33] */
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
module.exports = function hasSymbols() {
  if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') {
    return false;
  }
  if (_typeof(Symbol.iterator) === 'symbol') {
    return true;
  }
  var obj = {};
  var sym = Symbol('test');
  var symObj = Object(sym);
  if (typeof sym === 'string') {
    return false;
  }
  if (Object.prototype.toString.call(sym) !== '[object Symbol]') {
    return false;
  }
  if (Object.prototype.toString.call(symObj) !== '[object Symbol]') {
    return false;
  }

  // temp disabled per https://github.com/ljharb/object.assign/issues/17
  // if (sym instanceof Symbol) { return false; }
  // temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
  // if (!(symObj instanceof Symbol)) { return false; }

  // if (typeof Symbol.prototype.toString !== 'function') { return false; }
  // if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

  var symVal = 42;
  obj[sym] = symVal;
  for (sym in obj) {
    return false;
  } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
  if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) {
    return false;
  }
  if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) {
    return false;
  }
  var syms = Object.getOwnPropertySymbols(obj);
  if (syms.length !== 1 || syms[0] !== sym) {
    return false;
  }
  if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
    return false;
  }
  if (typeof Object.getOwnPropertyDescriptor === 'function') {
    var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
    if (descriptor.value !== symVal || descriptor.enumerable !== true) {
      return false;
    }
  }
  return true;
};

},{}],311:[function(require,module,exports){
'use strict';

var Buffer = require('safe-buffer').Buffer;
var Transform = require('stream').Transform;
var inherits = require('inherits');
function throwIfNotStringOrBuffer(val, prefix) {
  if (!Buffer.isBuffer(val) && typeof val !== 'string') {
    throw new TypeError(prefix + ' must be a string or a buffer');
  }
}
function HashBase(blockSize) {
  Transform.call(this);
  this._block = Buffer.allocUnsafe(blockSize);
  this._blockSize = blockSize;
  this._blockOffset = 0;
  this._length = [0, 0, 0, 0];
  this._finalized = false;
}
inherits(HashBase, Transform);
HashBase.prototype._transform = function (chunk, encoding, callback) {
  var error = null;
  try {
    this.update(chunk, encoding);
  } catch (err) {
    error = err;
  }
  callback(error);
};
HashBase.prototype._flush = function (callback) {
  var error = null;
  try {
    this.push(this.digest());
  } catch (err) {
    error = err;
  }
  callback(error);
};
HashBase.prototype.update = function (data, encoding) {
  throwIfNotStringOrBuffer(data, 'Data');
  if (this._finalized) throw new Error('Digest already called');
  if (!Buffer.isBuffer(data)) data = Buffer.from(data, encoding);

  // consume data
  var block = this._block;
  var offset = 0;
  while (this._blockOffset + data.length - offset >= this._blockSize) {
    for (var i = this._blockOffset; i < this._blockSize;) block[i++] = data[offset++];
    this._update();
    this._blockOffset = 0;
  }
  while (offset < data.length) block[this._blockOffset++] = data[offset++];

  // update length
  for (var j = 0, carry = data.length * 8; carry > 0; ++j) {
    this._length[j] += carry;
    carry = this._length[j] / 0x0100000000 | 0;
    if (carry > 0) this._length[j] -= 0x0100000000 * carry;
  }
  return this;
};
HashBase.prototype._update = function () {
  throw new Error('_update is not implemented');
};
HashBase.prototype.digest = function (encoding) {
  if (this._finalized) throw new Error('Digest already called');
  this._finalized = true;
  var digest = this._digest();
  if (encoding !== undefined) digest = digest.toString(encoding);

  // reset state
  this._block.fill(0);
  this._blockOffset = 0;
  for (var i = 0; i < 4; ++i) this._length[i] = 0;
  return digest;
};
HashBase.prototype._digest = function () {
  throw new Error('_digest is not implemented');
};
module.exports = HashBase;

},{"inherits":327,"safe-buffer":384,"stream":401}],312:[function(require,module,exports){
"use strict";

var hash = exports;
hash.utils = require('./hash/utils');
hash.common = require('./hash/common');
hash.sha = require('./hash/sha');
hash.ripemd = require('./hash/ripemd');
hash.hmac = require('./hash/hmac');

// Proxy hash functions to the main object
hash.sha1 = hash.sha.sha1;
hash.sha256 = hash.sha.sha256;
hash.sha224 = hash.sha.sha224;
hash.sha384 = hash.sha.sha384;
hash.sha512 = hash.sha.sha512;
hash.ripemd160 = hash.ripemd.ripemd160;

},{"./hash/common":313,"./hash/hmac":314,"./hash/ripemd":315,"./hash/sha":316,"./hash/utils":323}],313:[function(require,module,exports){
'use strict';

var utils = require('./utils');
var assert = require('minimalistic-assert');
function BlockHash() {
  this.pending = null;
  this.pendingTotal = 0;
  this.blockSize = this.constructor.blockSize;
  this.outSize = this.constructor.outSize;
  this.hmacStrength = this.constructor.hmacStrength;
  this.padLength = this.constructor.padLength / 8;
  this.endian = 'big';
  this._delta8 = this.blockSize / 8;
  this._delta32 = this.blockSize / 32;
}
exports.BlockHash = BlockHash;
BlockHash.prototype.update = function update(msg, enc) {
  // Convert message to array, pad it, and join into 32bit blocks
  msg = utils.toArray(msg, enc);
  if (!this.pending) this.pending = msg;else this.pending = this.pending.concat(msg);
  this.pendingTotal += msg.length;

  // Enough data, try updating
  if (this.pending.length >= this._delta8) {
    msg = this.pending;

    // Process pending data in blocks
    var r = msg.length % this._delta8;
    this.pending = msg.slice(msg.length - r, msg.length);
    if (this.pending.length === 0) this.pending = null;
    msg = utils.join32(msg, 0, msg.length - r, this.endian);
    for (var i = 0; i < msg.length; i += this._delta32) this._update(msg, i, i + this._delta32);
  }
  return this;
};
BlockHash.prototype.digest = function digest(enc) {
  this.update(this._pad());
  assert(this.pending === null);
  return this._digest(enc);
};
BlockHash.prototype._pad = function pad() {
  var len = this.pendingTotal;
  var bytes = this._delta8;
  var k = bytes - (len + this.padLength) % bytes;
  var res = new Array(k + this.padLength);
  res[0] = 0x80;
  for (var i = 1; i < k; i++) res[i] = 0;

  // Append length
  len <<= 3;
  if (this.endian === 'big') {
    for (var t = 8; t < this.padLength; t++) res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = len >>> 24 & 0xff;
    res[i++] = len >>> 16 & 0xff;
    res[i++] = len >>> 8 & 0xff;
    res[i++] = len & 0xff;
  } else {
    res[i++] = len & 0xff;
    res[i++] = len >>> 8 & 0xff;
    res[i++] = len >>> 16 & 0xff;
    res[i++] = len >>> 24 & 0xff;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    for (t = 8; t < this.padLength; t++) res[i++] = 0;
  }
  return res;
};

},{"./utils":323,"minimalistic-assert":342}],314:[function(require,module,exports){
'use strict';

var utils = require('./utils');
var assert = require('minimalistic-assert');
function Hmac(hash, key, enc) {
  if (!(this instanceof Hmac)) return new Hmac(hash, key, enc);
  this.Hash = hash;
  this.blockSize = hash.blockSize / 8;
  this.outSize = hash.outSize / 8;
  this.inner = null;
  this.outer = null;
  this._init(utils.toArray(key, enc));
}
module.exports = Hmac;
Hmac.prototype._init = function init(key) {
  // Shorten key, if needed
  if (key.length > this.blockSize) key = new this.Hash().update(key).digest();
  assert(key.length <= this.blockSize);

  // Add padding to key
  for (var i = key.length; i < this.blockSize; i++) key.push(0);
  for (i = 0; i < key.length; i++) key[i] ^= 0x36;
  this.inner = new this.Hash().update(key);

  // 0x36 ^ 0x5c = 0x6a
  for (i = 0; i < key.length; i++) key[i] ^= 0x6a;
  this.outer = new this.Hash().update(key);
};
Hmac.prototype.update = function update(msg, enc) {
  this.inner.update(msg, enc);
  return this;
};
Hmac.prototype.digest = function digest(enc) {
  this.outer.update(this.inner.digest());
  return this.outer.digest(enc);
};

},{"./utils":323,"minimalistic-assert":342}],315:[function(require,module,exports){
'use strict';

var utils = require('./utils');
var common = require('./common');
var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_3 = utils.sum32_3;
var sum32_4 = utils.sum32_4;
var BlockHash = common.BlockHash;
function RIPEMD160() {
  if (!(this instanceof RIPEMD160)) return new RIPEMD160();
  BlockHash.call(this);
  this.h = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];
  this.endian = 'little';
}
utils.inherits(RIPEMD160, BlockHash);
exports.ripemd160 = RIPEMD160;
RIPEMD160.blockSize = 512;
RIPEMD160.outSize = 160;
RIPEMD160.hmacStrength = 192;
RIPEMD160.padLength = 64;
RIPEMD160.prototype._update = function update(msg, start) {
  var A = this.h[0];
  var B = this.h[1];
  var C = this.h[2];
  var D = this.h[3];
  var E = this.h[4];
  var Ah = A;
  var Bh = B;
  var Ch = C;
  var Dh = D;
  var Eh = E;
  for (var j = 0; j < 80; j++) {
    var T = sum32(rotl32(sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)), s[j]), E);
    A = E;
    E = D;
    D = rotl32(C, 10);
    C = B;
    B = T;
    T = sum32(rotl32(sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)), sh[j]), Eh);
    Ah = Eh;
    Eh = Dh;
    Dh = rotl32(Ch, 10);
    Ch = Bh;
    Bh = T;
  }
  T = sum32_3(this.h[1], C, Dh);
  this.h[1] = sum32_3(this.h[2], D, Eh);
  this.h[2] = sum32_3(this.h[3], E, Ah);
  this.h[3] = sum32_3(this.h[4], A, Bh);
  this.h[4] = sum32_3(this.h[0], B, Ch);
  this.h[0] = T;
};
RIPEMD160.prototype._digest = function digest(enc) {
  if (enc === 'hex') return utils.toHex32(this.h, 'little');else return utils.split32(this.h, 'little');
};
function f(j, x, y, z) {
  if (j <= 15) return x ^ y ^ z;else if (j <= 31) return x & y | ~x & z;else if (j <= 47) return (x | ~y) ^ z;else if (j <= 63) return x & z | y & ~z;else return x ^ (y | ~z);
}
function K(j) {
  if (j <= 15) return 0x00000000;else if (j <= 31) return 0x5a827999;else if (j <= 47) return 0x6ed9eba1;else if (j <= 63) return 0x8f1bbcdc;else return 0xa953fd4e;
}
function Kh(j) {
  if (j <= 15) return 0x50a28be6;else if (j <= 31) return 0x5c4dd124;else if (j <= 47) return 0x6d703ef3;else if (j <= 63) return 0x7a6d76e9;else return 0x00000000;
}
var r = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13];
var rh = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11];
var s = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6];
var sh = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];

},{"./common":313,"./utils":323}],316:[function(require,module,exports){
'use strict';

exports.sha1 = require('./sha/1');
exports.sha224 = require('./sha/224');
exports.sha256 = require('./sha/256');
exports.sha384 = require('./sha/384');
exports.sha512 = require('./sha/512');

},{"./sha/1":317,"./sha/224":318,"./sha/256":319,"./sha/384":320,"./sha/512":321}],317:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var common = require('../common');
var shaCommon = require('./common');
var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_5 = utils.sum32_5;
var ft_1 = shaCommon.ft_1;
var BlockHash = common.BlockHash;
var sha1_K = [0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xCA62C1D6];
function SHA1() {
  if (!(this instanceof SHA1)) return new SHA1();
  BlockHash.call(this);
  this.h = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];
  this.W = new Array(80);
}
utils.inherits(SHA1, BlockHash);
module.exports = SHA1;
SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;
SHA1.prototype._update = function _update(msg, start) {
  var W = this.W;
  for (var i = 0; i < 16; i++) W[i] = msg[start + i];
  for (; i < W.length; i++) W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);
  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];
  for (i = 0; i < W.length; i++) {
    var s = ~~(i / 20);
    var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
    e = d;
    d = c;
    c = rotl32(b, 30);
    b = a;
    a = t;
  }
  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
};
SHA1.prototype._digest = function digest(enc) {
  if (enc === 'hex') return utils.toHex32(this.h, 'big');else return utils.split32(this.h, 'big');
};

},{"../common":313,"../utils":323,"./common":322}],318:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var SHA256 = require('./256');
function SHA224() {
  if (!(this instanceof SHA224)) return new SHA224();
  SHA256.call(this);
  this.h = [0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4];
}
utils.inherits(SHA224, SHA256);
module.exports = SHA224;
SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;
SHA224.prototype._digest = function digest(enc) {
  // Just truncate output
  if (enc === 'hex') return utils.toHex32(this.h.slice(0, 7), 'big');else return utils.split32(this.h.slice(0, 7), 'big');
};

},{"../utils":323,"./256":319}],319:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var common = require('../common');
var shaCommon = require('./common');
var assert = require('minimalistic-assert');
var sum32 = utils.sum32;
var sum32_4 = utils.sum32_4;
var sum32_5 = utils.sum32_5;
var ch32 = shaCommon.ch32;
var maj32 = shaCommon.maj32;
var s0_256 = shaCommon.s0_256;
var s1_256 = shaCommon.s1_256;
var g0_256 = shaCommon.g0_256;
var g1_256 = shaCommon.g1_256;
var BlockHash = common.BlockHash;
var sha256_K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];
function SHA256() {
  if (!(this instanceof SHA256)) return new SHA256();
  BlockHash.call(this);
  this.h = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];
  this.k = sha256_K;
  this.W = new Array(64);
}
utils.inherits(SHA256, BlockHash);
module.exports = SHA256;
SHA256.blockSize = 512;
SHA256.outSize = 256;
SHA256.hmacStrength = 192;
SHA256.padLength = 64;
SHA256.prototype._update = function _update(msg, start) {
  var W = this.W;
  for (var i = 0; i < 16; i++) W[i] = msg[start + i];
  for (; i < W.length; i++) W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);
  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];
  var f = this.h[5];
  var g = this.h[6];
  var h = this.h[7];
  assert(this.k.length === W.length);
  for (i = 0; i < W.length; i++) {
    var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
    var T2 = sum32(s0_256(a), maj32(a, b, c));
    h = g;
    g = f;
    f = e;
    e = sum32(d, T1);
    d = c;
    c = b;
    b = a;
    a = sum32(T1, T2);
  }
  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
  this.h[5] = sum32(this.h[5], f);
  this.h[6] = sum32(this.h[6], g);
  this.h[7] = sum32(this.h[7], h);
};
SHA256.prototype._digest = function digest(enc) {
  if (enc === 'hex') return utils.toHex32(this.h, 'big');else return utils.split32(this.h, 'big');
};

},{"../common":313,"../utils":323,"./common":322,"minimalistic-assert":342}],320:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var SHA512 = require('./512');
function SHA384() {
  if (!(this instanceof SHA384)) return new SHA384();
  SHA512.call(this);
  this.h = [0xcbbb9d5d, 0xc1059ed8, 0x629a292a, 0x367cd507, 0x9159015a, 0x3070dd17, 0x152fecd8, 0xf70e5939, 0x67332667, 0xffc00b31, 0x8eb44a87, 0x68581511, 0xdb0c2e0d, 0x64f98fa7, 0x47b5481d, 0xbefa4fa4];
}
utils.inherits(SHA384, SHA512);
module.exports = SHA384;
SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;
SHA384.prototype._digest = function digest(enc) {
  if (enc === 'hex') return utils.toHex32(this.h.slice(0, 12), 'big');else return utils.split32(this.h.slice(0, 12), 'big');
};

},{"../utils":323,"./512":321}],321:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var common = require('../common');
var assert = require('minimalistic-assert');
var rotr64_hi = utils.rotr64_hi;
var rotr64_lo = utils.rotr64_lo;
var shr64_hi = utils.shr64_hi;
var shr64_lo = utils.shr64_lo;
var sum64 = utils.sum64;
var sum64_hi = utils.sum64_hi;
var sum64_lo = utils.sum64_lo;
var sum64_4_hi = utils.sum64_4_hi;
var sum64_4_lo = utils.sum64_4_lo;
var sum64_5_hi = utils.sum64_5_hi;
var sum64_5_lo = utils.sum64_5_lo;
var BlockHash = common.BlockHash;
var sha512_K = [0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd, 0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc, 0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019, 0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118, 0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe, 0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2, 0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1, 0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694, 0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3, 0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65, 0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483, 0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5, 0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210, 0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4, 0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725, 0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70, 0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926, 0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df, 0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8, 0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b, 0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001, 0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30, 0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910, 0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8, 0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53, 0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8, 0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb, 0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3, 0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60, 0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec, 0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9, 0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b, 0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207, 0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178, 0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6, 0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b, 0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493, 0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c, 0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a, 0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817];
function SHA512() {
  if (!(this instanceof SHA512)) return new SHA512();
  BlockHash.call(this);
  this.h = [0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1, 0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179];
  this.k = sha512_K;
  this.W = new Array(160);
}
utils.inherits(SHA512, BlockHash);
module.exports = SHA512;
SHA512.blockSize = 1024;
SHA512.outSize = 512;
SHA512.hmacStrength = 192;
SHA512.padLength = 128;
SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
  var W = this.W;

  // 32 x 32bit words
  for (var i = 0; i < 32; i++) W[i] = msg[start + i];
  for (; i < W.length; i += 2) {
    var c0_hi = g1_512_hi(W[i - 4], W[i - 3]); // i - 2
    var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
    var c1_hi = W[i - 14]; // i - 7
    var c1_lo = W[i - 13];
    var c2_hi = g0_512_hi(W[i - 30], W[i - 29]); // i - 15
    var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
    var c3_hi = W[i - 32]; // i - 16
    var c3_lo = W[i - 31];
    W[i] = sum64_4_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
    W[i + 1] = sum64_4_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
  }
};
SHA512.prototype._update = function _update(msg, start) {
  this._prepareBlock(msg, start);
  var W = this.W;
  var ah = this.h[0];
  var al = this.h[1];
  var bh = this.h[2];
  var bl = this.h[3];
  var ch = this.h[4];
  var cl = this.h[5];
  var dh = this.h[6];
  var dl = this.h[7];
  var eh = this.h[8];
  var el = this.h[9];
  var fh = this.h[10];
  var fl = this.h[11];
  var gh = this.h[12];
  var gl = this.h[13];
  var hh = this.h[14];
  var hl = this.h[15];
  assert(this.k.length === W.length);
  for (var i = 0; i < W.length; i += 2) {
    var c0_hi = hh;
    var c0_lo = hl;
    var c1_hi = s1_512_hi(eh, el);
    var c1_lo = s1_512_lo(eh, el);
    var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
    var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
    var c3_hi = this.k[i];
    var c3_lo = this.k[i + 1];
    var c4_hi = W[i];
    var c4_lo = W[i + 1];
    var T1_hi = sum64_5_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
    var T1_lo = sum64_5_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
    c0_hi = s0_512_hi(ah, al);
    c0_lo = s0_512_lo(ah, al);
    c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
    c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);
    var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
    var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
    hh = gh;
    hl = gl;
    gh = fh;
    gl = fl;
    fh = eh;
    fl = el;
    eh = sum64_hi(dh, dl, T1_hi, T1_lo);
    el = sum64_lo(dl, dl, T1_hi, T1_lo);
    dh = ch;
    dl = cl;
    ch = bh;
    cl = bl;
    bh = ah;
    bl = al;
    ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
    al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
  }
  sum64(this.h, 0, ah, al);
  sum64(this.h, 2, bh, bl);
  sum64(this.h, 4, ch, cl);
  sum64(this.h, 6, dh, dl);
  sum64(this.h, 8, eh, el);
  sum64(this.h, 10, fh, fl);
  sum64(this.h, 12, gh, gl);
  sum64(this.h, 14, hh, hl);
};
SHA512.prototype._digest = function digest(enc) {
  if (enc === 'hex') return utils.toHex32(this.h, 'big');else return utils.split32(this.h, 'big');
};
function ch64_hi(xh, xl, yh, yl, zh) {
  var r = xh & yh ^ ~xh & zh;
  if (r < 0) r += 0x100000000;
  return r;
}
function ch64_lo(xh, xl, yh, yl, zh, zl) {
  var r = xl & yl ^ ~xl & zl;
  if (r < 0) r += 0x100000000;
  return r;
}
function maj64_hi(xh, xl, yh, yl, zh) {
  var r = xh & yh ^ xh & zh ^ yh & zh;
  if (r < 0) r += 0x100000000;
  return r;
}
function maj64_lo(xh, xl, yh, yl, zh, zl) {
  var r = xl & yl ^ xl & zl ^ yl & zl;
  if (r < 0) r += 0x100000000;
  return r;
}
function s0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 28);
  var c1_hi = rotr64_hi(xl, xh, 2); // 34
  var c2_hi = rotr64_hi(xl, xh, 7); // 39

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0) r += 0x100000000;
  return r;
}
function s0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 28);
  var c1_lo = rotr64_lo(xl, xh, 2); // 34
  var c2_lo = rotr64_lo(xl, xh, 7); // 39

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0) r += 0x100000000;
  return r;
}
function s1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 14);
  var c1_hi = rotr64_hi(xh, xl, 18);
  var c2_hi = rotr64_hi(xl, xh, 9); // 41

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0) r += 0x100000000;
  return r;
}
function s1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 14);
  var c1_lo = rotr64_lo(xh, xl, 18);
  var c2_lo = rotr64_lo(xl, xh, 9); // 41

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0) r += 0x100000000;
  return r;
}
function g0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 1);
  var c1_hi = rotr64_hi(xh, xl, 8);
  var c2_hi = shr64_hi(xh, xl, 7);
  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0) r += 0x100000000;
  return r;
}
function g0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 1);
  var c1_lo = rotr64_lo(xh, xl, 8);
  var c2_lo = shr64_lo(xh, xl, 7);
  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0) r += 0x100000000;
  return r;
}
function g1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 19);
  var c1_hi = rotr64_hi(xl, xh, 29); // 61
  var c2_hi = shr64_hi(xh, xl, 6);
  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0) r += 0x100000000;
  return r;
}
function g1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 19);
  var c1_lo = rotr64_lo(xl, xh, 29); // 61
  var c2_lo = shr64_lo(xh, xl, 6);
  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0) r += 0x100000000;
  return r;
}

},{"../common":313,"../utils":323,"minimalistic-assert":342}],322:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var rotr32 = utils.rotr32;
function ft_1(s, x, y, z) {
  if (s === 0) return ch32(x, y, z);
  if (s === 1 || s === 3) return p32(x, y, z);
  if (s === 2) return maj32(x, y, z);
}
exports.ft_1 = ft_1;
function ch32(x, y, z) {
  return x & y ^ ~x & z;
}
exports.ch32 = ch32;
function maj32(x, y, z) {
  return x & y ^ x & z ^ y & z;
}
exports.maj32 = maj32;
function p32(x, y, z) {
  return x ^ y ^ z;
}
exports.p32 = p32;
function s0_256(x) {
  return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
}
exports.s0_256 = s0_256;
function s1_256(x) {
  return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
}
exports.s1_256 = s1_256;
function g0_256(x) {
  return rotr32(x, 7) ^ rotr32(x, 18) ^ x >>> 3;
}
exports.g0_256 = g0_256;
function g1_256(x) {
  return rotr32(x, 17) ^ rotr32(x, 19) ^ x >>> 10;
}
exports.g1_256 = g1_256;

},{"../utils":323}],323:[function(require,module,exports){
'use strict';

var assert = require('minimalistic-assert');
var inherits = require('inherits');
exports.inherits = inherits;
function isSurrogatePair(msg, i) {
  if ((msg.charCodeAt(i) & 0xFC00) !== 0xD800) {
    return false;
  }
  if (i < 0 || i + 1 >= msg.length) {
    return false;
  }
  return (msg.charCodeAt(i + 1) & 0xFC00) === 0xDC00;
}
function toArray(msg, enc) {
  if (Array.isArray(msg)) return msg.slice();
  if (!msg) return [];
  var res = [];
  if (typeof msg === 'string') {
    if (!enc) {
      // Inspired by stringToUtf8ByteArray() in closure-library by Google
      // https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js#L117-L143
      // Apache License 2.0
      // https://github.com/google/closure-library/blob/master/LICENSE
      var p = 0;
      for (var i = 0; i < msg.length; i++) {
        var c = msg.charCodeAt(i);
        if (c < 128) {
          res[p++] = c;
        } else if (c < 2048) {
          res[p++] = c >> 6 | 192;
          res[p++] = c & 63 | 128;
        } else if (isSurrogatePair(msg, i)) {
          c = 0x10000 + ((c & 0x03FF) << 10) + (msg.charCodeAt(++i) & 0x03FF);
          res[p++] = c >> 18 | 240;
          res[p++] = c >> 12 & 63 | 128;
          res[p++] = c >> 6 & 63 | 128;
          res[p++] = c & 63 | 128;
        } else {
          res[p++] = c >> 12 | 224;
          res[p++] = c >> 6 & 63 | 128;
          res[p++] = c & 63 | 128;
        }
      }
    } else if (enc === 'hex') {
      msg = msg.replace(/[^a-z0-9]+/ig, '');
      if (msg.length % 2 !== 0) msg = '0' + msg;
      for (i = 0; i < msg.length; i += 2) res.push(parseInt(msg[i] + msg[i + 1], 16));
    }
  } else {
    for (i = 0; i < msg.length; i++) res[i] = msg[i] | 0;
  }
  return res;
}
exports.toArray = toArray;
function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++) res += zero2(msg[i].toString(16));
  return res;
}
exports.toHex = toHex;
function htonl(w) {
  var res = w >>> 24 | w >>> 8 & 0xff00 | w << 8 & 0xff0000 | (w & 0xff) << 24;
  return res >>> 0;
}
exports.htonl = htonl;
function toHex32(msg, endian) {
  var res = '';
  for (var i = 0; i < msg.length; i++) {
    var w = msg[i];
    if (endian === 'little') w = htonl(w);
    res += zero8(w.toString(16));
  }
  return res;
}
exports.toHex32 = toHex32;
function zero2(word) {
  if (word.length === 1) return '0' + word;else return word;
}
exports.zero2 = zero2;
function zero8(word) {
  if (word.length === 7) return '0' + word;else if (word.length === 6) return '00' + word;else if (word.length === 5) return '000' + word;else if (word.length === 4) return '0000' + word;else if (word.length === 3) return '00000' + word;else if (word.length === 2) return '000000' + word;else if (word.length === 1) return '0000000' + word;else return word;
}
exports.zero8 = zero8;
function join32(msg, start, end, endian) {
  var len = end - start;
  assert(len % 4 === 0);
  var res = new Array(len / 4);
  for (var i = 0, k = start; i < res.length; i++, k += 4) {
    var w;
    if (endian === 'big') w = msg[k] << 24 | msg[k + 1] << 16 | msg[k + 2] << 8 | msg[k + 3];else w = msg[k + 3] << 24 | msg[k + 2] << 16 | msg[k + 1] << 8 | msg[k];
    res[i] = w >>> 0;
  }
  return res;
}
exports.join32 = join32;
function split32(msg, endian) {
  var res = new Array(msg.length * 4);
  for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
    var m = msg[i];
    if (endian === 'big') {
      res[k] = m >>> 24;
      res[k + 1] = m >>> 16 & 0xff;
      res[k + 2] = m >>> 8 & 0xff;
      res[k + 3] = m & 0xff;
    } else {
      res[k + 3] = m >>> 24;
      res[k + 2] = m >>> 16 & 0xff;
      res[k + 1] = m >>> 8 & 0xff;
      res[k] = m & 0xff;
    }
  }
  return res;
}
exports.split32 = split32;
function rotr32(w, b) {
  return w >>> b | w << 32 - b;
}
exports.rotr32 = rotr32;
function rotl32(w, b) {
  return w << b | w >>> 32 - b;
}
exports.rotl32 = rotl32;
function sum32(a, b) {
  return a + b >>> 0;
}
exports.sum32 = sum32;
function sum32_3(a, b, c) {
  return a + b + c >>> 0;
}
exports.sum32_3 = sum32_3;
function sum32_4(a, b, c, d) {
  return a + b + c + d >>> 0;
}
exports.sum32_4 = sum32_4;
function sum32_5(a, b, c, d, e) {
  return a + b + c + d + e >>> 0;
}
exports.sum32_5 = sum32_5;
function sum64(buf, pos, ah, al) {
  var bh = buf[pos];
  var bl = buf[pos + 1];
  var lo = al + bl >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  buf[pos] = hi >>> 0;
  buf[pos + 1] = lo;
}
exports.sum64 = sum64;
function sum64_hi(ah, al, bh, bl) {
  var lo = al + bl >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  return hi >>> 0;
}
exports.sum64_hi = sum64_hi;
function sum64_lo(ah, al, bh, bl) {
  var lo = al + bl;
  return lo >>> 0;
}
exports.sum64_lo = sum64_lo;
function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
  var carry = 0;
  var lo = al;
  lo = lo + bl >>> 0;
  carry += lo < al ? 1 : 0;
  lo = lo + cl >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = lo + dl >>> 0;
  carry += lo < dl ? 1 : 0;
  var hi = ah + bh + ch + dh + carry;
  return hi >>> 0;
}
exports.sum64_4_hi = sum64_4_hi;
function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
  var lo = al + bl + cl + dl;
  return lo >>> 0;
}
exports.sum64_4_lo = sum64_4_lo;
function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var carry = 0;
  var lo = al;
  lo = lo + bl >>> 0;
  carry += lo < al ? 1 : 0;
  lo = lo + cl >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = lo + dl >>> 0;
  carry += lo < dl ? 1 : 0;
  lo = lo + el >>> 0;
  carry += lo < el ? 1 : 0;
  var hi = ah + bh + ch + dh + eh + carry;
  return hi >>> 0;
}
exports.sum64_5_hi = sum64_5_hi;
function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var lo = al + bl + cl + dl + el;
  return lo >>> 0;
}
exports.sum64_5_lo = sum64_5_lo;
function rotr64_hi(ah, al, num) {
  var r = al << 32 - num | ah >>> num;
  return r >>> 0;
}
exports.rotr64_hi = rotr64_hi;
function rotr64_lo(ah, al, num) {
  var r = ah << 32 - num | al >>> num;
  return r >>> 0;
}
exports.rotr64_lo = rotr64_lo;
function shr64_hi(ah, al, num) {
  return ah >>> num;
}
exports.shr64_hi = shr64_hi;
function shr64_lo(ah, al, num) {
  var r = ah << 32 - num | al >>> num;
  return r >>> 0;
}
exports.shr64_lo = shr64_lo;

},{"inherits":327,"minimalistic-assert":342}],324:[function(require,module,exports){
'use strict';

var call = Function.prototype.call;
var $hasOwn = Object.prototype.hasOwnProperty;
var bind = require('function-bind');

/** @type {import('.')} */
module.exports = bind.call(call, $hasOwn);

},{"function-bind":304}],325:[function(require,module,exports){
'use strict';

var hash = require('hash.js');
var utils = require('minimalistic-crypto-utils');
var assert = require('minimalistic-assert');
function HmacDRBG(options) {
  if (!(this instanceof HmacDRBG)) return new HmacDRBG(options);
  this.hash = options.hash;
  this.predResist = !!options.predResist;
  this.outLen = this.hash.outSize;
  this.minEntropy = options.minEntropy || this.hash.hmacStrength;
  this._reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;
  var entropy = utils.toArray(options.entropy, options.entropyEnc || 'hex');
  var nonce = utils.toArray(options.nonce, options.nonceEnc || 'hex');
  var pers = utils.toArray(options.pers, options.persEnc || 'hex');
  assert(entropy.length >= this.minEntropy / 8, 'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');
  this._init(entropy, nonce, pers);
}
module.exports = HmacDRBG;
HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
  var seed = entropy.concat(nonce).concat(pers);
  this.K = new Array(this.outLen / 8);
  this.V = new Array(this.outLen / 8);
  for (var i = 0; i < this.V.length; i++) {
    this.K[i] = 0x00;
    this.V[i] = 0x01;
  }
  this._update(seed);
  this._reseed = 1;
  this.reseedInterval = 0x1000000000000; // 2^48
};
HmacDRBG.prototype._hmac = function hmac() {
  return new hash.hmac(this.hash, this.K);
};
HmacDRBG.prototype._update = function update(seed) {
  var kmac = this._hmac().update(this.V).update([0x00]);
  if (seed) kmac = kmac.update(seed);
  this.K = kmac.digest();
  this.V = this._hmac().update(this.V).digest();
  if (!seed) return;
  this.K = this._hmac().update(this.V).update([0x01]).update(seed).digest();
  this.V = this._hmac().update(this.V).digest();
};
HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
  // Optional entropy enc
  if (typeof entropyEnc !== 'string') {
    addEnc = add;
    add = entropyEnc;
    entropyEnc = null;
  }
  entropy = utils.toArray(entropy, entropyEnc);
  add = utils.toArray(add, addEnc);
  assert(entropy.length >= this.minEntropy / 8, 'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');
  this._update(entropy.concat(add || []));
  this._reseed = 1;
};
HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
  if (this._reseed > this.reseedInterval) throw new Error('Reseed is required');

  // Optional encoding
  if (typeof enc !== 'string') {
    addEnc = add;
    add = enc;
    enc = null;
  }

  // Optional additional data
  if (add) {
    add = utils.toArray(add, addEnc || 'hex');
    this._update(add);
  }
  var temp = [];
  while (temp.length < len) {
    this.V = this._hmac().update(this.V).digest();
    temp = temp.concat(this.V);
  }
  var res = temp.slice(0, len);
  this._update(add);
  this._reseed++;
  return utils.encode(res, enc);
};

},{"hash.js":312,"minimalistic-assert":342,"minimalistic-crypto-utils":343}],326:[function(require,module,exports){
"use strict";

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];
  i += d;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};
exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
  buffer[offset + i - d] |= s * 128;
};

},{}],327:[function(require,module,exports){
"use strict";

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function TempCtor() {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  };
}

},{}],328:[function(require,module,exports){
"use strict";

module.exports = function (scope) {
  return function (func) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    return function (func) {
      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }
      return new Promise(function (resolve, reject) {
        func.apply(void 0, args.concat([function (err, res) {
          if (err) {
            reject(err);
          } else {
            resolve(res);
          }
        }]));
      });
    }.apply(void 0, [func.bind(scope)].concat(args));
  };
};

},{}],329:[function(require,module,exports){
"use strict";

/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
};
function isBuffer(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer(obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0));
}

},{}],330:[function(require,module,exports){
"use strict";

var toString = {}.toString;
module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],331:[function(require,module,exports){
(function (process,global){(function (){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
/**
 * [js-sha3]{@link https://github.com/emn178/js-sha3}
 *
 * @version 0.8.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2018
 * @license MIT
 */
/*jslint bitwise: true */
(function () {
  'use strict';

  var INPUT_ERROR = 'input is invalid type';
  var FINALIZE_ERROR = 'finalize already called';
  var WINDOW = (typeof window === "undefined" ? "undefined" : _typeof(window)) === 'object';
  var root = WINDOW ? window : {};
  if (root.JS_SHA3_NO_WINDOW) {
    WINDOW = false;
  }
  var WEB_WORKER = !WINDOW && (typeof self === "undefined" ? "undefined" : _typeof(self)) === 'object';
  var NODE_JS = !root.JS_SHA3_NO_NODE_JS && (typeof process === "undefined" ? "undefined" : _typeof(process)) === 'object' && process.versions && process.versions.node;
  if (NODE_JS) {
    root = global;
  } else if (WEB_WORKER) {
    root = self;
  }
  var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && (typeof module === "undefined" ? "undefined" : _typeof(module)) === 'object' && module.exports;
  var AMD = typeof define === 'function' && define.amd;
  var ARRAY_BUFFER = !root.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== 'undefined';
  var HEX_CHARS = '0123456789abcdef'.split('');
  var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
  var CSHAKE_PADDING = [4, 1024, 262144, 67108864];
  var KECCAK_PADDING = [1, 256, 65536, 16777216];
  var PADDING = [6, 1536, 393216, 100663296];
  var SHIFT = [0, 8, 16, 24];
  var RC = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648];
  var BITS = [224, 256, 384, 512];
  var SHAKE_BITS = [128, 256];
  var OUTPUT_TYPES = ['hex', 'buffer', 'arrayBuffer', 'array', 'digest'];
  var CSHAKE_BYTEPAD = {
    '128': 168,
    '256': 136
  };
  if (root.JS_SHA3_NO_NODE_JS || !Array.isArray) {
    Array.isArray = function (obj) {
      return Object.prototype.toString.call(obj) === '[object Array]';
    };
  }
  if (ARRAY_BUFFER && (root.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
    ArrayBuffer.isView = function (obj) {
      return _typeof(obj) === 'object' && obj.buffer && obj.buffer.constructor === ArrayBuffer;
    };
  }
  var createOutputMethod = function createOutputMethod(bits, padding, outputType) {
    return function (message) {
      return new Keccak(bits, padding, bits).update(message)[outputType]();
    };
  };
  var createShakeOutputMethod = function createShakeOutputMethod(bits, padding, outputType) {
    return function (message, outputBits) {
      return new Keccak(bits, padding, outputBits).update(message)[outputType]();
    };
  };
  var createCshakeOutputMethod = function createCshakeOutputMethod(bits, padding, outputType) {
    return function (message, outputBits, n, s) {
      return methods['cshake' + bits].update(message, outputBits, n, s)[outputType]();
    };
  };
  var createKmacOutputMethod = function createKmacOutputMethod(bits, padding, outputType) {
    return function (key, message, outputBits, s) {
      return methods['kmac' + bits].update(key, message, outputBits, s)[outputType]();
    };
  };
  var createOutputMethods = function createOutputMethods(method, createMethod, bits, padding) {
    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
      var type = OUTPUT_TYPES[i];
      method[type] = createMethod(bits, padding, type);
    }
    return method;
  };
  var createMethod = function createMethod(bits, padding) {
    var method = createOutputMethod(bits, padding, 'hex');
    method.create = function () {
      return new Keccak(bits, padding, bits);
    };
    method.update = function (message) {
      return method.create().update(message);
    };
    return createOutputMethods(method, createOutputMethod, bits, padding);
  };
  var createShakeMethod = function createShakeMethod(bits, padding) {
    var method = createShakeOutputMethod(bits, padding, 'hex');
    method.create = function (outputBits) {
      return new Keccak(bits, padding, outputBits);
    };
    method.update = function (message, outputBits) {
      return method.create(outputBits).update(message);
    };
    return createOutputMethods(method, createShakeOutputMethod, bits, padding);
  };
  var createCshakeMethod = function createCshakeMethod(bits, padding) {
    var w = CSHAKE_BYTEPAD[bits];
    var method = createCshakeOutputMethod(bits, padding, 'hex');
    method.create = function (outputBits, n, s) {
      if (!n && !s) {
        return methods['shake' + bits].create(outputBits);
      } else {
        return new Keccak(bits, padding, outputBits).bytepad([n, s], w);
      }
    };
    method.update = function (message, outputBits, n, s) {
      return method.create(outputBits, n, s).update(message);
    };
    return createOutputMethods(method, createCshakeOutputMethod, bits, padding);
  };
  var createKmacMethod = function createKmacMethod(bits, padding) {
    var w = CSHAKE_BYTEPAD[bits];
    var method = createKmacOutputMethod(bits, padding, 'hex');
    method.create = function (key, outputBits, s) {
      return new Kmac(bits, padding, outputBits).bytepad(['KMAC', s], w).bytepad([key], w);
    };
    method.update = function (key, message, outputBits, s) {
      return method.create(key, outputBits, s).update(message);
    };
    return createOutputMethods(method, createKmacOutputMethod, bits, padding);
  };
  var algorithms = [{
    name: 'keccak',
    padding: KECCAK_PADDING,
    bits: BITS,
    createMethod: createMethod
  }, {
    name: 'sha3',
    padding: PADDING,
    bits: BITS,
    createMethod: createMethod
  }, {
    name: 'shake',
    padding: SHAKE_PADDING,
    bits: SHAKE_BITS,
    createMethod: createShakeMethod
  }, {
    name: 'cshake',
    padding: CSHAKE_PADDING,
    bits: SHAKE_BITS,
    createMethod: createCshakeMethod
  }, {
    name: 'kmac',
    padding: CSHAKE_PADDING,
    bits: SHAKE_BITS,
    createMethod: createKmacMethod
  }];
  var methods = {},
    methodNames = [];
  for (var i = 0; i < algorithms.length; ++i) {
    var algorithm = algorithms[i];
    var bits = algorithm.bits;
    for (var j = 0; j < bits.length; ++j) {
      var methodName = algorithm.name + '_' + bits[j];
      methodNames.push(methodName);
      methods[methodName] = algorithm.createMethod(bits[j], algorithm.padding);
      if (algorithm.name !== 'sha3') {
        var newMethodName = algorithm.name + bits[j];
        methodNames.push(newMethodName);
        methods[newMethodName] = methods[methodName];
      }
    }
  }
  function Keccak(bits, padding, outputBits) {
    this.blocks = [];
    this.s = [];
    this.padding = padding;
    this.outputBits = outputBits;
    this.reset = true;
    this.finalized = false;
    this.block = 0;
    this.start = 0;
    this.blockCount = 1600 - (bits << 1) >> 5;
    this.byteCount = this.blockCount << 2;
    this.outputBlocks = outputBits >> 5;
    this.extraBytes = (outputBits & 31) >> 3;
    for (var i = 0; i < 50; ++i) {
      this.s[i] = 0;
    }
  }
  Keccak.prototype.update = function (message) {
    if (this.finalized) {
      throw new Error(FINALIZE_ERROR);
    }
    var notString,
      type = _typeof(message);
    if (type !== 'string') {
      if (type === 'object') {
        if (message === null) {
          throw new Error(INPUT_ERROR);
        } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
          message = new Uint8Array(message);
        } else if (!Array.isArray(message)) {
          if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
            throw new Error(INPUT_ERROR);
          }
        }
      } else {
        throw new Error(INPUT_ERROR);
      }
      notString = true;
    }
    var blocks = this.blocks,
      byteCount = this.byteCount,
      length = message.length,
      blockCount = this.blockCount,
      index = 0,
      s = this.s,
      i,
      code;
    while (index < length) {
      if (this.reset) {
        this.reset = false;
        blocks[0] = this.block;
        for (i = 1; i < blockCount + 1; ++i) {
          blocks[i] = 0;
        }
      }
      if (notString) {
        for (i = this.start; index < length && i < byteCount; ++index) {
          blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];
        }
      } else {
        for (i = this.start; index < length && i < byteCount; ++index) {
          code = message.charCodeAt(index);
          if (code < 0x80) {
            blocks[i >> 2] |= code << SHIFT[i++ & 3];
          } else if (code < 0x800) {
            blocks[i >> 2] |= (0xc0 | code >> 6) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | code & 0x3f) << SHIFT[i++ & 3];
          } else if (code < 0xd800 || code >= 0xe000) {
            blocks[i >> 2] |= (0xe0 | code >> 12) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | code >> 6 & 0x3f) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | code & 0x3f) << SHIFT[i++ & 3];
          } else {
            code = 0x10000 + ((code & 0x3ff) << 10 | message.charCodeAt(++index) & 0x3ff);
            blocks[i >> 2] |= (0xf0 | code >> 18) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | code >> 12 & 0x3f) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | code >> 6 & 0x3f) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | code & 0x3f) << SHIFT[i++ & 3];
          }
        }
      }
      this.lastByteIndex = i;
      if (i >= byteCount) {
        this.start = i - byteCount;
        this.block = blocks[blockCount];
        for (i = 0; i < blockCount; ++i) {
          s[i] ^= blocks[i];
        }
        f(s);
        this.reset = true;
      } else {
        this.start = i;
      }
    }
    return this;
  };
  Keccak.prototype.encode = function (x, right) {
    var o = x & 255,
      n = 1;
    var bytes = [o];
    x = x >> 8;
    o = x & 255;
    while (o > 0) {
      bytes.unshift(o);
      x = x >> 8;
      o = x & 255;
      ++n;
    }
    if (right) {
      bytes.push(n);
    } else {
      bytes.unshift(n);
    }
    this.update(bytes);
    return bytes.length;
  };
  Keccak.prototype.encodeString = function (str) {
    var notString,
      type = _typeof(str);
    if (type !== 'string') {
      if (type === 'object') {
        if (str === null) {
          throw new Error(INPUT_ERROR);
        } else if (ARRAY_BUFFER && str.constructor === ArrayBuffer) {
          str = new Uint8Array(str);
        } else if (!Array.isArray(str)) {
          if (!ARRAY_BUFFER || !ArrayBuffer.isView(str)) {
            throw new Error(INPUT_ERROR);
          }
        }
      } else {
        throw new Error(INPUT_ERROR);
      }
      notString = true;
    }
    var bytes = 0,
      length = str.length;
    if (notString) {
      bytes = length;
    } else {
      for (var i = 0; i < str.length; ++i) {
        var code = str.charCodeAt(i);
        if (code < 0x80) {
          bytes += 1;
        } else if (code < 0x800) {
          bytes += 2;
        } else if (code < 0xd800 || code >= 0xe000) {
          bytes += 3;
        } else {
          code = 0x10000 + ((code & 0x3ff) << 10 | str.charCodeAt(++i) & 0x3ff);
          bytes += 4;
        }
      }
    }
    bytes += this.encode(bytes * 8);
    this.update(str);
    return bytes;
  };
  Keccak.prototype.bytepad = function (strs, w) {
    var bytes = this.encode(w);
    for (var i = 0; i < strs.length; ++i) {
      bytes += this.encodeString(strs[i]);
    }
    var paddingBytes = w - bytes % w;
    var zeros = [];
    zeros.length = paddingBytes;
    this.update(zeros);
    return this;
  };
  Keccak.prototype.finalize = function () {
    if (this.finalized) {
      return;
    }
    this.finalized = true;
    var blocks = this.blocks,
      i = this.lastByteIndex,
      blockCount = this.blockCount,
      s = this.s;
    blocks[i >> 2] |= this.padding[i & 3];
    if (this.lastByteIndex === this.byteCount) {
      blocks[0] = blocks[blockCount];
      for (i = 1; i < blockCount + 1; ++i) {
        blocks[i] = 0;
      }
    }
    blocks[blockCount - 1] |= 0x80000000;
    for (i = 0; i < blockCount; ++i) {
      s[i] ^= blocks[i];
    }
    f(s);
  };
  Keccak.prototype.toString = Keccak.prototype.hex = function () {
    this.finalize();
    var blockCount = this.blockCount,
      s = this.s,
      outputBlocks = this.outputBlocks,
      extraBytes = this.extraBytes,
      i = 0,
      j = 0;
    var hex = '',
      block;
    while (j < outputBlocks) {
      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
        block = s[i];
        hex += HEX_CHARS[block >> 4 & 0x0F] + HEX_CHARS[block & 0x0F] + HEX_CHARS[block >> 12 & 0x0F] + HEX_CHARS[block >> 8 & 0x0F] + HEX_CHARS[block >> 20 & 0x0F] + HEX_CHARS[block >> 16 & 0x0F] + HEX_CHARS[block >> 28 & 0x0F] + HEX_CHARS[block >> 24 & 0x0F];
      }
      if (j % blockCount === 0) {
        f(s);
        i = 0;
      }
    }
    if (extraBytes) {
      block = s[i];
      hex += HEX_CHARS[block >> 4 & 0x0F] + HEX_CHARS[block & 0x0F];
      if (extraBytes > 1) {
        hex += HEX_CHARS[block >> 12 & 0x0F] + HEX_CHARS[block >> 8 & 0x0F];
      }
      if (extraBytes > 2) {
        hex += HEX_CHARS[block >> 20 & 0x0F] + HEX_CHARS[block >> 16 & 0x0F];
      }
    }
    return hex;
  };
  Keccak.prototype.arrayBuffer = function () {
    this.finalize();
    var blockCount = this.blockCount,
      s = this.s,
      outputBlocks = this.outputBlocks,
      extraBytes = this.extraBytes,
      i = 0,
      j = 0;
    var bytes = this.outputBits >> 3;
    var buffer;
    if (extraBytes) {
      buffer = new ArrayBuffer(outputBlocks + 1 << 2);
    } else {
      buffer = new ArrayBuffer(bytes);
    }
    var array = new Uint32Array(buffer);
    while (j < outputBlocks) {
      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
        array[j] = s[i];
      }
      if (j % blockCount === 0) {
        f(s);
      }
    }
    if (extraBytes) {
      array[i] = s[i];
      buffer = buffer.slice(0, bytes);
    }
    return buffer;
  };
  Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;
  Keccak.prototype.digest = Keccak.prototype.array = function () {
    this.finalize();
    var blockCount = this.blockCount,
      s = this.s,
      outputBlocks = this.outputBlocks,
      extraBytes = this.extraBytes,
      i = 0,
      j = 0;
    var array = [],
      offset,
      block;
    while (j < outputBlocks) {
      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
        offset = j << 2;
        block = s[i];
        array[offset] = block & 0xFF;
        array[offset + 1] = block >> 8 & 0xFF;
        array[offset + 2] = block >> 16 & 0xFF;
        array[offset + 3] = block >> 24 & 0xFF;
      }
      if (j % blockCount === 0) {
        f(s);
      }
    }
    if (extraBytes) {
      offset = j << 2;
      block = s[i];
      array[offset] = block & 0xFF;
      if (extraBytes > 1) {
        array[offset + 1] = block >> 8 & 0xFF;
      }
      if (extraBytes > 2) {
        array[offset + 2] = block >> 16 & 0xFF;
      }
    }
    return array;
  };
  function Kmac(bits, padding, outputBits) {
    Keccak.call(this, bits, padding, outputBits);
  }
  Kmac.prototype = new Keccak();
  Kmac.prototype.finalize = function () {
    this.encode(this.outputBits, true);
    return Keccak.prototype.finalize.call(this);
  };
  var f = function f(s) {
    var h, l, n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
    for (n = 0; n < 48; n += 2) {
      c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];
      c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];
      c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];
      c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];
      c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];
      c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];
      c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];
      c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];
      c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];
      c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];
      h = c8 ^ (c2 << 1 | c3 >>> 31);
      l = c9 ^ (c3 << 1 | c2 >>> 31);
      s[0] ^= h;
      s[1] ^= l;
      s[10] ^= h;
      s[11] ^= l;
      s[20] ^= h;
      s[21] ^= l;
      s[30] ^= h;
      s[31] ^= l;
      s[40] ^= h;
      s[41] ^= l;
      h = c0 ^ (c4 << 1 | c5 >>> 31);
      l = c1 ^ (c5 << 1 | c4 >>> 31);
      s[2] ^= h;
      s[3] ^= l;
      s[12] ^= h;
      s[13] ^= l;
      s[22] ^= h;
      s[23] ^= l;
      s[32] ^= h;
      s[33] ^= l;
      s[42] ^= h;
      s[43] ^= l;
      h = c2 ^ (c6 << 1 | c7 >>> 31);
      l = c3 ^ (c7 << 1 | c6 >>> 31);
      s[4] ^= h;
      s[5] ^= l;
      s[14] ^= h;
      s[15] ^= l;
      s[24] ^= h;
      s[25] ^= l;
      s[34] ^= h;
      s[35] ^= l;
      s[44] ^= h;
      s[45] ^= l;
      h = c4 ^ (c8 << 1 | c9 >>> 31);
      l = c5 ^ (c9 << 1 | c8 >>> 31);
      s[6] ^= h;
      s[7] ^= l;
      s[16] ^= h;
      s[17] ^= l;
      s[26] ^= h;
      s[27] ^= l;
      s[36] ^= h;
      s[37] ^= l;
      s[46] ^= h;
      s[47] ^= l;
      h = c6 ^ (c0 << 1 | c1 >>> 31);
      l = c7 ^ (c1 << 1 | c0 >>> 31);
      s[8] ^= h;
      s[9] ^= l;
      s[18] ^= h;
      s[19] ^= l;
      s[28] ^= h;
      s[29] ^= l;
      s[38] ^= h;
      s[39] ^= l;
      s[48] ^= h;
      s[49] ^= l;
      b0 = s[0];
      b1 = s[1];
      b32 = s[11] << 4 | s[10] >>> 28;
      b33 = s[10] << 4 | s[11] >>> 28;
      b14 = s[20] << 3 | s[21] >>> 29;
      b15 = s[21] << 3 | s[20] >>> 29;
      b46 = s[31] << 9 | s[30] >>> 23;
      b47 = s[30] << 9 | s[31] >>> 23;
      b28 = s[40] << 18 | s[41] >>> 14;
      b29 = s[41] << 18 | s[40] >>> 14;
      b20 = s[2] << 1 | s[3] >>> 31;
      b21 = s[3] << 1 | s[2] >>> 31;
      b2 = s[13] << 12 | s[12] >>> 20;
      b3 = s[12] << 12 | s[13] >>> 20;
      b34 = s[22] << 10 | s[23] >>> 22;
      b35 = s[23] << 10 | s[22] >>> 22;
      b16 = s[33] << 13 | s[32] >>> 19;
      b17 = s[32] << 13 | s[33] >>> 19;
      b48 = s[42] << 2 | s[43] >>> 30;
      b49 = s[43] << 2 | s[42] >>> 30;
      b40 = s[5] << 30 | s[4] >>> 2;
      b41 = s[4] << 30 | s[5] >>> 2;
      b22 = s[14] << 6 | s[15] >>> 26;
      b23 = s[15] << 6 | s[14] >>> 26;
      b4 = s[25] << 11 | s[24] >>> 21;
      b5 = s[24] << 11 | s[25] >>> 21;
      b36 = s[34] << 15 | s[35] >>> 17;
      b37 = s[35] << 15 | s[34] >>> 17;
      b18 = s[45] << 29 | s[44] >>> 3;
      b19 = s[44] << 29 | s[45] >>> 3;
      b10 = s[6] << 28 | s[7] >>> 4;
      b11 = s[7] << 28 | s[6] >>> 4;
      b42 = s[17] << 23 | s[16] >>> 9;
      b43 = s[16] << 23 | s[17] >>> 9;
      b24 = s[26] << 25 | s[27] >>> 7;
      b25 = s[27] << 25 | s[26] >>> 7;
      b6 = s[36] << 21 | s[37] >>> 11;
      b7 = s[37] << 21 | s[36] >>> 11;
      b38 = s[47] << 24 | s[46] >>> 8;
      b39 = s[46] << 24 | s[47] >>> 8;
      b30 = s[8] << 27 | s[9] >>> 5;
      b31 = s[9] << 27 | s[8] >>> 5;
      b12 = s[18] << 20 | s[19] >>> 12;
      b13 = s[19] << 20 | s[18] >>> 12;
      b44 = s[29] << 7 | s[28] >>> 25;
      b45 = s[28] << 7 | s[29] >>> 25;
      b26 = s[38] << 8 | s[39] >>> 24;
      b27 = s[39] << 8 | s[38] >>> 24;
      b8 = s[48] << 14 | s[49] >>> 18;
      b9 = s[49] << 14 | s[48] >>> 18;
      s[0] = b0 ^ ~b2 & b4;
      s[1] = b1 ^ ~b3 & b5;
      s[10] = b10 ^ ~b12 & b14;
      s[11] = b11 ^ ~b13 & b15;
      s[20] = b20 ^ ~b22 & b24;
      s[21] = b21 ^ ~b23 & b25;
      s[30] = b30 ^ ~b32 & b34;
      s[31] = b31 ^ ~b33 & b35;
      s[40] = b40 ^ ~b42 & b44;
      s[41] = b41 ^ ~b43 & b45;
      s[2] = b2 ^ ~b4 & b6;
      s[3] = b3 ^ ~b5 & b7;
      s[12] = b12 ^ ~b14 & b16;
      s[13] = b13 ^ ~b15 & b17;
      s[22] = b22 ^ ~b24 & b26;
      s[23] = b23 ^ ~b25 & b27;
      s[32] = b32 ^ ~b34 & b36;
      s[33] = b33 ^ ~b35 & b37;
      s[42] = b42 ^ ~b44 & b46;
      s[43] = b43 ^ ~b45 & b47;
      s[4] = b4 ^ ~b6 & b8;
      s[5] = b5 ^ ~b7 & b9;
      s[14] = b14 ^ ~b16 & b18;
      s[15] = b15 ^ ~b17 & b19;
      s[24] = b24 ^ ~b26 & b28;
      s[25] = b25 ^ ~b27 & b29;
      s[34] = b34 ^ ~b36 & b38;
      s[35] = b35 ^ ~b37 & b39;
      s[44] = b44 ^ ~b46 & b48;
      s[45] = b45 ^ ~b47 & b49;
      s[6] = b6 ^ ~b8 & b0;
      s[7] = b7 ^ ~b9 & b1;
      s[16] = b16 ^ ~b18 & b10;
      s[17] = b17 ^ ~b19 & b11;
      s[26] = b26 ^ ~b28 & b20;
      s[27] = b27 ^ ~b29 & b21;
      s[36] = b36 ^ ~b38 & b30;
      s[37] = b37 ^ ~b39 & b31;
      s[46] = b46 ^ ~b48 & b40;
      s[47] = b47 ^ ~b49 & b41;
      s[8] = b8 ^ ~b0 & b2;
      s[9] = b9 ^ ~b1 & b3;
      s[18] = b18 ^ ~b10 & b12;
      s[19] = b19 ^ ~b11 & b13;
      s[28] = b28 ^ ~b20 & b22;
      s[29] = b29 ^ ~b21 & b23;
      s[38] = b38 ^ ~b30 & b32;
      s[39] = b39 ^ ~b31 & b33;
      s[48] = b48 ^ ~b40 & b42;
      s[49] = b49 ^ ~b41 & b43;
      s[0] ^= RC[n];
      s[1] ^= RC[n + 1];
    }
  };
  if (COMMON_JS) {
    module.exports = methods;
  } else {
    for (i = 0; i < methodNames.length; ++i) {
      root[methodNames[i]] = methods[methodNames[i]];
    }
    if (AMD) {
      define(function () {
        return methods;
      });
    }
  }
})();

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"_process":363}],332:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
!function (t, e) {
  "object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) && "object" == (typeof module === "undefined" ? "undefined" : _typeof(module)) ? module.exports = e(require("bignumber.js")) : "function" == typeof define && define.amd ? define(["bignumber.js"], e) : "object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) ? exports.JSONBigNumber = e(require("bignumber.js")) : t.JSONBigNumber = e(t.BigNumber);
}(void 0, function (t) {
  return function () {
    "use strict";

    var e = {
        332: function _(e) {
          e.exports = t;
        }
      },
      r = {};
    function n(t) {
      var o = r[t];
      if (void 0 !== o) return o.exports;
      var u = r[t] = {
        exports: {}
      };
      return e[t](u, u.exports, n), u.exports;
    }
    n.n = function (t) {
      var e = t && t.__esModule ? function () {
        return t["default"];
      } : function () {
        return t;
      };
      return n.d(e, {
        a: e
      }), e;
    }, n.d = function (t, e) {
      for (var r in e) n.o(e, r) && !n.o(t, r) && Object.defineProperty(t, r, {
        enumerable: !0,
        get: e[r]
      });
    }, n.o = function (t, e) {
      return Object.prototype.hasOwnProperty.call(t, e);
    }, n.r = function (t) {
      "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
        value: "Module"
      }), Object.defineProperty(t, "__esModule", {
        value: !0
      });
    };
    var o = {};
    return function () {
      n.r(o), n.d(o, {
        stringify: function stringify() {
          return g;
        },
        parse: function parse() {
          return N;
        },
        "default": function _default() {
          return w;
        }
      });
      var t,
        e,
        r,
        u,
        i,
        f,
        a = n(332),
        s = n.n(a),
        c = /[\\"\u0000-\u001f\u007f-\u009f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
      function p(t) {
        return t < 10 ? "0" + t : t;
      }
      function l() {
        return this.valueOf();
      }
      function y(t) {
        return c.lastIndex = 0, c.test(t) ? '"' + t.replace(c, function (t) {
          var e = r[t];
          return "string" == typeof e ? e : "\\u" + ("0000" + t.charCodeAt(0).toString(16)).slice(-4);
        }) + '"' : '"' + t + '"';
      }
      function b(r, n) {
        var o,
          i,
          f,
          a,
          c,
          p = t,
          l = n[r],
          g = null != l && (l instanceof s() || s().isBigNumber(l));
        switch (g && !l.isFinite() && (l = null), l && "object" == _typeof(l) && "function" == typeof l.toJSON && (l = l.toJSON(r)), "function" == typeof u && (l = u.call(n, r, l)), _typeof(l)) {
          case "string":
            return g ? l : y(l);
          case "number":
            return isFinite(l) ? String(l) : "null";
          case "boolean":
          case "null":
            return String(l);
          case "object":
            if (!l) return "null";
            if (t += e, c = [], "[object Array]" === Object.prototype.toString.apply(l)) {
              for (a = l.length, o = 0; o < a; o += 1) c[o] = b(o, l) || "null";
              return f = 0 === c.length ? "[]" : t ? "[\n" + t + c.join(",\n" + t) + "\n" + p + "]" : "[" + c.join(",") + "]", t = p, f;
            }
            if (u && "object" == _typeof(u)) for (a = u.length, o = 0; o < a; o += 1) "string" == typeof u[o] && (f = b(i = u[o], l)) && c.push(y(i) + (t ? ": " : ":") + f);else for (i in l) Object.prototype.hasOwnProperty.call(l, i) && (f = b(i, l)) && c.push(y(i) + (t ? ": " : ":") + f);
            return f = 0 === c.length ? "{}" : t ? "{\n" + t + c.join(",\n" + t) + "\n" + p + "}" : "{" + c.join(",") + "}", t = p, f;
        }
      }
      function g(r, n, o) {
        var i;
        if (t = "", e = "", "number" == typeof o) for (i = 0; i < o; i += 1) e += " ";else "string" == typeof o && (e = o);
        if (u = n, n && "function" != typeof n && ("object" != _typeof(n) || "number" != typeof n.length)) throw new Error("JSON.stringify");
        return b("", {
          "": r
        });
      }
      "function" != typeof Date.prototype.toJSON && (Date.prototype.toJSON = function () {
        return isFinite(this.valueOf()) ? this.getUTCFullYear() + "-" + p(this.getUTCMonth() + 1) + "-" + p(this.getUTCDate()) + "T" + p(this.getUTCHours()) + ":" + p(this.getUTCMinutes()) + ":" + p(this.getUTCSeconds()) + "Z" : null;
      }, Boolean.prototype.toJSON = l, Number.prototype.toJSON = l, String.prototype.toJSON = l), r = {
        "\b": "\\b",
        "\t": "\\t",
        "\n": "\\n",
        "\f": "\\f",
        "\r": "\\r",
        '"': '\\"',
        "\\": "\\\\"
      };
      var d,
        _h,
        j = {
          '"': '"',
          "\\": "\\",
          "/": "/",
          b: "\b",
          f: "\f",
          n: "\n",
          r: "\r",
          t: "\t"
        },
        O = function O(t) {
          throw {
            name: "SyntaxError",
            message: t,
            at: i,
            text: d
          };
        },
        S = function S(t) {
          return t && t !== f && O("Expected '" + t + "' instead of '" + f + "'"), f = d.charAt(i), i += 1, f;
        },
        v = function v() {
          var t,
            e = "";
          for ("-" === f && (e = "-", S("-")); f >= "0" && f <= "9";) e += f, S();
          if ("." === f) for (e += "."; S() && f >= "0" && f <= "9";) e += f;
          if ("e" === f || "E" === f) for (e += f, S(), "-" !== f && "+" !== f || (e += f, S()); f >= "0" && f <= "9";) e += f, S();
          if ((t = new (s())(e)).isFinite()) return t;
          O("Bad number");
        },
        m = function m() {
          var t,
            e,
            r,
            n = "";
          if ('"' === f) for (; S();) {
            if ('"' === f) return S(), n;
            if ("\\" === f) {
              if (S(), "u" === f) {
                for (r = 0, e = 0; e < 4 && (t = parseInt(S(), 16), isFinite(t)); e += 1) r = 16 * r + t;
                n += String.fromCharCode(r);
              } else {
                if ("string" != typeof j[f]) break;
                n += j[f];
              }
            } else n += f;
          }
          O("Bad string");
        },
        x = function x() {
          for (; f && f <= " ";) S();
        };
      function N(t, e) {
        var r;
        return d = t, i = 0, f = " ", r = _h(), x(), f && O("Syntax error"), "function" == typeof e ? function t(r, n) {
          var o,
            u,
            i = r[n];
          if (i && "object" == _typeof(i)) for (o in i) Object.prototype.hasOwnProperty.call(i, o) && (void 0 !== (u = t(i, o)) ? i[o] = u : delete i[o]);
          return e.call(r, n, i);
        }({
          "": r
        }, "") : r;
      }
      _h = function h() {
        switch (x(), f) {
          case "{":
            return function () {
              var t,
                e = {};
              if ("{" === f) {
                if (S("{"), x(), "}" === f) return S("}"), e;
                for (; f;) {
                  if (t = m(), x(), S(":"), Object.hasOwnProperty.call(e, t) && O("Duplicate key '" + t + "'"), e[t] = _h(), x(), "}" === f) return S("}"), e;
                  S(","), x();
                }
              }
              O("Bad object");
            }();
          case "[":
            return function () {
              var t = [];
              if ("[" === f) {
                if (S("["), x(), "]" === f) return S("]"), t;
                for (; f;) {
                  if (t.push(_h()), x(), "]" === f) return S("]"), t;
                  S(","), x();
                }
              }
              O("Bad array");
            }();
          case '"':
            return m();
          case "-":
            return v();
          default:
            return f >= "0" && f <= "9" ? v() : function () {
              switch (f) {
                case "t":
                  return S("t"), S("r"), S("u"), S("e"), !0;
                case "f":
                  return S("f"), S("a"), S("l"), S("s"), S("e"), !1;
                case "n":
                  return S("n"), S("u"), S("l"), S("l"), null;
              }
              O("Unexpected '" + f + "'");
            }();
        }
      };
      var w = {
        parse: N,
        stringify: g
      };
    }(), o;
  }();
});

},{"bignumber.js":333}],333:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
;
(function (globalObject) {
  'use strict';

  /*
   *      bignumber.js v9.1.2
   *      A JavaScript library for arbitrary-precision arithmetic.
   *      https://github.com/MikeMcl/bignumber.js
   *      Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>
   *      MIT Licensed.
   *
   *      BigNumber.prototype methods     |  BigNumber methods
   *                                      |
   *      absoluteValue            abs    |  clone
   *      comparedTo                      |  config               set
   *      decimalPlaces            dp     |      DECIMAL_PLACES
   *      dividedBy                div    |      ROUNDING_MODE
   *      dividedToIntegerBy       idiv   |      EXPONENTIAL_AT
   *      exponentiatedBy          pow    |      RANGE
   *      integerValue                    |      CRYPTO
   *      isEqualTo                eq     |      MODULO_MODE
   *      isFinite                        |      POW_PRECISION
   *      isGreaterThan            gt     |      FORMAT
   *      isGreaterThanOrEqualTo   gte    |      ALPHABET
   *      isInteger                       |  isBigNumber
   *      isLessThan               lt     |  maximum              max
   *      isLessThanOrEqualTo      lte    |  minimum              min
   *      isNaN                           |  random
   *      isNegative                      |  sum
   *      isPositive                      |
   *      isZero                          |
   *      minus                           |
   *      modulo                   mod    |
   *      multipliedBy             times  |
   *      negated                         |
   *      plus                            |
   *      precision                sd     |
   *      shiftedBy                       |
   *      squareRoot               sqrt   |
   *      toExponential                   |
   *      toFixed                         |
   *      toFormat                        |
   *      toFraction                      |
   *      toJSON                          |
   *      toNumber                        |
   *      toPrecision                     |
   *      toString                        |
   *      valueOf                         |
   *
   */
  var BigNumber,
    isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i,
    mathceil = Math.ceil,
    mathfloor = Math.floor,
    bignumberError = '[BigNumber Error] ',
    tooManyDigits = bignumberError + 'Number primitive has more than 15 significant digits: ',
    BASE = 1e14,
    LOG_BASE = 14,
    MAX_SAFE_INTEGER = 0x1fffffffffffff,
    // 2^53 - 1
    // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1
    POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],
    SQRT_BASE = 1e7,
    // EDITABLE
    // The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and
    // the arguments to toExponential, toFixed, toFormat, and toPrecision.
    MAX = 1E9; // 0 to MAX_INT32

  /*
   * Create and return a BigNumber constructor.
   */
  function clone(configObject) {
    var div,
      convertBase,
      parseNumeric,
      P = BigNumber.prototype = {
        constructor: BigNumber,
        toString: null,
        valueOf: null
      },
      ONE = new BigNumber(1),
      //----------------------------- EDITABLE CONFIG DEFAULTS -------------------------------

      // The default values below must be integers within the inclusive ranges stated.
      // The values can also be changed at run-time using BigNumber.set.

      // The maximum number of decimal places for operations involving division.
      DECIMAL_PLACES = 20,
      // 0 to MAX

      // The rounding mode used when rounding to the above decimal places, and when using
      // toExponential, toFixed, toFormat and toPrecision, and round (default value).
      // UP         0 Away from zero.
      // DOWN       1 Towards zero.
      // CEIL       2 Towards +Infinity.
      // FLOOR      3 Towards -Infinity.
      // HALF_UP    4 Towards nearest neighbour. If equidistant, up.
      // HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
      // HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
      // HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
      // HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
      ROUNDING_MODE = 4,
      // 0 to 8

      // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]

      // The exponent value at and beneath which toString returns exponential notation.
      // Number type: -7
      TO_EXP_NEG = -7,
      // 0 to -MAX

      // The exponent value at and above which toString returns exponential notation.
      // Number type: 21
      TO_EXP_POS = 21,
      // 0 to MAX

      // RANGE : [MIN_EXP, MAX_EXP]

      // The minimum exponent value, beneath which underflow to zero occurs.
      // Number type: -324  (5e-324)
      MIN_EXP = -1e7,
      // -1 to -MAX

      // The maximum exponent value, above which overflow to Infinity occurs.
      // Number type:  308  (1.7976931348623157e+308)
      // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.
      MAX_EXP = 1e7,
      // 1 to MAX

      // Whether to use cryptographically-secure random number generation, if available.
      CRYPTO = false,
      // true or false

      // The modulo mode used when calculating the modulus: a mod n.
      // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
      // The remainder (r) is calculated as: r = a - n * q.
      //
      // UP        0 The remainder is positive if the dividend is negative, else is negative.
      // DOWN      1 The remainder has the same sign as the dividend.
      //             This modulo mode is commonly known as 'truncated division' and is
      //             equivalent to (a % n) in JavaScript.
      // FLOOR     3 The remainder has the same sign as the divisor (Python %).
      // HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.
      // EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).
      //             The remainder is always positive.
      //
      // The truncated division, floored division, Euclidian division and IEEE 754 remainder
      // modes are commonly used for the modulus operation.
      // Although the other rounding modes can also be used, they may not give useful results.
      MODULO_MODE = 1,
      // 0 to 9

      // The maximum number of significant digits of the result of the exponentiatedBy operation.
      // If POW_PRECISION is 0, there will be unlimited significant digits.
      POW_PRECISION = 0,
      // 0 to MAX

      // The format specification used by the BigNumber.prototype.toFormat method.
      FORMAT = {
        prefix: '',
        groupSize: 3,
        secondaryGroupSize: 0,
        groupSeparator: ',',
        decimalSeparator: '.',
        fractionGroupSize: 0,
        fractionGroupSeparator: '\xA0',
        // non-breaking space
        suffix: ''
      },
      // The alphabet used for base conversion. It must be at least 2 characters long, with no '+',
      // '-', '.', whitespace, or repeated character.
      // '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'
      ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyz',
      alphabetHasNormalDecimalDigits = true;

    //------------------------------------------------------------------------------------------

    // CONSTRUCTOR

    /*
     * The BigNumber constructor and exported function.
     * Create and return a new instance of a BigNumber object.
     *
     * v {number|string|BigNumber} A numeric value.
     * [b] {number} The base of v. Integer, 2 to ALPHABET.length inclusive.
     */
    function BigNumber(v, b) {
      var alphabet,
        c,
        caseChanged,
        e,
        i,
        isNum,
        len,
        str,
        x = this;

      // Enable constructor call without `new`.
      if (!(x instanceof BigNumber)) return new BigNumber(v, b);
      if (b == null) {
        if (v && v._isBigNumber === true) {
          x.s = v.s;
          if (!v.c || v.e > MAX_EXP) {
            x.c = x.e = null;
          } else if (v.e < MIN_EXP) {
            x.c = [x.e = 0];
          } else {
            x.e = v.e;
            x.c = v.c.slice();
          }
          return;
        }
        if ((isNum = typeof v == 'number') && v * 0 == 0) {
          // Use `1 / n` to handle minus zero also.
          x.s = 1 / v < 0 ? (v = -v, -1) : 1;

          // Fast path for integers, where n < 2147483648 (2**31).
          if (v === ~~v) {
            for (e = 0, i = v; i >= 10; i /= 10, e++);
            if (e > MAX_EXP) {
              x.c = x.e = null;
            } else {
              x.e = e;
              x.c = [v];
            }
            return;
          }
          str = String(v);
        } else {
          if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);
          x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
        }

        // Decimal point?
        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');

        // Exponential form?
        if ((i = str.search(/e/i)) > 0) {
          // Determine exponent.
          if (e < 0) e = i;
          e += +str.slice(i + 1);
          str = str.substring(0, i);
        } else if (e < 0) {
          // Integer.
          e = str.length;
        }
      } else {
        // '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
        intCheck(b, 2, ALPHABET.length, 'Base');

        // Allow exponential notation to be used with base 10 argument, while
        // also rounding to DECIMAL_PLACES as with other bases.
        if (b == 10 && alphabetHasNormalDecimalDigits) {
          x = new BigNumber(v);
          return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
        }
        str = String(v);
        if (isNum = typeof v == 'number') {
          // Avoid potential interpretation of Infinity and NaN as base 44+ values.
          if (v * 0 != 0) return parseNumeric(x, str, isNum, b);
          x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;

          // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
          if (BigNumber.DEBUG && str.replace(/^0\.0*|\./, '').length > 15) {
            throw Error(tooManyDigits + v);
          }
        } else {
          x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
        }
        alphabet = ALPHABET.slice(0, b);
        e = i = 0;

        // Check that str is a valid base b number.
        // Don't use RegExp, so alphabet can contain special characters.
        for (len = str.length; i < len; i++) {
          if (alphabet.indexOf(c = str.charAt(i)) < 0) {
            if (c == '.') {
              // If '.' is not the first character and it has not be found before.
              if (i > e) {
                e = len;
                continue;
              }
            } else if (!caseChanged) {
              // Allow e.g. hexadecimal 'FF' as well as 'ff'.
              if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
                caseChanged = true;
                i = -1;
                e = 0;
                continue;
              }
            }
            return parseNumeric(x, String(v), isNum, b);
          }
        }

        // Prevent later check for length on converted number.
        isNum = false;
        str = convertBase(str, b, 10, x.s);

        // Decimal point?
        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');else e = str.length;
      }

      // Determine leading zeros.
      for (i = 0; str.charCodeAt(i) === 48; i++);

      // Determine trailing zeros.
      for (len = str.length; str.charCodeAt(--len) === 48;);
      if (str = str.slice(i, ++len)) {
        len -= i;

        // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'
        if (isNum && BigNumber.DEBUG && len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
          throw Error(tooManyDigits + x.s * v);
        }

        // Overflow?
        if ((e = e - i - 1) > MAX_EXP) {
          // Infinity.
          x.c = x.e = null;

          // Underflow?
        } else if (e < MIN_EXP) {
          // Zero.
          x.c = [x.e = 0];
        } else {
          x.e = e;
          x.c = [];

          // Transform base

          // e is the base 10 exponent.
          // i is where to slice str to get the first element of the coefficient array.
          i = (e + 1) % LOG_BASE;
          if (e < 0) i += LOG_BASE; // i < 1

          if (i < len) {
            if (i) x.c.push(+str.slice(0, i));
            for (len -= LOG_BASE; i < len;) {
              x.c.push(+str.slice(i, i += LOG_BASE));
            }
            i = LOG_BASE - (str = str.slice(i)).length;
          } else {
            i -= len;
          }
          for (; i--; str += '0');
          x.c.push(+str);
        }
      } else {
        // Zero.
        x.c = [x.e = 0];
      }
    }

    // CONSTRUCTOR PROPERTIES

    BigNumber.clone = clone;
    BigNumber.ROUND_UP = 0;
    BigNumber.ROUND_DOWN = 1;
    BigNumber.ROUND_CEIL = 2;
    BigNumber.ROUND_FLOOR = 3;
    BigNumber.ROUND_HALF_UP = 4;
    BigNumber.ROUND_HALF_DOWN = 5;
    BigNumber.ROUND_HALF_EVEN = 6;
    BigNumber.ROUND_HALF_CEIL = 7;
    BigNumber.ROUND_HALF_FLOOR = 8;
    BigNumber.EUCLID = 9;

    /*
     * Configure infrequently-changing library-wide settings.
     *
     * Accept an object with the following optional properties (if the value of a property is
     * a number, it must be an integer within the inclusive range stated):
     *
     *   DECIMAL_PLACES   {number}           0 to MAX
     *   ROUNDING_MODE    {number}           0 to 8
     *   EXPONENTIAL_AT   {number|number[]}  -MAX to MAX  or  [-MAX to 0, 0 to MAX]
     *   RANGE            {number|number[]}  -MAX to MAX (not zero)  or  [-MAX to -1, 1 to MAX]
     *   CRYPTO           {boolean}          true or false
     *   MODULO_MODE      {number}           0 to 9
     *   POW_PRECISION       {number}           0 to MAX
     *   ALPHABET         {string}           A string of two or more unique characters which does
     *                                       not contain '.'.
     *   FORMAT           {object}           An object with some of the following properties:
     *     prefix                 {string}
     *     groupSize              {number}
     *     secondaryGroupSize     {number}
     *     groupSeparator         {string}
     *     decimalSeparator       {string}
     *     fractionGroupSize      {number}
     *     fractionGroupSeparator {string}
     *     suffix                 {string}
     *
     * (The values assigned to the above FORMAT object properties are not checked for validity.)
     *
     * E.g.
     * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })
     *
     * Ignore properties/parameters set to null or undefined, except for ALPHABET.
     *
     * Return an object with the properties current values.
     */
    BigNumber.config = BigNumber.set = function (obj) {
      var p, v;
      if (obj != null) {
        if (_typeof(obj) == 'object') {
          // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.
          // '[BigNumber Error] DECIMAL_PLACES {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'DECIMAL_PLACES')) {
            v = obj[p];
            intCheck(v, 0, MAX, p);
            DECIMAL_PLACES = v;
          }

          // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.
          // '[BigNumber Error] ROUNDING_MODE {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'ROUNDING_MODE')) {
            v = obj[p];
            intCheck(v, 0, 8, p);
            ROUNDING_MODE = v;
          }

          // EXPONENTIAL_AT {number|number[]}
          // Integer, -MAX to MAX inclusive or
          // [integer -MAX to 0 inclusive, 0 to MAX inclusive].
          // '[BigNumber Error] EXPONENTIAL_AT {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'EXPONENTIAL_AT')) {
            v = obj[p];
            if (v && v.pop) {
              intCheck(v[0], -MAX, 0, p);
              intCheck(v[1], 0, MAX, p);
              TO_EXP_NEG = v[0];
              TO_EXP_POS = v[1];
            } else {
              intCheck(v, -MAX, MAX, p);
              TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
            }
          }

          // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or
          // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].
          // '[BigNumber Error] RANGE {not a primitive number|not an integer|out of range|cannot be zero}: {v}'
          if (obj.hasOwnProperty(p = 'RANGE')) {
            v = obj[p];
            if (v && v.pop) {
              intCheck(v[0], -MAX, -1, p);
              intCheck(v[1], 1, MAX, p);
              MIN_EXP = v[0];
              MAX_EXP = v[1];
            } else {
              intCheck(v, -MAX, MAX, p);
              if (v) {
                MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
              } else {
                throw Error(bignumberError + p + ' cannot be zero: ' + v);
              }
            }
          }

          // CRYPTO {boolean} true or false.
          // '[BigNumber Error] CRYPTO not true or false: {v}'
          // '[BigNumber Error] crypto unavailable'
          if (obj.hasOwnProperty(p = 'CRYPTO')) {
            v = obj[p];
            if (v === !!v) {
              if (v) {
                if (typeof crypto != 'undefined' && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                  CRYPTO = v;
                } else {
                  CRYPTO = !v;
                  throw Error(bignumberError + 'crypto unavailable');
                }
              } else {
                CRYPTO = v;
              }
            } else {
              throw Error(bignumberError + p + ' not true or false: ' + v);
            }
          }

          // MODULO_MODE {number} Integer, 0 to 9 inclusive.
          // '[BigNumber Error] MODULO_MODE {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'MODULO_MODE')) {
            v = obj[p];
            intCheck(v, 0, 9, p);
            MODULO_MODE = v;
          }

          // POW_PRECISION {number} Integer, 0 to MAX inclusive.
          // '[BigNumber Error] POW_PRECISION {not a primitive number|not an integer|out of range}: {v}'
          if (obj.hasOwnProperty(p = 'POW_PRECISION')) {
            v = obj[p];
            intCheck(v, 0, MAX, p);
            POW_PRECISION = v;
          }

          // FORMAT {object}
          // '[BigNumber Error] FORMAT not an object: {v}'
          if (obj.hasOwnProperty(p = 'FORMAT')) {
            v = obj[p];
            if (_typeof(v) == 'object') FORMAT = v;else throw Error(bignumberError + p + ' not an object: ' + v);
          }

          // ALPHABET {string}
          // '[BigNumber Error] ALPHABET invalid: {v}'
          if (obj.hasOwnProperty(p = 'ALPHABET')) {
            v = obj[p];

            // Disallow if less than two characters,
            // or if it contains '+', '-', '.', whitespace, or a repeated character.
            if (typeof v == 'string' && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
              alphabetHasNormalDecimalDigits = v.slice(0, 10) == '0123456789';
              ALPHABET = v;
            } else {
              throw Error(bignumberError + p + ' invalid: ' + v);
            }
          }
        } else {
          // '[BigNumber Error] Object expected: {v}'
          throw Error(bignumberError + 'Object expected: ' + obj);
        }
      }
      return {
        DECIMAL_PLACES: DECIMAL_PLACES,
        ROUNDING_MODE: ROUNDING_MODE,
        EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
        RANGE: [MIN_EXP, MAX_EXP],
        CRYPTO: CRYPTO,
        MODULO_MODE: MODULO_MODE,
        POW_PRECISION: POW_PRECISION,
        FORMAT: FORMAT,
        ALPHABET: ALPHABET
      };
    };

    /*
     * Return true if v is a BigNumber instance, otherwise return false.
     *
     * If BigNumber.DEBUG is true, throw if a BigNumber instance is not well-formed.
     *
     * v {any}
     *
     * '[BigNumber Error] Invalid BigNumber: {v}'
     */
    BigNumber.isBigNumber = function (v) {
      if (!v || v._isBigNumber !== true) return false;
      if (!BigNumber.DEBUG) return true;
      var i,
        n,
        c = v.c,
        e = v.e,
        s = v.s;
      out: if ({}.toString.call(c) == '[object Array]') {
        if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {
          // If the first element is zero, the BigNumber value must be zero.
          if (c[0] === 0) {
            if (e === 0 && c.length === 1) return true;
            break out;
          }

          // Calculate number of digits that c[0] should have, based on the exponent.
          i = (e + 1) % LOG_BASE;
          if (i < 1) i += LOG_BASE;

          // Calculate number of digits of c[0].
          //if (Math.ceil(Math.log(c[0] + 1) / Math.LN10) == i) {
          if (String(c[0]).length == i) {
            for (i = 0; i < c.length; i++) {
              n = c[i];
              if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;
            }

            // Last element cannot be zero, unless it is the only element.
            if (n !== 0) return true;
          }
        }

        // Infinity/NaN
      } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
        return true;
      }
      throw Error(bignumberError + 'Invalid BigNumber: ' + v);
    };

    /*
     * Return a new BigNumber whose value is the maximum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */
    BigNumber.maximum = BigNumber.max = function () {
      return maxOrMin(arguments, -1);
    };

    /*
     * Return a new BigNumber whose value is the minimum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */
    BigNumber.minimum = BigNumber.min = function () {
      return maxOrMin(arguments, 1);
    };

    /*
     * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,
     * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing
     * zeros are produced).
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp}'
     * '[BigNumber Error] crypto unavailable'
     */
    BigNumber.random = function () {
      var pow2_53 = 0x20000000000000;

      // Return a 53 bit integer n, where 0 <= n < 9007199254740992.
      // Check if Math.random() produces more than 32 bits of randomness.
      // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.
      // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.
      var random53bitInt = Math.random() * pow2_53 & 0x1fffff ? function () {
        return mathfloor(Math.random() * pow2_53);
      } : function () {
        return (Math.random() * 0x40000000 | 0) * 0x800000 + (Math.random() * 0x800000 | 0);
      };
      return function (dp) {
        var a,
          b,
          e,
          k,
          v,
          i = 0,
          c = [],
          rand = new BigNumber(ONE);
        if (dp == null) dp = DECIMAL_PLACES;else intCheck(dp, 0, MAX);
        k = mathceil(dp / LOG_BASE);
        if (CRYPTO) {
          // Browsers supporting crypto.getRandomValues.
          if (crypto.getRandomValues) {
            a = crypto.getRandomValues(new Uint32Array(k *= 2));
            for (; i < k;) {
              // 53 bits:
              // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)
              // 11111 11111111 11111111 11111111 11100000 00000000 00000000
              // ((Math.pow(2, 32) - 1) >>> 11).toString(2)
              //                                     11111 11111111 11111111
              // 0x20000 is 2^21.
              v = a[i] * 0x20000 + (a[i + 1] >>> 11);

              // Rejection sampling:
              // 0 <= v < 9007199254740992
              // Probability that v >= 9e15, is
              // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251
              if (v >= 9e15) {
                b = crypto.getRandomValues(new Uint32Array(2));
                a[i] = b[0];
                a[i + 1] = b[1];
              } else {
                // 0 <= v <= 8999999999999999
                // 0 <= (v % 1e14) <= 99999999999999
                c.push(v % 1e14);
                i += 2;
              }
            }
            i = k / 2;

            // Node.js supporting crypto.randomBytes.
          } else if (crypto.randomBytes) {
            // buffer
            a = crypto.randomBytes(k *= 7);
            for (; i < k;) {
              // 0x1000000000000 is 2^48, 0x10000000000 is 2^40
              // 0x100000000 is 2^32, 0x1000000 is 2^24
              // 11111 11111111 11111111 11111111 11111111 11111111 11111111
              // 0 <= v < 9007199254740992
              v = (a[i] & 31) * 0x1000000000000 + a[i + 1] * 0x10000000000 + a[i + 2] * 0x100000000 + a[i + 3] * 0x1000000 + (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];
              if (v >= 9e15) {
                crypto.randomBytes(7).copy(a, i);
              } else {
                // 0 <= (v % 1e14) <= 99999999999999
                c.push(v % 1e14);
                i += 7;
              }
            }
            i = k / 7;
          } else {
            CRYPTO = false;
            throw Error(bignumberError + 'crypto unavailable');
          }
        }

        // Use Math.random.
        if (!CRYPTO) {
          for (; i < k;) {
            v = random53bitInt();
            if (v < 9e15) c[i++] = v % 1e14;
          }
        }
        k = c[--i];
        dp %= LOG_BASE;

        // Convert trailing digits to zeros according to dp.
        if (k && dp) {
          v = POWS_TEN[LOG_BASE - dp];
          c[i] = mathfloor(k / v) * v;
        }

        // Remove trailing elements which are zero.
        for (; c[i] === 0; c.pop(), i--);

        // Zero?
        if (i < 0) {
          c = [e = 0];
        } else {
          // Remove leading elements which are zero and adjust exponent accordingly.
          for (e = -1; c[0] === 0; c.splice(0, 1), e -= LOG_BASE);

          // Count the digits of the first element of c to determine leading zeros, and...
          for (i = 1, v = c[0]; v >= 10; v /= 10, i++);

          // adjust the exponent accordingly.
          if (i < LOG_BASE) e -= LOG_BASE - i;
        }
        rand.e = e;
        rand.c = c;
        return rand;
      };
    }();

    /*
     * Return a BigNumber whose value is the sum of the arguments.
     *
     * arguments {number|string|BigNumber}
     */
    BigNumber.sum = function () {
      var i = 1,
        args = arguments,
        sum = new BigNumber(args[0]);
      for (; i < args.length;) sum = sum.plus(args[i++]);
      return sum;
    };

    // PRIVATE FUNCTIONS

    // Called by BigNumber and BigNumber.prototype.toString.
    convertBase = function () {
      var decimal = '0123456789';

      /*
       * Convert string of baseIn to an array of numbers of baseOut.
       * Eg. toBaseOut('255', 10, 16) returns [15, 15].
       * Eg. toBaseOut('ff', 16, 10) returns [2, 5, 5].
       */
      function toBaseOut(str, baseIn, baseOut, alphabet) {
        var j,
          arr = [0],
          arrL,
          i = 0,
          len = str.length;
        for (; i < len;) {
          for (arrL = arr.length; arrL--; arr[arrL] *= baseIn);
          arr[0] += alphabet.indexOf(str.charAt(i++));
          for (j = 0; j < arr.length; j++) {
            if (arr[j] > baseOut - 1) {
              if (arr[j + 1] == null) arr[j + 1] = 0;
              arr[j + 1] += arr[j] / baseOut | 0;
              arr[j] %= baseOut;
            }
          }
        }
        return arr.reverse();
      }

      // Convert a numeric string of baseIn to a numeric string of baseOut.
      // If the caller is toString, we are converting from base 10 to baseOut.
      // If the caller is BigNumber, we are converting from baseIn to base 10.
      return function (str, baseIn, baseOut, sign, callerIsToString) {
        var alphabet,
          d,
          e,
          k,
          r,
          x,
          xc,
          y,
          i = str.indexOf('.'),
          dp = DECIMAL_PLACES,
          rm = ROUNDING_MODE;

        // Non-integer.
        if (i >= 0) {
          k = POW_PRECISION;

          // Unlimited precision.
          POW_PRECISION = 0;
          str = str.replace('.', '');
          y = new BigNumber(baseIn);
          x = y.pow(str.length - i);
          POW_PRECISION = k;

          // Convert str as if an integer, then restore the fraction part by dividing the
          // result by its base raised to a power.

          y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, '0'), 10, baseOut, decimal);
          y.e = y.c.length;
        }

        // Convert the number as integer.

        xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET));

        // xc now represents str as an integer and converted to baseOut. e is the exponent.
        e = k = xc.length;

        // Remove trailing zeros.
        for (; xc[--k] == 0; xc.pop());

        // Zero?
        if (!xc[0]) return alphabet.charAt(0);

        // Does str represent an integer? If so, no need for the division.
        if (i < 0) {
          --e;
        } else {
          x.c = xc;
          x.e = e;

          // The sign is needed for correct rounding.
          x.s = sign;
          x = div(x, y, dp, rm, baseOut);
          xc = x.c;
          r = x.r;
          e = x.e;
        }

        // xc now represents str converted to baseOut.

        // THe index of the rounding digit.
        d = e + dp + 1;

        // The rounding digit: the digit to the right of the digit that may be rounded up.
        i = xc[d];

        // Look at the rounding digits and mode to determine whether to round up.

        k = baseOut / 2;
        r = r || d < 0 || xc[d + 1] != null;
        r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : i > k || i == k && (rm == 4 || r || rm == 6 && xc[d - 1] & 1 || rm == (x.s < 0 ? 8 : 7));

        // If the index of the rounding digit is not greater than zero, or xc represents
        // zero, then the result of the base conversion is zero or, if rounding up, a value
        // such as 0.00001.
        if (d < 1 || !xc[0]) {
          // 1^-dp or 0
          str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
        } else {
          // Truncate xc to the required number of decimal places.
          xc.length = d;

          // Round up?
          if (r) {
            // Rounding up may mean the previous digit has to be rounded up and so on.
            for (--baseOut; ++xc[--d] > baseOut;) {
              xc[d] = 0;
              if (!d) {
                ++e;
                xc = [1].concat(xc);
              }
            }
          }

          // Determine trailing zeros.
          for (k = xc.length; !xc[--k];);

          // E.g. [4, 11, 15] becomes 4bf.
          for (i = 0, str = ''; i <= k; str += alphabet.charAt(xc[i++]));

          // Add leading zeros, decimal point and trailing zeros as required.
          str = toFixedPoint(str, e, alphabet.charAt(0));
        }

        // The caller will add the sign.
        return str;
      };
    }();

    // Perform division in the specified base. Called by div and convertBase.
    div = function () {
      // Assume non-zero x and k.
      function multiply(x, k, base) {
        var m,
          temp,
          xlo,
          xhi,
          carry = 0,
          i = x.length,
          klo = k % SQRT_BASE,
          khi = k / SQRT_BASE | 0;
        for (x = x.slice(); i--;) {
          xlo = x[i] % SQRT_BASE;
          xhi = x[i] / SQRT_BASE | 0;
          m = khi * xlo + xhi * klo;
          temp = klo * xlo + m % SQRT_BASE * SQRT_BASE + carry;
          carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
          x[i] = temp % base;
        }
        if (carry) x = [carry].concat(x);
        return x;
      }
      function compare(a, b, aL, bL) {
        var i, cmp;
        if (aL != bL) {
          cmp = aL > bL ? 1 : -1;
        } else {
          for (i = cmp = 0; i < aL; i++) {
            if (a[i] != b[i]) {
              cmp = a[i] > b[i] ? 1 : -1;
              break;
            }
          }
        }
        return cmp;
      }
      function subtract(a, b, aL, base) {
        var i = 0;

        // Subtract b from a.
        for (; aL--;) {
          a[aL] -= i;
          i = a[aL] < b[aL] ? 1 : 0;
          a[aL] = i * base + a[aL] - b[aL];
        }

        // Remove leading zeros.
        for (; !a[0] && a.length > 1; a.splice(0, 1));
      }

      // x: dividend, y: divisor.
      return function (x, y, dp, rm, base) {
        var cmp,
          e,
          i,
          more,
          n,
          prod,
          prodL,
          q,
          qc,
          rem,
          remL,
          rem0,
          xi,
          xL,
          yc0,
          yL,
          yz,
          s = x.s == y.s ? 1 : -1,
          xc = x.c,
          yc = y.c;

        // Either NaN, Infinity or 0?
        if (!xc || !xc[0] || !yc || !yc[0]) {
          return new BigNumber(
          // Return NaN if either NaN, or both Infinity or 0.
          !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN :
          // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
          xc && xc[0] == 0 || !yc ? s * 0 : s / 0);
        }
        q = new BigNumber(s);
        qc = q.c = [];
        e = x.e - y.e;
        s = dp + e + 1;
        if (!base) {
          base = BASE;
          e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
          s = s / LOG_BASE | 0;
        }

        // Result exponent may be one less then the current value of e.
        // The coefficients of the BigNumbers from convertBase may have trailing zeros.
        for (i = 0; yc[i] == (xc[i] || 0); i++);
        if (yc[i] > (xc[i] || 0)) e--;
        if (s < 0) {
          qc.push(1);
          more = true;
        } else {
          xL = xc.length;
          yL = yc.length;
          i = 0;
          s += 2;

          // Normalise xc and yc so highest order digit of yc is >= base / 2.

          n = mathfloor(base / (yc[0] + 1));

          // Not necessary, but to handle odd bases where yc[0] == (base / 2) - 1.
          // if (n > 1 || n++ == 1 && yc[0] < base / 2) {
          if (n > 1) {
            yc = multiply(yc, n, base);
            xc = multiply(xc, n, base);
            yL = yc.length;
            xL = xc.length;
          }
          xi = yL;
          rem = xc.slice(0, yL);
          remL = rem.length;

          // Add zeros to make remainder as long as divisor.
          for (; remL < yL; rem[remL++] = 0);
          yz = yc.slice();
          yz = [0].concat(yz);
          yc0 = yc[0];
          if (yc[1] >= base / 2) yc0++;
          // Not necessary, but to prevent trial digit n > base, when using base 3.
          // else if (base == 3 && yc0 == 1) yc0 = 1 + 1e-15;

          do {
            n = 0;

            // Compare divisor and remainder.
            cmp = compare(yc, rem, yL, remL);

            // If divisor < remainder.
            if (cmp < 0) {
              // Calculate trial digit, n.

              rem0 = rem[0];
              if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);

              // n is how many times the divisor goes into the current remainder.
              n = mathfloor(rem0 / yc0);

              //  Algorithm:
              //  product = divisor multiplied by trial digit (n).
              //  Compare product and remainder.
              //  If product is greater than remainder:
              //    Subtract divisor from product, decrement trial digit.
              //  Subtract product from remainder.
              //  If product was less than remainder at the last compare:
              //    Compare new remainder and divisor.
              //    If remainder is greater than divisor:
              //      Subtract divisor from remainder, increment trial digit.

              if (n > 1) {
                // n may be > base only when base is 3.
                if (n >= base) n = base - 1;

                // product = divisor * trial digit.
                prod = multiply(yc, n, base);
                prodL = prod.length;
                remL = rem.length;

                // Compare product and remainder.
                // If product > remainder then trial digit n too high.
                // n is 1 too high about 5% of the time, and is not known to have
                // ever been more than 1 too high.
                while (compare(prod, rem, prodL, remL) == 1) {
                  n--;

                  // Subtract divisor from product.
                  subtract(prod, yL < prodL ? yz : yc, prodL, base);
                  prodL = prod.length;
                  cmp = 1;
                }
              } else {
                // n is 0 or 1, cmp is -1.
                // If n is 0, there is no need to compare yc and rem again below,
                // so change cmp to 1 to avoid it.
                // If n is 1, leave cmp as -1, so yc and rem are compared again.
                if (n == 0) {
                  // divisor < remainder, so n must be at least 1.
                  cmp = n = 1;
                }

                // product = divisor
                prod = yc.slice();
                prodL = prod.length;
              }
              if (prodL < remL) prod = [0].concat(prod);

              // Subtract product from remainder.
              subtract(rem, prod, remL, base);
              remL = rem.length;

              // If product was < remainder.
              if (cmp == -1) {
                // Compare divisor and new remainder.
                // If divisor < new remainder, subtract divisor from remainder.
                // Trial digit n too low.
                // n is 1 too low about 5% of the time, and very rarely 2 too low.
                while (compare(yc, rem, yL, remL) < 1) {
                  n++;

                  // Subtract divisor from remainder.
                  subtract(rem, yL < remL ? yz : yc, remL, base);
                  remL = rem.length;
                }
              }
            } else if (cmp === 0) {
              n++;
              rem = [0];
            } // else cmp === 1 and n will be 0

            // Add the next digit, n, to the result array.
            qc[i++] = n;

            // Update the remainder.
            if (rem[0]) {
              rem[remL++] = xc[xi] || 0;
            } else {
              rem = [xc[xi]];
              remL = 1;
            }
          } while ((xi++ < xL || rem[0] != null) && s--);
          more = rem[0] != null;

          // Leading zero?
          if (!qc[0]) qc.splice(0, 1);
        }
        if (base == BASE) {
          // To calculate q.e, first get the number of digits of qc[0].
          for (i = 1, s = qc[0]; s >= 10; s /= 10, i++);
          round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);

          // Caller is convertBase.
        } else {
          q.e = e;
          q.r = +more;
        }
        return q;
      };
    }();

    /*
     * Return a string representing the value of BigNumber n in fixed-point or exponential
     * notation rounded to the specified decimal places or significant digits.
     *
     * n: a BigNumber.
     * i: the index of the last digit required (i.e. the digit that may be rounded up).
     * rm: the rounding mode.
     * id: 1 (toExponential) or 2 (toPrecision).
     */
    function format(n, i, rm, id) {
      var c0, e, ne, len, str;
      if (rm == null) rm = ROUNDING_MODE;else intCheck(rm, 0, 8);
      if (!n.c) return n.toString();
      c0 = n.c[0];
      ne = n.e;
      if (i == null) {
        str = coeffToString(n.c);
        str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, '0');
      } else {
        n = round(new BigNumber(n), i, rm);

        // n.e may have changed if the value was rounded up.
        e = n.e;
        str = coeffToString(n.c);
        len = str.length;

        // toPrecision returns exponential notation if the number of significant digits
        // specified is less than the number of digits necessary to represent the integer
        // part of the value in fixed-point notation.

        // Exponential notation.
        if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {
          // Append zeros?
          for (; len < i; str += '0', len++);
          str = toExponential(str, e);

          // Fixed-point notation.
        } else {
          i -= ne;
          str = toFixedPoint(str, e, '0');

          // Append zeros?
          if (e + 1 > len) {
            if (--i > 0) for (str += '.'; i--; str += '0');
          } else {
            i += e - len;
            if (i > 0) {
              if (e + 1 == len) str += '.';
              for (; i--; str += '0');
            }
          }
        }
      }
      return n.s < 0 && c0 ? '-' + str : str;
    }

    // Handle BigNumber.max and BigNumber.min.
    // If any number is NaN, return NaN.
    function maxOrMin(args, n) {
      var k,
        y,
        i = 1,
        x = new BigNumber(args[0]);
      for (; i < args.length; i++) {
        y = new BigNumber(args[i]);
        if (!y.s || (k = compare(x, y)) === n || k === 0 && x.s === n) {
          x = y;
        }
      }
      return x;
    }

    /*
     * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.
     * Called by minus, plus and times.
     */
    function normalise(n, c, e) {
      var i = 1,
        j = c.length;

      // Remove trailing zeros.
      for (; !c[--j]; c.pop());

      // Calculate the base 10 exponent. First get the number of digits of c[0].
      for (j = c[0]; j >= 10; j /= 10, i++);

      // Overflow?
      if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {
        // Infinity.
        n.c = n.e = null;

        // Underflow?
      } else if (e < MIN_EXP) {
        // Zero.
        n.c = [n.e = 0];
      } else {
        n.e = e;
        n.c = c;
      }
      return n;
    }

    // Handle values that fail the validity test in BigNumber.
    parseNumeric = function () {
      var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i,
        dotAfter = /^([^.]+)\.$/,
        dotBefore = /^\.([^.]+)$/,
        isInfinityOrNaN = /^-?(Infinity|NaN)$/,
        whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
      return function (x, str, isNum, b) {
        var base,
          s = isNum ? str : str.replace(whitespaceOrPlus, '');

        // No exception on Infinity or NaN.
        if (isInfinityOrNaN.test(s)) {
          x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
        } else {
          if (!isNum) {
            // basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i
            s = s.replace(basePrefix, function (m, p1, p2) {
              base = (p2 = p2.toLowerCase()) == 'x' ? 16 : p2 == 'b' ? 2 : 8;
              return !b || b == base ? p1 : m;
            });
            if (b) {
              base = b;

              // E.g. '1.' to '1', '.1' to '0.1'
              s = s.replace(dotAfter, '$1').replace(dotBefore, '0.$1');
            }
            if (str != s) return new BigNumber(s, base);
          }

          // '[BigNumber Error] Not a number: {n}'
          // '[BigNumber Error] Not a base {b} number: {n}'
          if (BigNumber.DEBUG) {
            throw Error(bignumberError + 'Not a' + (b ? ' base ' + b : '') + ' number: ' + str);
          }

          // NaN
          x.s = null;
        }
        x.c = x.e = null;
      };
    }();

    /*
     * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.
     * If r is truthy, it is known that there are more digits after the rounding digit.
     */
    function round(x, sd, rm, r) {
      var d,
        i,
        j,
        k,
        n,
        ni,
        rd,
        xc = x.c,
        pows10 = POWS_TEN;

      // if x is not Infinity or NaN...
      if (xc) {
        // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.
        // n is a base 1e14 number, the value of the element of array x.c containing rd.
        // ni is the index of n within x.c.
        // d is the number of digits of n.
        // i is the index of rd within n including leading zeros.
        // j is the actual index of rd within n (if < 0, rd is a leading zero).
        out: {
          // Get the number of digits of the first element of xc.
          for (d = 1, k = xc[0]; k >= 10; k /= 10, d++);
          i = sd - d;

          // If the rounding digit is in the first element of xc...
          if (i < 0) {
            i += LOG_BASE;
            j = sd;
            n = xc[ni = 0];

            // Get the rounding digit at index j of n.
            rd = mathfloor(n / pows10[d - j - 1] % 10);
          } else {
            ni = mathceil((i + 1) / LOG_BASE);
            if (ni >= xc.length) {
              if (r) {
                // Needed by sqrt.
                for (; xc.length <= ni; xc.push(0));
                n = rd = 0;
                d = 1;
                i %= LOG_BASE;
                j = i - LOG_BASE + 1;
              } else {
                break out;
              }
            } else {
              n = k = xc[ni];

              // Get the number of digits of n.
              for (d = 1; k >= 10; k /= 10, d++);

              // Get the index of rd within n.
              i %= LOG_BASE;

              // Get the index of rd within n, adjusted for leading zeros.
              // The number of leading zeros of n is given by LOG_BASE - d.
              j = i - LOG_BASE + d;

              // Get the rounding digit at index j of n.
              rd = j < 0 ? 0 : mathfloor(n / pows10[d - j - 1] % 10);
            }
          }
          r = r || sd < 0 ||
          // Are there any non-zero digits after the rounding digit?
          // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
          // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
          xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);
          r = rm < 4 ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 &&
          // Check whether the digit to the left of the rounding digit is odd.
          (i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
          if (sd < 1 || !xc[0]) {
            xc.length = 0;
            if (r) {
              // Convert sd to decimal places.
              sd -= x.e + 1;

              // 1, 0.1, 0.01, 0.001, 0.0001 etc.
              xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
              x.e = -sd || 0;
            } else {
              // Zero.
              xc[0] = x.e = 0;
            }
            return x;
          }

          // Remove excess digits.
          if (i == 0) {
            xc.length = ni;
            k = 1;
            ni--;
          } else {
            xc.length = ni + 1;
            k = pows10[LOG_BASE - i];

            // E.g. 56700 becomes 56000 if 7 is the rounding digit.
            // j > 0 means i > number of leading zeros of n.
            xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
          }

          // Round up?
          if (r) {
            for (;;) {
              // If the digit to be rounded up is in the first element of xc...
              if (ni == 0) {
                // i will be the length of xc[0] before k is added.
                for (i = 1, j = xc[0]; j >= 10; j /= 10, i++);
                j = xc[0] += k;
                for (k = 1; j >= 10; j /= 10, k++);

                // if i != k the length has increased.
                if (i != k) {
                  x.e++;
                  if (xc[0] == BASE) xc[0] = 1;
                }
                break;
              } else {
                xc[ni] += k;
                if (xc[ni] != BASE) break;
                xc[ni--] = 0;
                k = 1;
              }
            }
          }

          // Remove trailing zeros.
          for (i = xc.length; xc[--i] === 0; xc.pop());
        }

        // Overflow? Infinity.
        if (x.e > MAX_EXP) {
          x.c = x.e = null;

          // Underflow? Zero.
        } else if (x.e < MIN_EXP) {
          x.c = [x.e = 0];
        }
      }
      return x;
    }
    function valueOf(n) {
      var str,
        e = n.e;
      if (e === null) return n.toString();
      str = coeffToString(n.c);
      str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e, '0');
      return n.s < 0 ? '-' + str : str;
    }

    // PROTOTYPE/INSTANCE METHODS

    /*
     * Return a new BigNumber whose value is the absolute value of this BigNumber.
     */
    P.absoluteValue = P.abs = function () {
      var x = new BigNumber(this);
      if (x.s < 0) x.s = 1;
      return x;
    };

    /*
     * Return
     *   1 if the value of this BigNumber is greater than the value of BigNumber(y, b),
     *   -1 if the value of this BigNumber is less than the value of BigNumber(y, b),
     *   0 if they have the same value,
     *   or null if the value of either is NaN.
     */
    P.comparedTo = function (y, b) {
      return compare(this, new BigNumber(y, b));
    };

    /*
     * If dp is undefined or null or true or false, return the number of decimal places of the
     * value of this BigNumber, or null if the value of this BigNumber is Infinity or NaN.
     *
     * Otherwise, if dp is a number, return a new BigNumber whose value is the value of this
     * BigNumber rounded to a maximum of dp decimal places using rounding mode rm, or
     * ROUNDING_MODE if rm is omitted.
     *
     * [dp] {number} Decimal places: integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */
    P.decimalPlaces = P.dp = function (dp, rm) {
      var c,
        n,
        v,
        x = this;
      if (dp != null) {
        intCheck(dp, 0, MAX);
        if (rm == null) rm = ROUNDING_MODE;else intCheck(rm, 0, 8);
        return round(new BigNumber(x), dp + x.e + 1, rm);
      }
      if (!(c = x.c)) return null;
      n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;

      // Subtract the number of trailing zeros of the last number.
      if (v = c[v]) for (; v % 10 == 0; v /= 10, n--);
      if (n < 0) n = 0;
      return n;
    };

    /*
     *  n / 0 = I
     *  n / N = N
     *  n / I = 0
     *  0 / n = 0
     *  0 / 0 = N
     *  0 / N = N
     *  0 / I = 0
     *  N / n = N
     *  N / 0 = N
     *  N / N = N
     *  N / I = N
     *  I / n = I
     *  I / 0 = I
     *  I / N = N
     *  I / I = N
     *
     * Return a new BigNumber whose value is the value of this BigNumber divided by the value of
     * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.
     */
    P.dividedBy = P.div = function (y, b) {
      return div(this, new BigNumber(y, b), DECIMAL_PLACES, ROUNDING_MODE);
    };

    /*
     * Return a new BigNumber whose value is the integer part of dividing the value of this
     * BigNumber by the value of BigNumber(y, b).
     */
    P.dividedToIntegerBy = P.idiv = function (y, b) {
      return div(this, new BigNumber(y, b), 0, 1);
    };

    /*
     * Return a BigNumber whose value is the value of this BigNumber exponentiated by n.
     *
     * If m is present, return the result modulo m.
     * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.
     * If POW_PRECISION is non-zero and m is not present, round to POW_PRECISION using ROUNDING_MODE.
     *
     * The modular power operation works efficiently when x, n, and m are integers, otherwise it
     * is equivalent to calculating x.exponentiatedBy(n).modulo(m) with a POW_PRECISION of 0.
     *
     * n {number|string|BigNumber} The exponent. An integer.
     * [m] {number|string|BigNumber} The modulus.
     *
     * '[BigNumber Error] Exponent not an integer: {n}'
     */
    P.exponentiatedBy = P.pow = function (n, m) {
      var half,
        isModExp,
        i,
        k,
        more,
        nIsBig,
        nIsNeg,
        nIsOdd,
        y,
        x = this;
      n = new BigNumber(n);

      // Allow NaN and Infinity, but not other non-integers.
      if (n.c && !n.isInteger()) {
        throw Error(bignumberError + 'Exponent not an integer: ' + valueOf(n));
      }
      if (m != null) m = new BigNumber(m);

      // Exponent of MAX_SAFE_INTEGER is 15.
      nIsBig = n.e > 14;

      // If x is NaN, Infinity, 0 or 1, or n is Infinity, NaN or 0.
      if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {
        // The sign of the result of pow when x is negative depends on the evenness of n.
        // If +n overflows to Infinity, the evenness of n would be not be known.
        y = new BigNumber(Math.pow(+valueOf(x), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf(n)));
        return m ? y.mod(m) : y;
      }
      nIsNeg = n.s < 0;
      if (m) {
        // x % m returns NaN if abs(m) is zero, or m is NaN.
        if (m.c ? !m.c[0] : !m.s) return new BigNumber(NaN);
        isModExp = !nIsNeg && x.isInteger() && m.isInteger();
        if (isModExp) x = x.mod(m);

        // Overflow to Infinity: >=2**1e10 or >=1.0000024**1e15.
        // Underflow to 0: <=0.79**1e10 or <=0.9999975**1e15.
      } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0
      // [1, 240000000]
      ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7
      // [80000000000000]  [99999750000000]
      : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {
        // If x is negative and n is odd, k = -0, else k = 0.
        k = x.s < 0 && isOdd(n) ? -0 : 0;

        // If x >= 1, k = Infinity.
        if (x.e > -1) k = 1 / k;

        // If n is negative return 0, else return Infinity.
        return new BigNumber(nIsNeg ? 1 / k : k);
      } else if (POW_PRECISION) {
        // Truncating each coefficient array to a length of k after each multiplication
        // equates to truncating significant digits to POW_PRECISION + [28, 41],
        // i.e. there will be a minimum of 28 guard digits retained.
        k = mathceil(POW_PRECISION / LOG_BASE + 2);
      }
      if (nIsBig) {
        half = new BigNumber(0.5);
        if (nIsNeg) n.s = 1;
        nIsOdd = isOdd(n);
      } else {
        i = Math.abs(+valueOf(n));
        nIsOdd = i % 2;
      }
      y = new BigNumber(ONE);

      // Performs 54 loop iterations for n of 9007199254740991.
      for (;;) {
        if (nIsOdd) {
          y = y.times(x);
          if (!y.c) break;
          if (k) {
            if (y.c.length > k) y.c.length = k;
          } else if (isModExp) {
            y = y.mod(m); //y = y.minus(div(y, m, 0, MODULO_MODE).times(m));
          }
        }
        if (i) {
          i = mathfloor(i / 2);
          if (i === 0) break;
          nIsOdd = i % 2;
        } else {
          n = n.times(half);
          round(n, n.e + 1, 1);
          if (n.e > 14) {
            nIsOdd = isOdd(n);
          } else {
            i = +valueOf(n);
            if (i === 0) break;
            nIsOdd = i % 2;
          }
        }
        x = x.times(x);
        if (k) {
          if (x.c && x.c.length > k) x.c.length = k;
        } else if (isModExp) {
          x = x.mod(m); //x = x.minus(div(x, m, 0, MODULO_MODE).times(m));
        }
      }
      if (isModExp) return y;
      if (nIsNeg) y = ONE.div(y);
      return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
    };

    /*
     * Return a new BigNumber whose value is the value of this BigNumber rounded to an integer
     * using rounding mode rm, or ROUNDING_MODE if rm is omitted.
     *
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {rm}'
     */
    P.integerValue = function (rm) {
      var n = new BigNumber(this);
      if (rm == null) rm = ROUNDING_MODE;else intCheck(rm, 0, 8);
      return round(n, n.e + 1, rm);
    };

    /*
     * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),
     * otherwise return false.
     */
    P.isEqualTo = P.eq = function (y, b) {
      return compare(this, new BigNumber(y, b)) === 0;
    };

    /*
     * Return true if the value of this BigNumber is a finite number, otherwise return false.
     */
    P.isFinite = function () {
      return !!this.c;
    };

    /*
     * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),
     * otherwise return false.
     */
    P.isGreaterThan = P.gt = function (y, b) {
      return compare(this, new BigNumber(y, b)) > 0;
    };

    /*
     * Return true if the value of this BigNumber is greater than or equal to the value of
     * BigNumber(y, b), otherwise return false.
     */
    P.isGreaterThanOrEqualTo = P.gte = function (y, b) {
      return (b = compare(this, new BigNumber(y, b))) === 1 || b === 0;
    };

    /*
     * Return true if the value of this BigNumber is an integer, otherwise return false.
     */
    P.isInteger = function () {
      return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
    };

    /*
     * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),
     * otherwise return false.
     */
    P.isLessThan = P.lt = function (y, b) {
      return compare(this, new BigNumber(y, b)) < 0;
    };

    /*
     * Return true if the value of this BigNumber is less than or equal to the value of
     * BigNumber(y, b), otherwise return false.
     */
    P.isLessThanOrEqualTo = P.lte = function (y, b) {
      return (b = compare(this, new BigNumber(y, b))) === -1 || b === 0;
    };

    /*
     * Return true if the value of this BigNumber is NaN, otherwise return false.
     */
    P.isNaN = function () {
      return !this.s;
    };

    /*
     * Return true if the value of this BigNumber is negative, otherwise return false.
     */
    P.isNegative = function () {
      return this.s < 0;
    };

    /*
     * Return true if the value of this BigNumber is positive, otherwise return false.
     */
    P.isPositive = function () {
      return this.s > 0;
    };

    /*
     * Return true if the value of this BigNumber is 0 or -0, otherwise return false.
     */
    P.isZero = function () {
      return !!this.c && this.c[0] == 0;
    };

    /*
     *  n - 0 = n
     *  n - N = N
     *  n - I = -I
     *  0 - n = -n
     *  0 - 0 = 0
     *  0 - N = N
     *  0 - I = -I
     *  N - n = N
     *  N - 0 = N
     *  N - N = N
     *  N - I = N
     *  I - n = I
     *  I - 0 = I
     *  I - N = N
     *  I - I = N
     *
     * Return a new BigNumber whose value is the value of this BigNumber minus the value of
     * BigNumber(y, b).
     */
    P.minus = function (y, b) {
      var i,
        j,
        t,
        xLTy,
        x = this,
        a = x.s;
      y = new BigNumber(y, b);
      b = y.s;

      // Either NaN?
      if (!a || !b) return new BigNumber(NaN);

      // Signs differ?
      if (a != b) {
        y.s = -b;
        return x.plus(y);
      }
      var xe = x.e / LOG_BASE,
        ye = y.e / LOG_BASE,
        xc = x.c,
        yc = y.c;
      if (!xe || !ye) {
        // Either Infinity?
        if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber(yc ? x : NaN);

        // Either zero?
        if (!xc[0] || !yc[0]) {
          // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
          return yc[0] ? (y.s = -b, y) : new BigNumber(xc[0] ? x :
          // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
          ROUNDING_MODE == 3 ? -0 : 0);
        }
      }
      xe = bitFloor(xe);
      ye = bitFloor(ye);
      xc = xc.slice();

      // Determine which is the bigger number.
      if (a = xe - ye) {
        if (xLTy = a < 0) {
          a = -a;
          t = xc;
        } else {
          ye = xe;
          t = yc;
        }
        t.reverse();

        // Prepend zeros to equalise exponents.
        for (b = a; b--; t.push(0));
        t.reverse();
      } else {
        // Exponents equal. Check digit by digit.
        j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;
        for (a = b = 0; b < j; b++) {
          if (xc[b] != yc[b]) {
            xLTy = xc[b] < yc[b];
            break;
          }
        }
      }

      // x < y? Point xc to the array of the bigger number.
      if (xLTy) {
        t = xc;
        xc = yc;
        yc = t;
        y.s = -y.s;
      }
      b = (j = yc.length) - (i = xc.length);

      // Append zeros to xc if shorter.
      // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.
      if (b > 0) for (; b--; xc[i++] = 0);
      b = BASE - 1;

      // Subtract yc from xc.
      for (; j > a;) {
        if (xc[--j] < yc[j]) {
          for (i = j; i && !xc[--i]; xc[i] = b);
          --xc[i];
          xc[j] += BASE;
        }
        xc[j] -= yc[j];
      }

      // Remove leading zeros and adjust exponent accordingly.
      for (; xc[0] == 0; xc.splice(0, 1), --ye);

      // Zero?
      if (!xc[0]) {
        // Following IEEE 754 (2008) 6.3,
        // n - n = +0  but  n - n = -0  when rounding towards -Infinity.
        y.s = ROUNDING_MODE == 3 ? -1 : 1;
        y.c = [y.e = 0];
        return y;
      }

      // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity
      // for finite x and y.
      return normalise(y, xc, ye);
    };

    /*
     *   n % 0 =  N
     *   n % N =  N
     *   n % I =  n
     *   0 % n =  0
     *  -0 % n = -0
     *   0 % 0 =  N
     *   0 % N =  N
     *   0 % I =  0
     *   N % n =  N
     *   N % 0 =  N
     *   N % N =  N
     *   N % I =  N
     *   I % n =  N
     *   I % 0 =  N
     *   I % N =  N
     *   I % I =  N
     *
     * Return a new BigNumber whose value is the value of this BigNumber modulo the value of
     * BigNumber(y, b). The result depends on the value of MODULO_MODE.
     */
    P.modulo = P.mod = function (y, b) {
      var q,
        s,
        x = this;
      y = new BigNumber(y, b);

      // Return NaN if x is Infinity or NaN, or y is NaN or zero.
      if (!x.c || !y.s || y.c && !y.c[0]) {
        return new BigNumber(NaN);

        // Return x if y is Infinity or x is zero.
      } else if (!y.c || x.c && !x.c[0]) {
        return new BigNumber(x);
      }
      if (MODULO_MODE == 9) {
        // Euclidian division: q = sign(y) * floor(x / abs(y))
        // r = x - qy    where  0 <= r < abs(y)
        s = y.s;
        y.s = 1;
        q = div(x, y, 0, 3);
        y.s = s;
        q.s *= s;
      } else {
        q = div(x, y, 0, MODULO_MODE);
      }
      y = x.minus(q.times(y));

      // To match JavaScript %, ensure sign of zero is sign of dividend.
      if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;
      return y;
    };

    /*
     *  n * 0 = 0
     *  n * N = N
     *  n * I = I
     *  0 * n = 0
     *  0 * 0 = 0
     *  0 * N = N
     *  0 * I = N
     *  N * n = N
     *  N * 0 = N
     *  N * N = N
     *  N * I = N
     *  I * n = I
     *  I * 0 = N
     *  I * N = N
     *  I * I = I
     *
     * Return a new BigNumber whose value is the value of this BigNumber multiplied by the value
     * of BigNumber(y, b).
     */
    P.multipliedBy = P.times = function (y, b) {
      var c,
        e,
        i,
        j,
        k,
        m,
        xcL,
        xlo,
        xhi,
        ycL,
        ylo,
        yhi,
        zc,
        base,
        sqrtBase,
        x = this,
        xc = x.c,
        yc = (y = new BigNumber(y, b)).c;

      // Either NaN, Infinity or 0?
      if (!xc || !yc || !xc[0] || !yc[0]) {
        // Return NaN if either is NaN, or one is 0 and the other is Infinity.
        if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
          y.c = y.e = y.s = null;
        } else {
          y.s *= x.s;

          // Return Infinity if either is Infinity.
          if (!xc || !yc) {
            y.c = y.e = null;

            // Return 0 if either is 0.
          } else {
            y.c = [0];
            y.e = 0;
          }
        }
        return y;
      }
      e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
      y.s *= x.s;
      xcL = xc.length;
      ycL = yc.length;

      // Ensure xc points to longer array and xcL to its length.
      if (xcL < ycL) {
        zc = xc;
        xc = yc;
        yc = zc;
        i = xcL;
        xcL = ycL;
        ycL = i;
      }

      // Initialise the result array with zeros.
      for (i = xcL + ycL, zc = []; i--; zc.push(0));
      base = BASE;
      sqrtBase = SQRT_BASE;
      for (i = ycL; --i >= 0;) {
        c = 0;
        ylo = yc[i] % sqrtBase;
        yhi = yc[i] / sqrtBase | 0;
        for (k = xcL, j = i + k; j > i;) {
          xlo = xc[--k] % sqrtBase;
          xhi = xc[k] / sqrtBase | 0;
          m = yhi * xlo + xhi * ylo;
          xlo = ylo * xlo + m % sqrtBase * sqrtBase + zc[j] + c;
          c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
          zc[j--] = xlo % base;
        }
        zc[j] = c;
      }
      if (c) {
        ++e;
      } else {
        zc.splice(0, 1);
      }
      return normalise(y, zc, e);
    };

    /*
     * Return a new BigNumber whose value is the value of this BigNumber negated,
     * i.e. multiplied by -1.
     */
    P.negated = function () {
      var x = new BigNumber(this);
      x.s = -x.s || null;
      return x;
    };

    /*
     *  n + 0 = n
     *  n + N = N
     *  n + I = I
     *  0 + n = n
     *  0 + 0 = 0
     *  0 + N = N
     *  0 + I = I
     *  N + n = N
     *  N + 0 = N
     *  N + N = N
     *  N + I = N
     *  I + n = I
     *  I + 0 = I
     *  I + N = N
     *  I + I = I
     *
     * Return a new BigNumber whose value is the value of this BigNumber plus the value of
     * BigNumber(y, b).
     */
    P.plus = function (y, b) {
      var t,
        x = this,
        a = x.s;
      y = new BigNumber(y, b);
      b = y.s;

      // Either NaN?
      if (!a || !b) return new BigNumber(NaN);

      // Signs differ?
      if (a != b) {
        y.s = -b;
        return x.minus(y);
      }
      var xe = x.e / LOG_BASE,
        ye = y.e / LOG_BASE,
        xc = x.c,
        yc = y.c;
      if (!xe || !ye) {
        // Return Infinity if either Infinity.
        if (!xc || !yc) return new BigNumber(a / 0);

        // Either zero?
        // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
        if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber(xc[0] ? x : a * 0);
      }
      xe = bitFloor(xe);
      ye = bitFloor(ye);
      xc = xc.slice();

      // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.
      if (a = xe - ye) {
        if (a > 0) {
          ye = xe;
          t = yc;
        } else {
          a = -a;
          t = xc;
        }
        t.reverse();
        for (; a--; t.push(0));
        t.reverse();
      }
      a = xc.length;
      b = yc.length;

      // Point xc to the longer array, and b to the shorter length.
      if (a - b < 0) {
        t = yc;
        yc = xc;
        xc = t;
        b = a;
      }

      // Only start adding at yc.length - 1 as the further digits of xc can be ignored.
      for (a = 0; b;) {
        a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
        xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
      }
      if (a) {
        xc = [a].concat(xc);
        ++ye;
      }

      // No need to check for zero, as +x + +y != 0 && -x + -y != 0
      // ye = MAX_EXP + 1 possible
      return normalise(y, xc, ye);
    };

    /*
     * If sd is undefined or null or true or false, return the number of significant digits of
     * the value of this BigNumber, or null if the value of this BigNumber is Infinity or NaN.
     * If sd is true include integer-part trailing zeros in the count.
     *
     * Otherwise, if sd is a number, return a new BigNumber whose value is the value of this
     * BigNumber rounded to a maximum of sd significant digits using rounding mode rm, or
     * ROUNDING_MODE if rm is omitted.
     *
     * sd {number|boolean} number: significant digits: integer, 1 to MAX inclusive.
     *                     boolean: whether to count integer-part trailing zeros: true or false.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
     */
    P.precision = P.sd = function (sd, rm) {
      var c,
        n,
        v,
        x = this;
      if (sd != null && sd !== !!sd) {
        intCheck(sd, 1, MAX);
        if (rm == null) rm = ROUNDING_MODE;else intCheck(rm, 0, 8);
        return round(new BigNumber(x), sd, rm);
      }
      if (!(c = x.c)) return null;
      v = c.length - 1;
      n = v * LOG_BASE + 1;
      if (v = c[v]) {
        // Subtract the number of trailing zeros of the last element.
        for (; v % 10 == 0; v /= 10, n--);

        // Add the number of digits of the first element.
        for (v = c[0]; v >= 10; v /= 10, n++);
      }
      if (sd && x.e + 1 > n) n = x.e + 1;
      return n;
    };

    /*
     * Return a new BigNumber whose value is the value of this BigNumber shifted by k places
     * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.
     *
     * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {k}'
     */
    P.shiftedBy = function (k) {
      intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
      return this.times('1e' + k);
    };

    /*
     *  sqrt(-n) =  N
     *  sqrt(N) =  N
     *  sqrt(-I) =  N
     *  sqrt(I) =  I
     *  sqrt(0) =  0
     *  sqrt(-0) = -0
     *
     * Return a new BigNumber whose value is the square root of the value of this BigNumber,
     * rounded according to DECIMAL_PLACES and ROUNDING_MODE.
     */
    P.squareRoot = P.sqrt = function () {
      var m,
        n,
        r,
        rep,
        t,
        x = this,
        c = x.c,
        s = x.s,
        e = x.e,
        dp = DECIMAL_PLACES + 4,
        half = new BigNumber('0.5');

      // Negative/NaN/Infinity/zero?
      if (s !== 1 || !c || !c[0]) {
        return new BigNumber(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
      }

      // Initial estimate.
      s = Math.sqrt(+valueOf(x));

      // Math.sqrt underflow/overflow?
      // Pass x to Math.sqrt as integer, then adjust the exponent of the result.
      if (s == 0 || s == 1 / 0) {
        n = coeffToString(c);
        if ((n.length + e) % 2 == 0) n += '0';
        s = Math.sqrt(+n);
        e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);
        if (s == 1 / 0) {
          n = '5e' + e;
        } else {
          n = s.toExponential();
          n = n.slice(0, n.indexOf('e') + 1) + e;
        }
        r = new BigNumber(n);
      } else {
        r = new BigNumber(s + '');
      }

      // Check for zero.
      // r could be zero if MIN_EXP is changed after the this value was created.
      // This would cause a division by zero (x/t) and hence Infinity below, which would cause
      // coeffToString to throw.
      if (r.c[0]) {
        e = r.e;
        s = e + dp;
        if (s < 3) s = 0;

        // Newton-Raphson iteration.
        for (;;) {
          t = r;
          r = half.times(t.plus(div(x, t, dp, 1)));
          if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {
            // The exponent of r may here be one less than the final result exponent,
            // e.g 0.0009999 (e-4) --> 0.001 (e-3), so adjust s so the rounding digits
            // are indexed correctly.
            if (r.e < e) --s;
            n = n.slice(s - 3, s + 1);

            // The 4th rounding digit may be in error by -1 so if the 4 rounding digits
            // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the
            // iteration.
            if (n == '9999' || !rep && n == '4999') {
              // On the first iteration only, check to see if rounding up gives the
              // exact result as the nines may infinitely repeat.
              if (!rep) {
                round(t, t.e + DECIMAL_PLACES + 2, 0);
                if (t.times(t).eq(x)) {
                  r = t;
                  break;
                }
              }
              dp += 4;
              s += 4;
              rep = 1;
            } else {
              // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact
              // result. If not, then there are further digits and m will be truthy.
              if (!+n || !+n.slice(1) && n.charAt(0) == '5') {
                // Truncate to the first rounding digit.
                round(r, r.e + DECIMAL_PLACES + 2, 1);
                m = !r.times(r).eq(x);
              }
              break;
            }
          }
        }
      }
      return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
    };

    /*
     * Return a string representing the value of this BigNumber in exponential notation and
     * rounded using ROUNDING_MODE to dp fixed decimal places.
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */
    P.toExponential = function (dp, rm) {
      if (dp != null) {
        intCheck(dp, 0, MAX);
        dp++;
      }
      return format(this, dp, rm, 1);
    };

    /*
     * Return a string representing the value of this BigNumber in fixed-point notation rounding
     * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.
     *
     * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',
     * but e.g. (-0.00001).toFixed(0) is '-0'.
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     */
    P.toFixed = function (dp, rm) {
      if (dp != null) {
        intCheck(dp, 0, MAX);
        dp = dp + this.e + 1;
      }
      return format(this, dp, rm);
    };

    /*
     * Return a string representing the value of this BigNumber in fixed-point notation rounded
     * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties
     * of the format or FORMAT object (see BigNumber.set).
     *
     * The formatting object may contain some or all of the properties shown below.
     *
     * FORMAT = {
     *   prefix: '',
     *   groupSize: 3,
     *   secondaryGroupSize: 0,
     *   groupSeparator: ',',
     *   decimalSeparator: '.',
     *   fractionGroupSize: 0,
     *   fractionGroupSeparator: '\xA0',      // non-breaking space
     *   suffix: ''
     * };
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     * [format] {object} Formatting options. See FORMAT pbject above.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'
     * '[BigNumber Error] Argument not an object: {format}'
     */
    P.toFormat = function (dp, rm, format) {
      var str,
        x = this;
      if (format == null) {
        if (dp != null && rm && _typeof(rm) == 'object') {
          format = rm;
          rm = null;
        } else if (dp && _typeof(dp) == 'object') {
          format = dp;
          dp = rm = null;
        } else {
          format = FORMAT;
        }
      } else if (_typeof(format) != 'object') {
        throw Error(bignumberError + 'Argument not an object: ' + format);
      }
      str = x.toFixed(dp, rm);
      if (x.c) {
        var i,
          arr = str.split('.'),
          g1 = +format.groupSize,
          g2 = +format.secondaryGroupSize,
          groupSeparator = format.groupSeparator || '',
          intPart = arr[0],
          fractionPart = arr[1],
          isNeg = x.s < 0,
          intDigits = isNeg ? intPart.slice(1) : intPart,
          len = intDigits.length;
        if (g2) {
          i = g1;
          g1 = g2;
          g2 = i;
          len -= i;
        }
        if (g1 > 0 && len > 0) {
          i = len % g1 || g1;
          intPart = intDigits.substr(0, i);
          for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);
          if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);
          if (isNeg) intPart = '-' + intPart;
        }
        str = fractionPart ? intPart + (format.decimalSeparator || '') + ((g2 = +format.fractionGroupSize) ? fractionPart.replace(new RegExp('\\d{' + g2 + '}\\B', 'g'), '$&' + (format.fractionGroupSeparator || '')) : fractionPart) : intPart;
      }
      return (format.prefix || '') + str + (format.suffix || '');
    };

    /*
     * Return an array of two BigNumbers representing the value of this BigNumber as a simple
     * fraction with an integer numerator and an integer denominator.
     * The denominator will be a positive non-zero value less than or equal to the specified
     * maximum denominator. If a maximum denominator is not specified, the denominator will be
     * the lowest value necessary to represent the number exactly.
     *
     * [md] {number|string|BigNumber} Integer >= 1, or Infinity. The maximum denominator.
     *
     * '[BigNumber Error] Argument {not an integer|out of range} : {md}'
     */
    P.toFraction = function (md) {
      var d,
        d0,
        d1,
        d2,
        e,
        exp,
        n,
        n0,
        n1,
        q,
        r,
        s,
        x = this,
        xc = x.c;
      if (md != null) {
        n = new BigNumber(md);

        // Throw if md is less than one or is not an integer, unless it is Infinity.
        if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
          throw Error(bignumberError + 'Argument ' + (n.isInteger() ? 'out of range: ' : 'not an integer: ') + valueOf(n));
        }
      }
      if (!xc) return new BigNumber(x);
      d = new BigNumber(ONE);
      n1 = d0 = new BigNumber(ONE);
      d1 = n0 = new BigNumber(ONE);
      s = coeffToString(xc);

      // Determine initial denominator.
      // d is a power of 10 and the minimum max denominator that specifies the value exactly.
      e = d.e = s.length - x.e - 1;
      d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
      md = !md || n.comparedTo(d) > 0 ? e > 0 ? d : n1 : n;
      exp = MAX_EXP;
      MAX_EXP = 1 / 0;
      n = new BigNumber(s);

      // n0 = d1 = 0
      n0.c[0] = 0;
      for (;;) {
        q = div(n, d, 0, 1);
        d2 = d0.plus(q.times(d1));
        if (d2.comparedTo(md) == 1) break;
        d0 = d1;
        d1 = d2;
        n1 = n0.plus(q.times(d2 = n1));
        n0 = d2;
        d = n.minus(q.times(d2 = d));
        n = d2;
      }
      d2 = div(md.minus(d0), d1, 0, 1);
      n0 = n0.plus(d2.times(n1));
      d0 = d0.plus(d2.times(d1));
      n0.s = n1.s = x.s;
      e = e * 2;

      // Determine which fraction is closer to x, n0/d0 or n1/d1
      r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];
      MAX_EXP = exp;
      return r;
    };

    /*
     * Return the value of this BigNumber converted to a number primitive.
     */
    P.toNumber = function () {
      return +valueOf(this);
    };

    /*
     * Return a string representing the value of this BigNumber rounded to sd significant digits
     * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits
     * necessary to represent the integer part of the value in fixed-point notation, then use
     * exponential notation.
     *
     * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'
     */
    P.toPrecision = function (sd, rm) {
      if (sd != null) intCheck(sd, 1, MAX);
      return format(this, sd, rm, 2);
    };

    /*
     * Return a string representing the value of this BigNumber in base b, or base 10 if b is
     * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and
     * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent
     * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than
     * TO_EXP_NEG, return exponential notation.
     *
     * [b] {number} Integer, 2 to ALPHABET.length inclusive.
     *
     * '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'
     */
    P.toString = function (b) {
      var str,
        n = this,
        s = n.s,
        e = n.e;

      // Infinity or NaN?
      if (e === null) {
        if (s) {
          str = 'Infinity';
          if (s < 0) str = '-' + str;
        } else {
          str = 'NaN';
        }
      } else {
        if (b == null) {
          str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(coeffToString(n.c), e) : toFixedPoint(coeffToString(n.c), e, '0');
        } else if (b === 10 && alphabetHasNormalDecimalDigits) {
          n = round(new BigNumber(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
          str = toFixedPoint(coeffToString(n.c), n.e, '0');
        } else {
          intCheck(b, 2, ALPHABET.length, 'Base');
          str = convertBase(toFixedPoint(coeffToString(n.c), e, '0'), 10, b, s, true);
        }
        if (s < 0 && n.c[0]) str = '-' + str;
      }
      return str;
    };

    /*
     * Return as toString, but do not accept a base argument, and include the minus sign for
     * negative zero.
     */
    P.valueOf = P.toJSON = function () {
      return valueOf(this);
    };
    P._isBigNumber = true;
    if (configObject != null) BigNumber.set(configObject);
    return BigNumber;
  }

  // PRIVATE HELPER FUNCTIONS

  // These functions don't need access to variables,
  // e.g. DECIMAL_PLACES, in the scope of the `clone` function above.

  function bitFloor(n) {
    var i = n | 0;
    return n > 0 || n === i ? i : i - 1;
  }

  // Return a coefficient array as a string of base 10 digits.
  function coeffToString(a) {
    var s,
      z,
      i = 1,
      j = a.length,
      r = a[0] + '';
    for (; i < j;) {
      s = a[i++] + '';
      z = LOG_BASE - s.length;
      for (; z--; s = '0' + s);
      r += s;
    }

    // Determine trailing zeros.
    for (j = r.length; r.charCodeAt(--j) === 48;);
    return r.slice(0, j + 1 || 1);
  }

  // Compare the value of BigNumbers x and y.
  function compare(x, y) {
    var a,
      b,
      xc = x.c,
      yc = y.c,
      i = x.s,
      j = y.s,
      k = x.e,
      l = y.e;

    // Either NaN?
    if (!i || !j) return null;
    a = xc && !xc[0];
    b = yc && !yc[0];

    // Either zero?
    if (a || b) return a ? b ? 0 : -j : i;

    // Signs differ?
    if (i != j) return i;
    a = i < 0;
    b = k == l;

    // Either Infinity?
    if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;

    // Compare exponents.
    if (!b) return k > l ^ a ? 1 : -1;
    j = (k = xc.length) < (l = yc.length) ? k : l;

    // Compare digit by digit.
    for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;

    // Compare lengths.
    return k == l ? 0 : k > l ^ a ? 1 : -1;
  }

  /*
   * Check that n is a primitive number, an integer, and in range, otherwise throw.
   */
  function intCheck(n, min, max, name) {
    if (n < min || n > max || n !== mathfloor(n)) {
      throw Error(bignumberError + (name || 'Argument') + (typeof n == 'number' ? n < min || n > max ? ' out of range: ' : ' not an integer: ' : ' not a primitive number: ') + String(n));
    }
  }

  // Assumes finite n.
  function isOdd(n) {
    var k = n.c.length - 1;
    return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
  }
  function toExponential(str, e) {
    return (str.length > 1 ? str.charAt(0) + '.' + str.slice(1) : str) + (e < 0 ? 'e' : 'e+') + e;
  }
  function toFixedPoint(str, e, z) {
    var len, zs;

    // Negative exponent?
    if (e < 0) {
      // Prepend zeros.
      for (zs = z + '.'; ++e; zs += z);
      str = zs + str;

      // Positive exponent
    } else {
      len = str.length;

      // Append zeros.
      if (++e > len) {
        for (zs = z, e -= len; --e; zs += z);
        str += zs;
      } else if (e < len) {
        str = str.slice(0, e) + '.' + str.slice(e);
      }
    }
    return str;
  }

  // EXPORT

  BigNumber = clone();
  BigNumber['default'] = BigNumber.BigNumber = BigNumber;

  // AMD.
  if (typeof define == 'function' && define.amd) {
    define(function () {
      return BigNumber;
    });

    // Node.js and other environments that support module.exports.
  } else if (typeof module != 'undefined' && module.exports) {
    module.exports = BigNumber;

    // Browser.
  } else {
    if (!globalObject) {
      globalObject = typeof self != 'undefined' && self ? self : window;
    }
    globalObject.BigNumber = BigNumber;
  }
})(void 0);

},{}],334:[function(require,module,exports){
'use strict';

module.exports = require('./lib/api')(require('./lib/keccak'));

},{"./lib/api":335,"./lib/keccak":339}],335:[function(require,module,exports){
'use strict';

var createKeccak = require('./keccak');
var createShake = require('./shake');
module.exports = function (KeccakState) {
  var Keccak = createKeccak(KeccakState);
  var Shake = createShake(KeccakState);
  return function (algorithm, options) {
    var hash = typeof algorithm === 'string' ? algorithm.toLowerCase() : algorithm;
    switch (hash) {
      case 'keccak224':
        return new Keccak(1152, 448, null, 224, options);
      case 'keccak256':
        return new Keccak(1088, 512, null, 256, options);
      case 'keccak384':
        return new Keccak(832, 768, null, 384, options);
      case 'keccak512':
        return new Keccak(576, 1024, null, 512, options);
      case 'sha3-224':
        return new Keccak(1152, 448, 0x06, 224, options);
      case 'sha3-256':
        return new Keccak(1088, 512, 0x06, 256, options);
      case 'sha3-384':
        return new Keccak(832, 768, 0x06, 384, options);
      case 'sha3-512':
        return new Keccak(576, 1024, 0x06, 512, options);
      case 'shake128':
        return new Shake(1344, 256, 0x1f, options);
      case 'shake256':
        return new Shake(1088, 512, 0x1f, options);
      default:
        throw new Error('Invald algorithm: ' + algorithm);
    }
  };
};

},{"./keccak":336,"./shake":337}],336:[function(require,module,exports){
'use strict';

var Buffer = require('safe-buffer').Buffer;
var Transform = require('stream').Transform;
var inherits = require('inherits');
module.exports = function (KeccakState) {
  function Keccak(rate, capacity, delimitedSuffix, hashBitLength, options) {
    Transform.call(this, options);
    this._rate = rate;
    this._capacity = capacity;
    this._delimitedSuffix = delimitedSuffix;
    this._hashBitLength = hashBitLength;
    this._options = options;
    this._state = new KeccakState();
    this._state.initialize(rate, capacity);
    this._finalized = false;
  }
  inherits(Keccak, Transform);
  Keccak.prototype._transform = function (chunk, encoding, callback) {
    var error = null;
    try {
      this.update(chunk, encoding);
    } catch (err) {
      error = err;
    }
    callback(error);
  };
  Keccak.prototype._flush = function (callback) {
    var error = null;
    try {
      this.push(this.digest());
    } catch (err) {
      error = err;
    }
    callback(error);
  };
  Keccak.prototype.update = function (data, encoding) {
    if (!Buffer.isBuffer(data) && typeof data !== 'string') throw new TypeError('Data must be a string or a buffer');
    if (this._finalized) throw new Error('Digest already called');
    if (!Buffer.isBuffer(data)) data = Buffer.from(data, encoding);
    this._state.absorb(data);
    return this;
  };
  Keccak.prototype.digest = function (encoding) {
    if (this._finalized) throw new Error('Digest already called');
    this._finalized = true;
    if (this._delimitedSuffix) this._state.absorbLastFewBits(this._delimitedSuffix);
    var digest = this._state.squeeze(this._hashBitLength / 8);
    if (encoding !== undefined) digest = digest.toString(encoding);
    this._resetState();
    return digest;
  };

  // remove result from memory
  Keccak.prototype._resetState = function () {
    this._state.initialize(this._rate, this._capacity);
    return this;
  };

  // because sometimes we need hash right now and little later
  Keccak.prototype._clone = function () {
    var clone = new Keccak(this._rate, this._capacity, this._delimitedSuffix, this._hashBitLength, this._options);
    this._state.copy(clone._state);
    clone._finalized = this._finalized;
    return clone;
  };
  return Keccak;
};

},{"inherits":327,"safe-buffer":384,"stream":401}],337:[function(require,module,exports){
'use strict';

var Buffer = require('safe-buffer').Buffer;
var Transform = require('stream').Transform;
var inherits = require('inherits');
module.exports = function (KeccakState) {
  function Shake(rate, capacity, delimitedSuffix, options) {
    Transform.call(this, options);
    this._rate = rate;
    this._capacity = capacity;
    this._delimitedSuffix = delimitedSuffix;
    this._options = options;
    this._state = new KeccakState();
    this._state.initialize(rate, capacity);
    this._finalized = false;
  }
  inherits(Shake, Transform);
  Shake.prototype._transform = function (chunk, encoding, callback) {
    var error = null;
    try {
      this.update(chunk, encoding);
    } catch (err) {
      error = err;
    }
    callback(error);
  };
  Shake.prototype._flush = function () {};
  Shake.prototype._read = function (size) {
    this.push(this.squeeze(size));
  };
  Shake.prototype.update = function (data, encoding) {
    if (!Buffer.isBuffer(data) && typeof data !== 'string') throw new TypeError('Data must be a string or a buffer');
    if (this._finalized) throw new Error('Squeeze already called');
    if (!Buffer.isBuffer(data)) data = Buffer.from(data, encoding);
    this._state.absorb(data);
    return this;
  };
  Shake.prototype.squeeze = function (dataByteLength, encoding) {
    if (!this._finalized) {
      this._finalized = true;
      this._state.absorbLastFewBits(this._delimitedSuffix);
    }
    var data = this._state.squeeze(dataByteLength);
    if (encoding !== undefined) data = data.toString(encoding);
    return data;
  };
  Shake.prototype._resetState = function () {
    this._state.initialize(this._rate, this._capacity);
    return this;
  };
  Shake.prototype._clone = function () {
    var clone = new Shake(this._rate, this._capacity, this._delimitedSuffix, this._options);
    this._state.copy(clone._state);
    clone._finalized = this._finalized;
    return clone;
  };
  return Shake;
};

},{"inherits":327,"safe-buffer":384,"stream":401}],338:[function(require,module,exports){
'use strict';

var P1600_ROUND_CONSTANTS = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648];
exports.p1600 = function (s) {
  for (var round = 0; round < 24; ++round) {
    // theta
    var lo0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];
    var hi0 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];
    var lo1 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];
    var hi1 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];
    var lo2 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];
    var hi2 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];
    var lo3 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];
    var hi3 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];
    var lo4 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];
    var hi4 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];
    var lo = lo4 ^ (lo1 << 1 | hi1 >>> 31);
    var hi = hi4 ^ (hi1 << 1 | lo1 >>> 31);
    var t1slo0 = s[0] ^ lo;
    var t1shi0 = s[1] ^ hi;
    var t1slo5 = s[10] ^ lo;
    var t1shi5 = s[11] ^ hi;
    var t1slo10 = s[20] ^ lo;
    var t1shi10 = s[21] ^ hi;
    var t1slo15 = s[30] ^ lo;
    var t1shi15 = s[31] ^ hi;
    var t1slo20 = s[40] ^ lo;
    var t1shi20 = s[41] ^ hi;
    lo = lo0 ^ (lo2 << 1 | hi2 >>> 31);
    hi = hi0 ^ (hi2 << 1 | lo2 >>> 31);
    var t1slo1 = s[2] ^ lo;
    var t1shi1 = s[3] ^ hi;
    var t1slo6 = s[12] ^ lo;
    var t1shi6 = s[13] ^ hi;
    var t1slo11 = s[22] ^ lo;
    var t1shi11 = s[23] ^ hi;
    var t1slo16 = s[32] ^ lo;
    var t1shi16 = s[33] ^ hi;
    var t1slo21 = s[42] ^ lo;
    var t1shi21 = s[43] ^ hi;
    lo = lo1 ^ (lo3 << 1 | hi3 >>> 31);
    hi = hi1 ^ (hi3 << 1 | lo3 >>> 31);
    var t1slo2 = s[4] ^ lo;
    var t1shi2 = s[5] ^ hi;
    var t1slo7 = s[14] ^ lo;
    var t1shi7 = s[15] ^ hi;
    var t1slo12 = s[24] ^ lo;
    var t1shi12 = s[25] ^ hi;
    var t1slo17 = s[34] ^ lo;
    var t1shi17 = s[35] ^ hi;
    var t1slo22 = s[44] ^ lo;
    var t1shi22 = s[45] ^ hi;
    lo = lo2 ^ (lo4 << 1 | hi4 >>> 31);
    hi = hi2 ^ (hi4 << 1 | lo4 >>> 31);
    var t1slo3 = s[6] ^ lo;
    var t1shi3 = s[7] ^ hi;
    var t1slo8 = s[16] ^ lo;
    var t1shi8 = s[17] ^ hi;
    var t1slo13 = s[26] ^ lo;
    var t1shi13 = s[27] ^ hi;
    var t1slo18 = s[36] ^ lo;
    var t1shi18 = s[37] ^ hi;
    var t1slo23 = s[46] ^ lo;
    var t1shi23 = s[47] ^ hi;
    lo = lo3 ^ (lo0 << 1 | hi0 >>> 31);
    hi = hi3 ^ (hi0 << 1 | lo0 >>> 31);
    var t1slo4 = s[8] ^ lo;
    var t1shi4 = s[9] ^ hi;
    var t1slo9 = s[18] ^ lo;
    var t1shi9 = s[19] ^ hi;
    var t1slo14 = s[28] ^ lo;
    var t1shi14 = s[29] ^ hi;
    var t1slo19 = s[38] ^ lo;
    var t1shi19 = s[39] ^ hi;
    var t1slo24 = s[48] ^ lo;
    var t1shi24 = s[49] ^ hi;

    // rho & pi
    var t2slo0 = t1slo0;
    var t2shi0 = t1shi0;
    var t2slo16 = t1shi5 << 4 | t1slo5 >>> 28;
    var t2shi16 = t1slo5 << 4 | t1shi5 >>> 28;
    var t2slo7 = t1slo10 << 3 | t1shi10 >>> 29;
    var t2shi7 = t1shi10 << 3 | t1slo10 >>> 29;
    var t2slo23 = t1shi15 << 9 | t1slo15 >>> 23;
    var t2shi23 = t1slo15 << 9 | t1shi15 >>> 23;
    var t2slo14 = t1slo20 << 18 | t1shi20 >>> 14;
    var t2shi14 = t1shi20 << 18 | t1slo20 >>> 14;
    var t2slo10 = t1slo1 << 1 | t1shi1 >>> 31;
    var t2shi10 = t1shi1 << 1 | t1slo1 >>> 31;
    var t2slo1 = t1shi6 << 12 | t1slo6 >>> 20;
    var t2shi1 = t1slo6 << 12 | t1shi6 >>> 20;
    var t2slo17 = t1slo11 << 10 | t1shi11 >>> 22;
    var t2shi17 = t1shi11 << 10 | t1slo11 >>> 22;
    var t2slo8 = t1shi16 << 13 | t1slo16 >>> 19;
    var t2shi8 = t1slo16 << 13 | t1shi16 >>> 19;
    var t2slo24 = t1slo21 << 2 | t1shi21 >>> 30;
    var t2shi24 = t1shi21 << 2 | t1slo21 >>> 30;
    var t2slo20 = t1shi2 << 30 | t1slo2 >>> 2;
    var t2shi20 = t1slo2 << 30 | t1shi2 >>> 2;
    var t2slo11 = t1slo7 << 6 | t1shi7 >>> 26;
    var t2shi11 = t1shi7 << 6 | t1slo7 >>> 26;
    var t2slo2 = t1shi12 << 11 | t1slo12 >>> 21;
    var t2shi2 = t1slo12 << 11 | t1shi12 >>> 21;
    var t2slo18 = t1slo17 << 15 | t1shi17 >>> 17;
    var t2shi18 = t1shi17 << 15 | t1slo17 >>> 17;
    var t2slo9 = t1shi22 << 29 | t1slo22 >>> 3;
    var t2shi9 = t1slo22 << 29 | t1shi22 >>> 3;
    var t2slo5 = t1slo3 << 28 | t1shi3 >>> 4;
    var t2shi5 = t1shi3 << 28 | t1slo3 >>> 4;
    var t2slo21 = t1shi8 << 23 | t1slo8 >>> 9;
    var t2shi21 = t1slo8 << 23 | t1shi8 >>> 9;
    var t2slo12 = t1slo13 << 25 | t1shi13 >>> 7;
    var t2shi12 = t1shi13 << 25 | t1slo13 >>> 7;
    var t2slo3 = t1slo18 << 21 | t1shi18 >>> 11;
    var t2shi3 = t1shi18 << 21 | t1slo18 >>> 11;
    var t2slo19 = t1shi23 << 24 | t1slo23 >>> 8;
    var t2shi19 = t1slo23 << 24 | t1shi23 >>> 8;
    var t2slo15 = t1slo4 << 27 | t1shi4 >>> 5;
    var t2shi15 = t1shi4 << 27 | t1slo4 >>> 5;
    var t2slo6 = t1slo9 << 20 | t1shi9 >>> 12;
    var t2shi6 = t1shi9 << 20 | t1slo9 >>> 12;
    var t2slo22 = t1shi14 << 7 | t1slo14 >>> 25;
    var t2shi22 = t1slo14 << 7 | t1shi14 >>> 25;
    var t2slo13 = t1slo19 << 8 | t1shi19 >>> 24;
    var t2shi13 = t1shi19 << 8 | t1slo19 >>> 24;
    var t2slo4 = t1slo24 << 14 | t1shi24 >>> 18;
    var t2shi4 = t1shi24 << 14 | t1slo24 >>> 18;

    // chi
    s[0] = t2slo0 ^ ~t2slo1 & t2slo2;
    s[1] = t2shi0 ^ ~t2shi1 & t2shi2;
    s[10] = t2slo5 ^ ~t2slo6 & t2slo7;
    s[11] = t2shi5 ^ ~t2shi6 & t2shi7;
    s[20] = t2slo10 ^ ~t2slo11 & t2slo12;
    s[21] = t2shi10 ^ ~t2shi11 & t2shi12;
    s[30] = t2slo15 ^ ~t2slo16 & t2slo17;
    s[31] = t2shi15 ^ ~t2shi16 & t2shi17;
    s[40] = t2slo20 ^ ~t2slo21 & t2slo22;
    s[41] = t2shi20 ^ ~t2shi21 & t2shi22;
    s[2] = t2slo1 ^ ~t2slo2 & t2slo3;
    s[3] = t2shi1 ^ ~t2shi2 & t2shi3;
    s[12] = t2slo6 ^ ~t2slo7 & t2slo8;
    s[13] = t2shi6 ^ ~t2shi7 & t2shi8;
    s[22] = t2slo11 ^ ~t2slo12 & t2slo13;
    s[23] = t2shi11 ^ ~t2shi12 & t2shi13;
    s[32] = t2slo16 ^ ~t2slo17 & t2slo18;
    s[33] = t2shi16 ^ ~t2shi17 & t2shi18;
    s[42] = t2slo21 ^ ~t2slo22 & t2slo23;
    s[43] = t2shi21 ^ ~t2shi22 & t2shi23;
    s[4] = t2slo2 ^ ~t2slo3 & t2slo4;
    s[5] = t2shi2 ^ ~t2shi3 & t2shi4;
    s[14] = t2slo7 ^ ~t2slo8 & t2slo9;
    s[15] = t2shi7 ^ ~t2shi8 & t2shi9;
    s[24] = t2slo12 ^ ~t2slo13 & t2slo14;
    s[25] = t2shi12 ^ ~t2shi13 & t2shi14;
    s[34] = t2slo17 ^ ~t2slo18 & t2slo19;
    s[35] = t2shi17 ^ ~t2shi18 & t2shi19;
    s[44] = t2slo22 ^ ~t2slo23 & t2slo24;
    s[45] = t2shi22 ^ ~t2shi23 & t2shi24;
    s[6] = t2slo3 ^ ~t2slo4 & t2slo0;
    s[7] = t2shi3 ^ ~t2shi4 & t2shi0;
    s[16] = t2slo8 ^ ~t2slo9 & t2slo5;
    s[17] = t2shi8 ^ ~t2shi9 & t2shi5;
    s[26] = t2slo13 ^ ~t2slo14 & t2slo10;
    s[27] = t2shi13 ^ ~t2shi14 & t2shi10;
    s[36] = t2slo18 ^ ~t2slo19 & t2slo15;
    s[37] = t2shi18 ^ ~t2shi19 & t2shi15;
    s[46] = t2slo23 ^ ~t2slo24 & t2slo20;
    s[47] = t2shi23 ^ ~t2shi24 & t2shi20;
    s[8] = t2slo4 ^ ~t2slo0 & t2slo1;
    s[9] = t2shi4 ^ ~t2shi0 & t2shi1;
    s[18] = t2slo9 ^ ~t2slo5 & t2slo6;
    s[19] = t2shi9 ^ ~t2shi5 & t2shi6;
    s[28] = t2slo14 ^ ~t2slo10 & t2slo11;
    s[29] = t2shi14 ^ ~t2shi10 & t2shi11;
    s[38] = t2slo19 ^ ~t2slo15 & t2slo16;
    s[39] = t2shi19 ^ ~t2shi15 & t2shi16;
    s[48] = t2slo24 ^ ~t2slo20 & t2slo21;
    s[49] = t2shi24 ^ ~t2shi20 & t2shi21;

    // iota
    s[0] ^= P1600_ROUND_CONSTANTS[round * 2];
    s[1] ^= P1600_ROUND_CONSTANTS[round * 2 + 1];
  }
};

},{}],339:[function(require,module,exports){
'use strict';

var Buffer = require('safe-buffer').Buffer;
var keccakState = require('./keccak-state-unroll');
function Keccak() {
  // much faster than `new Array(50)`
  this.state = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  this.blockSize = null;
  this.count = 0;
  this.squeezing = false;
}
Keccak.prototype.initialize = function (rate, capacity) {
  for (var i = 0; i < 50; ++i) this.state[i] = 0;
  this.blockSize = rate / 8;
  this.count = 0;
  this.squeezing = false;
};
Keccak.prototype.absorb = function (data) {
  for (var i = 0; i < data.length; ++i) {
    this.state[~~(this.count / 4)] ^= data[i] << 8 * (this.count % 4);
    this.count += 1;
    if (this.count === this.blockSize) {
      keccakState.p1600(this.state);
      this.count = 0;
    }
  }
};
Keccak.prototype.absorbLastFewBits = function (bits) {
  this.state[~~(this.count / 4)] ^= bits << 8 * (this.count % 4);
  if ((bits & 0x80) !== 0 && this.count === this.blockSize - 1) keccakState.p1600(this.state);
  this.state[~~((this.blockSize - 1) / 4)] ^= 0x80 << 8 * ((this.blockSize - 1) % 4);
  keccakState.p1600(this.state);
  this.count = 0;
  this.squeezing = true;
};
Keccak.prototype.squeeze = function (length) {
  if (!this.squeezing) this.absorbLastFewBits(0x01);
  var output = Buffer.alloc(length);
  for (var i = 0; i < length; ++i) {
    output[i] = this.state[~~(this.count / 4)] >>> 8 * (this.count % 4) & 0xff;
    this.count += 1;
    if (this.count === this.blockSize) {
      keccakState.p1600(this.state);
      this.count = 0;
    }
  }
  return output;
};
Keccak.prototype.copy = function (dest) {
  for (var i = 0; i < 50; ++i) dest.state[i] = this.state[i];
  dest.blockSize = this.blockSize;
  dest.count = this.count;
  dest.squeezing = this.squeezing;
};
module.exports = Keccak;

},{"./keccak-state-unroll":338,"safe-buffer":384}],340:[function(require,module,exports){
'use strict';

var inherits = require('inherits');
var HashBase = require('hash-base');
var Buffer = require('safe-buffer').Buffer;
var ARRAY16 = new Array(16);
function MD5() {
  HashBase.call(this, 64);

  // state
  this._a = 0x67452301;
  this._b = 0xefcdab89;
  this._c = 0x98badcfe;
  this._d = 0x10325476;
}
inherits(MD5, HashBase);
MD5.prototype._update = function () {
  var M = ARRAY16;
  for (var i = 0; i < 16; ++i) M[i] = this._block.readInt32LE(i * 4);
  var a = this._a;
  var b = this._b;
  var c = this._c;
  var d = this._d;
  a = fnF(a, b, c, d, M[0], 0xd76aa478, 7);
  d = fnF(d, a, b, c, M[1], 0xe8c7b756, 12);
  c = fnF(c, d, a, b, M[2], 0x242070db, 17);
  b = fnF(b, c, d, a, M[3], 0xc1bdceee, 22);
  a = fnF(a, b, c, d, M[4], 0xf57c0faf, 7);
  d = fnF(d, a, b, c, M[5], 0x4787c62a, 12);
  c = fnF(c, d, a, b, M[6], 0xa8304613, 17);
  b = fnF(b, c, d, a, M[7], 0xfd469501, 22);
  a = fnF(a, b, c, d, M[8], 0x698098d8, 7);
  d = fnF(d, a, b, c, M[9], 0x8b44f7af, 12);
  c = fnF(c, d, a, b, M[10], 0xffff5bb1, 17);
  b = fnF(b, c, d, a, M[11], 0x895cd7be, 22);
  a = fnF(a, b, c, d, M[12], 0x6b901122, 7);
  d = fnF(d, a, b, c, M[13], 0xfd987193, 12);
  c = fnF(c, d, a, b, M[14], 0xa679438e, 17);
  b = fnF(b, c, d, a, M[15], 0x49b40821, 22);
  a = fnG(a, b, c, d, M[1], 0xf61e2562, 5);
  d = fnG(d, a, b, c, M[6], 0xc040b340, 9);
  c = fnG(c, d, a, b, M[11], 0x265e5a51, 14);
  b = fnG(b, c, d, a, M[0], 0xe9b6c7aa, 20);
  a = fnG(a, b, c, d, M[5], 0xd62f105d, 5);
  d = fnG(d, a, b, c, M[10], 0x02441453, 9);
  c = fnG(c, d, a, b, M[15], 0xd8a1e681, 14);
  b = fnG(b, c, d, a, M[4], 0xe7d3fbc8, 20);
  a = fnG(a, b, c, d, M[9], 0x21e1cde6, 5);
  d = fnG(d, a, b, c, M[14], 0xc33707d6, 9);
  c = fnG(c, d, a, b, M[3], 0xf4d50d87, 14);
  b = fnG(b, c, d, a, M[8], 0x455a14ed, 20);
  a = fnG(a, b, c, d, M[13], 0xa9e3e905, 5);
  d = fnG(d, a, b, c, M[2], 0xfcefa3f8, 9);
  c = fnG(c, d, a, b, M[7], 0x676f02d9, 14);
  b = fnG(b, c, d, a, M[12], 0x8d2a4c8a, 20);
  a = fnH(a, b, c, d, M[5], 0xfffa3942, 4);
  d = fnH(d, a, b, c, M[8], 0x8771f681, 11);
  c = fnH(c, d, a, b, M[11], 0x6d9d6122, 16);
  b = fnH(b, c, d, a, M[14], 0xfde5380c, 23);
  a = fnH(a, b, c, d, M[1], 0xa4beea44, 4);
  d = fnH(d, a, b, c, M[4], 0x4bdecfa9, 11);
  c = fnH(c, d, a, b, M[7], 0xf6bb4b60, 16);
  b = fnH(b, c, d, a, M[10], 0xbebfbc70, 23);
  a = fnH(a, b, c, d, M[13], 0x289b7ec6, 4);
  d = fnH(d, a, b, c, M[0], 0xeaa127fa, 11);
  c = fnH(c, d, a, b, M[3], 0xd4ef3085, 16);
  b = fnH(b, c, d, a, M[6], 0x04881d05, 23);
  a = fnH(a, b, c, d, M[9], 0xd9d4d039, 4);
  d = fnH(d, a, b, c, M[12], 0xe6db99e5, 11);
  c = fnH(c, d, a, b, M[15], 0x1fa27cf8, 16);
  b = fnH(b, c, d, a, M[2], 0xc4ac5665, 23);
  a = fnI(a, b, c, d, M[0], 0xf4292244, 6);
  d = fnI(d, a, b, c, M[7], 0x432aff97, 10);
  c = fnI(c, d, a, b, M[14], 0xab9423a7, 15);
  b = fnI(b, c, d, a, M[5], 0xfc93a039, 21);
  a = fnI(a, b, c, d, M[12], 0x655b59c3, 6);
  d = fnI(d, a, b, c, M[3], 0x8f0ccc92, 10);
  c = fnI(c, d, a, b, M[10], 0xffeff47d, 15);
  b = fnI(b, c, d, a, M[1], 0x85845dd1, 21);
  a = fnI(a, b, c, d, M[8], 0x6fa87e4f, 6);
  d = fnI(d, a, b, c, M[15], 0xfe2ce6e0, 10);
  c = fnI(c, d, a, b, M[6], 0xa3014314, 15);
  b = fnI(b, c, d, a, M[13], 0x4e0811a1, 21);
  a = fnI(a, b, c, d, M[4], 0xf7537e82, 6);
  d = fnI(d, a, b, c, M[11], 0xbd3af235, 10);
  c = fnI(c, d, a, b, M[2], 0x2ad7d2bb, 15);
  b = fnI(b, c, d, a, M[9], 0xeb86d391, 21);
  this._a = this._a + a | 0;
  this._b = this._b + b | 0;
  this._c = this._c + c | 0;
  this._d = this._d + d | 0;
};
MD5.prototype._digest = function () {
  // create padding and handle blocks
  this._block[this._blockOffset++] = 0x80;
  if (this._blockOffset > 56) {
    this._block.fill(0, this._blockOffset, 64);
    this._update();
    this._blockOffset = 0;
  }
  this._block.fill(0, this._blockOffset, 56);
  this._block.writeUInt32LE(this._length[0], 56);
  this._block.writeUInt32LE(this._length[1], 60);
  this._update();

  // produce result
  var buffer = Buffer.allocUnsafe(16);
  buffer.writeInt32LE(this._a, 0);
  buffer.writeInt32LE(this._b, 4);
  buffer.writeInt32LE(this._c, 8);
  buffer.writeInt32LE(this._d, 12);
  return buffer;
};
function rotl(x, n) {
  return x << n | x >>> 32 - n;
}
function fnF(a, b, c, d, m, k, s) {
  return rotl(a + (b & c | ~b & d) + m + k | 0, s) + b | 0;
}
function fnG(a, b, c, d, m, k, s) {
  return rotl(a + (b & d | c & ~d) + m + k | 0, s) + b | 0;
}
function fnH(a, b, c, d, m, k, s) {
  return rotl(a + (b ^ c ^ d) + m + k | 0, s) + b | 0;
}
function fnI(a, b, c, d, m, k, s) {
  return rotl(a + (c ^ (b | ~d)) + m + k | 0, s) + b | 0;
}
module.exports = MD5;

},{"hash-base":311,"inherits":327,"safe-buffer":384}],341:[function(require,module,exports){
"use strict";

var bn = require('bn.js');
var brorand = require('brorand');
function MillerRabin(rand) {
  this.rand = rand || new brorand.Rand();
}
module.exports = MillerRabin;
MillerRabin.create = function create(rand) {
  return new MillerRabin(rand);
};
MillerRabin.prototype._randbelow = function _randbelow(n) {
  var len = n.bitLength();
  var min_bytes = Math.ceil(len / 8);

  // Generage random bytes until a number less than n is found.
  // This ensures that 0..n-1 have an equal probability of being selected.
  do var a = new bn(this.rand.generate(min_bytes)); while (a.cmp(n) >= 0);
  return a;
};
MillerRabin.prototype._randrange = function _randrange(start, stop) {
  // Generate a random number greater than or equal to start and less than stop.
  var size = stop.sub(start);
  return start.add(this._randbelow(size));
};
MillerRabin.prototype.test = function test(n, k, cb) {
  var len = n.bitLength();
  var red = bn.mont(n);
  var rone = new bn(1).toRed(red);
  if (!k) k = Math.max(1, len / 48 | 0);

  // Find d and s, (n - 1) = (2 ^ s) * d;
  var n1 = n.subn(1);
  for (var s = 0; !n1.testn(s); s++) {}
  var d = n.shrn(s);
  var rn1 = n1.toRed(red);
  var prime = true;
  for (; k > 0; k--) {
    var a = this._randrange(new bn(2), n1);
    if (cb) cb(a);
    var x = a.toRed(red).redPow(d);
    if (x.cmp(rone) === 0 || x.cmp(rn1) === 0) continue;
    for (var i = 1; i < s; i++) {
      x = x.redSqr();
      if (x.cmp(rone) === 0) return false;
      if (x.cmp(rn1) === 0) break;
    }
    if (i === s) return false;
  }
  return prime;
};
MillerRabin.prototype.getDivisor = function getDivisor(n, k) {
  var len = n.bitLength();
  var red = bn.mont(n);
  var rone = new bn(1).toRed(red);
  if (!k) k = Math.max(1, len / 48 | 0);

  // Find d and s, (n - 1) = (2 ^ s) * d;
  var n1 = n.subn(1);
  for (var s = 0; !n1.testn(s); s++) {}
  var d = n.shrn(s);
  var rn1 = n1.toRed(red);
  for (; k > 0; k--) {
    var a = this._randrange(new bn(2), n1);
    var g = n.gcd(a);
    if (g.cmpn(1) !== 0) return g;
    var x = a.toRed(red).redPow(d);
    if (x.cmp(rone) === 0 || x.cmp(rn1) === 0) continue;
    for (var i = 1; i < s; i++) {
      x = x.redSqr();
      if (x.cmp(rone) === 0) return x.fromRed().subn(1).gcd(n);
      if (x.cmp(rn1) === 0) break;
    }
    if (i === s) {
      x = x.redSqr();
      return x.fromRed().subn(1).gcd(n);
    }
  }
  return false;
};

},{"bn.js":103,"brorand":104}],342:[function(require,module,exports){
"use strict";

module.exports = assert;
function assert(val, msg) {
  if (!val) throw new Error(msg || 'Assertion failed');
}
assert.equal = function assertEqual(l, r, msg) {
  if (l != r) throw new Error(msg || 'Assertion failed: ' + l + ' != ' + r);
};

},{}],343:[function(require,module,exports){
'use strict';

var utils = exports;
function toArray(msg, enc) {
  if (Array.isArray(msg)) return msg.slice();
  if (!msg) return [];
  var res = [];
  if (typeof msg !== 'string') {
    for (var i = 0; i < msg.length; i++) res[i] = msg[i] | 0;
    return res;
  }
  if (enc === 'hex') {
    msg = msg.replace(/[^a-z0-9]+/ig, '');
    if (msg.length % 2 !== 0) msg = '0' + msg;
    for (var i = 0; i < msg.length; i += 2) res.push(parseInt(msg[i] + msg[i + 1], 16));
  } else {
    for (var i = 0; i < msg.length; i++) {
      var c = msg.charCodeAt(i);
      var hi = c >> 8;
      var lo = c & 0xff;
      if (hi) res.push(hi, lo);else res.push(lo);
    }
  }
  return res;
}
utils.toArray = toArray;
function zero2(word) {
  if (word.length === 1) return '0' + word;else return word;
}
utils.zero2 = zero2;
function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++) res += zero2(msg[i].toString(16));
  return res;
}
utils.toHex = toHex;
utils.encode = function encode(arr, enc) {
  if (enc === 'hex') return toHex(arr);else return arr;
};

},{}],344:[function(require,module,exports){
'use strict';

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var keysShim;
if (!Object.keys) {
  // modified from https://github.com/es-shims/es5-shim
  var has = Object.prototype.hasOwnProperty;
  var toStr = Object.prototype.toString;
  var isArgs = require('./isArguments'); // eslint-disable-line global-require
  var isEnumerable = Object.prototype.propertyIsEnumerable;
  var hasDontEnumBug = !isEnumerable.call({
    toString: null
  }, 'toString');
  var hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');
  var dontEnums = ['toString', 'toLocaleString', 'valueOf', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'constructor'];
  var equalsConstructorPrototype = function equalsConstructorPrototype(o) {
    var ctor = o.constructor;
    return ctor && ctor.prototype === o;
  };
  var excludedKeys = {
    $applicationCache: true,
    $console: true,
    $external: true,
    $frame: true,
    $frameElement: true,
    $frames: true,
    $innerHeight: true,
    $innerWidth: true,
    $onmozfullscreenchange: true,
    $onmozfullscreenerror: true,
    $outerHeight: true,
    $outerWidth: true,
    $pageXOffset: true,
    $pageYOffset: true,
    $parent: true,
    $scrollLeft: true,
    $scrollTop: true,
    $scrollX: true,
    $scrollY: true,
    $self: true,
    $webkitIndexedDB: true,
    $webkitStorageInfo: true,
    $window: true
  };
  var hasAutomationEqualityBug = function () {
    /* global window */
    if (typeof window === 'undefined') {
      return false;
    }
    for (var k in window) {
      try {
        if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && _typeof(window[k]) === 'object') {
          try {
            equalsConstructorPrototype(window[k]);
          } catch (e) {
            return true;
          }
        }
      } catch (e) {
        return true;
      }
    }
    return false;
  }();
  var equalsConstructorPrototypeIfNotBuggy = function equalsConstructorPrototypeIfNotBuggy(o) {
    /* global window */
    if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
      return equalsConstructorPrototype(o);
    }
    try {
      return equalsConstructorPrototype(o);
    } catch (e) {
      return false;
    }
  };
  keysShim = function keys(object) {
    var isObject = object !== null && _typeof(object) === 'object';
    var isFunction = toStr.call(object) === '[object Function]';
    var isArguments = isArgs(object);
    var isString = isObject && toStr.call(object) === '[object String]';
    var theKeys = [];
    if (!isObject && !isFunction && !isArguments) {
      throw new TypeError('Object.keys called on a non-object');
    }
    var skipProto = hasProtoEnumBug && isFunction;
    if (isString && object.length > 0 && !has.call(object, 0)) {
      for (var i = 0; i < object.length; ++i) {
        theKeys.push(String(i));
      }
    }
    if (isArguments && object.length > 0) {
      for (var j = 0; j < object.length; ++j) {
        theKeys.push(String(j));
      }
    } else {
      for (var name in object) {
        if (!(skipProto && name === 'prototype') && has.call(object, name)) {
          theKeys.push(String(name));
        }
      }
    }
    if (hasDontEnumBug) {
      var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
      for (var k = 0; k < dontEnums.length; ++k) {
        if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
          theKeys.push(dontEnums[k]);
        }
      }
    }
    return theKeys;
  };
}
module.exports = keysShim;

},{"./isArguments":346}],345:[function(require,module,exports){
'use strict';

var slice = Array.prototype.slice;
var isArgs = require('./isArguments');
var origKeys = Object.keys;
var keysShim = origKeys ? function keys(o) {
  return origKeys(o);
} : require('./implementation');
var originalKeys = Object.keys;
keysShim.shim = function shimObjectKeys() {
  if (Object.keys) {
    var keysWorksWithArguments = function () {
      // Safari 5.0 bug
      var args = Object.keys(arguments);
      return args && args.length === arguments.length;
    }(1, 2);
    if (!keysWorksWithArguments) {
      Object.keys = function keys(object) {
        // eslint-disable-line func-name-matching
        if (isArgs(object)) {
          return originalKeys(slice.call(object));
        }
        return originalKeys(object);
      };
    }
  } else {
    Object.keys = keysShim;
  }
  return Object.keys || keysShim;
};
module.exports = keysShim;

},{"./implementation":344,"./isArguments":346}],346:[function(require,module,exports){
'use strict';

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var toStr = Object.prototype.toString;
module.exports = function isArguments(value) {
  var str = toStr.call(value);
  var isArgs = str === '[object Arguments]';
  if (!isArgs) {
    isArgs = str !== '[object Array]' && value !== null && _typeof(value) === 'object' && typeof value.length === 'number' && value.length >= 0 && toStr.call(value.callee) === '[object Function]';
  }
  return isArgs;
};

},{}],347:[function(require,module,exports){
'use strict';

// modified from https://github.com/es-shims/es6-shim
var objectKeys = require('object-keys');
var hasSymbols = require('has-symbols/shams')();
var callBound = require('call-bind/callBound');
var toObject = Object;
var $push = callBound('Array.prototype.push');
var $propIsEnumerable = callBound('Object.prototype.propertyIsEnumerable');
var originalGetSymbols = hasSymbols ? Object.getOwnPropertySymbols : null;

// eslint-disable-next-line no-unused-vars
module.exports = function assign(target, source1) {
  if (target == null) {
    throw new TypeError('target must be an object');
  }
  var to = toObject(target); // step 1
  if (arguments.length === 1) {
    return to; // step 2
  }
  for (var s = 1; s < arguments.length; ++s) {
    var from = toObject(arguments[s]); // step 3.a.i

    // step 3.a.ii:
    var keys = objectKeys(from);
    var getSymbols = hasSymbols && (Object.getOwnPropertySymbols || originalGetSymbols);
    if (getSymbols) {
      var syms = getSymbols(from);
      for (var j = 0; j < syms.length; ++j) {
        var key = syms[j];
        if ($propIsEnumerable(from, key)) {
          $push(keys, key);
        }
      }
    }

    // step 3.a.iii:
    for (var i = 0; i < keys.length; ++i) {
      var nextKey = keys[i];
      if ($propIsEnumerable(from, nextKey)) {
        // step 3.a.iii.2
        var propValue = from[nextKey]; // step 3.a.iii.2.a
        to[nextKey] = propValue; // step 3.a.iii.2.b
      }
    }
  }
  return to; // step 4
};

},{"call-bind/callBound":140,"has-symbols/shams":310,"object-keys":345}],348:[function(require,module,exports){
'use strict';

var implementation = require('./implementation');
var lacksProperEnumerationOrder = function lacksProperEnumerationOrder() {
  if (!Object.assign) {
    return false;
  }
  /*
   * v8, specifically in node 4.x, has a bug with incorrect property enumeration order
   * note: this does not detect the bug unless there's 20 characters
   */
  var str = 'abcdefghijklmnopqrst';
  var letters = str.split('');
  var map = {};
  for (var i = 0; i < letters.length; ++i) {
    map[letters[i]] = letters[i];
  }
  var obj = Object.assign({}, map);
  var actual = '';
  for (var k in obj) {
    actual += k;
  }
  return str !== actual;
};
var assignHasPendingExceptions = function assignHasPendingExceptions() {
  if (!Object.assign || !Object.preventExtensions) {
    return false;
  }
  /*
   * Firefox 37 still has "pending exception" logic in its Object.assign implementation,
   * which is 72% slower than our shim, and Firefox 40's native implementation.
   */
  var thrower = Object.preventExtensions({
    1: 2
  });
  try {
    Object.assign(thrower, 'xy');
  } catch (e) {
    return thrower[1] === 'y';
  }
  return false;
};
module.exports = function getPolyfill() {
  if (!Object.assign) {
    return implementation;
  }
  if (lacksProperEnumerationOrder()) {
    return implementation;
  }
  if (assignHasPendingExceptions()) {
    return implementation;
  }
  return Object.assign;
};

},{"./implementation":347}],349:[function(require,module,exports){
module.exports={"2.16.840.1.101.3.4.1.1": "aes-128-ecb",
"2.16.840.1.101.3.4.1.2": "aes-128-cbc",
"2.16.840.1.101.3.4.1.3": "aes-128-ofb",
"2.16.840.1.101.3.4.1.4": "aes-128-cfb",
"2.16.840.1.101.3.4.1.21": "aes-192-ecb",
"2.16.840.1.101.3.4.1.22": "aes-192-cbc",
"2.16.840.1.101.3.4.1.23": "aes-192-ofb",
"2.16.840.1.101.3.4.1.24": "aes-192-cfb",
"2.16.840.1.101.3.4.1.41": "aes-256-ecb",
"2.16.840.1.101.3.4.1.42": "aes-256-cbc",
"2.16.840.1.101.3.4.1.43": "aes-256-ofb",
"2.16.840.1.101.3.4.1.44": "aes-256-cfb"
}
},{}],350:[function(require,module,exports){
// from https://github.com/indutny/self-signed/blob/gh-pages/lib/asn1.js
// Fedor, you are amazing.

'use strict';

var asn1 = require('asn1.js');
exports.certificate = require('./certificate');
var RSAPrivateKey = asn1.define('RSAPrivateKey', function () {
  this.seq().obj(this.key('version')['int'](), this.key('modulus')['int'](), this.key('publicExponent')['int'](), this.key('privateExponent')['int'](), this.key('prime1')['int'](), this.key('prime2')['int'](), this.key('exponent1')['int'](), this.key('exponent2')['int'](), this.key('coefficient')['int']());
});
exports.RSAPrivateKey = RSAPrivateKey;
var RSAPublicKey = asn1.define('RSAPublicKey', function () {
  this.seq().obj(this.key('modulus')['int'](), this.key('publicExponent')['int']());
});
exports.RSAPublicKey = RSAPublicKey;
var AlgorithmIdentifier = asn1.define('AlgorithmIdentifier', function () {
  this.seq().obj(this.key('algorithm').objid(), this.key('none').null_().optional(), this.key('curve').objid().optional(), this.key('params').seq().obj(this.key('p')['int'](), this.key('q')['int'](), this.key('g')['int']()).optional());
});
var PublicKey = asn1.define('SubjectPublicKeyInfo', function () {
  this.seq().obj(this.key('algorithm').use(AlgorithmIdentifier), this.key('subjectPublicKey').bitstr());
});
exports.PublicKey = PublicKey;
var PrivateKeyInfo = asn1.define('PrivateKeyInfo', function () {
  this.seq().obj(this.key('version')['int'](), this.key('algorithm').use(AlgorithmIdentifier), this.key('subjectPrivateKey').octstr());
});
exports.PrivateKey = PrivateKeyInfo;
var EncryptedPrivateKeyInfo = asn1.define('EncryptedPrivateKeyInfo', function () {
  this.seq().obj(this.key('algorithm').seq().obj(this.key('id').objid(), this.key('decrypt').seq().obj(this.key('kde').seq().obj(this.key('id').objid(), this.key('kdeparams').seq().obj(this.key('salt').octstr(), this.key('iters')['int']())), this.key('cipher').seq().obj(this.key('algo').objid(), this.key('iv').octstr()))), this.key('subjectPrivateKey').octstr());
});
exports.EncryptedPrivateKey = EncryptedPrivateKeyInfo;
var DSAPrivateKey = asn1.define('DSAPrivateKey', function () {
  this.seq().obj(this.key('version')['int'](), this.key('p')['int'](), this.key('q')['int'](), this.key('g')['int'](), this.key('pub_key')['int'](), this.key('priv_key')['int']());
});
exports.DSAPrivateKey = DSAPrivateKey;
exports.DSAparam = asn1.define('DSAparam', function () {
  this['int']();
});
var ECParameters = asn1.define('ECParameters', function () {
  this.choice({
    namedCurve: this.objid()
  });
});
var ECPrivateKey = asn1.define('ECPrivateKey', function () {
  this.seq().obj(this.key('version')['int'](), this.key('privateKey').octstr(), this.key('parameters').optional().explicit(0).use(ECParameters), this.key('publicKey').optional().explicit(1).bitstr());
});
exports.ECPrivateKey = ECPrivateKey;
exports.signature = asn1.define('signature', function () {
  this.seq().obj(this.key('r')['int'](), this.key('s')['int']());
});

},{"./certificate":351,"asn1.js":83}],351:[function(require,module,exports){
// from https://github.com/Rantanen/node-dtls/blob/25a7dc861bda38cfeac93a723500eea4f0ac2e86/Certificate.js
// thanks to @Rantanen

'use strict';

var asn = require('asn1.js');
var Time = asn.define('Time', function () {
  this.choice({
    utcTime: this.utctime(),
    generalTime: this.gentime()
  });
});
var AttributeTypeValue = asn.define('AttributeTypeValue', function () {
  this.seq().obj(this.key('type').objid(), this.key('value').any());
});
var AlgorithmIdentifier = asn.define('AlgorithmIdentifier', function () {
  this.seq().obj(this.key('algorithm').objid(), this.key('parameters').optional(), this.key('curve').objid().optional());
});
var SubjectPublicKeyInfo = asn.define('SubjectPublicKeyInfo', function () {
  this.seq().obj(this.key('algorithm').use(AlgorithmIdentifier), this.key('subjectPublicKey').bitstr());
});
var RelativeDistinguishedName = asn.define('RelativeDistinguishedName', function () {
  this.setof(AttributeTypeValue);
});
var RDNSequence = asn.define('RDNSequence', function () {
  this.seqof(RelativeDistinguishedName);
});
var Name = asn.define('Name', function () {
  this.choice({
    rdnSequence: this.use(RDNSequence)
  });
});
var Validity = asn.define('Validity', function () {
  this.seq().obj(this.key('notBefore').use(Time), this.key('notAfter').use(Time));
});
var Extension = asn.define('Extension', function () {
  this.seq().obj(this.key('extnID').objid(), this.key('critical').bool().def(false), this.key('extnValue').octstr());
});
var TBSCertificate = asn.define('TBSCertificate', function () {
  this.seq().obj(this.key('version').explicit(0)['int']().optional(), this.key('serialNumber')['int'](), this.key('signature').use(AlgorithmIdentifier), this.key('issuer').use(Name), this.key('validity').use(Validity), this.key('subject').use(Name), this.key('subjectPublicKeyInfo').use(SubjectPublicKeyInfo), this.key('issuerUniqueID').implicit(1).bitstr().optional(), this.key('subjectUniqueID').implicit(2).bitstr().optional(), this.key('extensions').explicit(3).seqof(Extension).optional());
});
var X509Certificate = asn.define('X509Certificate', function () {
  this.seq().obj(this.key('tbsCertificate').use(TBSCertificate), this.key('signatureAlgorithm').use(AlgorithmIdentifier), this.key('signatureValue').bitstr());
});
module.exports = X509Certificate;

},{"asn1.js":83}],352:[function(require,module,exports){
'use strict';

// adapted from https://github.com/apatil/pemstrip
var findProc = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m;
var startRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m;
var fullRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m;
var evp = require('evp_bytestokey');
var ciphers = require('browserify-aes');
var Buffer = require('safe-buffer').Buffer;
module.exports = function (okey, password) {
  var key = okey.toString();
  var match = key.match(findProc);
  var decrypted;
  if (!match) {
    var match2 = key.match(fullRegex);
    decrypted = Buffer.from(match2[2].replace(/[\r\n]/g, ''), 'base64');
  } else {
    var suite = 'aes' + match[1];
    var iv = Buffer.from(match[2], 'hex');
    var cipherText = Buffer.from(match[3].replace(/[\r\n]/g, ''), 'base64');
    var cipherKey = evp(password, iv.slice(0, 8), parseInt(match[1], 10)).key;
    var out = [];
    var cipher = ciphers.createDecipheriv(suite, cipherKey, iv);
    out.push(cipher.update(cipherText));
    out.push(cipher['final']());
    decrypted = Buffer.concat(out);
  }
  var tag = key.match(startRegex)[1];
  return {
    tag: tag,
    data: decrypted
  };
};

},{"browserify-aes":108,"evp_bytestokey":302,"safe-buffer":354}],353:[function(require,module,exports){
'use strict';

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var asn1 = require('./asn1');
var aesid = require('./aesid.json');
var fixProc = require('./fixProc');
var ciphers = require('browserify-aes');
var compat = require('pbkdf2');
var Buffer = require('safe-buffer').Buffer;
function decrypt(data, password) {
  var salt = data.algorithm.decrypt.kde.kdeparams.salt;
  var iters = parseInt(data.algorithm.decrypt.kde.kdeparams.iters.toString(), 10);
  var algo = aesid[data.algorithm.decrypt.cipher.algo.join('.')];
  var iv = data.algorithm.decrypt.cipher.iv;
  var cipherText = data.subjectPrivateKey;
  var keylen = parseInt(algo.split('-')[1], 10) / 8;
  var key = compat.pbkdf2Sync(password, salt, iters, keylen, 'sha1');
  var cipher = ciphers.createDecipheriv(algo, key, iv);
  var out = [];
  out.push(cipher.update(cipherText));
  out.push(cipher['final']());
  return Buffer.concat(out);
}
function parseKeys(buffer) {
  var password;
  if (_typeof(buffer) === 'object' && !Buffer.isBuffer(buffer)) {
    password = buffer.passphrase;
    buffer = buffer.key;
  }
  if (typeof buffer === 'string') {
    buffer = Buffer.from(buffer);
  }
  var stripped = fixProc(buffer, password);
  var type = stripped.tag;
  var data = stripped.data;
  var subtype, ndata;
  switch (type) {
    case 'CERTIFICATE':
      ndata = asn1.certificate.decode(data, 'der').tbsCertificate.subjectPublicKeyInfo;
    // falls through
    case 'PUBLIC KEY':
      if (!ndata) {
        ndata = asn1.PublicKey.decode(data, 'der');
      }
      subtype = ndata.algorithm.algorithm.join('.');
      switch (subtype) {
        case '1.2.840.113549.1.1.1':
          return asn1.RSAPublicKey.decode(ndata.subjectPublicKey.data, 'der');
        case '1.2.840.10045.2.1':
          ndata.subjectPrivateKey = ndata.subjectPublicKey;
          return {
            type: 'ec',
            data: ndata
          };
        case '1.2.840.10040.4.1':
          ndata.algorithm.params.pub_key = asn1.DSAparam.decode(ndata.subjectPublicKey.data, 'der');
          return {
            type: 'dsa',
            data: ndata.algorithm.params
          };
        default:
          throw new Error('unknown key id ' + subtype);
      }
    // throw new Error('unknown key type ' + type)
    case 'ENCRYPTED PRIVATE KEY':
      data = asn1.EncryptedPrivateKey.decode(data, 'der');
      data = decrypt(data, password);
    // falls through
    case 'PRIVATE KEY':
      ndata = asn1.PrivateKey.decode(data, 'der');
      subtype = ndata.algorithm.algorithm.join('.');
      switch (subtype) {
        case '1.2.840.113549.1.1.1':
          return asn1.RSAPrivateKey.decode(ndata.subjectPrivateKey, 'der');
        case '1.2.840.10045.2.1':
          return {
            curve: ndata.algorithm.curve,
            privateKey: asn1.ECPrivateKey.decode(ndata.subjectPrivateKey, 'der').privateKey
          };
        case '1.2.840.10040.4.1':
          ndata.algorithm.params.priv_key = asn1.DSAparam.decode(ndata.subjectPrivateKey, 'der');
          return {
            type: 'dsa',
            params: ndata.algorithm.params
          };
        default:
          throw new Error('unknown key id ' + subtype);
      }
    // throw new Error('unknown key type ' + type)
    case 'RSA PUBLIC KEY':
      return asn1.RSAPublicKey.decode(data, 'der');
    case 'RSA PRIVATE KEY':
      return asn1.RSAPrivateKey.decode(data, 'der');
    case 'DSA PRIVATE KEY':
      return {
        type: 'dsa',
        params: asn1.DSAPrivateKey.decode(data, 'der')
      };
    case 'EC PRIVATE KEY':
      data = asn1.ECPrivateKey.decode(data, 'der');
      return {
        curve: data.parameters.value,
        privateKey: data.privateKey
      };
    default:
      throw new Error('unknown key type ' + type);
  }
}
parseKeys.signature = asn1.signature;
module.exports = parseKeys;

},{"./aesid.json":349,"./asn1":350,"./fixProc":352,"browserify-aes":108,"pbkdf2":356,"safe-buffer":354}],354:[function(require,module,exports){
arguments[4][136][0].apply(exports,arguments)
},{"buffer":139,"dup":136}],355:[function(require,module,exports){
(function (process){(function (){
// 'path' module extracted from Node.js v8.11.1 (only the posix part)
// transplited with Babel

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function assertPath(path) {
  if (typeof path !== 'string') {
    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));
  }
}

// Resolves . and .. elements in a path with directory names
function normalizeStringPosix(path, allowAboveRoot) {
  var res = '';
  var lastSegmentLength = 0;
  var lastSlash = -1;
  var dots = 0;
  var code;
  for (var i = 0; i <= path.length; ++i) {
    if (i < path.length) code = path.charCodeAt(i);else if (code === 47 /*/*/) break;else code = 47 /*/*/;
    if (code === 47 /*/*/) {
      if (lastSlash === i - 1 || dots === 1) {
        // NOOP
      } else if (lastSlash !== i - 1 && dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {
          if (res.length > 2) {
            var lastSlashIndex = res.lastIndexOf('/');
            if (lastSlashIndex !== res.length - 1) {
              if (lastSlashIndex === -1) {
                res = '';
                lastSegmentLength = 0;
              } else {
                res = res.slice(0, lastSlashIndex);
                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');
              }
              lastSlash = i;
              dots = 0;
              continue;
            }
          } else if (res.length === 2 || res.length === 1) {
            res = '';
            lastSegmentLength = 0;
            lastSlash = i;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          if (res.length > 0) res += '/..';else res = '..';
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0) res += '/' + path.slice(lastSlash + 1, i);else res = path.slice(lastSlash + 1, i);
        lastSegmentLength = i - lastSlash - 1;
      }
      lastSlash = i;
      dots = 0;
    } else if (code === 46 /*.*/ && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}
function _format(sep, pathObject) {
  var dir = pathObject.dir || pathObject.root;
  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');
  if (!dir) {
    return base;
  }
  if (dir === pathObject.root) {
    return dir + base;
  }
  return dir + sep + base;
}
var posix = {
  // path.resolve([from ...], to)
  resolve: function resolve() {
    var resolvedPath = '';
    var resolvedAbsolute = false;
    var cwd;
    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
      var path;
      if (i >= 0) path = arguments[i];else {
        if (cwd === undefined) cwd = process.cwd();
        path = cwd;
      }
      assertPath(path);

      // Skip empty entries
      if (path.length === 0) {
        continue;
      }
      resolvedPath = path + '/' + resolvedPath;
      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;
    }

    // At this point the path should be resolved to a full absolute path, but
    // handle relative paths to be safe (might happen when process.cwd() fails)

    // Normalize the path
    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
    if (resolvedAbsolute) {
      if (resolvedPath.length > 0) return '/' + resolvedPath;else return '/';
    } else if (resolvedPath.length > 0) {
      return resolvedPath;
    } else {
      return '.';
    }
  },
  normalize: function normalize(path) {
    assertPath(path);
    if (path.length === 0) return '.';
    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;
    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;

    // Normalize the path
    path = normalizeStringPosix(path, !isAbsolute);
    if (path.length === 0 && !isAbsolute) path = '.';
    if (path.length > 0 && trailingSeparator) path += '/';
    if (isAbsolute) return '/' + path;
    return path;
  },
  isAbsolute: function isAbsolute(path) {
    assertPath(path);
    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;
  },
  join: function join() {
    if (arguments.length === 0) return '.';
    var joined;
    for (var i = 0; i < arguments.length; ++i) {
      var arg = arguments[i];
      assertPath(arg);
      if (arg.length > 0) {
        if (joined === undefined) joined = arg;else joined += '/' + arg;
      }
    }
    if (joined === undefined) return '.';
    return posix.normalize(joined);
  },
  relative: function relative(from, to) {
    assertPath(from);
    assertPath(to);
    if (from === to) return '';
    from = posix.resolve(from);
    to = posix.resolve(to);
    if (from === to) return '';

    // Trim any leading backslashes
    var fromStart = 1;
    for (; fromStart < from.length; ++fromStart) {
      if (from.charCodeAt(fromStart) !== 47 /*/*/) break;
    }
    var fromEnd = from.length;
    var fromLen = fromEnd - fromStart;

    // Trim any leading backslashes
    var toStart = 1;
    for (; toStart < to.length; ++toStart) {
      if (to.charCodeAt(toStart) !== 47 /*/*/) break;
    }
    var toEnd = to.length;
    var toLen = toEnd - toStart;

    // Compare paths to find the longest common path from root
    var length = fromLen < toLen ? fromLen : toLen;
    var lastCommonSep = -1;
    var i = 0;
    for (; i <= length; ++i) {
      if (i === length) {
        if (toLen > length) {
          if (to.charCodeAt(toStart + i) === 47 /*/*/) {
            // We get here if `from` is the exact base path for `to`.
            // For example: from='/foo/bar'; to='/foo/bar/baz'
            return to.slice(toStart + i + 1);
          } else if (i === 0) {
            // We get here if `from` is the root
            // For example: from='/'; to='/foo'
            return to.slice(toStart + i);
          }
        } else if (fromLen > length) {
          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {
            // We get here if `to` is the exact base path for `from`.
            // For example: from='/foo/bar/baz'; to='/foo/bar'
            lastCommonSep = i;
          } else if (i === 0) {
            // We get here if `to` is the root.
            // For example: from='/foo'; to='/'
            lastCommonSep = 0;
          }
        }
        break;
      }
      var fromCode = from.charCodeAt(fromStart + i);
      var toCode = to.charCodeAt(toStart + i);
      if (fromCode !== toCode) break;else if (fromCode === 47 /*/*/) lastCommonSep = i;
    }
    var out = '';
    // Generate the relative path based on the path difference between `to`
    // and `from`
    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {
        if (out.length === 0) out += '..';else out += '/..';
      }
    }

    // Lastly, append the rest of the destination (`to`) path that comes after
    // the common path parts
    if (out.length > 0) return out + to.slice(toStart + lastCommonSep);else {
      toStart += lastCommonSep;
      if (to.charCodeAt(toStart) === 47 /*/*/) ++toStart;
      return to.slice(toStart);
    }
  },
  _makeLong: function _makeLong(path) {
    return path;
  },
  dirname: function dirname(path) {
    assertPath(path);
    if (path.length === 0) return '.';
    var code = path.charCodeAt(0);
    var hasRoot = code === 47 /*/*/;
    var end = -1;
    var matchedSlash = true;
    for (var i = path.length - 1; i >= 1; --i) {
      code = path.charCodeAt(i);
      if (code === 47 /*/*/) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
        // We saw the first non-path separator
        matchedSlash = false;
      }
    }
    if (end === -1) return hasRoot ? '/' : '.';
    if (hasRoot && end === 1) return '//';
    return path.slice(0, end);
  },
  basename: function basename(path, ext) {
    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('"ext" argument must be a string');
    assertPath(path);
    var start = 0;
    var end = -1;
    var matchedSlash = true;
    var i;
    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
      if (ext.length === path.length && ext === path) return '';
      var extIdx = ext.length - 1;
      var firstNonSlashEnd = -1;
      for (i = path.length - 1; i >= 0; --i) {
        var code = path.charCodeAt(i);
        if (code === 47 /*/*/) {
          // If we reached a path separator that was not part of a set of path
          // separators at the end of the string, stop now
          if (!matchedSlash) {
            start = i + 1;
            break;
          }
        } else {
          if (firstNonSlashEnd === -1) {
            // We saw the first non-path separator, remember this index in case
            // we need it if the extension ends up not matching
            matchedSlash = false;
            firstNonSlashEnd = i + 1;
          }
          if (extIdx >= 0) {
            // Try to match the explicit extension
            if (code === ext.charCodeAt(extIdx)) {
              if (--extIdx === -1) {
                // We matched the extension, so mark this as the end of our path
                // component
                end = i;
              }
            } else {
              // Extension does not match, so our result is the entire path
              // component
              extIdx = -1;
              end = firstNonSlashEnd;
            }
          }
        }
      }
      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;
      return path.slice(start, end);
    } else {
      for (i = path.length - 1; i >= 0; --i) {
        if (path.charCodeAt(i) === 47 /*/*/) {
          // If we reached a path separator that was not part of a set of path
          // separators at the end of the string, stop now
          if (!matchedSlash) {
            start = i + 1;
            break;
          }
        } else if (end === -1) {
          // We saw the first non-path separator, mark this as the end of our
          // path component
          matchedSlash = false;
          end = i + 1;
        }
      }
      if (end === -1) return '';
      return path.slice(start, end);
    }
  },
  extname: function extname(path) {
    assertPath(path);
    var startDot = -1;
    var startPart = 0;
    var end = -1;
    var matchedSlash = true;
    // Track the state of characters (if any) we see before our first dot and
    // after any path separator we find
    var preDotState = 0;
    for (var i = path.length - 1; i >= 0; --i) {
      var code = path.charCodeAt(i);
      if (code === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
      if (end === -1) {
        // We saw the first non-path separator, mark this as the end of our
        // extension
        matchedSlash = false;
        end = i + 1;
      }
      if (code === 46 /*.*/) {
        // If this is our first dot, mark it as the start of our extension
        if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;
      } else if (startDot !== -1) {
        // We saw a non-dot and non-path separator before our dot, so we should
        // have a good chance at having a non-empty extension
        preDotState = -1;
      }
    }
    if (startDot === -1 || end === -1 ||
    // We saw a non-dot character immediately before the dot
    preDotState === 0 ||
    // The (right-most) trimmed path component is exactly '..'
    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      return '';
    }
    return path.slice(startDot, end);
  },
  format: function format(pathObject) {
    if (pathObject === null || _typeof(pathObject) !== 'object') {
      throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + _typeof(pathObject));
    }
    return _format('/', pathObject);
  },
  parse: function parse(path) {
    assertPath(path);
    var ret = {
      root: '',
      dir: '',
      base: '',
      ext: '',
      name: ''
    };
    if (path.length === 0) return ret;
    var code = path.charCodeAt(0);
    var isAbsolute = code === 47 /*/*/;
    var start;
    if (isAbsolute) {
      ret.root = '/';
      start = 1;
    } else {
      start = 0;
    }
    var startDot = -1;
    var startPart = 0;
    var end = -1;
    var matchedSlash = true;
    var i = path.length - 1;

    // Track the state of characters (if any) we see before our first dot and
    // after any path separator we find
    var preDotState = 0;

    // Get non-dir info
    for (; i >= start; --i) {
      code = path.charCodeAt(i);
      if (code === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
      if (end === -1) {
        // We saw the first non-path separator, mark this as the end of our
        // extension
        matchedSlash = false;
        end = i + 1;
      }
      if (code === 46 /*.*/) {
        // If this is our first dot, mark it as the start of our extension
        if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;
      } else if (startDot !== -1) {
        // We saw a non-dot and non-path separator before our dot, so we should
        // have a good chance at having a non-empty extension
        preDotState = -1;
      }
    }
    if (startDot === -1 || end === -1 ||
    // We saw a non-dot character immediately before the dot
    preDotState === 0 ||
    // The (right-most) trimmed path component is exactly '..'
    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      if (end !== -1) {
        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);
      }
    } else {
      if (startPart === 0 && isAbsolute) {
        ret.name = path.slice(1, startDot);
        ret.base = path.slice(1, end);
      } else {
        ret.name = path.slice(startPart, startDot);
        ret.base = path.slice(startPart, end);
      }
      ret.ext = path.slice(startDot, end);
    }
    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';
    return ret;
  },
  sep: '/',
  delimiter: ':',
  win32: null,
  posix: null
};
posix.posix = posix;
module.exports = posix;

}).call(this)}).call(this,require('_process'))
},{"_process":363}],356:[function(require,module,exports){
"use strict";

exports.pbkdf2 = require('./lib/async');
exports.pbkdf2Sync = require('./lib/sync');

},{"./lib/async":357,"./lib/sync":360}],357:[function(require,module,exports){
(function (global){(function (){
"use strict";

var Buffer = require('safe-buffer').Buffer;
var checkParameters = require('./precondition');
var defaultEncoding = require('./default-encoding');
var sync = require('./sync');
var toBuffer = require('./to-buffer');
var ZERO_BUF;
var subtle = global.crypto && global.crypto.subtle;
var toBrowser = {
  sha: 'SHA-1',
  'sha-1': 'SHA-1',
  sha1: 'SHA-1',
  sha256: 'SHA-256',
  'sha-256': 'SHA-256',
  sha384: 'SHA-384',
  'sha-384': 'SHA-384',
  'sha-512': 'SHA-512',
  sha512: 'SHA-512'
};
var checks = [];
function checkNative(algo) {
  if (global.process && !global.process.browser) {
    return Promise.resolve(false);
  }
  if (!subtle || !subtle.importKey || !subtle.deriveBits) {
    return Promise.resolve(false);
  }
  if (checks[algo] !== undefined) {
    return checks[algo];
  }
  ZERO_BUF = ZERO_BUF || Buffer.alloc(8);
  var prom = browserPbkdf2(ZERO_BUF, ZERO_BUF, 10, 128, algo).then(function () {
    return true;
  })["catch"](function () {
    return false;
  });
  checks[algo] = prom;
  return prom;
}
var nextTick;
function getNextTick() {
  if (nextTick) {
    return nextTick;
  }
  if (global.process && global.process.nextTick) {
    nextTick = global.process.nextTick;
  } else if (global.queueMicrotask) {
    nextTick = global.queueMicrotask;
  } else if (global.setImmediate) {
    nextTick = global.setImmediate;
  } else {
    nextTick = global.setTimeout;
  }
  return nextTick;
}
function browserPbkdf2(password, salt, iterations, length, algo) {
  return subtle.importKey('raw', password, {
    name: 'PBKDF2'
  }, false, ['deriveBits']).then(function (key) {
    return subtle.deriveBits({
      name: 'PBKDF2',
      salt: salt,
      iterations: iterations,
      hash: {
        name: algo
      }
    }, key, length << 3);
  }).then(function (res) {
    return Buffer.from(res);
  });
}
function resolvePromise(promise, callback) {
  promise.then(function (out) {
    getNextTick()(function () {
      callback(null, out);
    });
  }, function (e) {
    getNextTick()(function () {
      callback(e);
    });
  });
}
module.exports = function (password, salt, iterations, keylen, digest, callback) {
  if (typeof digest === 'function') {
    callback = digest;
    digest = undefined;
  }
  digest = digest || 'sha1';
  var algo = toBrowser[digest.toLowerCase()];
  if (!algo || typeof global.Promise !== 'function') {
    getNextTick()(function () {
      var out;
      try {
        out = sync(password, salt, iterations, keylen, digest);
      } catch (e) {
        return callback(e);
      }
      callback(null, out);
    });
    return;
  }
  checkParameters(iterations, keylen);
  password = toBuffer(password, defaultEncoding, 'Password');
  salt = toBuffer(salt, defaultEncoding, 'Salt');
  if (typeof callback !== 'function') throw new Error('No callback provided to pbkdf2');
  resolvePromise(checkNative(algo).then(function (resp) {
    if (resp) return browserPbkdf2(password, salt, iterations, keylen, algo);
    return sync(password, salt, iterations, keylen, digest);
  }), callback);
};

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./default-encoding":358,"./precondition":359,"./sync":360,"./to-buffer":361,"safe-buffer":384}],358:[function(require,module,exports){
(function (process,global){(function (){
"use strict";

var defaultEncoding;
/* istanbul ignore next */
if (global.process && global.process.browser) {
  defaultEncoding = 'utf-8';
} else if (global.process && global.process.version) {
  var pVersionMajor = parseInt(process.version.split('.')[0].slice(1), 10);
  defaultEncoding = pVersionMajor >= 6 ? 'utf-8' : 'binary';
} else {
  defaultEncoding = 'utf-8';
}
module.exports = defaultEncoding;

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"_process":363}],359:[function(require,module,exports){
"use strict";

var MAX_ALLOC = Math.pow(2, 30) - 1; // default in iojs

module.exports = function (iterations, keylen) {
  if (typeof iterations !== 'number') {
    throw new TypeError('Iterations not a number');
  }
  if (iterations < 0) {
    throw new TypeError('Bad iterations');
  }
  if (typeof keylen !== 'number') {
    throw new TypeError('Key length not a number');
  }
  if (keylen < 0 || keylen > MAX_ALLOC || keylen !== keylen) {
    /* eslint no-self-compare: 0 */
    throw new TypeError('Bad key length');
  }
};

},{}],360:[function(require,module,exports){
"use strict";

var md5 = require('create-hash/md5');
var RIPEMD160 = require('ripemd160');
var sha = require('sha.js');
var Buffer = require('safe-buffer').Buffer;
var checkParameters = require('./precondition');
var defaultEncoding = require('./default-encoding');
var toBuffer = require('./to-buffer');
var ZEROS = Buffer.alloc(128);
var sizes = {
  md5: 16,
  sha1: 20,
  sha224: 28,
  sha256: 32,
  sha384: 48,
  sha512: 64,
  rmd160: 20,
  ripemd160: 20
};
function Hmac(alg, key, saltLen) {
  var hash = getDigest(alg);
  var blocksize = alg === 'sha512' || alg === 'sha384' ? 128 : 64;
  if (key.length > blocksize) {
    key = hash(key);
  } else if (key.length < blocksize) {
    key = Buffer.concat([key, ZEROS], blocksize);
  }
  var ipad = Buffer.allocUnsafe(blocksize + sizes[alg]);
  var opad = Buffer.allocUnsafe(blocksize + sizes[alg]);
  for (var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36;
    opad[i] = key[i] ^ 0x5C;
  }
  var ipad1 = Buffer.allocUnsafe(blocksize + saltLen + 4);
  ipad.copy(ipad1, 0, 0, blocksize);
  this.ipad1 = ipad1;
  this.ipad2 = ipad;
  this.opad = opad;
  this.alg = alg;
  this.blocksize = blocksize;
  this.hash = hash;
  this.size = sizes[alg];
}
Hmac.prototype.run = function (data, ipad) {
  data.copy(ipad, this.blocksize);
  var h = this.hash(ipad);
  h.copy(this.opad, this.blocksize);
  return this.hash(this.opad);
};
function getDigest(alg) {
  function shaFunc(data) {
    return sha(alg).update(data).digest();
  }
  function rmd160Func(data) {
    return new RIPEMD160().update(data).digest();
  }
  if (alg === 'rmd160' || alg === 'ripemd160') return rmd160Func;
  if (alg === 'md5') return md5;
  return shaFunc;
}
function pbkdf2(password, salt, iterations, keylen, digest) {
  checkParameters(iterations, keylen);
  password = toBuffer(password, defaultEncoding, 'Password');
  salt = toBuffer(salt, defaultEncoding, 'Salt');
  digest = digest || 'sha1';
  var hmac = new Hmac(digest, password, salt.length);
  var DK = Buffer.allocUnsafe(keylen);
  var block1 = Buffer.allocUnsafe(salt.length + 4);
  salt.copy(block1, 0, 0, salt.length);
  var destPos = 0;
  var hLen = sizes[digest];
  var l = Math.ceil(keylen / hLen);
  for (var i = 1; i <= l; i++) {
    block1.writeUInt32BE(i, salt.length);
    var T = hmac.run(block1, hmac.ipad1);
    var U = T;
    for (var j = 1; j < iterations; j++) {
      U = hmac.run(U, hmac.ipad2);
      for (var k = 0; k < hLen; k++) T[k] ^= U[k];
    }
    T.copy(DK, destPos);
    destPos += hLen;
  }
  return DK;
}
module.exports = pbkdf2;

},{"./default-encoding":358,"./precondition":359,"./to-buffer":361,"create-hash/md5":146,"ripemd160":382,"safe-buffer":384,"sha.js":394}],361:[function(require,module,exports){
"use strict";

var Buffer = require('safe-buffer').Buffer;
module.exports = function (thing, encoding, name) {
  if (Buffer.isBuffer(thing)) {
    return thing;
  } else if (typeof thing === 'string') {
    return Buffer.from(thing, encoding);
  } else if (ArrayBuffer.isView(thing)) {
    return Buffer.from(thing.buffer);
  } else {
    throw new TypeError(name + ' must be a string, a Buffer, a typed array or a DataView');
  }
};

},{"safe-buffer":384}],362:[function(require,module,exports){
(function (process){(function (){
'use strict';

if (typeof process === 'undefined' || !process.version || process.version.indexOf('v0.') === 0 || process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = {
    nextTick: nextTick
  };
} else {
  module.exports = process;
}
function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
    case 0:
    case 1:
      return process.nextTick(fn);
    case 2:
      return process.nextTick(function afterTickOne() {
        fn.call(null, arg1);
      });
    case 3:
      return process.nextTick(function afterTickTwo() {
        fn.call(null, arg1, arg2);
      });
    case 4:
      return process.nextTick(function afterTickThree() {
        fn.call(null, arg1, arg2, arg3);
      });
    default:
      args = new Array(len - 1);
      i = 0;
      while (i < args.length) {
        args[i++] = arguments[i];
      }
      return process.nextTick(function afterTick() {
        fn.apply(null, args);
      });
  }
}

}).call(this)}).call(this,require('_process'))
},{"_process":363}],363:[function(require,module,exports){
"use strict";

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;
function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}
(function () {
  try {
    if (typeof setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }
  try {
    if (typeof clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();
function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  }
  // if setTimeout wasn't available but was latter defined
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}
function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  }
  // if clearTimeout wasn't available but was latter defined
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }
  draining = false;
  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }
  if (queue.length) {
    drainQueue();
  }
}
function drainQueue() {
  if (draining) {
    return;
  }
  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;
  while (len) {
    currentQueue = queue;
    queue = [];
    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }
    queueIndex = -1;
    len = queue.length;
  }
  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}
process.nextTick = function (fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }
  queue.push(new Item(fun, args));
  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
};

// v8 likes predictible objects
function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}
Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};
function noop() {}
process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;
process.listeners = function (name) {
  return [];
};
process.binding = function (name) {
  throw new Error('process.binding is not supported');
};
process.cwd = function () {
  return '/';
};
process.chdir = function (dir) {
  throw new Error('process.chdir is not supported');
};
process.umask = function () {
  return 0;
};

},{}],364:[function(require,module,exports){
"use strict";

exports.publicEncrypt = require('./publicEncrypt');
exports.privateDecrypt = require('./privateDecrypt');
exports.privateEncrypt = function privateEncrypt(key, buf) {
  return exports.publicEncrypt(key, buf, true);
};
exports.publicDecrypt = function publicDecrypt(key, buf) {
  return exports.privateDecrypt(key, buf, true);
};

},{"./privateDecrypt":366,"./publicEncrypt":367}],365:[function(require,module,exports){
"use strict";

var createHash = require('create-hash');
var Buffer = require('safe-buffer').Buffer;
module.exports = function (seed, len) {
  var t = Buffer.alloc(0);
  var i = 0;
  var c;
  while (t.length < len) {
    c = i2ops(i++);
    t = Buffer.concat([t, createHash('sha1').update(seed).update(c).digest()]);
  }
  return t.slice(0, len);
};
function i2ops(c) {
  var out = Buffer.allocUnsafe(4);
  out.writeUInt32BE(c, 0);
  return out;
}

},{"create-hash":145,"safe-buffer":384}],366:[function(require,module,exports){
"use strict";

var parseKeys = require('parse-asn1');
var mgf = require('./mgf');
var xor = require('./xor');
var BN = require('bn.js');
var crt = require('browserify-rsa');
var createHash = require('create-hash');
var withPublic = require('./withPublic');
var Buffer = require('safe-buffer').Buffer;
module.exports = function privateDecrypt(privateKey, enc, reverse) {
  var padding;
  if (privateKey.padding) {
    padding = privateKey.padding;
  } else if (reverse) {
    padding = 1;
  } else {
    padding = 4;
  }
  var key = parseKeys(privateKey);
  var k = key.modulus.byteLength();
  if (enc.length > k || new BN(enc).cmp(key.modulus) >= 0) {
    throw new Error('decryption error');
  }
  var msg;
  if (reverse) {
    msg = withPublic(new BN(enc), key);
  } else {
    msg = crt(enc, key);
  }
  var zBuffer = Buffer.alloc(k - msg.length);
  msg = Buffer.concat([zBuffer, msg], k);
  if (padding === 4) {
    return oaep(key, msg);
  } else if (padding === 1) {
    return pkcs1(key, msg, reverse);
  } else if (padding === 3) {
    return msg;
  } else {
    throw new Error('unknown padding');
  }
};
function oaep(key, msg) {
  var k = key.modulus.byteLength();
  var iHash = createHash('sha1').update(Buffer.alloc(0)).digest();
  var hLen = iHash.length;
  if (msg[0] !== 0) {
    throw new Error('decryption error');
  }
  var maskedSeed = msg.slice(1, hLen + 1);
  var maskedDb = msg.slice(hLen + 1);
  var seed = xor(maskedSeed, mgf(maskedDb, hLen));
  var db = xor(maskedDb, mgf(seed, k - hLen - 1));
  if (compare(iHash, db.slice(0, hLen))) {
    throw new Error('decryption error');
  }
  var i = hLen;
  while (db[i] === 0) {
    i++;
  }
  if (db[i++] !== 1) {
    throw new Error('decryption error');
  }
  return db.slice(i);
}
function pkcs1(key, msg, reverse) {
  var p1 = msg.slice(0, 2);
  var i = 2;
  var status = 0;
  while (msg[i++] !== 0) {
    if (i >= msg.length) {
      status++;
      break;
    }
  }
  var ps = msg.slice(2, i - 1);
  if (p1.toString('hex') !== '0002' && !reverse || p1.toString('hex') !== '0001' && reverse) {
    status++;
  }
  if (ps.length < 8) {
    status++;
  }
  if (status) {
    throw new Error('decryption error');
  }
  return msg.slice(i);
}
function compare(a, b) {
  a = Buffer.from(a);
  b = Buffer.from(b);
  var dif = 0;
  var len = a.length;
  if (a.length !== b.length) {
    dif++;
    len = Math.min(a.length, b.length);
  }
  var i = -1;
  while (++i < len) {
    dif += a[i] ^ b[i];
  }
  return dif;
}

},{"./mgf":365,"./withPublic":368,"./xor":369,"bn.js":103,"browserify-rsa":126,"create-hash":145,"parse-asn1":353,"safe-buffer":384}],367:[function(require,module,exports){
"use strict";

var parseKeys = require('parse-asn1');
var randomBytes = require('randombytes');
var createHash = require('create-hash');
var mgf = require('./mgf');
var xor = require('./xor');
var BN = require('bn.js');
var withPublic = require('./withPublic');
var crt = require('browserify-rsa');
var Buffer = require('safe-buffer').Buffer;
module.exports = function publicEncrypt(publicKey, msg, reverse) {
  var padding;
  if (publicKey.padding) {
    padding = publicKey.padding;
  } else if (reverse) {
    padding = 1;
  } else {
    padding = 4;
  }
  var key = parseKeys(publicKey);
  var paddedMsg;
  if (padding === 4) {
    paddedMsg = oaep(key, msg);
  } else if (padding === 1) {
    paddedMsg = pkcs1(key, msg, reverse);
  } else if (padding === 3) {
    paddedMsg = new BN(msg);
    if (paddedMsg.cmp(key.modulus) >= 0) {
      throw new Error('data too long for modulus');
    }
  } else {
    throw new Error('unknown padding');
  }
  if (reverse) {
    return crt(paddedMsg, key);
  } else {
    return withPublic(paddedMsg, key);
  }
};
function oaep(key, msg) {
  var k = key.modulus.byteLength();
  var mLen = msg.length;
  var iHash = createHash('sha1').update(Buffer.alloc(0)).digest();
  var hLen = iHash.length;
  var hLen2 = 2 * hLen;
  if (mLen > k - hLen2 - 2) {
    throw new Error('message too long');
  }
  var ps = Buffer.alloc(k - mLen - hLen2 - 2);
  var dblen = k - hLen - 1;
  var seed = randomBytes(hLen);
  var maskedDb = xor(Buffer.concat([iHash, ps, Buffer.alloc(1, 1), msg], dblen), mgf(seed, dblen));
  var maskedSeed = xor(seed, mgf(maskedDb, hLen));
  return new BN(Buffer.concat([Buffer.alloc(1), maskedSeed, maskedDb], k));
}
function pkcs1(key, msg, reverse) {
  var mLen = msg.length;
  var k = key.modulus.byteLength();
  if (mLen > k - 11) {
    throw new Error('message too long');
  }
  var ps;
  if (reverse) {
    ps = Buffer.alloc(k - mLen - 3, 0xff);
  } else {
    ps = nonZero(k - mLen - 3);
  }
  return new BN(Buffer.concat([Buffer.from([0, reverse ? 1 : 2]), ps, Buffer.alloc(1), msg], k));
}
function nonZero(len) {
  var out = Buffer.allocUnsafe(len);
  var i = 0;
  var cache = randomBytes(len * 2);
  var cur = 0;
  var num;
  while (i < len) {
    if (cur === cache.length) {
      cache = randomBytes(len * 2);
      cur = 0;
    }
    num = cache[cur++];
    if (num) {
      out[i++] = num;
    }
  }
  return out;
}

},{"./mgf":365,"./withPublic":368,"./xor":369,"bn.js":103,"browserify-rsa":126,"create-hash":145,"parse-asn1":353,"randombytes":370,"safe-buffer":384}],368:[function(require,module,exports){
"use strict";

var BN = require('bn.js');
var Buffer = require('safe-buffer').Buffer;
function withPublic(paddedMsg, key) {
  return Buffer.from(paddedMsg.toRed(BN.mont(key.modulus)).redPow(new BN(key.publicExponent)).fromRed().toArray());
}
module.exports = withPublic;

},{"bn.js":103,"safe-buffer":384}],369:[function(require,module,exports){
"use strict";

module.exports = function xor(a, b) {
  var len = a.length;
  var i = -1;
  while (++i < len) {
    a[i] ^= b[i];
  }
  return a;
};

},{}],370:[function(require,module,exports){
(function (process,global){(function (){
'use strict';

// limit of Crypto.getRandomValues()
// https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues
var MAX_BYTES = 65536;

// Node supports requesting up to this number of bytes
// https://github.com/nodejs/node/blob/master/lib/internal/crypto/random.js#L48
var MAX_UINT32 = 4294967295;
function oldBrowser() {
  throw new Error('Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11');
}
var Buffer = require('safe-buffer').Buffer;
var crypto = global.crypto || global.msCrypto;
if (crypto && crypto.getRandomValues) {
  module.exports = randomBytes;
} else {
  module.exports = oldBrowser;
}
function randomBytes(size, cb) {
  // phantomjs needs to throw
  if (size > MAX_UINT32) throw new RangeError('requested too many random bytes');
  var bytes = Buffer.allocUnsafe(size);
  if (size > 0) {
    // getRandomValues fails on IE if size == 0
    if (size > MAX_BYTES) {
      // this is the max bytes crypto.getRandomValues
      // can do at once see https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues
      for (var generated = 0; generated < size; generated += MAX_BYTES) {
        // buffer.slice automatically checks if the end is past the end of
        // the buffer so we don't have to here
        crypto.getRandomValues(bytes.slice(generated, generated + MAX_BYTES));
      }
    } else {
      crypto.getRandomValues(bytes);
    }
  }
  if (typeof cb === 'function') {
    return process.nextTick(function () {
      cb(null, bytes);
    });
  }
  return bytes;
}

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"_process":363,"safe-buffer":384}],371:[function(require,module,exports){
(function (process,global){(function (){
'use strict';

function oldBrowser() {
  throw new Error('secure random number generation not supported by this browser\nuse chrome, FireFox or Internet Explorer 11');
}
var safeBuffer = require('safe-buffer');
var randombytes = require('randombytes');
var Buffer = safeBuffer.Buffer;
var kBufferMaxLength = safeBuffer.kMaxLength;
var crypto = global.crypto || global.msCrypto;
var kMaxUint32 = Math.pow(2, 32) - 1;
function assertOffset(offset, length) {
  if (typeof offset !== 'number' || offset !== offset) {
    // eslint-disable-line no-self-compare
    throw new TypeError('offset must be a number');
  }
  if (offset > kMaxUint32 || offset < 0) {
    throw new TypeError('offset must be a uint32');
  }
  if (offset > kBufferMaxLength || offset > length) {
    throw new RangeError('offset out of range');
  }
}
function assertSize(size, offset, length) {
  if (typeof size !== 'number' || size !== size) {
    // eslint-disable-line no-self-compare
    throw new TypeError('size must be a number');
  }
  if (size > kMaxUint32 || size < 0) {
    throw new TypeError('size must be a uint32');
  }
  if (size + offset > length || size > kBufferMaxLength) {
    throw new RangeError('buffer too small');
  }
}
if (crypto && crypto.getRandomValues || !process.browser) {
  exports.randomFill = randomFill;
  exports.randomFillSync = randomFillSync;
} else {
  exports.randomFill = oldBrowser;
  exports.randomFillSync = oldBrowser;
}
function randomFill(buf, offset, size, cb) {
  if (!Buffer.isBuffer(buf) && !(buf instanceof global.Uint8Array)) {
    throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
  }
  if (typeof offset === 'function') {
    cb = offset;
    offset = 0;
    size = buf.length;
  } else if (typeof size === 'function') {
    cb = size;
    size = buf.length - offset;
  } else if (typeof cb !== 'function') {
    throw new TypeError('"cb" argument must be a function');
  }
  assertOffset(offset, buf.length);
  assertSize(size, offset, buf.length);
  return actualFill(buf, offset, size, cb);
}
function actualFill(buf, offset, size, cb) {
  if (process.browser) {
    var ourBuf = buf.buffer;
    var uint = new Uint8Array(ourBuf, offset, size);
    crypto.getRandomValues(uint);
    if (cb) {
      process.nextTick(function () {
        cb(null, buf);
      });
      return;
    }
    return buf;
  }
  if (cb) {
    randombytes(size, function (err, bytes) {
      if (err) {
        return cb(err);
      }
      bytes.copy(buf, offset);
      cb(null, buf);
    });
    return;
  }
  var bytes = randombytes(size);
  bytes.copy(buf, offset);
  return buf;
}
function randomFillSync(buf, offset, size) {
  if (typeof offset === 'undefined') {
    offset = 0;
  }
  if (!Buffer.isBuffer(buf) && !(buf instanceof global.Uint8Array)) {
    throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
  }
  assertOffset(offset, buf.length);
  if (size === undefined) size = buf.length - offset;
  assertSize(size, offset, buf.length);
  return actualFill(buf, offset, size);
}

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"_process":363,"randombytes":370,"safe-buffer":384}],372:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/
var pna = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }
  return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');
util.inherits(Duplex, Readable);
{
  // avoid scope creep, the keys array can then be collected
  var keys = objectKeys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}
function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  if (options && options.readable === false) this.readable = false;
  if (options && options.writable === false) this.writable = false;
  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;
  this.once('end', onend);
}
Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  pna.nextTick(onEndNT, this);
}
function onEndNT(self) {
  self.end();
}
Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function get() {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});
Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();
  pna.nextTick(cb, err);
};

},{"./_stream_readable":374,"./_stream_writable":376,"core-util-is":143,"inherits":327,"process-nextick-args":362}],373:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

'use strict';

module.exports = PassThrough;
var Transform = require('./_stream_transform');

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);
function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);
  Transform.call(this, options);
}
PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};

},{"./_stream_transform":375,"core-util-is":143,"inherits":327}],374:[function(require,module,exports){
(function (process,global){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/
var pna = require('process-nextick-args');
/*</replacement>*/

module.exports = Readable;

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = require('events').EventEmitter;
var EElistenerCount = function EElistenerCount(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = (typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var debugUtil = require('util');
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function debug() {};
}
/*</replacement>*/

var BufferList = require('./internal/streams/BufferList');
var destroyImpl = require('./internal/streams/destroy');
var StringDecoder;
util.inherits(Readable, Stream);
var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];
function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}
function ReadableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var readableHwm = options.readableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}
function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');
  if (!(this instanceof Readable)) return new Readable(options);
  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;
  if (options) {
    if (typeof options.read === 'function') this._read = options.read;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }
  Stream.call(this);
}
Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function get() {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;
  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }
  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};
function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }
  return needMoreData(state);
}
function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}
function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}
Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;
  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }
  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }
  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;
  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }
  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }
  if (ret !== null) this.emit('data', ret);
  return ret;
};
function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}
function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    pna.nextTick(maybeReadMore_, stream, state);
  }
}
function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};
Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;
  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);
  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }
  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);
  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);
    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', state.awaitDrain);
        state.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);
  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }
  return dest;
};
function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}
Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, {
        hasUnpiped: false
      });
    }
    return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;
  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit('unpipe', this, unpipeInfo);
  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);
  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        pna.nextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }
  return res;
};
Readable.prototype.addListener = Readable.prototype.on;
function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};
function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    pna.nextTick(resume_, stream, state);
  }
}
function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }
  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}
Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};
function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var _this = this;
  var state = this._readableState;
  var paused = false;
  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }
    _this.push(null);
  });
  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;
    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  this._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };
  return this;
};
Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.highWaterMark;
  }
});

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;
  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }
  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}
function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');
  if (!state.endEmitted) {
    state.ended = true;
    pna.nextTick(endReadableNT, state, stream);
  }
}
function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}
function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./_stream_duplex":372,"./internal/streams/BufferList":377,"./internal/streams/destroy":378,"./internal/streams/stream":379,"_process":363,"core-util-is":143,"events":301,"inherits":327,"isarray":330,"process-nextick-args":362,"safe-buffer":384,"string_decoder/":380,"util":105}],375:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;
var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);
function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;
  if (!cb) {
    return this.emit('error', new Error('write callback called multiple times'));
  }
  ts.writechunk = null;
  ts.writecb = null;
  if (data != null)
    // single equals check for both `null` and `undefined`
    this.push(data);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}
function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);
  Duplex.call(this, options);
  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;
  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;
    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish);
}
function prefinish() {
  var _this = this;
  if (typeof this._flush === 'function') {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}
Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};
Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;
  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};
Transform.prototype._destroy = function (err, cb) {
  var _this2 = this;
  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
    _this2.emit('close');
  });
};
function done(stream, er, data) {
  if (er) return stream.emit('error', er);
  if (data != null)
    // single equals check for both `null` and `undefined`
    stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');
  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');
  return stream.push(null);
}

},{"./_stream_duplex":372,"core-util-is":143,"inherits":327}],376:[function(require,module,exports){
(function (process,global,setImmediate){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

'use strict';

/*<replacement>*/
var pna = require('process-nextick-args');
/*</replacement>*/

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;
  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = (typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

var destroyImpl = require('./internal/streams/destroy');
util.inherits(Writable, Stream);
function nop() {}
function WritableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var writableHwm = options.writableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}
WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};
(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function value(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function realHasInstance(object) {
    return object instanceof this;
  };
}
function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }
  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;
  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options["final"] === 'function') this._final = options["final"];
  }
  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};
function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  pna.nextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;
  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    pna.nextTick(cb, er);
    valid = false;
  }
  return valid;
}
Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = !state.objectMode && _isUint8Array(chunk);
  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }
  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }
  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};
Writable.prototype.cork = function () {
  var state = this._writableState;
  state.corked++;
};
Writable.prototype.uncork = function () {
  var state = this._writableState;
  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};
Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};
function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}
Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;
  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }
  return ret;
}
function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}
function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;
  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    pna.nextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    pna.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}
function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}
function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);
    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }
    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}
function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;
  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }
    if (entry === null) state.lastBufferedRequest = null;
  }
  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}
Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};
Writable.prototype._writev = null;
Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;
  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }
  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending) endWritable(this, state, cb);
};
function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      stream.emit('error', err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      pna.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}
function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }
  return need;
}
function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}
function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }

  // reuse the free corkReq.
  state.corkedRequestsFree.next = corkReq;
}
Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function get() {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("timers").setImmediate)
},{"./_stream_duplex":372,"./internal/streams/destroy":378,"./internal/streams/stream":379,"_process":363,"core-util-is":143,"inherits":327,"process-nextick-args":362,"safe-buffer":384,"timers":419,"util-deprecate":422}],377:[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
var Buffer = require('safe-buffer').Buffer;
var util = require('util');
function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}
module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);
    this.head = null;
    this.tail = null;
    this.length = 0;
  }
  BufferList.prototype.push = function push(v) {
    var entry = {
      data: v,
      next: null
    };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };
  BufferList.prototype.unshift = function unshift(v) {
    var entry = {
      data: v,
      next: this.head
    };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };
  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };
  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };
  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }
    return ret;
  };
  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };
  return BufferList;
}();
if (util && util.inspect && util.inspect.custom) {
  module.exports.prototype[util.inspect.custom] = function () {
    var obj = util.inspect({
      length: this.length
    });
    return this.constructor.name + ' ' + obj;
  };
}

},{"safe-buffer":384,"util":105}],378:[function(require,module,exports){
'use strict';

/*<replacement>*/
var pna = require('process-nextick-args');
/*</replacement>*/

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;
  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;
  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err) {
      if (!this._writableState) {
        pna.nextTick(emitErrorNT, this, err);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        pna.nextTick(emitErrorNT, this, err);
      }
    }
    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }
  this._destroy(err || null, function (err) {
    if (!cb && err) {
      if (!_this._writableState) {
        pna.nextTick(emitErrorNT, _this, err);
      } else if (!_this._writableState.errorEmitted) {
        _this._writableState.errorEmitted = true;
        pna.nextTick(emitErrorNT, _this, err);
      }
    } else if (cb) {
      cb(err);
    }
  });
  return this;
}
function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }
  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}
function emitErrorNT(self, err) {
  self.emit('error', err);
}
module.exports = {
  destroy: destroy,
  undestroy: undestroy
};

},{"process-nextick-args":362}],379:[function(require,module,exports){
"use strict";

module.exports = require('events').EventEmitter;

},{"events":301}],380:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/
var Buffer = require('safe-buffer').Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
    case 'raw':
      return true;
    default:
      return false;
  }
};
function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
}
;

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}
StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};
StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(_byte) {
  if (_byte <= 0x7F) return 0;else if (_byte >> 5 === 0x06) return 2;else if (_byte >> 4 === 0x0E) return 3;else if (_byte >> 3 === 0x1E) return 4;
  return _byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return "\uFFFD";
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return "\uFFFD";
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return "\uFFFD";
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + "\uFFFD";
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}
function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}
function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}
function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}

},{"safe-buffer":384}],381:[function(require,module,exports){
"use strict";

exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

},{"./lib/_stream_duplex.js":372,"./lib/_stream_passthrough.js":373,"./lib/_stream_readable.js":374,"./lib/_stream_transform.js":375,"./lib/_stream_writable.js":376}],382:[function(require,module,exports){
'use strict';

var Buffer = require('buffer').Buffer;
var inherits = require('inherits');
var HashBase = require('hash-base');
var ARRAY16 = new Array(16);
var zl = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13];
var zr = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11];
var sl = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6];
var sr = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];
var hl = [0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e];
var hr = [0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000];
function RIPEMD160() {
  HashBase.call(this, 64);

  // state
  this._a = 0x67452301;
  this._b = 0xefcdab89;
  this._c = 0x98badcfe;
  this._d = 0x10325476;
  this._e = 0xc3d2e1f0;
}
inherits(RIPEMD160, HashBase);
RIPEMD160.prototype._update = function () {
  var words = ARRAY16;
  for (var j = 0; j < 16; ++j) words[j] = this._block.readInt32LE(j * 4);
  var al = this._a | 0;
  var bl = this._b | 0;
  var cl = this._c | 0;
  var dl = this._d | 0;
  var el = this._e | 0;
  var ar = this._a | 0;
  var br = this._b | 0;
  var cr = this._c | 0;
  var dr = this._d | 0;
  var er = this._e | 0;

  // computation
  for (var i = 0; i < 80; i += 1) {
    var tl;
    var tr;
    if (i < 16) {
      tl = fn1(al, bl, cl, dl, el, words[zl[i]], hl[0], sl[i]);
      tr = fn5(ar, br, cr, dr, er, words[zr[i]], hr[0], sr[i]);
    } else if (i < 32) {
      tl = fn2(al, bl, cl, dl, el, words[zl[i]], hl[1], sl[i]);
      tr = fn4(ar, br, cr, dr, er, words[zr[i]], hr[1], sr[i]);
    } else if (i < 48) {
      tl = fn3(al, bl, cl, dl, el, words[zl[i]], hl[2], sl[i]);
      tr = fn3(ar, br, cr, dr, er, words[zr[i]], hr[2], sr[i]);
    } else if (i < 64) {
      tl = fn4(al, bl, cl, dl, el, words[zl[i]], hl[3], sl[i]);
      tr = fn2(ar, br, cr, dr, er, words[zr[i]], hr[3], sr[i]);
    } else {
      // if (i<80) {
      tl = fn5(al, bl, cl, dl, el, words[zl[i]], hl[4], sl[i]);
      tr = fn1(ar, br, cr, dr, er, words[zr[i]], hr[4], sr[i]);
    }
    al = el;
    el = dl;
    dl = rotl(cl, 10);
    cl = bl;
    bl = tl;
    ar = er;
    er = dr;
    dr = rotl(cr, 10);
    cr = br;
    br = tr;
  }

  // update state
  var t = this._b + cl + dr | 0;
  this._b = this._c + dl + er | 0;
  this._c = this._d + el + ar | 0;
  this._d = this._e + al + br | 0;
  this._e = this._a + bl + cr | 0;
  this._a = t;
};
RIPEMD160.prototype._digest = function () {
  // create padding and handle blocks
  this._block[this._blockOffset++] = 0x80;
  if (this._blockOffset > 56) {
    this._block.fill(0, this._blockOffset, 64);
    this._update();
    this._blockOffset = 0;
  }
  this._block.fill(0, this._blockOffset, 56);
  this._block.writeUInt32LE(this._length[0], 56);
  this._block.writeUInt32LE(this._length[1], 60);
  this._update();

  // produce result
  var buffer = Buffer.alloc ? Buffer.alloc(20) : new Buffer(20);
  buffer.writeInt32LE(this._a, 0);
  buffer.writeInt32LE(this._b, 4);
  buffer.writeInt32LE(this._c, 8);
  buffer.writeInt32LE(this._d, 12);
  buffer.writeInt32LE(this._e, 16);
  return buffer;
};
function rotl(x, n) {
  return x << n | x >>> 32 - n;
}
function fn1(a, b, c, d, e, m, k, s) {
  return rotl(a + (b ^ c ^ d) + m + k | 0, s) + e | 0;
}
function fn2(a, b, c, d, e, m, k, s) {
  return rotl(a + (b & c | ~b & d) + m + k | 0, s) + e | 0;
}
function fn3(a, b, c, d, e, m, k, s) {
  return rotl(a + ((b | ~c) ^ d) + m + k | 0, s) + e | 0;
}
function fn4(a, b, c, d, e, m, k, s) {
  return rotl(a + (b & d | c & ~d) + m + k | 0, s) + e | 0;
}
function fn5(a, b, c, d, e, m, k, s) {
  return rotl(a + (b ^ (c | ~d)) + m + k | 0, s) + e | 0;
}
module.exports = RIPEMD160;

},{"buffer":139,"hash-base":311,"inherits":327}],383:[function(require,module,exports){
"use strict";

var assert = require('assert');
var Buffer = require('safe-buffer').Buffer;
/**
 * RLP Encoding based on: https://github.com/ethereum/wiki/wiki/%5BEnglish%5D-RLP
 * This function takes in a data, convert it to buffer if not, and a length for recursion
 *
 * @param {Buffer,String,Integer,Array} data - will be converted to buffer
 * @returns {Buffer} - returns buffer of encoded data
 **/
exports.encode = function (input) {
  if (input instanceof Array) {
    var output = [];
    for (var i = 0; i < input.length; i++) {
      output.push(exports.encode(input[i]));
    }
    var buf = Buffer.concat(output);
    return Buffer.concat([encodeLength(buf.length, 192), buf]);
  } else {
    input = toBuffer(input);
    if (input.length === 1 && input[0] < 128) {
      return input;
    } else {
      return Buffer.concat([encodeLength(input.length, 128), input]);
    }
  }
};
function safeParseInt(v, base) {
  if (v.slice(0, 2) === '00') {
    throw new Error('invalid RLP: extra zeros');
  }
  return parseInt(v, base);
}
function encodeLength(len, offset) {
  if (len < 56) {
    return Buffer.from([len + offset]);
  } else {
    var hexLength = intToHex(len);
    var lLength = hexLength.length / 2;
    var firstByte = intToHex(offset + 55 + lLength);
    return Buffer.from(firstByte + hexLength, 'hex');
  }
}

/**
 * RLP Decoding based on: {@link https://github.com/ethereum/wiki/wiki/%5BEnglish%5D-RLP|RLP}
 * @param {Buffer,String,Integer,Array} data - will be converted to buffer
 * @returns {Array} - returns decode Array of Buffers containg the original message
 **/
exports.decode = function (input, stream) {
  if (!input || input.length === 0) {
    return Buffer.from([]);
  }
  input = toBuffer(input);
  var decoded = _decode(input);
  if (stream) {
    return decoded;
  }
  assert.equal(decoded.remainder.length, 0, 'invalid remainder');
  return decoded.data;
};
exports.getLength = function (input) {
  if (!input || input.length === 0) {
    return Buffer.from([]);
  }
  input = toBuffer(input);
  var firstByte = input[0];
  if (firstByte <= 0x7f) {
    return input.length;
  } else if (firstByte <= 0xb7) {
    return firstByte - 0x7f;
  } else if (firstByte <= 0xbf) {
    return firstByte - 0xb6;
  } else if (firstByte <= 0xf7) {
    // a list between  0-55 bytes long
    return firstByte - 0xbf;
  } else {
    // a list  over 55 bytes long
    var llength = firstByte - 0xf6;
    var length = safeParseInt(input.slice(1, llength).toString('hex'), 16);
    return llength + length;
  }
};
function _decode(input) {
  var length, llength, data, innerRemainder, d;
  var decoded = [];
  var firstByte = input[0];
  if (firstByte <= 0x7f) {
    // a single byte whose value is in the [0x00, 0x7f] range, that byte is its own RLP encoding.
    return {
      data: input.slice(0, 1),
      remainder: input.slice(1)
    };
  } else if (firstByte <= 0xb7) {
    // string is 0-55 bytes long. A single byte with value 0x80 plus the length of the string followed by the string
    // The range of the first byte is [0x80, 0xb7]
    length = firstByte - 0x7f;

    // set 0x80 null to 0
    if (firstByte === 0x80) {
      data = Buffer.from([]);
    } else {
      data = input.slice(1, length);
    }
    if (length === 2 && data[0] < 0x80) {
      throw new Error('invalid rlp encoding: byte must be less 0x80');
    }
    return {
      data: data,
      remainder: input.slice(length)
    };
  } else if (firstByte <= 0xbf) {
    llength = firstByte - 0xb6;
    length = safeParseInt(input.slice(1, llength).toString('hex'), 16);
    data = input.slice(llength, length + llength);
    if (data.length < length) {
      throw new Error('invalid RLP');
    }
    return {
      data: data,
      remainder: input.slice(length + llength)
    };
  } else if (firstByte <= 0xf7) {
    // a list between  0-55 bytes long
    length = firstByte - 0xbf;
    innerRemainder = input.slice(1, length);
    while (innerRemainder.length) {
      d = _decode(innerRemainder);
      decoded.push(d.data);
      innerRemainder = d.remainder;
    }
    return {
      data: decoded,
      remainder: input.slice(length)
    };
  } else {
    // a list  over 55 bytes long
    llength = firstByte - 0xf6;
    length = safeParseInt(input.slice(1, llength).toString('hex'), 16);
    var totalLength = llength + length;
    if (totalLength > input.length) {
      throw new Error('invalid rlp: total length is larger than the data');
    }
    innerRemainder = input.slice(llength, totalLength);
    if (innerRemainder.length === 0) {
      throw new Error('invalid rlp, List has a invalid length');
    }
    while (innerRemainder.length) {
      d = _decode(innerRemainder);
      decoded.push(d.data);
      innerRemainder = d.remainder;
    }
    return {
      data: decoded,
      remainder: input.slice(totalLength)
    };
  }
}
function isHexPrefixed(str) {
  return str.slice(0, 2) === '0x';
}

// Removes 0x from a given String
function stripHexPrefix(str) {
  if (typeof str !== 'string') {
    return str;
  }
  return isHexPrefixed(str) ? str.slice(2) : str;
}
function intToHex(i) {
  var hex = i.toString(16);
  if (hex.length % 2) {
    hex = '0' + hex;
  }
  return hex;
}
function padToEven(a) {
  if (a.length % 2) a = '0' + a;
  return a;
}
function intToBuffer(i) {
  var hex = intToHex(i);
  return Buffer.from(hex, 'hex');
}
function toBuffer(v) {
  if (!Buffer.isBuffer(v)) {
    if (typeof v === 'string') {
      if (isHexPrefixed(v)) {
        v = Buffer.from(padToEven(stripHexPrefix(v)), 'hex');
      } else {
        v = Buffer.from(v);
      }
    } else if (typeof v === 'number') {
      if (!v) {
        v = Buffer.from([]);
      } else {
        v = intToBuffer(v);
      }
    } else if (v === null || v === undefined) {
      v = Buffer.from([]);
    } else if (v.toArray) {
      // converts a BN to a Buffer
      v = Buffer.from(v.toArray());
    } else {
      throw new Error('invalid type');
    }
  }
  return v;
}

},{"assert":97,"safe-buffer":384}],384:[function(require,module,exports){
"use strict";

/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer');
var Buffer = buffer.Buffer;

// alternative to using Object.keys for old browsers
function copyProps(src, dst) {
  for (var key in src) {
    dst[key] = src[key];
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer;
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports);
  exports.Buffer = SafeBuffer;
}
function SafeBuffer(arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length);
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer);
SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number');
  }
  return Buffer(arg, encodingOrOffset, length);
};
SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }
  var buf = Buffer(size);
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding);
    } else {
      buf.fill(fill);
    }
  } else {
    buf.fill(0);
  }
  return buf;
};
SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }
  return Buffer(size);
};
SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }
  return buffer.SlowBuffer(size);
};

},{"buffer":139}],385:[function(require,module,exports){
(function (setImmediate){(function (){
"use strict";

(function (root) {
  var MAX_VALUE = 0x7fffffff;

  // The SHA256 and PBKDF2 implementation are from scrypt-async-js:
  // See: https://github.com/dchest/scrypt-async-js
  function SHA256(m) {
    var K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];
    var h0 = 0x6a09e667,
      h1 = 0xbb67ae85,
      h2 = 0x3c6ef372,
      h3 = 0xa54ff53a;
    var h4 = 0x510e527f,
      h5 = 0x9b05688c,
      h6 = 0x1f83d9ab,
      h7 = 0x5be0cd19;
    var w = new Array(64);
    function blocks(p) {
      var off = 0,
        len = p.length;
      while (len >= 64) {
        var a = h0,
          b = h1,
          c = h2,
          d = h3,
          e = h4,
          f = h5,
          g = h6,
          h = h7,
          u,
          i,
          j,
          t1,
          t2;
        for (i = 0; i < 16; i++) {
          j = off + i * 4;
          w[i] = (p[j] & 0xff) << 24 | (p[j + 1] & 0xff) << 16 | (p[j + 2] & 0xff) << 8 | p[j + 3] & 0xff;
        }
        for (i = 16; i < 64; i++) {
          u = w[i - 2];
          t1 = (u >>> 17 | u << 32 - 17) ^ (u >>> 19 | u << 32 - 19) ^ u >>> 10;
          u = w[i - 15];
          t2 = (u >>> 7 | u << 32 - 7) ^ (u >>> 18 | u << 32 - 18) ^ u >>> 3;
          w[i] = (t1 + w[i - 7] | 0) + (t2 + w[i - 16] | 0) | 0;
        }
        for (i = 0; i < 64; i++) {
          t1 = (((e >>> 6 | e << 32 - 6) ^ (e >>> 11 | e << 32 - 11) ^ (e >>> 25 | e << 32 - 25)) + (e & f ^ ~e & g) | 0) + (h + (K[i] + w[i] | 0) | 0) | 0;
          t2 = ((a >>> 2 | a << 32 - 2) ^ (a >>> 13 | a << 32 - 13) ^ (a >>> 22 | a << 32 - 22)) + (a & b ^ a & c ^ b & c) | 0;
          h = g;
          g = f;
          f = e;
          e = d + t1 | 0;
          d = c;
          c = b;
          b = a;
          a = t1 + t2 | 0;
        }
        h0 = h0 + a | 0;
        h1 = h1 + b | 0;
        h2 = h2 + c | 0;
        h3 = h3 + d | 0;
        h4 = h4 + e | 0;
        h5 = h5 + f | 0;
        h6 = h6 + g | 0;
        h7 = h7 + h | 0;
        off += 64;
        len -= 64;
      }
    }
    blocks(m);
    var i,
      bytesLeft = m.length % 64,
      bitLenHi = m.length / 0x20000000 | 0,
      bitLenLo = m.length << 3,
      numZeros = bytesLeft < 56 ? 56 : 120,
      p = m.slice(m.length - bytesLeft, m.length);
    p.push(0x80);
    for (i = bytesLeft + 1; i < numZeros; i++) {
      p.push(0);
    }
    p.push(bitLenHi >>> 24 & 0xff);
    p.push(bitLenHi >>> 16 & 0xff);
    p.push(bitLenHi >>> 8 & 0xff);
    p.push(bitLenHi >>> 0 & 0xff);
    p.push(bitLenLo >>> 24 & 0xff);
    p.push(bitLenLo >>> 16 & 0xff);
    p.push(bitLenLo >>> 8 & 0xff);
    p.push(bitLenLo >>> 0 & 0xff);
    blocks(p);
    return [h0 >>> 24 & 0xff, h0 >>> 16 & 0xff, h0 >>> 8 & 0xff, h0 >>> 0 & 0xff, h1 >>> 24 & 0xff, h1 >>> 16 & 0xff, h1 >>> 8 & 0xff, h1 >>> 0 & 0xff, h2 >>> 24 & 0xff, h2 >>> 16 & 0xff, h2 >>> 8 & 0xff, h2 >>> 0 & 0xff, h3 >>> 24 & 0xff, h3 >>> 16 & 0xff, h3 >>> 8 & 0xff, h3 >>> 0 & 0xff, h4 >>> 24 & 0xff, h4 >>> 16 & 0xff, h4 >>> 8 & 0xff, h4 >>> 0 & 0xff, h5 >>> 24 & 0xff, h5 >>> 16 & 0xff, h5 >>> 8 & 0xff, h5 >>> 0 & 0xff, h6 >>> 24 & 0xff, h6 >>> 16 & 0xff, h6 >>> 8 & 0xff, h6 >>> 0 & 0xff, h7 >>> 24 & 0xff, h7 >>> 16 & 0xff, h7 >>> 8 & 0xff, h7 >>> 0 & 0xff];
  }
  function PBKDF2_HMAC_SHA256_OneIter(password, salt, dkLen) {
    // compress password if it's longer than hash block length
    password = password.length <= 64 ? password : SHA256(password);
    var i;
    var innerLen = 64 + salt.length + 4;
    var inner = new Array(innerLen);
    var outerKey = new Array(64);
    var dk = [];

    // inner = (password ^ ipad) || salt || counter
    for (i = 0; i < 64; i++) inner[i] = 0x36;
    for (i = 0; i < password.length; i++) inner[i] ^= password[i];
    for (i = 0; i < salt.length; i++) inner[64 + i] = salt[i];
    for (i = innerLen - 4; i < innerLen; i++) inner[i] = 0;

    // outerKey = password ^ opad
    for (i = 0; i < 64; i++) outerKey[i] = 0x5c;
    for (i = 0; i < password.length; i++) outerKey[i] ^= password[i];

    // increments counter inside inner
    function incrementCounter() {
      for (var i = innerLen - 1; i >= innerLen - 4; i--) {
        inner[i]++;
        if (inner[i] <= 0xff) return;
        inner[i] = 0;
      }
    }

    // output blocks = SHA256(outerKey || SHA256(inner)) ...
    while (dkLen >= 32) {
      incrementCounter();
      dk = dk.concat(SHA256(outerKey.concat(SHA256(inner))));
      dkLen -= 32;
    }
    if (dkLen > 0) {
      incrementCounter();
      dk = dk.concat(SHA256(outerKey.concat(SHA256(inner))).slice(0, dkLen));
    }
    return dk;
  }

  // The following is an adaptation of scryptsy
  // See: https://www.npmjs.com/package/scryptsy
  function blockmix_salsa8(BY, Yi, r, x, _X) {
    var i;
    arraycopy(BY, (2 * r - 1) * 16, _X, 0, 16);
    for (i = 0; i < 2 * r; i++) {
      blockxor(BY, i * 16, _X, 16);
      salsa20_8(_X, x);
      arraycopy(_X, 0, BY, Yi + i * 16, 16);
    }
    for (i = 0; i < r; i++) {
      arraycopy(BY, Yi + i * 2 * 16, BY, i * 16, 16);
    }
    for (i = 0; i < r; i++) {
      arraycopy(BY, Yi + (i * 2 + 1) * 16, BY, (i + r) * 16, 16);
    }
  }
  function R(a, b) {
    return a << b | a >>> 32 - b;
  }
  function salsa20_8(B, x) {
    arraycopy(B, 0, x, 0, 16);
    for (var i = 8; i > 0; i -= 2) {
      x[4] ^= R(x[0] + x[12], 7);
      x[8] ^= R(x[4] + x[0], 9);
      x[12] ^= R(x[8] + x[4], 13);
      x[0] ^= R(x[12] + x[8], 18);
      x[9] ^= R(x[5] + x[1], 7);
      x[13] ^= R(x[9] + x[5], 9);
      x[1] ^= R(x[13] + x[9], 13);
      x[5] ^= R(x[1] + x[13], 18);
      x[14] ^= R(x[10] + x[6], 7);
      x[2] ^= R(x[14] + x[10], 9);
      x[6] ^= R(x[2] + x[14], 13);
      x[10] ^= R(x[6] + x[2], 18);
      x[3] ^= R(x[15] + x[11], 7);
      x[7] ^= R(x[3] + x[15], 9);
      x[11] ^= R(x[7] + x[3], 13);
      x[15] ^= R(x[11] + x[7], 18);
      x[1] ^= R(x[0] + x[3], 7);
      x[2] ^= R(x[1] + x[0], 9);
      x[3] ^= R(x[2] + x[1], 13);
      x[0] ^= R(x[3] + x[2], 18);
      x[6] ^= R(x[5] + x[4], 7);
      x[7] ^= R(x[6] + x[5], 9);
      x[4] ^= R(x[7] + x[6], 13);
      x[5] ^= R(x[4] + x[7], 18);
      x[11] ^= R(x[10] + x[9], 7);
      x[8] ^= R(x[11] + x[10], 9);
      x[9] ^= R(x[8] + x[11], 13);
      x[10] ^= R(x[9] + x[8], 18);
      x[12] ^= R(x[15] + x[14], 7);
      x[13] ^= R(x[12] + x[15], 9);
      x[14] ^= R(x[13] + x[12], 13);
      x[15] ^= R(x[14] + x[13], 18);
    }
    for (i = 0; i < 16; ++i) {
      B[i] += x[i];
    }
  }

  // naive approach... going back to loop unrolling may yield additional performance
  function blockxor(S, Si, D, len) {
    for (var i = 0; i < len; i++) {
      D[i] ^= S[Si + i];
    }
  }
  function arraycopy(src, srcPos, dest, destPos, length) {
    while (length--) {
      dest[destPos++] = src[srcPos++];
    }
  }
  function checkBufferish(o) {
    if (!o || typeof o.length !== 'number') {
      return false;
    }
    for (var i = 0; i < o.length; i++) {
      if (typeof o[i] !== 'number') {
        return false;
      }
      var v = parseInt(o[i]);
      if (v != o[i] || v < 0 || v >= 256) {
        return false;
      }
    }
    return true;
  }
  function ensureInteger(value, name) {
    var intValue = parseInt(value);
    if (value != intValue) {
      throw new Error('invalid ' + name);
    }
    return intValue;
  }

  // N = Cpu cost, r = Memory cost, p = parallelization cost
  // callback(error, progress, key)
  function scrypt(password, salt, N, r, p, dkLen, callback) {
    if (!callback) {
      throw new Error('missing callback');
    }
    N = ensureInteger(N, 'N');
    r = ensureInteger(r, 'r');
    p = ensureInteger(p, 'p');
    dkLen = ensureInteger(dkLen, 'dkLen');
    if (N === 0 || (N & N - 1) !== 0) {
      throw new Error('N must be power of 2');
    }
    if (N > MAX_VALUE / 128 / r) {
      throw new Error('N too large');
    }
    if (r > MAX_VALUE / 128 / p) {
      throw new Error('r too large');
    }
    if (!checkBufferish(password)) {
      throw new Error('password must be an array or buffer');
    }
    password = Array.prototype.slice.call(password);
    if (!checkBufferish(salt)) {
      throw new Error('salt must be an array or buffer');
    }
    salt = Array.prototype.slice.call(salt);
    var b = PBKDF2_HMAC_SHA256_OneIter(password, salt, p * 128 * r);
    var B = new Uint32Array(p * 32 * r);
    for (var i = 0; i < B.length; i++) {
      var j = i * 4;
      B[i] = (b[j + 3] & 0xff) << 24 | (b[j + 2] & 0xff) << 16 | (b[j + 1] & 0xff) << 8 | (b[j + 0] & 0xff) << 0;
    }
    var XY = new Uint32Array(64 * r);
    var V = new Uint32Array(32 * r * N);
    var Yi = 32 * r;

    // scratch space
    var x = new Uint32Array(16); // salsa20_8
    var _X = new Uint32Array(16); // blockmix_salsa8

    var totalOps = p * N * 2;
    var currentOp = 0;
    var lastPercent10 = null;

    // Set this to true to abandon the scrypt on the next step
    var stop = false;

    // State information
    var state = 0;
    var i0 = 0,
      i1;
    var Bi;

    // How many blockmix_salsa8 can we do per step?
    var limit = parseInt(1000 / r);

    // Trick from scrypt-async; if there is a setImmediate shim in place, use it
    var nextTick = typeof setImmediate !== 'undefined' ? setImmediate : setTimeout;

    // This is really all I changed; making scryptsy a state machine so we occasionally
    // stop and give other evnts on the evnt loop a chance to run. ~RicMoo
    var incrementalSMix = function incrementalSMix() {
      if (stop) {
        return callback(new Error('cancelled'), currentOp / totalOps);
      }
      switch (state) {
        case 0:
          // for (var i = 0; i < p; i++)...
          Bi = i0 * 32 * r;
          arraycopy(B, Bi, XY, 0, Yi); // ROMix - 1

          state = 1; // Move to ROMix 2
          i1 = 0;

        // Fall through

        case 1:
          // Run up to 1000 steps of the first inner smix loop
          var steps = N - i1;
          if (steps > limit) {
            steps = limit;
          }
          for (var i = 0; i < steps; i++) {
            // ROMix - 2
            arraycopy(XY, 0, V, (i1 + i) * Yi, Yi); // ROMix - 3
            blockmix_salsa8(XY, Yi, r, x, _X); // ROMix - 4
          }

          // for (var i = 0; i < N; i++)
          i1 += steps;
          currentOp += steps;

          // Call the callback with the progress (optionally stopping us)
          var percent10 = parseInt(1000 * currentOp / totalOps);
          if (percent10 !== lastPercent10) {
            stop = callback(null, currentOp / totalOps);
            if (stop) {
              break;
            }
            lastPercent10 = percent10;
          }
          if (i1 < N) {
            break;
          }
          i1 = 0; // Move to ROMix 6
          state = 2;

        // Fall through

        case 2:
          // Run up to 1000 steps of the second inner smix loop
          var steps = N - i1;
          if (steps > limit) {
            steps = limit;
          }
          for (var i = 0; i < steps; i++) {
            // ROMix - 6
            var offset = (2 * r - 1) * 16; // ROMix - 7
            var j = XY[offset] & N - 1;
            blockxor(V, j * Yi, XY, Yi); // ROMix - 8 (inner)
            blockmix_salsa8(XY, Yi, r, x, _X); // ROMix - 9 (outer)
          }

          // for (var i = 0; i < N; i++)...
          i1 += steps;
          currentOp += steps;

          // Call the callback with the progress (optionally stopping us)
          var percent10 = parseInt(1000 * currentOp / totalOps);
          if (percent10 !== lastPercent10) {
            stop = callback(null, currentOp / totalOps);
            if (stop) {
              break;
            }
            lastPercent10 = percent10;
          }
          if (i1 < N) {
            break;
          }
          arraycopy(XY, 0, B, Bi, Yi); // ROMix - 10

          // for (var i = 0; i < p; i++)...
          i0++;
          if (i0 < p) {
            state = 0;
            break;
          }
          b = [];
          for (var i = 0; i < B.length; i++) {
            b.push(B[i] >> 0 & 0xff);
            b.push(B[i] >> 8 & 0xff);
            b.push(B[i] >> 16 & 0xff);
            b.push(B[i] >> 24 & 0xff);
          }
          var derivedKey = PBKDF2_HMAC_SHA256_OneIter(password, b, dkLen);

          // Done; don't break (which would reschedule)
          return callback(null, 1.0, derivedKey);
      }

      // Schedule the next steps
      nextTick(incrementalSMix);
    };

    // Bootstrap the incremental smix
    incrementalSMix();
  }

  // node.js
  if (typeof exports !== 'undefined') {
    module.exports = scrypt;

    // RequireJS/AMD
    // http://www.requirejs.org/docs/api.html
    // https://github.com/amdjs/amdjs-api/wiki/AMD
  } else if (typeof define === 'function' && define.amd) {
    define(scrypt);

    // Web Browsers
  } else if (root) {
    // If there was an existing library "scrypt", make sure it is still available
    if (root.scrypt) {
      root._scrypt = root.scrypt;
    }
    root.scrypt = scrypt;
  }
})(void 0);

}).call(this)}).call(this,require("timers").setImmediate)
},{"timers":419}],386:[function(require,module,exports){
'use strict';

module.exports = require('./lib')(require('./lib/elliptic'));

},{"./lib":390,"./lib/elliptic":389}],387:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';

var toString = Object.prototype.toString;

// TypeError
exports.isArray = function (value, message) {
  if (!Array.isArray(value)) throw TypeError(message);
};
exports.isBoolean = function (value, message) {
  if (toString.call(value) !== '[object Boolean]') throw TypeError(message);
};
exports.isBuffer = function (value, message) {
  if (!Buffer.isBuffer(value)) throw TypeError(message);
};
exports.isFunction = function (value, message) {
  if (toString.call(value) !== '[object Function]') throw TypeError(message);
};
exports.isNumber = function (value, message) {
  if (toString.call(value) !== '[object Number]') throw TypeError(message);
};
exports.isObject = function (value, message) {
  if (toString.call(value) !== '[object Object]') throw TypeError(message);
};

// RangeError
exports.isBufferLength = function (buffer, length, message) {
  if (buffer.length !== length) throw RangeError(message);
};
exports.isBufferLength2 = function (buffer, length1, length2, message) {
  if (buffer.length !== length1 && buffer.length !== length2) throw RangeError(message);
};
exports.isLengthGTZero = function (value, message) {
  if (value.length === 0) throw RangeError(message);
};
exports.isNumberInInterval = function (number, x, y, message) {
  if (number <= x || number >= y) throw RangeError(message);
};

}).call(this)}).call(this,{"isBuffer":require("../../is-buffer/index.js")})
},{"../../is-buffer/index.js":329}],388:[function(require,module,exports){
'use strict';

var Buffer = require('safe-buffer').Buffer;
var bip66 = require('bip66');
var EC_PRIVKEY_EXPORT_DER_COMPRESSED = Buffer.from([
// begin
0x30, 0x81, 0xd3, 0x02, 0x01, 0x01, 0x04, 0x20,
// private key
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
// middle
0xa0, 0x81, 0x85, 0x30, 0x81, 0x82, 0x02, 0x01, 0x01, 0x30, 0x2c, 0x06, 0x07, 0x2a, 0x86, 0x48, 0xcE, 0x3d, 0x01, 0x01, 0x02, 0x21, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfE, 0xff, 0xff, 0xfc, 0x2f, 0x30, 0x06, 0x04, 0x01, 0x00, 0x04, 0x01, 0x07, 0x04, 0x21, 0x02, 0x79, 0xbE, 0x66, 0x7E, 0xf9, 0xdc, 0xbb, 0xac, 0x55, 0xa0, 0x62, 0x95, 0xcE, 0x87, 0x0b, 0x07, 0x02, 0x9b, 0xfc, 0xdb, 0x2d, 0xcE, 0x28, 0xd9, 0x59, 0xf2, 0x81, 0x5b, 0x16, 0xf8, 0x17, 0x98, 0x02, 0x21, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfE, 0xba, 0xaE, 0xdc, 0xE6, 0xaf, 0x48, 0xa0, 0x3b, 0xbf, 0xd2, 0x5E, 0x8c, 0xd0, 0x36, 0x41, 0x41, 0x02, 0x01, 0x01, 0xa1, 0x24, 0x03, 0x22, 0x00,
// public key
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);
var EC_PRIVKEY_EXPORT_DER_UNCOMPRESSED = Buffer.from([
// begin
0x30, 0x82, 0x01, 0x13, 0x02, 0x01, 0x01, 0x04, 0x20,
// private key
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
// middle
0xa0, 0x81, 0xa5, 0x30, 0x81, 0xa2, 0x02, 0x01, 0x01, 0x30, 0x2c, 0x06, 0x07, 0x2a, 0x86, 0x48, 0xcE, 0x3d, 0x01, 0x01, 0x02, 0x21, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfE, 0xff, 0xff, 0xfc, 0x2f, 0x30, 0x06, 0x04, 0x01, 0x00, 0x04, 0x01, 0x07, 0x04, 0x41, 0x04, 0x79, 0xbE, 0x66, 0x7E, 0xf9, 0xdc, 0xbb, 0xac, 0x55, 0xa0, 0x62, 0x95, 0xcE, 0x87, 0x0b, 0x07, 0x02, 0x9b, 0xfc, 0xdb, 0x2d, 0xcE, 0x28, 0xd9, 0x59, 0xf2, 0x81, 0x5b, 0x16, 0xf8, 0x17, 0x98, 0x48, 0x3a, 0xda, 0x77, 0x26, 0xa3, 0xc4, 0x65, 0x5d, 0xa4, 0xfb, 0xfc, 0x0E, 0x11, 0x08, 0xa8, 0xfd, 0x17, 0xb4, 0x48, 0xa6, 0x85, 0x54, 0x19, 0x9c, 0x47, 0xd0, 0x8f, 0xfb, 0x10, 0xd4, 0xb8, 0x02, 0x21, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfE, 0xba, 0xaE, 0xdc, 0xE6, 0xaf, 0x48, 0xa0, 0x3b, 0xbf, 0xd2, 0x5E, 0x8c, 0xd0, 0x36, 0x41, 0x41, 0x02, 0x01, 0x01, 0xa1, 0x44, 0x03, 0x42, 0x00,
// public key
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);
exports.privateKeyExport = function (privateKey, publicKey, compressed) {
  var result = Buffer.from(compressed ? EC_PRIVKEY_EXPORT_DER_COMPRESSED : EC_PRIVKEY_EXPORT_DER_UNCOMPRESSED);
  privateKey.copy(result, compressed ? 8 : 9);
  publicKey.copy(result, compressed ? 181 : 214);
  return result;
};
exports.privateKeyImport = function (privateKey) {
  var length = privateKey.length;

  // sequence header
  var index = 0;
  if (length < index + 1 || privateKey[index] !== 0x30) return;
  index += 1;

  // sequence length constructor
  if (length < index + 1 || !(privateKey[index] & 0x80)) return;
  var lenb = privateKey[index] & 0x7f;
  index += 1;
  if (lenb < 1 || lenb > 2) return;
  if (length < index + lenb) return;

  // sequence length
  var len = privateKey[index + lenb - 1] | (lenb > 1 ? privateKey[index + lenb - 2] << 8 : 0);
  index += lenb;
  if (length < index + len) return;

  // sequence element 0: version number (=1)
  if (length < index + 3 || privateKey[index] !== 0x02 || privateKey[index + 1] !== 0x01 || privateKey[index + 2] !== 0x01) {
    return;
  }
  index += 3;

  // sequence element 1: octet string, up to 32 bytes
  if (length < index + 2 || privateKey[index] !== 0x04 || privateKey[index + 1] > 0x20 || length < index + 2 + privateKey[index + 1]) {
    return;
  }
  return privateKey.slice(index + 2, index + 2 + privateKey[index + 1]);
};
exports.signatureExport = function (sigObj) {
  var r = Buffer.concat([Buffer.from([0]), sigObj.r]);
  for (var lenR = 33, posR = 0; lenR > 1 && r[posR] === 0x00 && !(r[posR + 1] & 0x80); --lenR, ++posR);
  var s = Buffer.concat([Buffer.from([0]), sigObj.s]);
  for (var lenS = 33, posS = 0; lenS > 1 && s[posS] === 0x00 && !(s[posS + 1] & 0x80); --lenS, ++posS);
  return bip66.encode(r.slice(posR), s.slice(posS));
};
exports.signatureImport = function (sig) {
  var r = Buffer.alloc(32, 0);
  var s = Buffer.alloc(32, 0);
  try {
    var sigObj = bip66.decode(sig);
    if (sigObj.r.length === 33 && sigObj.r[0] === 0x00) sigObj.r = sigObj.r.slice(1);
    if (sigObj.r.length > 32) throw new Error('R length is too long');
    if (sigObj.s.length === 33 && sigObj.s[0] === 0x00) sigObj.s = sigObj.s.slice(1);
    if (sigObj.s.length > 32) throw new Error('S length is too long');
  } catch (err) {
    return;
  }
  sigObj.r.copy(r, 32 - sigObj.r.length);
  sigObj.s.copy(s, 32 - sigObj.s.length);
  return {
    r: r,
    s: s
  };
};
exports.signatureImportLax = function (sig) {
  var r = Buffer.alloc(32, 0);
  var s = Buffer.alloc(32, 0);
  var length = sig.length;
  var index = 0;

  // sequence tag byte
  if (sig[index++] !== 0x30) return;

  // sequence length byte
  var lenbyte = sig[index++];
  if (lenbyte & 0x80) {
    index += lenbyte - 0x80;
    if (index > length) return;
  }

  // sequence tag byte for r
  if (sig[index++] !== 0x02) return;

  // length for r
  var rlen = sig[index++];
  if (rlen & 0x80) {
    lenbyte = rlen - 0x80;
    if (index + lenbyte > length) return;
    for (; lenbyte > 0 && sig[index] === 0x00; index += 1, lenbyte -= 1);
    for (rlen = 0; lenbyte > 0; index += 1, lenbyte -= 1) rlen = (rlen << 8) + sig[index];
  }
  if (rlen > length - index) return;
  var rindex = index;
  index += rlen;

  // sequence tag byte for s
  if (sig[index++] !== 0x02) return;

  // length for s
  var slen = sig[index++];
  if (slen & 0x80) {
    lenbyte = slen - 0x80;
    if (index + lenbyte > length) return;
    for (; lenbyte > 0 && sig[index] === 0x00; index += 1, lenbyte -= 1);
    for (slen = 0; lenbyte > 0; index += 1, lenbyte -= 1) slen = (slen << 8) + sig[index];
  }
  if (slen > length - index) return;
  var sindex = index;
  index += slen;

  // ignore leading zeros in r
  for (; rlen > 0 && sig[rindex] === 0x00; rlen -= 1, rindex += 1);
  // copy r value
  if (rlen > 32) return;
  var rvalue = sig.slice(rindex, rindex + rlen);
  rvalue.copy(r, 32 - rvalue.length);

  // ignore leading zeros in s
  for (; slen > 0 && sig[sindex] === 0x00; slen -= 1, sindex += 1);
  // copy s value
  if (slen > 32) return;
  var svalue = sig.slice(sindex, sindex + slen);
  svalue.copy(s, 32 - svalue.length);
  return {
    r: r,
    s: s
  };
};

},{"bip66":102,"safe-buffer":384}],389:[function(require,module,exports){
'use strict';

var Buffer = require('safe-buffer').Buffer;
var createHash = require('create-hash');
var BN = require('bn.js');
var EC = require('elliptic').ec;
var messages = require('../messages.json');
var ec = new EC('secp256k1');
var ecparams = ec.curve;
function loadCompressedPublicKey(first, xBuffer) {
  var x = new BN(xBuffer);

  // overflow
  if (x.cmp(ecparams.p) >= 0) return null;
  x = x.toRed(ecparams.red);

  // compute corresponding Y
  var y = x.redSqr().redIMul(x).redIAdd(ecparams.b).redSqrt();
  if (first === 0x03 !== y.isOdd()) y = y.redNeg();
  return ec.keyPair({
    pub: {
      x: x,
      y: y
    }
  });
}
function loadUncompressedPublicKey(first, xBuffer, yBuffer) {
  var x = new BN(xBuffer);
  var y = new BN(yBuffer);

  // overflow
  if (x.cmp(ecparams.p) >= 0 || y.cmp(ecparams.p) >= 0) return null;
  x = x.toRed(ecparams.red);
  y = y.toRed(ecparams.red);

  // is odd flag
  if ((first === 0x06 || first === 0x07) && y.isOdd() !== (first === 0x07)) return null;

  // x*x*x + b = y*y
  var x3 = x.redSqr().redIMul(x);
  if (!y.redSqr().redISub(x3.redIAdd(ecparams.b)).isZero()) return null;
  return ec.keyPair({
    pub: {
      x: x,
      y: y
    }
  });
}
function loadPublicKey(publicKey) {
  var first = publicKey[0];
  switch (first) {
    case 0x02:
    case 0x03:
      if (publicKey.length !== 33) return null;
      return loadCompressedPublicKey(first, publicKey.slice(1, 33));
    case 0x04:
    case 0x06:
    case 0x07:
      if (publicKey.length !== 65) return null;
      return loadUncompressedPublicKey(first, publicKey.slice(1, 33), publicKey.slice(33, 65));
    default:
      return null;
  }
}
exports.privateKeyVerify = function (privateKey) {
  var bn = new BN(privateKey);
  return bn.cmp(ecparams.n) < 0 && !bn.isZero();
};
exports.privateKeyExport = function (privateKey, compressed) {
  var d = new BN(privateKey);
  if (d.cmp(ecparams.n) >= 0 || d.isZero()) throw new Error(messages.EC_PRIVATE_KEY_EXPORT_DER_FAIL);
  return Buffer.from(ec.keyFromPrivate(privateKey).getPublic(compressed, true));
};
exports.privateKeyNegate = function (privateKey) {
  var bn = new BN(privateKey);
  return bn.isZero() ? Buffer.alloc(32) : ecparams.n.sub(bn).umod(ecparams.n).toArrayLike(Buffer, 'be', 32);
};
exports.privateKeyModInverse = function (privateKey) {
  var bn = new BN(privateKey);
  if (bn.cmp(ecparams.n) >= 0 || bn.isZero()) throw new Error(messages.EC_PRIVATE_KEY_RANGE_INVALID);
  return bn.invm(ecparams.n).toArrayLike(Buffer, 'be', 32);
};
exports.privateKeyTweakAdd = function (privateKey, tweak) {
  var bn = new BN(tweak);
  if (bn.cmp(ecparams.n) >= 0) throw new Error(messages.EC_PRIVATE_KEY_TWEAK_ADD_FAIL);
  bn.iadd(new BN(privateKey));
  if (bn.cmp(ecparams.n) >= 0) bn.isub(ecparams.n);
  if (bn.isZero()) throw new Error(messages.EC_PRIVATE_KEY_TWEAK_ADD_FAIL);
  return bn.toArrayLike(Buffer, 'be', 32);
};
exports.privateKeyTweakMul = function (privateKey, tweak) {
  var bn = new BN(tweak);
  if (bn.cmp(ecparams.n) >= 0 || bn.isZero()) throw new Error(messages.EC_PRIVATE_KEY_TWEAK_MUL_FAIL);
  bn.imul(new BN(privateKey));
  if (bn.cmp(ecparams.n)) bn = bn.umod(ecparams.n);
  return bn.toArrayLike(Buffer, 'be', 32);
};
exports.publicKeyCreate = function (privateKey, compressed) {
  var d = new BN(privateKey);
  if (d.cmp(ecparams.n) >= 0 || d.isZero()) throw new Error(messages.EC_PUBLIC_KEY_CREATE_FAIL);
  return Buffer.from(ec.keyFromPrivate(privateKey).getPublic(compressed, true));
};
exports.publicKeyConvert = function (publicKey, compressed) {
  var pair = loadPublicKey(publicKey);
  if (pair === null) throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL);
  return Buffer.from(pair.getPublic(compressed, true));
};
exports.publicKeyVerify = function (publicKey) {
  return loadPublicKey(publicKey) !== null;
};
exports.publicKeyTweakAdd = function (publicKey, tweak, compressed) {
  var pair = loadPublicKey(publicKey);
  if (pair === null) throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL);
  tweak = new BN(tweak);
  if (tweak.cmp(ecparams.n) >= 0) throw new Error(messages.EC_PUBLIC_KEY_TWEAK_ADD_FAIL);
  return Buffer.from(ecparams.g.mul(tweak).add(pair.pub).encode(true, compressed));
};
exports.publicKeyTweakMul = function (publicKey, tweak, compressed) {
  var pair = loadPublicKey(publicKey);
  if (pair === null) throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL);
  tweak = new BN(tweak);
  if (tweak.cmp(ecparams.n) >= 0 || tweak.isZero()) throw new Error(messages.EC_PUBLIC_KEY_TWEAK_MUL_FAIL);
  return Buffer.from(pair.pub.mul(tweak).encode(true, compressed));
};
exports.publicKeyCombine = function (publicKeys, compressed) {
  var pairs = new Array(publicKeys.length);
  for (var i = 0; i < publicKeys.length; ++i) {
    pairs[i] = loadPublicKey(publicKeys[i]);
    if (pairs[i] === null) throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL);
  }
  var point = pairs[0].pub;
  for (var j = 1; j < pairs.length; ++j) point = point.add(pairs[j].pub);
  if (point.isInfinity()) throw new Error(messages.EC_PUBLIC_KEY_COMBINE_FAIL);
  return Buffer.from(point.encode(true, compressed));
};
exports.signatureNormalize = function (signature) {
  var r = new BN(signature.slice(0, 32));
  var s = new BN(signature.slice(32, 64));
  if (r.cmp(ecparams.n) >= 0 || s.cmp(ecparams.n) >= 0) throw new Error(messages.ECDSA_SIGNATURE_PARSE_FAIL);
  var result = Buffer.from(signature);
  if (s.cmp(ec.nh) === 1) ecparams.n.sub(s).toArrayLike(Buffer, 'be', 32).copy(result, 32);
  return result;
};
exports.signatureExport = function (signature) {
  var r = signature.slice(0, 32);
  var s = signature.slice(32, 64);
  if (new BN(r).cmp(ecparams.n) >= 0 || new BN(s).cmp(ecparams.n) >= 0) throw new Error(messages.ECDSA_SIGNATURE_PARSE_FAIL);
  return {
    r: r,
    s: s
  };
};
exports.signatureImport = function (sigObj) {
  var r = new BN(sigObj.r);
  if (r.cmp(ecparams.n) >= 0) r = new BN(0);
  var s = new BN(sigObj.s);
  if (s.cmp(ecparams.n) >= 0) s = new BN(0);
  return Buffer.concat([r.toArrayLike(Buffer, 'be', 32), s.toArrayLike(Buffer, 'be', 32)]);
};
exports.sign = function (message, privateKey, noncefn, data) {
  if (typeof noncefn === 'function') {
    var getNonce = noncefn;
    noncefn = function noncefn(counter) {
      var nonce = getNonce(message, privateKey, null, data, counter);
      if (!Buffer.isBuffer(nonce) || nonce.length !== 32) throw new Error(messages.ECDSA_SIGN_FAIL);
      return new BN(nonce);
    };
  }
  var d = new BN(privateKey);
  if (d.cmp(ecparams.n) >= 0 || d.isZero()) throw new Error(messages.ECDSA_SIGN_FAIL);
  var result = ec.sign(message, privateKey, {
    canonical: true,
    k: noncefn,
    pers: data
  });
  return {
    signature: Buffer.concat([result.r.toArrayLike(Buffer, 'be', 32), result.s.toArrayLike(Buffer, 'be', 32)]),
    recovery: result.recoveryParam
  };
};
exports.verify = function (message, signature, publicKey) {
  var sigObj = {
    r: signature.slice(0, 32),
    s: signature.slice(32, 64)
  };
  var sigr = new BN(sigObj.r);
  var sigs = new BN(sigObj.s);
  if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0) throw new Error(messages.ECDSA_SIGNATURE_PARSE_FAIL);
  if (sigs.cmp(ec.nh) === 1 || sigr.isZero() || sigs.isZero()) return false;
  var pair = loadPublicKey(publicKey);
  if (pair === null) throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL);
  return ec.verify(message, sigObj, {
    x: pair.pub.x,
    y: pair.pub.y
  });
};
exports.recover = function (message, signature, recovery, compressed) {
  var sigObj = {
    r: signature.slice(0, 32),
    s: signature.slice(32, 64)
  };
  var sigr = new BN(sigObj.r);
  var sigs = new BN(sigObj.s);
  if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0) throw new Error(messages.ECDSA_SIGNATURE_PARSE_FAIL);
  try {
    if (sigr.isZero() || sigs.isZero()) throw new Error();
    var point = ec.recoverPubKey(message, sigObj, recovery);
    return Buffer.from(point.encode(true, compressed));
  } catch (err) {
    throw new Error(messages.ECDSA_RECOVER_FAIL);
  }
};
exports.ecdh = function (publicKey, privateKey) {
  var shared = exports.ecdhUnsafe(publicKey, privateKey, true);
  return createHash('sha256').update(shared).digest();
};
exports.ecdhUnsafe = function (publicKey, privateKey, compressed) {
  var pair = loadPublicKey(publicKey);
  if (pair === null) throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL);
  var scalar = new BN(privateKey);
  if (scalar.cmp(ecparams.n) >= 0 || scalar.isZero()) throw new Error(messages.ECDH_FAIL);
  return Buffer.from(pair.pub.mul(scalar).encode(true, compressed));
};

},{"../messages.json":391,"bn.js":103,"create-hash":145,"elliptic":161,"safe-buffer":384}],390:[function(require,module,exports){
'use strict';

var assert = require('./assert');
var der = require('./der');
var messages = require('./messages.json');
function initCompressedValue(value, defaultValue) {
  if (value === undefined) return defaultValue;
  assert.isBoolean(value, messages.COMPRESSED_TYPE_INVALID);
  return value;
}
module.exports = function (secp256k1) {
  return {
    privateKeyVerify: function privateKeyVerify(privateKey) {
      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID);
      return privateKey.length === 32 && secp256k1.privateKeyVerify(privateKey);
    },
    privateKeyExport: function privateKeyExport(privateKey, compressed) {
      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID);
      assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID);
      compressed = initCompressedValue(compressed, true);
      var publicKey = secp256k1.privateKeyExport(privateKey, compressed);
      return der.privateKeyExport(privateKey, publicKey, compressed);
    },
    privateKeyImport: function privateKeyImport(privateKey) {
      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID);
      privateKey = der.privateKeyImport(privateKey);
      if (privateKey && privateKey.length === 32 && secp256k1.privateKeyVerify(privateKey)) return privateKey;
      throw new Error(messages.EC_PRIVATE_KEY_IMPORT_DER_FAIL);
    },
    privateKeyNegate: function privateKeyNegate(privateKey) {
      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID);
      assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID);
      return secp256k1.privateKeyNegate(privateKey);
    },
    privateKeyModInverse: function privateKeyModInverse(privateKey) {
      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID);
      assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID);
      return secp256k1.privateKeyModInverse(privateKey);
    },
    privateKeyTweakAdd: function privateKeyTweakAdd(privateKey, tweak) {
      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID);
      assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID);
      assert.isBuffer(tweak, messages.TWEAK_TYPE_INVALID);
      assert.isBufferLength(tweak, 32, messages.TWEAK_LENGTH_INVALID);
      return secp256k1.privateKeyTweakAdd(privateKey, tweak);
    },
    privateKeyTweakMul: function privateKeyTweakMul(privateKey, tweak) {
      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID);
      assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID);
      assert.isBuffer(tweak, messages.TWEAK_TYPE_INVALID);
      assert.isBufferLength(tweak, 32, messages.TWEAK_LENGTH_INVALID);
      return secp256k1.privateKeyTweakMul(privateKey, tweak);
    },
    publicKeyCreate: function publicKeyCreate(privateKey, compressed) {
      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID);
      assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID);
      compressed = initCompressedValue(compressed, true);
      return secp256k1.publicKeyCreate(privateKey, compressed);
    },
    publicKeyConvert: function publicKeyConvert(publicKey, compressed) {
      assert.isBuffer(publicKey, messages.EC_PUBLIC_KEY_TYPE_INVALID);
      assert.isBufferLength2(publicKey, 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID);
      compressed = initCompressedValue(compressed, true);
      return secp256k1.publicKeyConvert(publicKey, compressed);
    },
    publicKeyVerify: function publicKeyVerify(publicKey) {
      assert.isBuffer(publicKey, messages.EC_PUBLIC_KEY_TYPE_INVALID);
      return secp256k1.publicKeyVerify(publicKey);
    },
    publicKeyTweakAdd: function publicKeyTweakAdd(publicKey, tweak, compressed) {
      assert.isBuffer(publicKey, messages.EC_PUBLIC_KEY_TYPE_INVALID);
      assert.isBufferLength2(publicKey, 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID);
      assert.isBuffer(tweak, messages.TWEAK_TYPE_INVALID);
      assert.isBufferLength(tweak, 32, messages.TWEAK_LENGTH_INVALID);
      compressed = initCompressedValue(compressed, true);
      return secp256k1.publicKeyTweakAdd(publicKey, tweak, compressed);
    },
    publicKeyTweakMul: function publicKeyTweakMul(publicKey, tweak, compressed) {
      assert.isBuffer(publicKey, messages.EC_PUBLIC_KEY_TYPE_INVALID);
      assert.isBufferLength2(publicKey, 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID);
      assert.isBuffer(tweak, messages.TWEAK_TYPE_INVALID);
      assert.isBufferLength(tweak, 32, messages.TWEAK_LENGTH_INVALID);
      compressed = initCompressedValue(compressed, true);
      return secp256k1.publicKeyTweakMul(publicKey, tweak, compressed);
    },
    publicKeyCombine: function publicKeyCombine(publicKeys, compressed) {
      assert.isArray(publicKeys, messages.EC_PUBLIC_KEYS_TYPE_INVALID);
      assert.isLengthGTZero(publicKeys, messages.EC_PUBLIC_KEYS_LENGTH_INVALID);
      for (var i = 0; i < publicKeys.length; ++i) {
        assert.isBuffer(publicKeys[i], messages.EC_PUBLIC_KEY_TYPE_INVALID);
        assert.isBufferLength2(publicKeys[i], 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID);
      }
      compressed = initCompressedValue(compressed, true);
      return secp256k1.publicKeyCombine(publicKeys, compressed);
    },
    signatureNormalize: function signatureNormalize(signature) {
      assert.isBuffer(signature, messages.ECDSA_SIGNATURE_TYPE_INVALID);
      assert.isBufferLength(signature, 64, messages.ECDSA_SIGNATURE_LENGTH_INVALID);
      return secp256k1.signatureNormalize(signature);
    },
    signatureExport: function signatureExport(signature) {
      assert.isBuffer(signature, messages.ECDSA_SIGNATURE_TYPE_INVALID);
      assert.isBufferLength(signature, 64, messages.ECDSA_SIGNATURE_LENGTH_INVALID);
      var sigObj = secp256k1.signatureExport(signature);
      return der.signatureExport(sigObj);
    },
    signatureImport: function signatureImport(sig) {
      assert.isBuffer(sig, messages.ECDSA_SIGNATURE_TYPE_INVALID);
      assert.isLengthGTZero(sig, messages.ECDSA_SIGNATURE_LENGTH_INVALID);
      var sigObj = der.signatureImport(sig);
      if (sigObj) return secp256k1.signatureImport(sigObj);
      throw new Error(messages.ECDSA_SIGNATURE_PARSE_DER_FAIL);
    },
    signatureImportLax: function signatureImportLax(sig) {
      assert.isBuffer(sig, messages.ECDSA_SIGNATURE_TYPE_INVALID);
      assert.isLengthGTZero(sig, messages.ECDSA_SIGNATURE_LENGTH_INVALID);
      var sigObj = der.signatureImportLax(sig);
      if (sigObj) return secp256k1.signatureImport(sigObj);
      throw new Error(messages.ECDSA_SIGNATURE_PARSE_DER_FAIL);
    },
    sign: function sign(message, privateKey, options) {
      assert.isBuffer(message, messages.MSG32_TYPE_INVALID);
      assert.isBufferLength(message, 32, messages.MSG32_LENGTH_INVALID);
      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID);
      assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID);
      var data = null;
      var noncefn = null;
      if (options !== undefined) {
        assert.isObject(options, messages.OPTIONS_TYPE_INVALID);
        if (options.data !== undefined) {
          assert.isBuffer(options.data, messages.OPTIONS_DATA_TYPE_INVALID);
          assert.isBufferLength(options.data, 32, messages.OPTIONS_DATA_LENGTH_INVALID);
          data = options.data;
        }
        if (options.noncefn !== undefined) {
          assert.isFunction(options.noncefn, messages.OPTIONS_NONCEFN_TYPE_INVALID);
          noncefn = options.noncefn;
        }
      }
      return secp256k1.sign(message, privateKey, noncefn, data);
    },
    verify: function verify(message, signature, publicKey) {
      assert.isBuffer(message, messages.MSG32_TYPE_INVALID);
      assert.isBufferLength(message, 32, messages.MSG32_LENGTH_INVALID);
      assert.isBuffer(signature, messages.ECDSA_SIGNATURE_TYPE_INVALID);
      assert.isBufferLength(signature, 64, messages.ECDSA_SIGNATURE_LENGTH_INVALID);
      assert.isBuffer(publicKey, messages.EC_PUBLIC_KEY_TYPE_INVALID);
      assert.isBufferLength2(publicKey, 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID);
      return secp256k1.verify(message, signature, publicKey);
    },
    recover: function recover(message, signature, recovery, compressed) {
      assert.isBuffer(message, messages.MSG32_TYPE_INVALID);
      assert.isBufferLength(message, 32, messages.MSG32_LENGTH_INVALID);
      assert.isBuffer(signature, messages.ECDSA_SIGNATURE_TYPE_INVALID);
      assert.isBufferLength(signature, 64, messages.ECDSA_SIGNATURE_LENGTH_INVALID);
      assert.isNumber(recovery, messages.RECOVERY_ID_TYPE_INVALID);
      assert.isNumberInInterval(recovery, -1, 4, messages.RECOVERY_ID_VALUE_INVALID);
      compressed = initCompressedValue(compressed, true);
      return secp256k1.recover(message, signature, recovery, compressed);
    },
    ecdh: function ecdh(publicKey, privateKey) {
      assert.isBuffer(publicKey, messages.EC_PUBLIC_KEY_TYPE_INVALID);
      assert.isBufferLength2(publicKey, 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID);
      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID);
      assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID);
      return secp256k1.ecdh(publicKey, privateKey);
    },
    ecdhUnsafe: function ecdhUnsafe(publicKey, privateKey, compressed) {
      assert.isBuffer(publicKey, messages.EC_PUBLIC_KEY_TYPE_INVALID);
      assert.isBufferLength2(publicKey, 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID);
      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID);
      assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID);
      compressed = initCompressedValue(compressed, true);
      return secp256k1.ecdhUnsafe(publicKey, privateKey, compressed);
    }
  };
};

},{"./assert":387,"./der":388,"./messages.json":391}],391:[function(require,module,exports){
module.exports={
  "COMPRESSED_TYPE_INVALID": "compressed should be a boolean",
  "EC_PRIVATE_KEY_TYPE_INVALID": "private key should be a Buffer",
  "EC_PRIVATE_KEY_LENGTH_INVALID": "private key length is invalid",
  "EC_PRIVATE_KEY_RANGE_INVALID": "private key range is invalid",
  "EC_PRIVATE_KEY_TWEAK_ADD_FAIL": "tweak out of range or resulting private key is invalid",
  "EC_PRIVATE_KEY_TWEAK_MUL_FAIL": "tweak out of range",
  "EC_PRIVATE_KEY_EXPORT_DER_FAIL": "couldn't export to DER format",
  "EC_PRIVATE_KEY_IMPORT_DER_FAIL": "couldn't import from DER format",
  "EC_PUBLIC_KEYS_TYPE_INVALID": "public keys should be an Array",
  "EC_PUBLIC_KEYS_LENGTH_INVALID": "public keys Array should have at least 1 element",
  "EC_PUBLIC_KEY_TYPE_INVALID": "public key should be a Buffer",
  "EC_PUBLIC_KEY_LENGTH_INVALID": "public key length is invalid",
  "EC_PUBLIC_KEY_PARSE_FAIL": "the public key could not be parsed or is invalid",
  "EC_PUBLIC_KEY_CREATE_FAIL": "private was invalid, try again",
  "EC_PUBLIC_KEY_TWEAK_ADD_FAIL": "tweak out of range or resulting public key is invalid",
  "EC_PUBLIC_KEY_TWEAK_MUL_FAIL": "tweak out of range",
  "EC_PUBLIC_KEY_COMBINE_FAIL": "the sum of the public keys is not valid",
  "ECDH_FAIL": "scalar was invalid (zero or overflow)",
  "ECDSA_SIGNATURE_TYPE_INVALID": "signature should be a Buffer",
  "ECDSA_SIGNATURE_LENGTH_INVALID": "signature length is invalid",
  "ECDSA_SIGNATURE_PARSE_FAIL": "couldn't parse signature",
  "ECDSA_SIGNATURE_PARSE_DER_FAIL": "couldn't parse DER signature",
  "ECDSA_SIGNATURE_SERIALIZE_DER_FAIL": "couldn't serialize signature to DER format",
  "ECDSA_SIGN_FAIL": "nonce generation function failed or private key is invalid",
  "ECDSA_RECOVER_FAIL": "couldn't recover public key from signature",
  "MSG32_TYPE_INVALID": "message should be a Buffer",
  "MSG32_LENGTH_INVALID": "message length is invalid",
  "OPTIONS_TYPE_INVALID": "options should be an Object",
  "OPTIONS_DATA_TYPE_INVALID": "options.data should be a Buffer",
  "OPTIONS_DATA_LENGTH_INVALID": "options.data length is invalid",
  "OPTIONS_NONCEFN_TYPE_INVALID": "options.noncefn should be a Function",
  "RECOVERY_ID_TYPE_INVALID": "recovery should be a Number",
  "RECOVERY_ID_VALUE_INVALID": "recovery should have value between -1 and 4",
  "TWEAK_TYPE_INVALID": "tweak should be a Buffer",
  "TWEAK_LENGTH_INVALID": "tweak length is invalid"
}

},{}],392:[function(require,module,exports){
'use strict';

var GetIntrinsic = require('get-intrinsic');
var define = require('define-data-property');
var hasDescriptors = require('has-property-descriptors')();
var gOPD = require('gopd');
var $TypeError = require('es-errors/type');
var $floor = GetIntrinsic('%Math.floor%');

/** @type {import('.')} */
module.exports = function setFunctionLength(fn, length) {
  if (typeof fn !== 'function') {
    throw new $TypeError('`fn` is not a function');
  }
  if (typeof length !== 'number' || length < 0 || length > 0xFFFFFFFF || $floor(length) !== length) {
    throw new $TypeError('`length` must be a positive 32-bit integer');
  }
  var loose = arguments.length > 2 && !!arguments[2];
  var functionLengthIsConfigurable = true;
  var functionLengthIsWritable = true;
  if ('length' in fn && gOPD) {
    var desc = gOPD(fn, 'length');
    if (desc && !desc.configurable) {
      functionLengthIsConfigurable = false;
    }
    if (desc && !desc.writable) {
      functionLengthIsWritable = false;
    }
  }
  if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
    if (hasDescriptors) {
      define( /** @type {Parameters<define>[0]} */fn, 'length', length, true, true);
    } else {
      define( /** @type {Parameters<define>[0]} */fn, 'length', length);
    }
  }
  return fn;
};

},{"define-data-property":150,"es-errors/type":184,"get-intrinsic":305,"gopd":306,"has-property-descriptors":307}],393:[function(require,module,exports){
"use strict";

var Buffer = require('safe-buffer').Buffer;

// prototype class for hash functions
function Hash(blockSize, finalSize) {
  this._block = Buffer.alloc(blockSize);
  this._finalSize = finalSize;
  this._blockSize = blockSize;
  this._len = 0;
}
Hash.prototype.update = function (data, enc) {
  if (typeof data === 'string') {
    enc = enc || 'utf8';
    data = Buffer.from(data, enc);
  }
  var block = this._block;
  var blockSize = this._blockSize;
  var length = data.length;
  var accum = this._len;
  for (var offset = 0; offset < length;) {
    var assigned = accum % blockSize;
    var remainder = Math.min(length - offset, blockSize - assigned);
    for (var i = 0; i < remainder; i++) {
      block[assigned + i] = data[offset + i];
    }
    accum += remainder;
    offset += remainder;
    if (accum % blockSize === 0) {
      this._update(block);
    }
  }
  this._len += length;
  return this;
};
Hash.prototype.digest = function (enc) {
  var rem = this._len % this._blockSize;
  this._block[rem] = 0x80;

  // zero (rem + 1) trailing bits, where (rem + 1) is the smallest
  // non-negative solution to the equation (length + 1 + (rem + 1)) === finalSize mod blockSize
  this._block.fill(0, rem + 1);
  if (rem >= this._finalSize) {
    this._update(this._block);
    this._block.fill(0);
  }
  var bits = this._len * 8;

  // uint32
  if (bits <= 0xffffffff) {
    this._block.writeUInt32BE(bits, this._blockSize - 4);

    // uint64
  } else {
    var lowBits = (bits & 0xffffffff) >>> 0;
    var highBits = (bits - lowBits) / 0x100000000;
    this._block.writeUInt32BE(highBits, this._blockSize - 8);
    this._block.writeUInt32BE(lowBits, this._blockSize - 4);
  }
  this._update(this._block);
  var hash = this._hash();
  return enc ? hash.toString(enc) : hash;
};
Hash.prototype._update = function () {
  throw new Error('_update must be implemented by subclass');
};
module.exports = Hash;

},{"safe-buffer":384}],394:[function(require,module,exports){
"use strict";

var _exports = module.exports = function SHA(algorithm) {
  algorithm = algorithm.toLowerCase();
  var Algorithm = _exports[algorithm];
  if (!Algorithm) throw new Error(algorithm + ' is not supported (we accept pull requests)');
  return new Algorithm();
};
_exports.sha = require('./sha');
_exports.sha1 = require('./sha1');
_exports.sha224 = require('./sha224');
_exports.sha256 = require('./sha256');
_exports.sha384 = require('./sha384');
_exports.sha512 = require('./sha512');

},{"./sha":395,"./sha1":396,"./sha224":397,"./sha256":398,"./sha384":399,"./sha512":400}],395:[function(require,module,exports){
"use strict";

/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-0, as defined
 * in FIPS PUB 180-1
 * This source code is derived from sha1.js of the same repository.
 * The difference between SHA-0 and SHA-1 is just a bitwise rotate left
 * operation was added.
 */

var inherits = require('inherits');
var Hash = require('./hash');
var Buffer = require('safe-buffer').Buffer;
var K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0];
var W = new Array(80);
function Sha() {
  this.init();
  this._w = W;
  Hash.call(this, 64, 56);
}
inherits(Sha, Hash);
Sha.prototype.init = function () {
  this._a = 0x67452301;
  this._b = 0xefcdab89;
  this._c = 0x98badcfe;
  this._d = 0x10325476;
  this._e = 0xc3d2e1f0;
  return this;
};
function rotl5(num) {
  return num << 5 | num >>> 27;
}
function rotl30(num) {
  return num << 30 | num >>> 2;
}
function ft(s, b, c, d) {
  if (s === 0) return b & c | ~b & d;
  if (s === 2) return b & c | b & d | c & d;
  return b ^ c ^ d;
}
Sha.prototype._update = function (M) {
  var W = this._w;
  var a = this._a | 0;
  var b = this._b | 0;
  var c = this._c | 0;
  var d = this._d | 0;
  var e = this._e | 0;
  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4);
  for (; i < 80; ++i) W[i] = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
  for (var j = 0; j < 80; ++j) {
    var s = ~~(j / 20);
    var t = rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s] | 0;
    e = d;
    d = c;
    c = rotl30(b);
    b = a;
    a = t;
  }
  this._a = a + this._a | 0;
  this._b = b + this._b | 0;
  this._c = c + this._c | 0;
  this._d = d + this._d | 0;
  this._e = e + this._e | 0;
};
Sha.prototype._hash = function () {
  var H = Buffer.allocUnsafe(20);
  H.writeInt32BE(this._a | 0, 0);
  H.writeInt32BE(this._b | 0, 4);
  H.writeInt32BE(this._c | 0, 8);
  H.writeInt32BE(this._d | 0, 12);
  H.writeInt32BE(this._e | 0, 16);
  return H;
};
module.exports = Sha;

},{"./hash":393,"inherits":327,"safe-buffer":384}],396:[function(require,module,exports){
"use strict";

/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

var inherits = require('inherits');
var Hash = require('./hash');
var Buffer = require('safe-buffer').Buffer;
var K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0];
var W = new Array(80);
function Sha1() {
  this.init();
  this._w = W;
  Hash.call(this, 64, 56);
}
inherits(Sha1, Hash);
Sha1.prototype.init = function () {
  this._a = 0x67452301;
  this._b = 0xefcdab89;
  this._c = 0x98badcfe;
  this._d = 0x10325476;
  this._e = 0xc3d2e1f0;
  return this;
};
function rotl1(num) {
  return num << 1 | num >>> 31;
}
function rotl5(num) {
  return num << 5 | num >>> 27;
}
function rotl30(num) {
  return num << 30 | num >>> 2;
}
function ft(s, b, c, d) {
  if (s === 0) return b & c | ~b & d;
  if (s === 2) return b & c | b & d | c & d;
  return b ^ c ^ d;
}
Sha1.prototype._update = function (M) {
  var W = this._w;
  var a = this._a | 0;
  var b = this._b | 0;
  var c = this._c | 0;
  var d = this._d | 0;
  var e = this._e | 0;
  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4);
  for (; i < 80; ++i) W[i] = rotl1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16]);
  for (var j = 0; j < 80; ++j) {
    var s = ~~(j / 20);
    var t = rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s] | 0;
    e = d;
    d = c;
    c = rotl30(b);
    b = a;
    a = t;
  }
  this._a = a + this._a | 0;
  this._b = b + this._b | 0;
  this._c = c + this._c | 0;
  this._d = d + this._d | 0;
  this._e = e + this._e | 0;
};
Sha1.prototype._hash = function () {
  var H = Buffer.allocUnsafe(20);
  H.writeInt32BE(this._a | 0, 0);
  H.writeInt32BE(this._b | 0, 4);
  H.writeInt32BE(this._c | 0, 8);
  H.writeInt32BE(this._d | 0, 12);
  H.writeInt32BE(this._e | 0, 16);
  return H;
};
module.exports = Sha1;

},{"./hash":393,"inherits":327,"safe-buffer":384}],397:[function(require,module,exports){
"use strict";

/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = require('inherits');
var Sha256 = require('./sha256');
var Hash = require('./hash');
var Buffer = require('safe-buffer').Buffer;
var W = new Array(64);
function Sha224() {
  this.init();
  this._w = W; // new Array(64)

  Hash.call(this, 64, 56);
}
inherits(Sha224, Sha256);
Sha224.prototype.init = function () {
  this._a = 0xc1059ed8;
  this._b = 0x367cd507;
  this._c = 0x3070dd17;
  this._d = 0xf70e5939;
  this._e = 0xffc00b31;
  this._f = 0x68581511;
  this._g = 0x64f98fa7;
  this._h = 0xbefa4fa4;
  return this;
};
Sha224.prototype._hash = function () {
  var H = Buffer.allocUnsafe(28);
  H.writeInt32BE(this._a, 0);
  H.writeInt32BE(this._b, 4);
  H.writeInt32BE(this._c, 8);
  H.writeInt32BE(this._d, 12);
  H.writeInt32BE(this._e, 16);
  H.writeInt32BE(this._f, 20);
  H.writeInt32BE(this._g, 24);
  return H;
};
module.exports = Sha224;

},{"./hash":393,"./sha256":398,"inherits":327,"safe-buffer":384}],398:[function(require,module,exports){
"use strict";

/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = require('inherits');
var Hash = require('./hash');
var Buffer = require('safe-buffer').Buffer;
var K = [0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5, 0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5, 0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3, 0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174, 0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC, 0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA, 0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7, 0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967, 0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13, 0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85, 0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3, 0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070, 0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5, 0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3, 0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208, 0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2];
var W = new Array(64);
function Sha256() {
  this.init();
  this._w = W; // new Array(64)

  Hash.call(this, 64, 56);
}
inherits(Sha256, Hash);
Sha256.prototype.init = function () {
  this._a = 0x6a09e667;
  this._b = 0xbb67ae85;
  this._c = 0x3c6ef372;
  this._d = 0xa54ff53a;
  this._e = 0x510e527f;
  this._f = 0x9b05688c;
  this._g = 0x1f83d9ab;
  this._h = 0x5be0cd19;
  return this;
};
function ch(x, y, z) {
  return z ^ x & (y ^ z);
}
function maj(x, y, z) {
  return x & y | z & (x | y);
}
function sigma0(x) {
  return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10);
}
function sigma1(x) {
  return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7);
}
function gamma0(x) {
  return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ x >>> 3;
}
function gamma1(x) {
  return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ x >>> 10;
}
Sha256.prototype._update = function (M) {
  var W = this._w;
  var a = this._a | 0;
  var b = this._b | 0;
  var c = this._c | 0;
  var d = this._d | 0;
  var e = this._e | 0;
  var f = this._f | 0;
  var g = this._g | 0;
  var h = this._h | 0;
  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4);
  for (; i < 64; ++i) W[i] = gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16] | 0;
  for (var j = 0; j < 64; ++j) {
    var T1 = h + sigma1(e) + ch(e, f, g) + K[j] + W[j] | 0;
    var T2 = sigma0(a) + maj(a, b, c) | 0;
    h = g;
    g = f;
    f = e;
    e = d + T1 | 0;
    d = c;
    c = b;
    b = a;
    a = T1 + T2 | 0;
  }
  this._a = a + this._a | 0;
  this._b = b + this._b | 0;
  this._c = c + this._c | 0;
  this._d = d + this._d | 0;
  this._e = e + this._e | 0;
  this._f = f + this._f | 0;
  this._g = g + this._g | 0;
  this._h = h + this._h | 0;
};
Sha256.prototype._hash = function () {
  var H = Buffer.allocUnsafe(32);
  H.writeInt32BE(this._a, 0);
  H.writeInt32BE(this._b, 4);
  H.writeInt32BE(this._c, 8);
  H.writeInt32BE(this._d, 12);
  H.writeInt32BE(this._e, 16);
  H.writeInt32BE(this._f, 20);
  H.writeInt32BE(this._g, 24);
  H.writeInt32BE(this._h, 28);
  return H;
};
module.exports = Sha256;

},{"./hash":393,"inherits":327,"safe-buffer":384}],399:[function(require,module,exports){
"use strict";

var inherits = require('inherits');
var SHA512 = require('./sha512');
var Hash = require('./hash');
var Buffer = require('safe-buffer').Buffer;
var W = new Array(160);
function Sha384() {
  this.init();
  this._w = W;
  Hash.call(this, 128, 112);
}
inherits(Sha384, SHA512);
Sha384.prototype.init = function () {
  this._ah = 0xcbbb9d5d;
  this._bh = 0x629a292a;
  this._ch = 0x9159015a;
  this._dh = 0x152fecd8;
  this._eh = 0x67332667;
  this._fh = 0x8eb44a87;
  this._gh = 0xdb0c2e0d;
  this._hh = 0x47b5481d;
  this._al = 0xc1059ed8;
  this._bl = 0x367cd507;
  this._cl = 0x3070dd17;
  this._dl = 0xf70e5939;
  this._el = 0xffc00b31;
  this._fl = 0x68581511;
  this._gl = 0x64f98fa7;
  this._hl = 0xbefa4fa4;
  return this;
};
Sha384.prototype._hash = function () {
  var H = Buffer.allocUnsafe(48);
  function writeInt64BE(h, l, offset) {
    H.writeInt32BE(h, offset);
    H.writeInt32BE(l, offset + 4);
  }
  writeInt64BE(this._ah, this._al, 0);
  writeInt64BE(this._bh, this._bl, 8);
  writeInt64BE(this._ch, this._cl, 16);
  writeInt64BE(this._dh, this._dl, 24);
  writeInt64BE(this._eh, this._el, 32);
  writeInt64BE(this._fh, this._fl, 40);
  return H;
};
module.exports = Sha384;

},{"./hash":393,"./sha512":400,"inherits":327,"safe-buffer":384}],400:[function(require,module,exports){
"use strict";

var inherits = require('inherits');
var Hash = require('./hash');
var Buffer = require('safe-buffer').Buffer;
var K = [0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd, 0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc, 0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019, 0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118, 0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe, 0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2, 0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1, 0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694, 0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3, 0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65, 0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483, 0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5, 0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210, 0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4, 0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725, 0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70, 0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926, 0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df, 0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8, 0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b, 0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001, 0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30, 0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910, 0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8, 0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53, 0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8, 0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb, 0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3, 0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60, 0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec, 0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9, 0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b, 0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207, 0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178, 0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6, 0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b, 0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493, 0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c, 0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a, 0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817];
var W = new Array(160);
function Sha512() {
  this.init();
  this._w = W;
  Hash.call(this, 128, 112);
}
inherits(Sha512, Hash);
Sha512.prototype.init = function () {
  this._ah = 0x6a09e667;
  this._bh = 0xbb67ae85;
  this._ch = 0x3c6ef372;
  this._dh = 0xa54ff53a;
  this._eh = 0x510e527f;
  this._fh = 0x9b05688c;
  this._gh = 0x1f83d9ab;
  this._hh = 0x5be0cd19;
  this._al = 0xf3bcc908;
  this._bl = 0x84caa73b;
  this._cl = 0xfe94f82b;
  this._dl = 0x5f1d36f1;
  this._el = 0xade682d1;
  this._fl = 0x2b3e6c1f;
  this._gl = 0xfb41bd6b;
  this._hl = 0x137e2179;
  return this;
};
function Ch(x, y, z) {
  return z ^ x & (y ^ z);
}
function maj(x, y, z) {
  return x & y | z & (x | y);
}
function sigma0(x, xl) {
  return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25);
}
function sigma1(x, xl) {
  return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23);
}
function Gamma0(x, xl) {
  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ x >>> 7;
}
function Gamma0l(x, xl) {
  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25);
}
function Gamma1(x, xl) {
  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ x >>> 6;
}
function Gamma1l(x, xl) {
  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26);
}
function getCarry(a, b) {
  return a >>> 0 < b >>> 0 ? 1 : 0;
}
Sha512.prototype._update = function (M) {
  var W = this._w;
  var ah = this._ah | 0;
  var bh = this._bh | 0;
  var ch = this._ch | 0;
  var dh = this._dh | 0;
  var eh = this._eh | 0;
  var fh = this._fh | 0;
  var gh = this._gh | 0;
  var hh = this._hh | 0;
  var al = this._al | 0;
  var bl = this._bl | 0;
  var cl = this._cl | 0;
  var dl = this._dl | 0;
  var el = this._el | 0;
  var fl = this._fl | 0;
  var gl = this._gl | 0;
  var hl = this._hl | 0;
  for (var i = 0; i < 32; i += 2) {
    W[i] = M.readInt32BE(i * 4);
    W[i + 1] = M.readInt32BE(i * 4 + 4);
  }
  for (; i < 160; i += 2) {
    var xh = W[i - 15 * 2];
    var xl = W[i - 15 * 2 + 1];
    var gamma0 = Gamma0(xh, xl);
    var gamma0l = Gamma0l(xl, xh);
    xh = W[i - 2 * 2];
    xl = W[i - 2 * 2 + 1];
    var gamma1 = Gamma1(xh, xl);
    var gamma1l = Gamma1l(xl, xh);

    // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
    var Wi7h = W[i - 7 * 2];
    var Wi7l = W[i - 7 * 2 + 1];
    var Wi16h = W[i - 16 * 2];
    var Wi16l = W[i - 16 * 2 + 1];
    var Wil = gamma0l + Wi7l | 0;
    var Wih = gamma0 + Wi7h + getCarry(Wil, gamma0l) | 0;
    Wil = Wil + gamma1l | 0;
    Wih = Wih + gamma1 + getCarry(Wil, gamma1l) | 0;
    Wil = Wil + Wi16l | 0;
    Wih = Wih + Wi16h + getCarry(Wil, Wi16l) | 0;
    W[i] = Wih;
    W[i + 1] = Wil;
  }
  for (var j = 0; j < 160; j += 2) {
    Wih = W[j];
    Wil = W[j + 1];
    var majh = maj(ah, bh, ch);
    var majl = maj(al, bl, cl);
    var sigma0h = sigma0(ah, al);
    var sigma0l = sigma0(al, ah);
    var sigma1h = sigma1(eh, el);
    var sigma1l = sigma1(el, eh);

    // t1 = h + sigma1 + ch + K[j] + W[j]
    var Kih = K[j];
    var Kil = K[j + 1];
    var chh = Ch(eh, fh, gh);
    var chl = Ch(el, fl, gl);
    var t1l = hl + sigma1l | 0;
    var t1h = hh + sigma1h + getCarry(t1l, hl) | 0;
    t1l = t1l + chl | 0;
    t1h = t1h + chh + getCarry(t1l, chl) | 0;
    t1l = t1l + Kil | 0;
    t1h = t1h + Kih + getCarry(t1l, Kil) | 0;
    t1l = t1l + Wil | 0;
    t1h = t1h + Wih + getCarry(t1l, Wil) | 0;

    // t2 = sigma0 + maj
    var t2l = sigma0l + majl | 0;
    var t2h = sigma0h + majh + getCarry(t2l, sigma0l) | 0;
    hh = gh;
    hl = gl;
    gh = fh;
    gl = fl;
    fh = eh;
    fl = el;
    el = dl + t1l | 0;
    eh = dh + t1h + getCarry(el, dl) | 0;
    dh = ch;
    dl = cl;
    ch = bh;
    cl = bl;
    bh = ah;
    bl = al;
    al = t1l + t2l | 0;
    ah = t1h + t2h + getCarry(al, t1l) | 0;
  }
  this._al = this._al + al | 0;
  this._bl = this._bl + bl | 0;
  this._cl = this._cl + cl | 0;
  this._dl = this._dl + dl | 0;
  this._el = this._el + el | 0;
  this._fl = this._fl + fl | 0;
  this._gl = this._gl + gl | 0;
  this._hl = this._hl + hl | 0;
  this._ah = this._ah + ah + getCarry(this._al, al) | 0;
  this._bh = this._bh + bh + getCarry(this._bl, bl) | 0;
  this._ch = this._ch + ch + getCarry(this._cl, cl) | 0;
  this._dh = this._dh + dh + getCarry(this._dl, dl) | 0;
  this._eh = this._eh + eh + getCarry(this._el, el) | 0;
  this._fh = this._fh + fh + getCarry(this._fl, fl) | 0;
  this._gh = this._gh + gh + getCarry(this._gl, gl) | 0;
  this._hh = this._hh + hh + getCarry(this._hl, hl) | 0;
};
Sha512.prototype._hash = function () {
  var H = Buffer.allocUnsafe(64);
  function writeInt64BE(h, l, offset) {
    H.writeInt32BE(h, offset);
    H.writeInt32BE(l, offset + 4);
  }
  writeInt64BE(this._ah, this._al, 0);
  writeInt64BE(this._bh, this._bl, 8);
  writeInt64BE(this._ch, this._cl, 16);
  writeInt64BE(this._dh, this._dl, 24);
  writeInt64BE(this._eh, this._el, 32);
  writeInt64BE(this._fh, this._fl, 40);
  writeInt64BE(this._gh, this._gl, 48);
  writeInt64BE(this._hh, this._hl, 56);
  return H;
};
module.exports = Sha512;

},{"./hash":393,"inherits":327,"safe-buffer":384}],401:[function(require,module,exports){
"use strict";

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;
var EE = require('events').EventEmitter;
var inherits = require('inherits');
inherits(Stream, EE);
Stream.Readable = require('readable-stream/lib/_stream_readable.js');
Stream.Writable = require('readable-stream/lib/_stream_writable.js');
Stream.Duplex = require('readable-stream/lib/_stream_duplex.js');
Stream.Transform = require('readable-stream/lib/_stream_transform.js');
Stream.PassThrough = require('readable-stream/lib/_stream_passthrough.js');
Stream.finished = require('readable-stream/lib/internal/streams/end-of-stream.js');
Stream.pipeline = require('readable-stream/lib/internal/streams/pipeline.js');

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;

// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}
Stream.prototype.pipe = function (dest, options) {
  var source = this;
  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }
  source.on('data', ondata);
  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }
  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }
  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;
    dest.end();
  }
  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;
    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }
  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);
    source.removeListener('end', onend);
    source.removeListener('close', onclose);
    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);
    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);
    dest.removeListener('close', cleanup);
  }
  source.on('end', cleanup);
  source.on('close', cleanup);
  dest.on('close', cleanup);
  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":301,"inherits":402,"readable-stream/lib/_stream_duplex.js":404,"readable-stream/lib/_stream_passthrough.js":405,"readable-stream/lib/_stream_readable.js":406,"readable-stream/lib/_stream_transform.js":407,"readable-stream/lib/_stream_writable.js":408,"readable-stream/lib/internal/streams/end-of-stream.js":412,"readable-stream/lib/internal/streams/pipeline.js":414}],402:[function(require,module,exports){
arguments[4][135][0].apply(exports,arguments)
},{"dup":135}],403:[function(require,module,exports){
'use strict';

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
var codes = {};
function createErrorType(code, message, Base) {
  if (!Base) {
    Base = Error;
  }
  function getMessage(arg1, arg2, arg3) {
    if (typeof message === 'string') {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }
  var NodeError = /*#__PURE__*/
  function (_Base) {
    _inheritsLoose(NodeError, _Base);
    function NodeError(arg1, arg2, arg3) {
      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
    }
    return NodeError;
  }(Base);
  NodeError.prototype.name = Base.name;
  NodeError.prototype.code = code;
  codes[code] = NodeError;
} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js

function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    var len = expected.length;
    expected = expected.map(function (i) {
      return String(i);
    });
    if (len > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
    } else if (len === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith

function startsWith(str, search, pos) {
  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith

function endsWith(str, search, this_len) {
  if (this_len === undefined || this_len > str.length) {
    this_len = str.length;
  }
  return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes

function includes(str, search, start) {
  if (typeof start !== 'number') {
    start = 0;
  }
  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}
createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
  return 'The value "' + value + '" is invalid for option "' + name + '"';
}, TypeError);
createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
  // determiner: 'must be' or 'must not be'
  var determiner;
  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
    determiner = 'must not be';
    expected = expected.replace(/^not /, '');
  } else {
    determiner = 'must be';
  }
  var msg;
  if (endsWith(name, ' argument')) {
    // For cases like 'first argument'
    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  } else {
    var type = includes(name, '.') ? 'property' : 'argument';
    msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  }
  msg += ". Received type ".concat(_typeof(actual));
  return msg;
}, TypeError);
createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
  return 'The ' + name + ' method is not implemented';
});
createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
createErrorType('ERR_STREAM_DESTROYED', function (name) {
  return 'Cannot call ' + name + ' after a stream was destroyed';
});
createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
  return 'Unknown encoding: ' + arg;
}, TypeError);
createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');
module.exports.codes = codes;

},{}],404:[function(require,module,exports){
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) keys.push(key);
  return keys;
};
/*</replacement>*/

module.exports = Duplex;
var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');
require('inherits')(Duplex, Readable);
{
  // Allow the keys array to be GC'ed.
  var keys = objectKeys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}
function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  this.allowHalfOpen = true;
  if (options) {
    if (options.readable === false) this.readable = false;
    if (options.writable === false) this.writable = false;
    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false;
      this.once('end', onend);
    }
  }
}
Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});
Object.defineProperty(Duplex.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});
Object.defineProperty(Duplex.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
});

// the no-half-open enforcer
function onend() {
  // If the writable side ended, then we're ok.
  if (this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  process.nextTick(onEndNT, this);
}
function onEndNT(self) {
  self.end();
}
Object.defineProperty(Duplex.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

}).call(this)}).call(this,require('_process'))
},{"./_stream_readable":406,"./_stream_writable":408,"_process":363,"inherits":402}],405:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

'use strict';

module.exports = PassThrough;
var Transform = require('./_stream_transform');
require('inherits')(PassThrough, Transform);
function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);
  Transform.call(this, options);
}
PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};

},{"./_stream_transform":407,"inherits":402}],406:[function(require,module,exports){
(function (process,global){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

module.exports = Readable;

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = require('events').EventEmitter;
var EElistenerCount = function EElistenerCount(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

var Buffer = require('buffer').Buffer;
var OurUint8Array = (typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*<replacement>*/
var debugUtil = require('util');
var debug;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function debug() {};
}
/*</replacement>*/

var BufferList = require('./internal/streams/buffer_list');
var destroyImpl = require('./internal/streams/destroy');
var _require = require('./internal/streams/state'),
  getHighWaterMark = _require.getHighWaterMark;
var _require$codes = require('../errors').codes,
  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
  ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
  ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;

// Lazy loaded to improve the startup performance.
var StringDecoder;
var createReadableStreamAsyncIterator;
var from;
require('inherits')(Readable, Stream);
var errorOrDestroy = destroyImpl.errorOrDestroy;
var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];
function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}
function ReadableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.paused = true;

  // Should close be emitted on destroy. Defaults to true.
  this.emitClose = options.emitClose !== false;

  // Should .destroy() be called after 'end' (and potentially 'finish')
  this.autoDestroy = !!options.autoDestroy;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}
function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');
  if (!(this instanceof Readable)) return new Readable(options);

  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the ReadableState constructor, at least with V8 6.5
  var isDuplex = this instanceof Duplex;
  this._readableState = new ReadableState(options, this, isDuplex);

  // legacy
  this.readable = true;
  if (options) {
    if (typeof options.read === 'function') this._read = options.read;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }
  Stream.call(this);
}
Object.defineProperty(Readable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;
  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }
  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};
function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  debug('readableAddChunk', chunk);
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      errorOrDestroy(stream, er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (addToFront) {
        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
      } else if (state.destroyed) {
        return false;
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
      maybeReadMore(stream, state);
    }
  }

  // We can push more data if we are below the highWaterMark.
  // Also, if we have no data yet, we can stand some more bytes.
  // This is to work around cases where hwm=0, such as the repl.
  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}
function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    state.awaitDrain = 0;
    stream.emit('data', chunk);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}
function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
  }
  return er;
}
Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  var decoder = new StringDecoder(enc);
  this._readableState.decoder = decoder;
  // If setEncoding(null), decoder.encoding equals utf8
  this._readableState.encoding = this._readableState.decoder.encoding;

  // Iterate over current buffer to convert already stored Buffers:
  var p = this._readableState.buffer.head;
  var content = '';
  while (p !== null) {
    content += decoder.write(p.data);
    p = p.next;
  }
  this._readableState.buffer.clear();
  if (content !== '') this._readableState.buffer.push(content);
  this._readableState.length = content.length;
  return this;
};

// Don't raise the hwm > 1GB
var MAX_HWM = 0x40000000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;
  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }
  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }
  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;
  if (ret === null) {
    state.needReadable = state.length <= state.highWaterMark;
    n = 0;
  } else {
    state.length -= n;
    state.awaitDrain = 0;
  }
  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }
  if (ret !== null) this.emit('data', ret);
  return ret;
};
function onEofChunk(stream, state) {
  debug('onEofChunk');
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;
  if (state.sync) {
    // if we are sync, wait until next tick to emit the data.
    // Otherwise we risk emitting data in the flow()
    // the readable code triggers during a read() call
    emitReadable(stream);
  } else {
    // emit 'readable' now to make sure it gets picked up.
    state.needReadable = false;
    if (!state.emittedReadable) {
      state.emittedReadable = true;
      emitReadable_(stream);
    }
  }
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  debug('emitReadable', state.needReadable, state.emittedReadable);
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    process.nextTick(emitReadable_, stream);
  }
}
function emitReadable_(stream) {
  var state = stream._readableState;
  debug('emitReadable_', state.destroyed, state.length, state.ended);
  if (!state.destroyed && (state.length || state.ended)) {
    stream.emit('readable');
    state.emittedReadable = false;
  }

  // The stream needs another readable event if
  // 1. It is not flowing, as the flow mechanism will take
  //    care of it.
  // 2. It is not ended.
  // 3. It is below the highWaterMark, so we can schedule
  //    another readable later.
  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(maybeReadMore_, stream, state);
  }
}
function maybeReadMore_(stream, state) {
  // Attempt to read more data if we should.
  //
  // The conditions for reading more data are (one of):
  // - Not enough data buffered (state.length < state.highWaterMark). The loop
  //   is responsible for filling the buffer with enough data if such data
  //   is available. If highWaterMark is 0 and we are not in the flowing mode
  //   we should _not_ attempt to buffer any extra data. We'll get more data
  //   when the stream consumer calls read() instead.
  // - No data in the buffer, and the stream is in flowing mode. In this mode
  //   the loop below is responsible for ensuring read() is called. Failing to
  //   call read here would abort the flow and there's no other mechanism for
  //   continuing the flow if the stream consumer has just subscribed to the
  //   'data' event.
  //
  // In addition to the above conditions to keep reading data, the following
  // conditions prevent the data from being read:
  // - The stream has ended (state.ended).
  // - There is already a pending 'read' operation (state.reading). This is a
  //   case where the the stream has called the implementation defined _read()
  //   method, but they are processing the call asynchronously and have _not_
  //   called push() with new data. In this case we skip performing more
  //   read()s. The execution ends in this method again after the _read() ends
  //   up calling push() with more data.
  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
    var len = state.length;
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
};
Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;
  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }
  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);
  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);
    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    debug('dest.write', ret);
    if (ret === false) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', state.awaitDrain);
        state.awaitDrain++;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);
  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }
  return dest;
};
function pipeOnDrain(src) {
  return function pipeOnDrainFunctionResult() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}
Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    for (var i = 0; i < len; i++) dests[i].emit('unpipe', this, {
      hasUnpiped: false
    });
    return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;
  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit('unpipe', this, unpipeInfo);
  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);
  var state = this._readableState;
  if (ev === 'data') {
    // update readableListening so that resume() may be a no-op
    // a few lines down. This is needed to support once('readable').
    state.readableListening = this.listenerCount('readable') > 0;

    // Try start flowing on next tick if stream isn't explicitly paused
    if (state.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.flowing = false;
      state.emittedReadable = false;
      debug('on readable', state.length, state.reading);
      if (state.length) {
        emitReadable(this);
      } else if (!state.reading) {
        process.nextTick(nReadingNextTick, this);
      }
    }
  }
  return res;
};
Readable.prototype.addListener = Readable.prototype.on;
Readable.prototype.removeListener = function (ev, fn) {
  var res = Stream.prototype.removeListener.call(this, ev, fn);
  if (ev === 'readable') {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }
  return res;
};
Readable.prototype.removeAllListeners = function (ev) {
  var res = Stream.prototype.removeAllListeners.apply(this, arguments);
  if (ev === 'readable' || ev === undefined) {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }
  return res;
};
function updateReadableListening(self) {
  var state = self._readableState;
  state.readableListening = self.listenerCount('readable') > 0;
  if (state.resumeScheduled && !state.paused) {
    // flowing needs to be set to true now, otherwise
    // the upcoming resume will not flow.
    state.flowing = true;

    // crude way to check if we should resume
  } else if (self.listenerCount('data') > 0) {
    self.resume();
  }
}
function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    // we flow only if there is no one listening
    // for readable, but we still have to call
    // resume()
    state.flowing = !state.readableListening;
    resume(this, state);
  }
  state.paused = false;
  return this;
};
function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(resume_, stream, state);
  }
}
function resume_(stream, state) {
  debug('resume', state.reading);
  if (!state.reading) {
    stream.read(0);
  }
  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}
Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (this._readableState.flowing !== false) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  this._readableState.paused = true;
  return this;
};
function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null);
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var _this = this;
  var state = this._readableState;
  var paused = false;
  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }
    _this.push(null);
  });
  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;
    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function methodWrap(method) {
        return function methodWrapReturnFunction() {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  this._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };
  return this;
};
if (typeof Symbol === 'function') {
  Readable.prototype[Symbol.asyncIterator] = function () {
    if (createReadableStreamAsyncIterator === undefined) {
      createReadableStreamAsyncIterator = require('./internal/streams/async_iterator');
    }
    return createReadableStreamAsyncIterator(this);
  };
}
Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.highWaterMark;
  }
});
Object.defineProperty(Readable.prototype, 'readableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState && this._readableState.buffer;
  }
});
Object.defineProperty(Readable.prototype, 'readableFlowing', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.flowing;
  },
  set: function set(state) {
    if (this._readableState) {
      this._readableState.flowing = state;
    }
  }
});

// exposed for testing purposes only.
Readable._fromList = fromList;
Object.defineProperty(Readable.prototype, 'readableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.length;
  }
});

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;
  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = state.buffer.consume(n, state.decoder);
  }
  return ret;
}
function endReadable(stream) {
  var state = stream._readableState;
  debug('endReadable', state.endEmitted);
  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(endReadableNT, state, stream);
  }
}
function endReadableNT(state, stream) {
  debug('endReadableNT', state.endEmitted, state.length);

  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
    if (state.autoDestroy) {
      // In case of duplex streams we need a way to detect
      // if the writable side is ready for autoDestroy as well
      var wState = stream._writableState;
      if (!wState || wState.autoDestroy && wState.finished) {
        stream.destroy();
      }
    }
  }
}
if (typeof Symbol === 'function') {
  Readable.from = function (iterable, opts) {
    if (from === undefined) {
      from = require('./internal/streams/from');
    }
    return from(Readable, iterable, opts);
  };
}
function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../errors":403,"./_stream_duplex":404,"./internal/streams/async_iterator":409,"./internal/streams/buffer_list":410,"./internal/streams/destroy":411,"./internal/streams/from":413,"./internal/streams/state":415,"./internal/streams/stream":416,"_process":363,"buffer":139,"events":301,"inherits":402,"string_decoder/":417,"util":105}],407:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;
var _require$codes = require('../errors').codes,
  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
  ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
  ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,
  ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
var Duplex = require('./_stream_duplex');
require('inherits')(Transform, Duplex);
function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;
  if (cb === null) {
    return this.emit('error', new ERR_MULTIPLE_CALLBACK());
  }
  ts.writechunk = null;
  ts.writecb = null;
  if (data != null)
    // single equals check for both `null` and `undefined`
    this.push(data);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}
function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);
  Duplex.call(this, options);
  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;
  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;
    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish);
}
function prefinish() {
  var _this = this;
  if (typeof this._flush === 'function' && !this._readableState.destroyed) {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}
Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
};
Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;
  if (ts.writechunk !== null && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};
Transform.prototype._destroy = function (err, cb) {
  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
  });
};
function done(stream, er, data) {
  if (er) return stream.emit('error', er);
  if (data != null)
    // single equals check for both `null` and `undefined`
    stream.push(data);

  // TODO(BridgeAR): Write a test for these two error cases
  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return stream.push(null);
}

},{"../errors":403,"./_stream_duplex":404,"inherits":402}],408:[function(require,module,exports){
(function (process,global){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

'use strict';

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;
  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

var Buffer = require('buffer').Buffer;
var OurUint8Array = (typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
var destroyImpl = require('./internal/streams/destroy');
var _require = require('./internal/streams/state'),
  getHighWaterMark = _require.getHighWaterMark;
var _require$codes = require('../errors').codes,
  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
  ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
  ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
  ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
  ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
  ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
  ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
var errorOrDestroy = destroyImpl.errorOrDestroy;
require('inherits')(Writable, Stream);
function nop() {}
function WritableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream,
  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.
  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // Should close be emitted on destroy. Defaults to true.
  this.emitClose = options.emitClose !== false;

  // Should .destroy() be called after 'finish' (and potentially 'end')
  this.autoDestroy = !!options.autoDestroy;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}
WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};
(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function writableStateBufferGetter() {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function value(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function realHasInstance(object) {
    return object instanceof this;
  };
}
function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.

  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the WritableState constructor, at least with V8 6.5
  var isDuplex = this instanceof Duplex;
  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
  this._writableState = new WritableState(options, this, isDuplex);

  // legacy.
  this.writable = true;
  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options["final"] === 'function') this._final = options["final"];
  }
  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
};
function writeAfterEnd(stream, cb) {
  var er = new ERR_STREAM_WRITE_AFTER_END();
  // TODO: defer error events consistently everywhere, not just the cb
  errorOrDestroy(stream, er);
  process.nextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var er;
  if (chunk === null) {
    er = new ERR_STREAM_NULL_VALUES();
  } else if (typeof chunk !== 'string' && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
  }
  if (er) {
    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
    return false;
  }
  return true;
}
Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = !state.objectMode && _isUint8Array(chunk);
  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }
  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }
  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};
Writable.prototype.cork = function () {
  this._writableState.corked++;
};
Writable.prototype.uncork = function () {
  var state = this._writableState;
  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};
Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};
Object.defineProperty(Writable.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});
function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}
Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;
  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }
  return ret;
}
function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}
function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;
  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    process.nextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    process.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}
function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}
function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state) || stream.destroyed;
    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }
    if (sync) {
      process.nextTick(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}
function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;
  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }
    if (entry === null) state.lastBufferedRequest = null;
  }
  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}
Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
};
Writable.prototype._writev = null;
Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;
  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }
  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending) endWritable(this, state, cb);
  return this;
};
Object.defineProperty(Writable.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
});
function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      errorOrDestroy(stream, err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function' && !state.destroyed) {
      state.pendingcb++;
      state.finalCalled = true;
      process.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}
function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
      if (state.autoDestroy) {
        // In case of duplex streams we need a way to detect
        // if the readable side is ready for autoDestroy as well
        var rState = stream._readableState;
        if (!rState || rState.autoDestroy && rState.endEmitted) {
          stream.destroy();
        }
      }
    }
  }
  return need;
}
function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}
function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }

  // reuse the free corkReq.
  state.corkedRequestsFree.next = corkReq;
}
Object.defineProperty(Writable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  cb(err);
};

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../errors":403,"./_stream_duplex":404,"./internal/streams/destroy":411,"./internal/streams/state":415,"./internal/streams/stream":416,"_process":363,"buffer":139,"inherits":402,"util-deprecate":422}],409:[function(require,module,exports){
(function (process){(function (){
'use strict';

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var _Object$setPrototypeO;
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var finished = require('./end-of-stream');
var kLastResolve = Symbol('lastResolve');
var kLastReject = Symbol('lastReject');
var kError = Symbol('error');
var kEnded = Symbol('ended');
var kLastPromise = Symbol('lastPromise');
var kHandlePromise = Symbol('handlePromise');
var kStream = Symbol('stream');
function createIterResult(value, done) {
  return {
    value: value,
    done: done
  };
}
function readAndResolve(iter) {
  var resolve = iter[kLastResolve];
  if (resolve !== null) {
    var data = iter[kStream].read();
    // we defer if data is null
    // we can be expecting either 'end' or
    // 'error'
    if (data !== null) {
      iter[kLastPromise] = null;
      iter[kLastResolve] = null;
      iter[kLastReject] = null;
      resolve(createIterResult(data, false));
    }
  }
}
function onReadable(iter) {
  // we wait for the next tick, because it might
  // emit an error with process.nextTick
  process.nextTick(readAndResolve, iter);
}
function wrapForNext(lastPromise, iter) {
  return function (resolve, reject) {
    lastPromise.then(function () {
      if (iter[kEnded]) {
        resolve(createIterResult(undefined, true));
        return;
      }
      iter[kHandlePromise](resolve, reject);
    }, reject);
  };
}
var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
  get stream() {
    return this[kStream];
  },
  next: function next() {
    var _this = this;
    // if we have detected an error in the meanwhile
    // reject straight away
    var error = this[kError];
    if (error !== null) {
      return Promise.reject(error);
    }
    if (this[kEnded]) {
      return Promise.resolve(createIterResult(undefined, true));
    }
    if (this[kStream].destroyed) {
      // We need to defer via nextTick because if .destroy(err) is
      // called, the error will be emitted via nextTick, and
      // we cannot guarantee that there is no error lingering around
      // waiting to be emitted.
      return new Promise(function (resolve, reject) {
        process.nextTick(function () {
          if (_this[kError]) {
            reject(_this[kError]);
          } else {
            resolve(createIterResult(undefined, true));
          }
        });
      });
    }

    // if we have multiple next() calls
    // we will wait for the previous Promise to finish
    // this logic is optimized to support for await loops,
    // where next() is only called once at a time
    var lastPromise = this[kLastPromise];
    var promise;
    if (lastPromise) {
      promise = new Promise(wrapForNext(lastPromise, this));
    } else {
      // fast path needed to support multiple this.push()
      // without triggering the next() queue
      var data = this[kStream].read();
      if (data !== null) {
        return Promise.resolve(createIterResult(data, false));
      }
      promise = new Promise(this[kHandlePromise]);
    }
    this[kLastPromise] = promise;
    return promise;
  }
}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
  return this;
}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
  var _this2 = this;
  // destroy(err, cb) is a private API
  // we can guarantee we have that here, because we control the
  // Readable class this is attached to
  return new Promise(function (resolve, reject) {
    _this2[kStream].destroy(null, function (err) {
      if (err) {
        reject(err);
        return;
      }
      resolve(createIterResult(undefined, true));
    });
  });
}), _Object$setPrototypeO), AsyncIteratorPrototype);
var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
  var _Object$create;
  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
    value: stream,
    writable: true
  }), _defineProperty(_Object$create, kLastResolve, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kLastReject, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kError, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kEnded, {
    value: stream._readableState.endEmitted,
    writable: true
  }), _defineProperty(_Object$create, kHandlePromise, {
    value: function value(resolve, reject) {
      var data = iterator[kStream].read();
      if (data) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(data, false));
      } else {
        iterator[kLastResolve] = resolve;
        iterator[kLastReject] = reject;
      }
    },
    writable: true
  }), _Object$create));
  iterator[kLastPromise] = null;
  finished(stream, function (err) {
    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
      var reject = iterator[kLastReject];
      // reject if we are waiting for data in the Promise
      // returned by next() and store the error
      if (reject !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        reject(err);
      }
      iterator[kError] = err;
      return;
    }
    var resolve = iterator[kLastResolve];
    if (resolve !== null) {
      iterator[kLastPromise] = null;
      iterator[kLastResolve] = null;
      iterator[kLastReject] = null;
      resolve(createIterResult(undefined, true));
    }
    iterator[kEnded] = true;
  });
  stream.on('readable', onReadable.bind(null, iterator));
  return iterator;
};
module.exports = createReadableStreamAsyncIterator;

}).call(this)}).call(this,require('_process'))
},{"./end-of-stream":412,"_process":363}],410:[function(require,module,exports){
'use strict';

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var _require = require('buffer'),
  Buffer = _require.Buffer;
var _require2 = require('util'),
  inspect = _require2.inspect;
var custom = inspect && inspect.custom || 'inspect';
function copyBuffer(src, target, offset) {
  Buffer.prototype.copy.call(src, target, offset);
}
module.exports = /*#__PURE__*/function () {
  function BufferList() {
    _classCallCheck(this, BufferList);
    this.head = null;
    this.tail = null;
    this.length = 0;
  }
  _createClass(BufferList, [{
    key: "push",
    value: function push(v) {
      var entry = {
        data: v,
        next: null
      };
      if (this.length > 0) this.tail.next = entry;else this.head = entry;
      this.tail = entry;
      ++this.length;
    }
  }, {
    key: "unshift",
    value: function unshift(v) {
      var entry = {
        data: v,
        next: this.head
      };
      if (this.length === 0) this.tail = entry;
      this.head = entry;
      ++this.length;
    }
  }, {
    key: "shift",
    value: function shift() {
      if (this.length === 0) return;
      var ret = this.head.data;
      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
      --this.length;
      return ret;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.head = this.tail = null;
      this.length = 0;
    }
  }, {
    key: "join",
    value: function join(s) {
      if (this.length === 0) return '';
      var p = this.head;
      var ret = '' + p.data;
      while (p = p.next) ret += s + p.data;
      return ret;
    }
  }, {
    key: "concat",
    value: function concat(n) {
      if (this.length === 0) return Buffer.alloc(0);
      var ret = Buffer.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;
      while (p) {
        copyBuffer(p.data, ret, i);
        i += p.data.length;
        p = p.next;
      }
      return ret;
    }

    // Consumes a specified amount of bytes or characters from the buffered data.
  }, {
    key: "consume",
    value: function consume(n, hasStrings) {
      var ret;
      if (n < this.head.data.length) {
        // `slice` is the same for buffers and strings.
        ret = this.head.data.slice(0, n);
        this.head.data = this.head.data.slice(n);
      } else if (n === this.head.data.length) {
        // First chunk is a perfect match.
        ret = this.shift();
      } else {
        // Result spans more than one buffer.
        ret = hasStrings ? this._getString(n) : this._getBuffer(n);
      }
      return ret;
    }
  }, {
    key: "first",
    value: function first() {
      return this.head.data;
    }

    // Consumes a specified amount of characters from the buffered data.
  }, {
    key: "_getString",
    value: function _getString(n) {
      var p = this.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;
      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length) ret += str;else ret += str.slice(0, n);
        n -= nb;
        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = str.slice(nb);
          }
          break;
        }
        ++c;
      }
      this.length -= c;
      return ret;
    }

    // Consumes a specified amount of bytes from the buffered data.
  }, {
    key: "_getBuffer",
    value: function _getBuffer(n) {
      var ret = Buffer.allocUnsafe(n);
      var p = this.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;
      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;
        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = buf.slice(nb);
          }
          break;
        }
        ++c;
      }
      this.length -= c;
      return ret;
    }

    // Make sure the linked list only shows the minimal necessary information.
  }, {
    key: custom,
    value: function value(_, options) {
      return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
        // Only inspect one level.
        depth: 0,
        // It should not recurse.
        customInspect: false
      }));
    }
  }]);
  return BufferList;
}();

},{"buffer":139,"util":105}],411:[function(require,module,exports){
(function (process){(function (){
'use strict';

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;
  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;
  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err) {
      if (!this._writableState) {
        process.nextTick(emitErrorNT, this, err);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        process.nextTick(emitErrorNT, this, err);
      }
    }
    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }
  this._destroy(err || null, function (err) {
    if (!cb && err) {
      if (!_this._writableState) {
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else if (!_this._writableState.errorEmitted) {
        _this._writableState.errorEmitted = true;
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    } else if (cb) {
      process.nextTick(emitCloseNT, _this);
      cb(err);
    } else {
      process.nextTick(emitCloseNT, _this);
    }
  });
  return this;
}
function emitErrorAndCloseNT(self, err) {
  emitErrorNT(self, err);
  emitCloseNT(self);
}
function emitCloseNT(self) {
  if (self._writableState && !self._writableState.emitClose) return;
  if (self._readableState && !self._readableState.emitClose) return;
  self.emit('close');
}
function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }
  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}
function emitErrorNT(self, err) {
  self.emit('error', err);
}
function errorOrDestroy(stream, err) {
  // We have tests that rely on errors being emitted
  // in the same tick, so changing this is semver major.
  // For now when you opt-in to autoDestroy we allow
  // the error to be emitted nextTick. In a future
  // semver major update we should change the default to this.

  var rState = stream._readableState;
  var wState = stream._writableState;
  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
}
module.exports = {
  destroy: destroy,
  undestroy: undestroy,
  errorOrDestroy: errorOrDestroy
};

}).call(this)}).call(this,require('_process'))
},{"_process":363}],412:[function(require,module,exports){
// Ported from https://github.com/mafintosh/end-of-stream with
// permission from the author, Mathias Buus (@mafintosh).

'use strict';

var ERR_STREAM_PREMATURE_CLOSE = require('../../../errors').codes.ERR_STREAM_PREMATURE_CLOSE;
function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    callback.apply(this, args);
  };
}
function noop() {}
function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}
function eos(stream, opts, callback) {
  if (typeof opts === 'function') return eos(stream, null, opts);
  if (!opts) opts = {};
  callback = once(callback || noop);
  var readable = opts.readable || opts.readable !== false && stream.readable;
  var writable = opts.writable || opts.writable !== false && stream.writable;
  var onlegacyfinish = function onlegacyfinish() {
    if (!stream.writable) onfinish();
  };
  var writableEnded = stream._writableState && stream._writableState.finished;
  var onfinish = function onfinish() {
    writable = false;
    writableEnded = true;
    if (!readable) callback.call(stream);
  };
  var readableEnded = stream._readableState && stream._readableState.endEmitted;
  var onend = function onend() {
    readable = false;
    readableEnded = true;
    if (!writable) callback.call(stream);
  };
  var onerror = function onerror(err) {
    callback.call(stream, err);
  };
  var onclose = function onclose() {
    var err;
    if (readable && !readableEnded) {
      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
    if (writable && !writableEnded) {
      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
  };
  var onrequest = function onrequest() {
    stream.req.on('finish', onfinish);
  };
  if (isRequest(stream)) {
    stream.on('complete', onfinish);
    stream.on('abort', onclose);
    if (stream.req) onrequest();else stream.on('request', onrequest);
  } else if (writable && !stream._writableState) {
    // legacy streams
    stream.on('end', onlegacyfinish);
    stream.on('close', onlegacyfinish);
  }
  stream.on('end', onend);
  stream.on('finish', onfinish);
  if (opts.error !== false) stream.on('error', onerror);
  stream.on('close', onclose);
  return function () {
    stream.removeListener('complete', onfinish);
    stream.removeListener('abort', onclose);
    stream.removeListener('request', onrequest);
    if (stream.req) stream.req.removeListener('finish', onfinish);
    stream.removeListener('end', onlegacyfinish);
    stream.removeListener('close', onlegacyfinish);
    stream.removeListener('finish', onfinish);
    stream.removeListener('end', onend);
    stream.removeListener('error', onerror);
    stream.removeListener('close', onclose);
  };
}
module.exports = eos;

},{"../../../errors":403}],413:[function(require,module,exports){
"use strict";

module.exports = function () {
  throw new Error('Readable.from is not available in the browser');
};

},{}],414:[function(require,module,exports){
// Ported from https://github.com/mafintosh/pump with
// permission from the author, Mathias Buus (@mafintosh).

'use strict';

var eos;
function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;
    callback.apply(void 0, arguments);
  };
}
var _require$codes = require('../../../errors').codes,
  ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
  ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
function noop(err) {
  // Rethrow the error if it exists to avoid swallowing it
  if (err) throw err;
}
function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}
function destroyer(stream, reading, writing, callback) {
  callback = once(callback);
  var closed = false;
  stream.on('close', function () {
    closed = true;
  });
  if (eos === undefined) eos = require('./end-of-stream');
  eos(stream, {
    readable: reading,
    writable: writing
  }, function (err) {
    if (err) return callback(err);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function (err) {
    if (closed) return;
    if (destroyed) return;
    destroyed = true;

    // request.destroy just do .end - .abort is what we want
    if (isRequest(stream)) return stream.abort();
    if (typeof stream.destroy === 'function') return stream.destroy();
    callback(err || new ERR_STREAM_DESTROYED('pipe'));
  };
}
function call(fn) {
  fn();
}
function pipe(from, to) {
  return from.pipe(to);
}
function popCallback(streams) {
  if (!streams.length) return noop;
  if (typeof streams[streams.length - 1] !== 'function') return noop;
  return streams.pop();
}
function pipeline() {
  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
    streams[_key] = arguments[_key];
  }
  var callback = popCallback(streams);
  if (Array.isArray(streams[0])) streams = streams[0];
  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS('streams');
  }
  var error;
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1;
    var writing = i > 0;
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err;
      if (err) destroys.forEach(call);
      if (reading) return;
      destroys.forEach(call);
      callback(error);
    });
  });
  return streams.reduce(pipe);
}
module.exports = pipeline;

},{"../../../errors":403,"./end-of-stream":412}],415:[function(require,module,exports){
'use strict';

var ERR_INVALID_OPT_VALUE = require('../../../errors').codes.ERR_INVALID_OPT_VALUE;
function highWaterMarkFrom(options, isDuplex, duplexKey) {
  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}
function getHighWaterMark(state, options, duplexKey, isDuplex) {
  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
  if (hwm != null) {
    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
      var name = isDuplex ? duplexKey : 'highWaterMark';
      throw new ERR_INVALID_OPT_VALUE(name, hwm);
    }
    return Math.floor(hwm);
  }

  // Default value
  return state.objectMode ? 16 : 16 * 1024;
}
module.exports = {
  getHighWaterMark: getHighWaterMark
};

},{"../../../errors":403}],416:[function(require,module,exports){
arguments[4][379][0].apply(exports,arguments)
},{"dup":379,"events":301}],417:[function(require,module,exports){
arguments[4][380][0].apply(exports,arguments)
},{"dup":380,"safe-buffer":418}],418:[function(require,module,exports){
arguments[4][136][0].apply(exports,arguments)
},{"buffer":139,"dup":136}],419:[function(require,module,exports){
(function (setImmediate,clearImmediate){(function (){
"use strict";

var nextTick = require('process/browser.js').nextTick;
var apply = Function.prototype.apply;
var slice = Array.prototype.slice;
var immediateIds = {};
var nextImmediateId = 0;

// DOM APIs, for completeness

exports.setTimeout = function () {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function () {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout = exports.clearInterval = function (timeout) {
  timeout.close();
};
function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function () {};
Timeout.prototype.close = function () {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function (item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};
exports.unenroll = function (item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};
exports._unrefActive = exports.active = function (item) {
  clearTimeout(item._idleTimeoutId);
  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout) item._onTimeout();
    }, msecs);
  }
};

// That's not how node.js implements it but the exposed api is the same.
exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function (fn) {
  var id = nextImmediateId++;
  var args = arguments.length < 2 ? false : slice.call(arguments, 1);
  immediateIds[id] = true;
  nextTick(function onNextTick() {
    if (immediateIds[id]) {
      // fn.call() is faster so we optimize for the common use-case
      // @see http://jsperf.com/call-apply-segu
      if (args) {
        fn.apply(null, args);
      } else {
        fn.call(null);
      }
      // Prevent ids from leaking
      exports.clearImmediate(id);
    }
  });
  return id;
};
exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function (id) {
  delete immediateIds[id];
};

}).call(this)}).call(this,require("timers").setImmediate,require("timers").clearImmediate)
},{"process/browser.js":363,"timers":419}],420:[function(require,module,exports){
(function (global){(function (){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global global, define, System, Reflect, Promise */
var __extends;
var __assign;
var __rest;
var __decorate;
var __param;
var __metadata;
var __awaiter;
var __generator;
var __exportStar;
var __values;
var __read;
var __spread;
var __spreadArrays;
var __spreadArray;
var _await;
var __asyncGenerator;
var __asyncDelegator;
var __asyncValues;
var __makeTemplateObject;
var __importStar;
var __importDefault;
var __classPrivateFieldGet;
var __classPrivateFieldSet;
var __classPrivateFieldIn;
var __createBinding;
(function (factory) {
  var root = (typeof global === "undefined" ? "undefined" : _typeof(global)) === "object" ? global : (typeof self === "undefined" ? "undefined" : _typeof(self)) === "object" ? self : _typeof(this) === "object" ? this : {};
  if (typeof define === "function" && define.amd) {
    define("tslib", ["exports"], function (exports) {
      factory(createExporter(root, createExporter(exports)));
    });
  } else if ((typeof module === "undefined" ? "undefined" : _typeof(module)) === "object" && _typeof(module.exports) === "object") {
    factory(createExporter(root, createExporter(module.exports)));
  } else {
    factory(createExporter(root));
  }
  function createExporter(exports, previous) {
    if (exports !== root) {
      if (typeof Object.create === "function") {
        Object.defineProperty(exports, "__esModule", {
          value: true
        });
      } else {
        exports.__esModule = true;
      }
    }
    return function (id, v) {
      return exports[id] = previous ? previous(id, v) : v;
    };
  }
})(function (exporter) {
  var extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
  };
  __extends = function __extends(d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  __rest = function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
  };
  __decorate = function __decorate(decorators, target, key, desc) {
    var c = arguments.length,
      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
      d;
    if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
  __param = function __param(paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
  __metadata = function __metadata(metadataKey, metadataValue) {
    if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
  };
  __awaiter = function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function (resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  __generator = function __generator(thisArg, body) {
    var _ = {
        label: 0,
        sent: function sent() {
          if (t[0] & 1) throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      },
      f,
      y,
      t,
      g;
    return g = {
      next: verb(0),
      "throw": verb(1),
      "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
      return this;
    }), g;
    function verb(n) {
      return function (v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f) throw new TypeError("Generator is already executing.");
      while (_) try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        if (y = 0, t) op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return {
              value: op[1],
              done: false
            };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2]) _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
      if (op[0] & 5) throw op[1];
      return {
        value: op[0] ? op[1] : void 0,
        done: true
      };
    }
  };
  __exportStar = function __exportStar(m, o) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
  };
  __createBinding = Object.create ? function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = {
        enumerable: true,
        get: function get() {
          return m[k];
        }
      };
    }
    Object.defineProperty(o, k2, desc);
  } : function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
  };
  __values = function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator,
      m = s && o[s],
      i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
      next: function next() {
        if (o && i >= o.length) o = void 0;
        return {
          value: o && o[i++],
          done: !o
        };
      }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  };
  __read = function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o),
      r,
      ar = [],
      e;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    } catch (error) {
      e = {
        error: error
      };
    } finally {
      try {
        if (r && !r.done && (m = i["return"])) m.call(i);
      } finally {
        if (e) throw e.error;
      }
    }
    return ar;
  };

  /** @deprecated */
  __spread = function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
  };

  /** @deprecated */
  __spreadArrays = function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];
    return r;
  };
  __spreadArray = function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar) ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
  };
  _await = function __await(v) {
    return this instanceof _await ? (this.v = v, this) : new _await(v);
  };
  __asyncGenerator = function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []),
      i,
      q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
      return this;
    }, i;
    function verb(n) {
      if (g[n]) i[n] = function (v) {
        return new Promise(function (a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
    }
    function resume(n, v) {
      try {
        step(g[n](v));
      } catch (e) {
        settle(q[0][3], e);
      }
    }
    function step(r) {
      r.value instanceof _await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }
    function fulfill(value) {
      resume("next", value);
    }
    function reject(value) {
      resume("throw", value);
    }
    function settle(f, v) {
      if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
    }
  };
  __asyncDelegator = function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) {
      throw e;
    }), verb("return"), i[Symbol.iterator] = function () {
      return this;
    }, i;
    function verb(n, f) {
      i[n] = o[n] ? function (v) {
        return (p = !p) ? {
          value: _await(o[n](v)),
          done: n === "return"
        } : f ? f(v) : v;
      } : f;
    }
  };
  __asyncValues = function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator],
      i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
      return this;
    }, i);
    function verb(n) {
      i[n] = o[n] && function (v) {
        return new Promise(function (resolve, reject) {
          v = o[n](v), settle(resolve, reject, v.done, v.value);
        });
      };
    }
    function settle(resolve, reject, d, v) {
      Promise.resolve(v).then(function (v) {
        resolve({
          value: v,
          done: d
        });
      }, reject);
    }
  };
  __makeTemplateObject = function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) {
      Object.defineProperty(cooked, "raw", {
        value: raw
      });
    } else {
      cooked.raw = raw;
    }
    return cooked;
  };
  var __setModuleDefault = Object.create ? function (o, v) {
    Object.defineProperty(o, "default", {
      enumerable: true,
      value: v
    });
  } : function (o, v) {
    o["default"] = v;
  };
  __importStar = function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
  };
  __importDefault = function __importDefault(mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };
  __classPrivateFieldGet = function __classPrivateFieldGet(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  };
  __classPrivateFieldSet = function __classPrivateFieldSet(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  };
  __classPrivateFieldIn = function __classPrivateFieldIn(state, receiver) {
    if (receiver === null || _typeof(receiver) !== "object" && typeof receiver !== "function") throw new TypeError("Cannot use 'in' operator on non-object");
    return typeof state === "function" ? receiver === state : state.has(receiver);
  };
  exporter("__extends", __extends);
  exporter("__assign", __assign);
  exporter("__rest", __rest);
  exporter("__decorate", __decorate);
  exporter("__param", __param);
  exporter("__metadata", __metadata);
  exporter("__awaiter", __awaiter);
  exporter("__generator", __generator);
  exporter("__exportStar", __exportStar);
  exporter("__createBinding", __createBinding);
  exporter("__values", __values);
  exporter("__read", __read);
  exporter("__spread", __spread);
  exporter("__spreadArrays", __spreadArrays);
  exporter("__spreadArray", __spreadArray);
  exporter("__await", _await);
  exporter("__asyncGenerator", __asyncGenerator);
  exporter("__asyncDelegator", __asyncDelegator);
  exporter("__asyncValues", __asyncValues);
  exporter("__makeTemplateObject", __makeTemplateObject);
  exporter("__importStar", __importStar);
  exporter("__importDefault", __importDefault);
  exporter("__classPrivateFieldGet", __classPrivateFieldGet);
  exporter("__classPrivateFieldSet", __classPrivateFieldSet);
  exporter("__classPrivateFieldIn", __classPrivateFieldIn);
});

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],421:[function(require,module,exports){
"use strict";

/*! https://mths.be/utf8js v3.0.0 by @mathias */
;
(function (root) {
  var stringFromCharCode = String.fromCharCode;

  // Taken from https://mths.be/punycode
  function ucs2decode(string) {
    var output = [];
    var counter = 0;
    var length = string.length;
    var value;
    var extra;
    while (counter < length) {
      value = string.charCodeAt(counter++);
      if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
        // high surrogate, and there is a next character
        extra = string.charCodeAt(counter++);
        if ((extra & 0xFC00) == 0xDC00) {
          // low surrogate
          output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
        } else {
          // unmatched surrogate; only append this code unit, in case the next
          // code unit is the high surrogate of a surrogate pair
          output.push(value);
          counter--;
        }
      } else {
        output.push(value);
      }
    }
    return output;
  }

  // Taken from https://mths.be/punycode
  function ucs2encode(array) {
    var length = array.length;
    var index = -1;
    var value;
    var output = '';
    while (++index < length) {
      value = array[index];
      if (value > 0xFFFF) {
        value -= 0x10000;
        output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
        value = 0xDC00 | value & 0x3FF;
      }
      output += stringFromCharCode(value);
    }
    return output;
  }
  function checkScalarValue(codePoint) {
    if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
      throw Error('Lone surrogate U+' + codePoint.toString(16).toUpperCase() + ' is not a scalar value');
    }
  }
  /*--------------------------------------------------------------------------*/

  function createByte(codePoint, shift) {
    return stringFromCharCode(codePoint >> shift & 0x3F | 0x80);
  }
  function encodeCodePoint(codePoint) {
    if ((codePoint & 0xFFFFFF80) == 0) {
      // 1-byte sequence
      return stringFromCharCode(codePoint);
    }
    var symbol = '';
    if ((codePoint & 0xFFFFF800) == 0) {
      // 2-byte sequence
      symbol = stringFromCharCode(codePoint >> 6 & 0x1F | 0xC0);
    } else if ((codePoint & 0xFFFF0000) == 0) {
      // 3-byte sequence
      checkScalarValue(codePoint);
      symbol = stringFromCharCode(codePoint >> 12 & 0x0F | 0xE0);
      symbol += createByte(codePoint, 6);
    } else if ((codePoint & 0xFFE00000) == 0) {
      // 4-byte sequence
      symbol = stringFromCharCode(codePoint >> 18 & 0x07 | 0xF0);
      symbol += createByte(codePoint, 12);
      symbol += createByte(codePoint, 6);
    }
    symbol += stringFromCharCode(codePoint & 0x3F | 0x80);
    return symbol;
  }
  function utf8encode(string) {
    var codePoints = ucs2decode(string);
    var length = codePoints.length;
    var index = -1;
    var codePoint;
    var byteString = '';
    while (++index < length) {
      codePoint = codePoints[index];
      byteString += encodeCodePoint(codePoint);
    }
    return byteString;
  }

  /*--------------------------------------------------------------------------*/

  function readContinuationByte() {
    if (byteIndex >= byteCount) {
      throw Error('Invalid byte index');
    }
    var continuationByte = byteArray[byteIndex] & 0xFF;
    byteIndex++;
    if ((continuationByte & 0xC0) == 0x80) {
      return continuationByte & 0x3F;
    }

    // If we end up here, its not a continuation byte
    throw Error('Invalid continuation byte');
  }
  function decodeSymbol() {
    var byte1;
    var byte2;
    var byte3;
    var byte4;
    var codePoint;
    if (byteIndex > byteCount) {
      throw Error('Invalid byte index');
    }
    if (byteIndex == byteCount) {
      return false;
    }

    // Read first byte
    byte1 = byteArray[byteIndex] & 0xFF;
    byteIndex++;

    // 1-byte sequence (no continuation bytes)
    if ((byte1 & 0x80) == 0) {
      return byte1;
    }

    // 2-byte sequence
    if ((byte1 & 0xE0) == 0xC0) {
      byte2 = readContinuationByte();
      codePoint = (byte1 & 0x1F) << 6 | byte2;
      if (codePoint >= 0x80) {
        return codePoint;
      } else {
        throw Error('Invalid continuation byte');
      }
    }

    // 3-byte sequence (may include unpaired surrogates)
    if ((byte1 & 0xF0) == 0xE0) {
      byte2 = readContinuationByte();
      byte3 = readContinuationByte();
      codePoint = (byte1 & 0x0F) << 12 | byte2 << 6 | byte3;
      if (codePoint >= 0x0800) {
        checkScalarValue(codePoint);
        return codePoint;
      } else {
        throw Error('Invalid continuation byte');
      }
    }

    // 4-byte sequence
    if ((byte1 & 0xF8) == 0xF0) {
      byte2 = readContinuationByte();
      byte3 = readContinuationByte();
      byte4 = readContinuationByte();
      codePoint = (byte1 & 0x07) << 0x12 | byte2 << 0x0C | byte3 << 0x06 | byte4;
      if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
        return codePoint;
      }
    }
    throw Error('Invalid UTF-8 detected');
  }
  var byteArray;
  var byteCount;
  var byteIndex;
  function utf8decode(byteString) {
    byteArray = ucs2decode(byteString);
    byteCount = byteArray.length;
    byteIndex = 0;
    var codePoints = [];
    var tmp;
    while ((tmp = decodeSymbol()) !== false) {
      codePoints.push(tmp);
    }
    return ucs2encode(codePoints);
  }

  /*--------------------------------------------------------------------------*/

  root.version = '3.0.0';
  root.encode = utf8encode;
  root.decode = utf8decode;
})(typeof exports === 'undefined' ? (void 0).utf8 = {} : exports);

},{}],422:[function(require,module,exports){
(function (global){(function (){
"use strict";

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate(fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }
  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }
  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config(name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],423:[function(require,module,exports){
"use strict";

function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _toDate = _interopRequireDefault(require("./lib/toDate"));
var _toFloat = _interopRequireDefault(require("./lib/toFloat"));
var _toInt = _interopRequireDefault(require("./lib/toInt"));
var _toBoolean = _interopRequireDefault(require("./lib/toBoolean"));
var _equals = _interopRequireDefault(require("./lib/equals"));
var _contains = _interopRequireDefault(require("./lib/contains"));
var _matches = _interopRequireDefault(require("./lib/matches"));
var _isEmail = _interopRequireDefault(require("./lib/isEmail"));
var _isURL = _interopRequireDefault(require("./lib/isURL"));
var _isMACAddress = _interopRequireDefault(require("./lib/isMACAddress"));
var _isIP = _interopRequireDefault(require("./lib/isIP"));
var _isIPRange = _interopRequireDefault(require("./lib/isIPRange"));
var _isFQDN = _interopRequireDefault(require("./lib/isFQDN"));
var _isDate = _interopRequireDefault(require("./lib/isDate"));
var _isTime = _interopRequireDefault(require("./lib/isTime"));
var _isBoolean = _interopRequireDefault(require("./lib/isBoolean"));
var _isLocale = _interopRequireDefault(require("./lib/isLocale"));
var _isAbaRouting = _interopRequireDefault(require("./lib/isAbaRouting"));
var _isAlpha = _interopRequireWildcard(require("./lib/isAlpha"));
var _isAlphanumeric = _interopRequireWildcard(require("./lib/isAlphanumeric"));
var _isNumeric = _interopRequireDefault(require("./lib/isNumeric"));
var _isPassportNumber = _interopRequireDefault(require("./lib/isPassportNumber"));
var _isPort = _interopRequireDefault(require("./lib/isPort"));
var _isLowercase = _interopRequireDefault(require("./lib/isLowercase"));
var _isUppercase = _interopRequireDefault(require("./lib/isUppercase"));
var _isIMEI = _interopRequireDefault(require("./lib/isIMEI"));
var _isAscii = _interopRequireDefault(require("./lib/isAscii"));
var _isFullWidth = _interopRequireDefault(require("./lib/isFullWidth"));
var _isHalfWidth = _interopRequireDefault(require("./lib/isHalfWidth"));
var _isVariableWidth = _interopRequireDefault(require("./lib/isVariableWidth"));
var _isMultibyte = _interopRequireDefault(require("./lib/isMultibyte"));
var _isSemVer = _interopRequireDefault(require("./lib/isSemVer"));
var _isSurrogatePair = _interopRequireDefault(require("./lib/isSurrogatePair"));
var _isInt = _interopRequireDefault(require("./lib/isInt"));
var _isFloat = _interopRequireWildcard(require("./lib/isFloat"));
var _isDecimal = _interopRequireDefault(require("./lib/isDecimal"));
var _isHexadecimal = _interopRequireDefault(require("./lib/isHexadecimal"));
var _isOctal = _interopRequireDefault(require("./lib/isOctal"));
var _isDivisibleBy = _interopRequireDefault(require("./lib/isDivisibleBy"));
var _isHexColor = _interopRequireDefault(require("./lib/isHexColor"));
var _isRgbColor = _interopRequireDefault(require("./lib/isRgbColor"));
var _isHSL = _interopRequireDefault(require("./lib/isHSL"));
var _isISRC = _interopRequireDefault(require("./lib/isISRC"));
var _isIBAN = _interopRequireWildcard(require("./lib/isIBAN"));
var _isBIC = _interopRequireDefault(require("./lib/isBIC"));
var _isMD = _interopRequireDefault(require("./lib/isMD5"));
var _isHash = _interopRequireDefault(require("./lib/isHash"));
var _isJWT = _interopRequireDefault(require("./lib/isJWT"));
var _isJSON = _interopRequireDefault(require("./lib/isJSON"));
var _isEmpty = _interopRequireDefault(require("./lib/isEmpty"));
var _isLength = _interopRequireDefault(require("./lib/isLength"));
var _isByteLength = _interopRequireDefault(require("./lib/isByteLength"));
var _isUUID = _interopRequireDefault(require("./lib/isUUID"));
var _isMongoId = _interopRequireDefault(require("./lib/isMongoId"));
var _isAfter = _interopRequireDefault(require("./lib/isAfter"));
var _isBefore = _interopRequireDefault(require("./lib/isBefore"));
var _isIn = _interopRequireDefault(require("./lib/isIn"));
var _isLuhnNumber = _interopRequireDefault(require("./lib/isLuhnNumber"));
var _isCreditCard = _interopRequireDefault(require("./lib/isCreditCard"));
var _isIdentityCard = _interopRequireDefault(require("./lib/isIdentityCard"));
var _isEAN = _interopRequireDefault(require("./lib/isEAN"));
var _isISIN = _interopRequireDefault(require("./lib/isISIN"));
var _isISBN = _interopRequireDefault(require("./lib/isISBN"));
var _isISSN = _interopRequireDefault(require("./lib/isISSN"));
var _isTaxID = _interopRequireDefault(require("./lib/isTaxID"));
var _isMobilePhone = _interopRequireWildcard(require("./lib/isMobilePhone"));
var _isEthereumAddress = _interopRequireDefault(require("./lib/isEthereumAddress"));
var _isCurrency = _interopRequireDefault(require("./lib/isCurrency"));
var _isBtcAddress = _interopRequireDefault(require("./lib/isBtcAddress"));
var _isISO = require("./lib/isISO6346");
var _isISO2 = _interopRequireDefault(require("./lib/isISO6391"));
var _isISO3 = _interopRequireDefault(require("./lib/isISO8601"));
var _isRFC = _interopRequireDefault(require("./lib/isRFC3339"));
var _isISO31661Alpha = _interopRequireDefault(require("./lib/isISO31661Alpha2"));
var _isISO31661Alpha2 = _interopRequireDefault(require("./lib/isISO31661Alpha3"));
var _isISO4 = _interopRequireDefault(require("./lib/isISO4217"));
var _isBase = _interopRequireDefault(require("./lib/isBase32"));
var _isBase2 = _interopRequireDefault(require("./lib/isBase58"));
var _isBase3 = _interopRequireDefault(require("./lib/isBase64"));
var _isDataURI = _interopRequireDefault(require("./lib/isDataURI"));
var _isMagnetURI = _interopRequireDefault(require("./lib/isMagnetURI"));
var _isMailtoURI = _interopRequireDefault(require("./lib/isMailtoURI"));
var _isMimeType = _interopRequireDefault(require("./lib/isMimeType"));
var _isLatLong = _interopRequireDefault(require("./lib/isLatLong"));
var _isPostalCode = _interopRequireWildcard(require("./lib/isPostalCode"));
var _ltrim = _interopRequireDefault(require("./lib/ltrim"));
var _rtrim = _interopRequireDefault(require("./lib/rtrim"));
var _trim = _interopRequireDefault(require("./lib/trim"));
var _escape = _interopRequireDefault(require("./lib/escape"));
var _unescape = _interopRequireDefault(require("./lib/unescape"));
var _stripLow = _interopRequireDefault(require("./lib/stripLow"));
var _whitelist = _interopRequireDefault(require("./lib/whitelist"));
var _blacklist = _interopRequireDefault(require("./lib/blacklist"));
var _isWhitelisted = _interopRequireDefault(require("./lib/isWhitelisted"));
var _normalizeEmail = _interopRequireDefault(require("./lib/normalizeEmail"));
var _isSlug = _interopRequireDefault(require("./lib/isSlug"));
var _isLicensePlate = _interopRequireDefault(require("./lib/isLicensePlate"));
var _isStrongPassword = _interopRequireDefault(require("./lib/isStrongPassword"));
var _isVAT = _interopRequireDefault(require("./lib/isVAT"));
function _getRequireWildcardCache(e) {
  if ("function" != typeof WeakMap) return null;
  var r = new WeakMap(),
    t = new WeakMap();
  return (_getRequireWildcardCache = function _getRequireWildcardCache(e) {
    return e ? t : r;
  })(e);
}
function _interopRequireWildcard(e, r) {
  if (!r && e && e.__esModule) return e;
  if (null === e || "object" != _typeof(e) && "function" != typeof e) return {
    "default": e
  };
  var t = _getRequireWildcardCache(r);
  if (t && t.has(e)) return t.get(e);
  var n = {
      __proto__: null
    },
    a = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) {
    var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
    i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
  }
  return n["default"] = e, t && t.set(e, n), n;
}
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
var version = '13.12.0';
var validator = {
  version: version,
  toDate: _toDate["default"],
  toFloat: _toFloat["default"],
  toInt: _toInt["default"],
  toBoolean: _toBoolean["default"],
  equals: _equals["default"],
  contains: _contains["default"],
  matches: _matches["default"],
  isEmail: _isEmail["default"],
  isURL: _isURL["default"],
  isMACAddress: _isMACAddress["default"],
  isIP: _isIP["default"],
  isIPRange: _isIPRange["default"],
  isFQDN: _isFQDN["default"],
  isBoolean: _isBoolean["default"],
  isIBAN: _isIBAN["default"],
  isBIC: _isBIC["default"],
  isAbaRouting: _isAbaRouting["default"],
  isAlpha: _isAlpha["default"],
  isAlphaLocales: _isAlpha.locales,
  isAlphanumeric: _isAlphanumeric["default"],
  isAlphanumericLocales: _isAlphanumeric.locales,
  isNumeric: _isNumeric["default"],
  isPassportNumber: _isPassportNumber["default"],
  isPort: _isPort["default"],
  isLowercase: _isLowercase["default"],
  isUppercase: _isUppercase["default"],
  isAscii: _isAscii["default"],
  isFullWidth: _isFullWidth["default"],
  isHalfWidth: _isHalfWidth["default"],
  isVariableWidth: _isVariableWidth["default"],
  isMultibyte: _isMultibyte["default"],
  isSemVer: _isSemVer["default"],
  isSurrogatePair: _isSurrogatePair["default"],
  isInt: _isInt["default"],
  isIMEI: _isIMEI["default"],
  isFloat: _isFloat["default"],
  isFloatLocales: _isFloat.locales,
  isDecimal: _isDecimal["default"],
  isHexadecimal: _isHexadecimal["default"],
  isOctal: _isOctal["default"],
  isDivisibleBy: _isDivisibleBy["default"],
  isHexColor: _isHexColor["default"],
  isRgbColor: _isRgbColor["default"],
  isHSL: _isHSL["default"],
  isISRC: _isISRC["default"],
  isMD5: _isMD["default"],
  isHash: _isHash["default"],
  isJWT: _isJWT["default"],
  isJSON: _isJSON["default"],
  isEmpty: _isEmpty["default"],
  isLength: _isLength["default"],
  isLocale: _isLocale["default"],
  isByteLength: _isByteLength["default"],
  isUUID: _isUUID["default"],
  isMongoId: _isMongoId["default"],
  isAfter: _isAfter["default"],
  isBefore: _isBefore["default"],
  isIn: _isIn["default"],
  isLuhnNumber: _isLuhnNumber["default"],
  isCreditCard: _isCreditCard["default"],
  isIdentityCard: _isIdentityCard["default"],
  isEAN: _isEAN["default"],
  isISIN: _isISIN["default"],
  isISBN: _isISBN["default"],
  isISSN: _isISSN["default"],
  isMobilePhone: _isMobilePhone["default"],
  isMobilePhoneLocales: _isMobilePhone.locales,
  isPostalCode: _isPostalCode["default"],
  isPostalCodeLocales: _isPostalCode.locales,
  isEthereumAddress: _isEthereumAddress["default"],
  isCurrency: _isCurrency["default"],
  isBtcAddress: _isBtcAddress["default"],
  isISO6346: _isISO.isISO6346,
  isFreightContainerID: _isISO.isFreightContainerID,
  isISO6391: _isISO2["default"],
  isISO8601: _isISO3["default"],
  isRFC3339: _isRFC["default"],
  isISO31661Alpha2: _isISO31661Alpha["default"],
  isISO31661Alpha3: _isISO31661Alpha2["default"],
  isISO4217: _isISO4["default"],
  isBase32: _isBase["default"],
  isBase58: _isBase2["default"],
  isBase64: _isBase3["default"],
  isDataURI: _isDataURI["default"],
  isMagnetURI: _isMagnetURI["default"],
  isMailtoURI: _isMailtoURI["default"],
  isMimeType: _isMimeType["default"],
  isLatLong: _isLatLong["default"],
  ltrim: _ltrim["default"],
  rtrim: _rtrim["default"],
  trim: _trim["default"],
  escape: _escape["default"],
  unescape: _unescape["default"],
  stripLow: _stripLow["default"],
  whitelist: _whitelist["default"],
  blacklist: _blacklist["default"],
  isWhitelisted: _isWhitelisted["default"],
  normalizeEmail: _normalizeEmail["default"],
  toString: toString,
  isSlug: _isSlug["default"],
  isStrongPassword: _isStrongPassword["default"],
  isTaxID: _isTaxID["default"],
  isDate: _isDate["default"],
  isTime: _isTime["default"],
  isLicensePlate: _isLicensePlate["default"],
  isVAT: _isVAT["default"],
  ibanLocales: _isIBAN.locales
};
var _default = exports["default"] = validator;
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./lib/blacklist":425,"./lib/contains":426,"./lib/equals":427,"./lib/escape":428,"./lib/isAbaRouting":429,"./lib/isAfter":430,"./lib/isAlpha":431,"./lib/isAlphanumeric":432,"./lib/isAscii":433,"./lib/isBIC":434,"./lib/isBase32":435,"./lib/isBase58":436,"./lib/isBase64":437,"./lib/isBefore":438,"./lib/isBoolean":439,"./lib/isBtcAddress":440,"./lib/isByteLength":441,"./lib/isCreditCard":442,"./lib/isCurrency":443,"./lib/isDataURI":444,"./lib/isDate":445,"./lib/isDecimal":446,"./lib/isDivisibleBy":447,"./lib/isEAN":448,"./lib/isEmail":449,"./lib/isEmpty":450,"./lib/isEthereumAddress":451,"./lib/isFQDN":452,"./lib/isFloat":453,"./lib/isFullWidth":454,"./lib/isHSL":455,"./lib/isHalfWidth":456,"./lib/isHash":457,"./lib/isHexColor":458,"./lib/isHexadecimal":459,"./lib/isIBAN":460,"./lib/isIMEI":461,"./lib/isIP":462,"./lib/isIPRange":463,"./lib/isISBN":464,"./lib/isISIN":465,"./lib/isISO31661Alpha2":466,"./lib/isISO31661Alpha3":467,"./lib/isISO4217":468,"./lib/isISO6346":469,"./lib/isISO6391":470,"./lib/isISO8601":471,"./lib/isISRC":472,"./lib/isISSN":473,"./lib/isIdentityCard":474,"./lib/isIn":475,"./lib/isInt":476,"./lib/isJSON":477,"./lib/isJWT":478,"./lib/isLatLong":479,"./lib/isLength":480,"./lib/isLicensePlate":481,"./lib/isLocale":482,"./lib/isLowercase":483,"./lib/isLuhnNumber":484,"./lib/isMACAddress":485,"./lib/isMD5":486,"./lib/isMagnetURI":487,"./lib/isMailtoURI":488,"./lib/isMimeType":489,"./lib/isMobilePhone":490,"./lib/isMongoId":491,"./lib/isMultibyte":492,"./lib/isNumeric":493,"./lib/isOctal":494,"./lib/isPassportNumber":495,"./lib/isPort":496,"./lib/isPostalCode":497,"./lib/isRFC3339":498,"./lib/isRgbColor":499,"./lib/isSemVer":500,"./lib/isSlug":501,"./lib/isStrongPassword":502,"./lib/isSurrogatePair":503,"./lib/isTaxID":504,"./lib/isTime":505,"./lib/isURL":506,"./lib/isUUID":507,"./lib/isUppercase":508,"./lib/isVAT":509,"./lib/isVariableWidth":510,"./lib/isWhitelisted":511,"./lib/ltrim":512,"./lib/matches":513,"./lib/normalizeEmail":514,"./lib/rtrim":515,"./lib/stripLow":516,"./lib/toBoolean":517,"./lib/toDate":518,"./lib/toFloat":519,"./lib/toInt":520,"./lib/trim":521,"./lib/unescape":522,"./lib/whitelist":529}],424:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.farsiLocales = exports.englishLocales = exports.dotDecimal = exports.decimal = exports.commaDecimal = exports.bengaliLocales = exports.arabicLocales = exports.alphanumeric = exports.alpha = void 0;
var alpha = exports.alpha = {
  'en-US': /^[A-Z]+$/i,
  'az-AZ': /^[A-VXYZ]+$/i,
  'bg-BG': /^[-]+$/i,
  'cs-CZ': /^[A-Z]+$/i,
  'da-DK': /^[A-Z]+$/i,
  'de-DE': /^[A-Z]+$/i,
  'el-GR': /^[-]+$/i,
  'es-ES': /^[A-Z]+$/i,
  'fa-IR': /^[]+$/i,
  'fi-FI': /^[A-Z]+$/i,
  'fr-FR': /^[A-Z]+$/i,
  'it-IT': /^[A-Z]+$/i,
  'ja-JP': /^[----]+$/i,
  'nb-NO': /^[A-Z]+$/i,
  'nl-NL': /^[A-Z]+$/i,
  'nn-NO': /^[A-Z]+$/i,
  'hu-HU': /^[A-Z]+$/i,
  'pl-PL': /^[A-Z]+$/i,
  'pt-PT': /^[A-Z]+$/i,
  'ru-RU': /^[-]+$/i,
  'kk-KZ': /^[-\u04D8\u04B0\u0406\u04A2\u0492\u04AE\u049A\u04E8\u04BA]+$/i,
  'sl-SI': /^[A-Z]+$/i,
  'sk-SK': /^[A-Z]+$/i,
  'sr-RS@latin': /^[A-Z]+$/i,
  'sr-RS': /^[-]+$/i,
  'sv-SE': /^[A-Z]+$/i,
  'th-TH': /^[-\s]+$/i,
  'tr-TR': /^[A-Z]+$/i,
  'uk-UA': /^[-I]+$/i,
  'vi-VN': /^[A-Z]+$/i,
  'ko-KR': /^[---]*$/,
  'ku-IQ': /^[]+$/i,
  ar: /^[]+$/,
  he: /^[-]+$/,
  fa: /^['']+$/i,
  bn: /^['']+$/,
  eo: /^[ABCD-GHIJK-PRSTUVZ]+$/i,
  'hi-IN': /^[\u0900-\u0961]+[\u0972-\u097F]*$/i,
  'si-LK': /^[\u0D80-\u0DFF]+$/
};
var alphanumeric = exports.alphanumeric = {
  'en-US': /^[0-9A-Z]+$/i,
  'az-AZ': /^[0-9A-VXYZ]+$/i,
  'bg-BG': /^[0-9-]+$/i,
  'cs-CZ': /^[0-9A-Z]+$/i,
  'da-DK': /^[0-9A-Z]+$/i,
  'de-DE': /^[0-9A-Z]+$/i,
  'el-GR': /^[0-9-]+$/i,
  'es-ES': /^[0-9A-Z]+$/i,
  'fi-FI': /^[0-9A-Z]+$/i,
  'fr-FR': /^[0-9A-Z]+$/i,
  'it-IT': /^[0-9A-Z]+$/i,
  'ja-JP': /^[0-9-----]+$/i,
  'hu-HU': /^[0-9A-Z]+$/i,
  'nb-NO': /^[0-9A-Z]+$/i,
  'nl-NL': /^[0-9A-Z]+$/i,
  'nn-NO': /^[0-9A-Z]+$/i,
  'pl-PL': /^[0-9A-Z]+$/i,
  'pt-PT': /^[0-9A-Z]+$/i,
  'ru-RU': /^[0-9-]+$/i,
  'kk-KZ': /^[0-9-\u04D8\u04B0\u0406\u04A2\u0492\u04AE\u049A\u04E8\u04BA]+$/i,
  'sl-SI': /^[0-9A-Z]+$/i,
  'sk-SK': /^[0-9A-Z]+$/i,
  'sr-RS@latin': /^[0-9A-Z]+$/i,
  'sr-RS': /^[0-9-]+$/i,
  'sv-SE': /^[0-9A-Z]+$/i,
  'th-TH': /^[-\s]+$/i,
  'tr-TR': /^[0-9A-Z]+$/i,
  'uk-UA': /^[0-9-I]+$/i,
  'ko-KR': /^[0-9---]*$/,
  'ku-IQ': /^[0-9]+$/i,
  'vi-VN': /^[0-9A-Z]+$/i,
  ar: /^[0-9]+$/,
  he: /^[0-9-]+$/,
  fa: /^['0-9']+$/i,
  bn: /^['']+$/,
  eo: /^[0-9ABCD-GHIJK-PRSTUVZ]+$/i,
  'hi-IN': /^[\u0900-\u0963]+[\u0966-\u097F]*$/i,
  'si-LK': /^[0-9\u0D80-\u0DFF]+$/
};
var decimal = exports.decimal = {
  'en-US': '.',
  ar: ''
};
var englishLocales = exports.englishLocales = ['AU', 'GB', 'HK', 'IN', 'NZ', 'ZA', 'ZM'];
for (var locale, i = 0; i < englishLocales.length; i++) {
  locale = "en-".concat(englishLocales[i]);
  alpha[locale] = alpha['en-US'];
  alphanumeric[locale] = alphanumeric['en-US'];
  decimal[locale] = decimal['en-US'];
}

// Source: http://www.localeplanet.com/java/
var arabicLocales = exports.arabicLocales = ['AE', 'BH', 'DZ', 'EG', 'IQ', 'JO', 'KW', 'LB', 'LY', 'MA', 'QM', 'QA', 'SA', 'SD', 'SY', 'TN', 'YE'];
for (var _locale, _i = 0; _i < arabicLocales.length; _i++) {
  _locale = "ar-".concat(arabicLocales[_i]);
  alpha[_locale] = alpha.ar;
  alphanumeric[_locale] = alphanumeric.ar;
  decimal[_locale] = decimal.ar;
}
var farsiLocales = exports.farsiLocales = ['IR', 'AF'];
for (var _locale2, _i2 = 0; _i2 < farsiLocales.length; _i2++) {
  _locale2 = "fa-".concat(farsiLocales[_i2]);
  alphanumeric[_locale2] = alphanumeric.fa;
  decimal[_locale2] = decimal.ar;
}
var bengaliLocales = exports.bengaliLocales = ['BD', 'IN'];
for (var _locale3, _i3 = 0; _i3 < bengaliLocales.length; _i3++) {
  _locale3 = "bn-".concat(bengaliLocales[_i3]);
  alpha[_locale3] = alpha.bn;
  alphanumeric[_locale3] = alphanumeric.bn;
  decimal[_locale3] = decimal['en-US'];
}

// Source: https://en.wikipedia.org/wiki/Decimal_mark
var dotDecimal = exports.dotDecimal = ['ar-EG', 'ar-LB', 'ar-LY'];
var commaDecimal = exports.commaDecimal = ['bg-BG', 'cs-CZ', 'da-DK', 'de-DE', 'el-GR', 'en-ZM', 'eo', 'es-ES', 'fr-CA', 'fr-FR', 'id-ID', 'it-IT', 'ku-IQ', 'hi-IN', 'hu-HU', 'nb-NO', 'nn-NO', 'nl-NL', 'pl-PL', 'pt-PT', 'ru-RU', 'kk-KZ', 'si-LK', 'sl-SI', 'sr-RS@latin', 'sr-RS', 'sv-SE', 'tr-TR', 'uk-UA', 'vi-VN'];
for (var _i4 = 0; _i4 < dotDecimal.length; _i4++) {
  decimal[dotDecimal[_i4]] = decimal['en-US'];
}
for (var _i5 = 0; _i5 < commaDecimal.length; _i5++) {
  decimal[commaDecimal[_i5]] = ',';
}
alpha['fr-CA'] = alpha['fr-FR'];
alphanumeric['fr-CA'] = alphanumeric['fr-FR'];
alpha['pt-BR'] = alpha['pt-PT'];
alphanumeric['pt-BR'] = alphanumeric['pt-PT'];
decimal['pt-BR'] = decimal['pt-PT'];

// see #862
alpha['pl-Pl'] = alpha['pl-PL'];
alphanumeric['pl-Pl'] = alphanumeric['pl-PL'];
decimal['pl-Pl'] = decimal['pl-PL'];

// see #1455
alpha['fa-AF'] = alpha.fa;

},{}],425:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = blacklist;
var _assertString = _interopRequireDefault(require("./util/assertString"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
function blacklist(str, chars) {
  (0, _assertString["default"])(str);
  return str.replace(new RegExp("[".concat(chars, "]+"), 'g'), '');
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./util/assertString":524}],426:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = contains;
var _assertString = _interopRequireDefault(require("./util/assertString"));
var _toString = _interopRequireDefault(require("./util/toString"));
var _merge = _interopRequireDefault(require("./util/merge"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
var defaulContainsOptions = {
  ignoreCase: false,
  minOccurrences: 1
};
function contains(str, elem, options) {
  (0, _assertString["default"])(str);
  options = (0, _merge["default"])(options, defaulContainsOptions);
  if (options.ignoreCase) {
    return str.toLowerCase().split((0, _toString["default"])(elem).toLowerCase()).length > options.minOccurrences;
  }
  return str.split((0, _toString["default"])(elem)).length > options.minOccurrences;
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./util/assertString":524,"./util/merge":526,"./util/toString":528}],427:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = equals;
var _assertString = _interopRequireDefault(require("./util/assertString"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
function equals(str, comparison) {
  (0, _assertString["default"])(str);
  return str === comparison;
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./util/assertString":524}],428:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = escape;
var _assertString = _interopRequireDefault(require("./util/assertString"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
function escape(str) {
  (0, _assertString["default"])(str);
  return str.replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/'/g, '&#x27;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\//g, '&#x2F;').replace(/\\/g, '&#x5C;').replace(/`/g, '&#96;');
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./util/assertString":524}],429:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isAbaRouting;
var _assertString = _interopRequireDefault(require("./util/assertString"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
// http://www.brainjar.com/js/validation/
// https://www.aba.com/news-research/research-analysis/routing-number-policy-procedures
// series reserved for future use are excluded
var isRoutingReg = /^(?!(1[3-9])|(20)|(3[3-9])|(4[0-9])|(5[0-9])|(60)|(7[3-9])|(8[1-9])|(9[0-2])|(9[3-9]))[0-9]{9}$/;
function isAbaRouting(str) {
  (0, _assertString["default"])(str);
  if (!isRoutingReg.test(str)) return false;
  var checkSumVal = 0;
  for (var i = 0; i < str.length; i++) {
    if (i % 3 === 0) checkSumVal += str[i] * 3;else if (i % 3 === 1) checkSumVal += str[i] * 7;else checkSumVal += str[i] * 1;
  }
  return checkSumVal % 10 === 0;
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./util/assertString":524}],430:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isAfter;
var _toDate = _interopRequireDefault(require("./toDate"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
function isAfter(date, options) {
  // For backwards compatibility:
  // isAfter(str [, date]), i.e. `options` could be used as argument for the legacy `date`
  var comparisonDate = (options === null || options === void 0 ? void 0 : options.comparisonDate) || options || Date().toString();
  var comparison = (0, _toDate["default"])(comparisonDate);
  var original = (0, _toDate["default"])(date);
  return !!(original && comparison && original > comparison);
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./toDate":518}],431:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isAlpha;
exports.locales = void 0;
var _assertString = _interopRequireDefault(require("./util/assertString"));
var _alpha = require("./alpha");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
function isAlpha(_str) {
  var locale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'en-US';
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  (0, _assertString["default"])(_str);
  var str = _str;
  var ignore = options.ignore;
  if (ignore) {
    if (ignore instanceof RegExp) {
      str = str.replace(ignore, '');
    } else if (typeof ignore === 'string') {
      str = str.replace(new RegExp("[".concat(ignore.replace(/[-[\]{}()*+?.,\\^$|#\\s]/g, '\\$&'), "]"), 'g'), ''); // escape regex for ignore
    } else {
      throw new Error('ignore should be instance of a String or RegExp');
    }
  }
  if (locale in _alpha.alpha) {
    return _alpha.alpha[locale].test(str);
  }
  throw new Error("Invalid locale '".concat(locale, "'"));
}
var locales = exports.locales = Object.keys(_alpha.alpha);

},{"./alpha":424,"./util/assertString":524}],432:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isAlphanumeric;
exports.locales = void 0;
var _assertString = _interopRequireDefault(require("./util/assertString"));
var _alpha = require("./alpha");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
function isAlphanumeric(_str) {
  var locale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'en-US';
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  (0, _assertString["default"])(_str);
  var str = _str;
  var ignore = options.ignore;
  if (ignore) {
    if (ignore instanceof RegExp) {
      str = str.replace(ignore, '');
    } else if (typeof ignore === 'string') {
      str = str.replace(new RegExp("[".concat(ignore.replace(/[-[\]{}()*+?.,\\^$|#\\s]/g, '\\$&'), "]"), 'g'), ''); // escape regex for ignore
    } else {
      throw new Error('ignore should be instance of a String or RegExp');
    }
  }
  if (locale in _alpha.alphanumeric) {
    return _alpha.alphanumeric[locale].test(str);
  }
  throw new Error("Invalid locale '".concat(locale, "'"));
}
var locales = exports.locales = Object.keys(_alpha.alphanumeric);

},{"./alpha":424,"./util/assertString":524}],433:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isAscii;
var _assertString = _interopRequireDefault(require("./util/assertString"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
/* eslint-disable no-control-regex */
var ascii = /^[\x00-\x7F]+$/;
/* eslint-enable no-control-regex */

function isAscii(str) {
  (0, _assertString["default"])(str);
  return ascii.test(str);
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./util/assertString":524}],434:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isBIC;
var _assertString = _interopRequireDefault(require("./util/assertString"));
var _isISO31661Alpha = require("./isISO31661Alpha2");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
// https://en.wikipedia.org/wiki/ISO_9362
var isBICReg = /^[A-Za-z]{6}[A-Za-z0-9]{2}([A-Za-z0-9]{3})?$/;
function isBIC(str) {
  (0, _assertString["default"])(str);

  // toUpperCase() should be removed when a new major version goes out that changes
  // the regex to [A-Z] (per the spec).
  var countryCode = str.slice(4, 6).toUpperCase();
  if (!_isISO31661Alpha.CountryCodes.has(countryCode) && countryCode !== 'XK') {
    return false;
  }
  return isBICReg.test(str);
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./isISO31661Alpha2":466,"./util/assertString":524}],435:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isBase32;
var _assertString = _interopRequireDefault(require("./util/assertString"));
var _merge = _interopRequireDefault(require("./util/merge"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
var base32 = /^[A-Z2-7]+=*$/;
var crockfordBase32 = /^[A-HJKMNP-TV-Z0-9]+$/;
var defaultBase32Options = {
  crockford: false
};
function isBase32(str, options) {
  (0, _assertString["default"])(str);
  options = (0, _merge["default"])(options, defaultBase32Options);
  if (options.crockford) {
    return crockfordBase32.test(str);
  }
  var len = str.length;
  if (len % 8 === 0 && base32.test(str)) {
    return true;
  }
  return false;
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./util/assertString":524,"./util/merge":526}],436:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isBase58;
var _assertString = _interopRequireDefault(require("./util/assertString"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
// Accepted chars - 123456789ABCDEFGH JKLMN PQRSTUVWXYZabcdefghijk mnopqrstuvwxyz
var base58Reg = /^[A-HJ-NP-Za-km-z1-9]*$/;
function isBase58(str) {
  (0, _assertString["default"])(str);
  if (base58Reg.test(str)) {
    return true;
  }
  return false;
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./util/assertString":524}],437:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isBase64;
var _assertString = _interopRequireDefault(require("./util/assertString"));
var _merge = _interopRequireDefault(require("./util/merge"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
var notBase64 = /[^A-Z0-9+\/=]/i;
var urlSafeBase64 = /^[A-Z0-9_\-]*$/i;
var defaultBase64Options = {
  urlSafe: false
};
function isBase64(str, options) {
  (0, _assertString["default"])(str);
  options = (0, _merge["default"])(options, defaultBase64Options);
  var len = str.length;
  if (options.urlSafe) {
    return urlSafeBase64.test(str);
  }
  if (len % 4 !== 0 || notBase64.test(str)) {
    return false;
  }
  var firstPaddingChar = str.indexOf('=');
  return firstPaddingChar === -1 || firstPaddingChar === len - 1 || firstPaddingChar === len - 2 && str[len - 1] === '=';
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./util/assertString":524,"./util/merge":526}],438:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isBefore;
var _assertString = _interopRequireDefault(require("./util/assertString"));
var _toDate = _interopRequireDefault(require("./toDate"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
function isBefore(str) {
  var date = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : String(new Date());
  (0, _assertString["default"])(str);
  var comparison = (0, _toDate["default"])(date);
  var original = (0, _toDate["default"])(str);
  return !!(original && comparison && original < comparison);
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./toDate":518,"./util/assertString":524}],439:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isBoolean;
var _assertString = _interopRequireDefault(require("./util/assertString"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
var defaultOptions = {
  loose: false
};
var strictBooleans = ['true', 'false', '1', '0'];
var looseBooleans = [].concat(strictBooleans, ['yes', 'no']);
function isBoolean(str) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultOptions;
  (0, _assertString["default"])(str);
  if (options.loose) {
    return looseBooleans.includes(str.toLowerCase());
  }
  return strictBooleans.includes(str);
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./util/assertString":524}],440:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isBtcAddress;
var _assertString = _interopRequireDefault(require("./util/assertString"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
var bech32 = /^(bc1)[a-z0-9]{25,39}$/;
var base58 = /^(1|3)[A-HJ-NP-Za-km-z1-9]{25,39}$/;
function isBtcAddress(str) {
  (0, _assertString["default"])(str);
  return bech32.test(str) || base58.test(str);
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./util/assertString":524}],441:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isByteLength;
var _assertString = _interopRequireDefault(require("./util/assertString"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}
/* eslint-disable prefer-rest-params */
function isByteLength(str, options) {
  (0, _assertString["default"])(str);
  var min;
  var max;
  if (_typeof(options) === 'object') {
    min = options.min || 0;
    max = options.max;
  } else {
    // backwards compatibility: isByteLength(str, min [, max])
    min = arguments[1];
    max = arguments[2];
  }
  var len = encodeURI(str).split(/%..|./).length - 1;
  return len >= min && (typeof max === 'undefined' || len <= max);
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./util/assertString":524}],442:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isCreditCard;
var _assertString = _interopRequireDefault(require("./util/assertString"));
var _isLuhnNumber = _interopRequireDefault(require("./isLuhnNumber"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
var cards = {
  amex: /^3[47][0-9]{13}$/,
  dinersclub: /^3(?:0[0-5]|[68][0-9])[0-9]{11}$/,
  discover: /^6(?:011|5[0-9][0-9])[0-9]{12,15}$/,
  jcb: /^(?:2131|1800|35\d{3})\d{11}$/,
  mastercard: /^5[1-5][0-9]{2}|(222[1-9]|22[3-9][0-9]|2[3-6][0-9]{2}|27[01][0-9]|2720)[0-9]{12}$/,
  // /^[25][1-7][0-9]{14}$/;
  unionpay: /^(6[27][0-9]{14}|^(81[0-9]{14,17}))$/,
  visa: /^(?:4[0-9]{12})(?:[0-9]{3,6})?$/
};
var allCards = function () {
  var tmpCardsArray = [];
  for (var cardProvider in cards) {
    // istanbul ignore else
    if (cards.hasOwnProperty(cardProvider)) {
      tmpCardsArray.push(cards[cardProvider]);
    }
  }
  return tmpCardsArray;
}();
function isCreditCard(card) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  (0, _assertString["default"])(card);
  var provider = options.provider;
  var sanitized = card.replace(/[- ]+/g, '');
  if (provider && provider.toLowerCase() in cards) {
    // specific provider in the list
    if (!cards[provider.toLowerCase()].test(sanitized)) {
      return false;
    }
  } else if (provider && !(provider.toLowerCase() in cards)) {
    /* specific provider not in the list */
    throw new Error("".concat(provider, " is not a valid credit card provider."));
  } else if (!allCards.some(function (cardProvider) {
    return cardProvider.test(sanitized);
  })) {
    // no specific provider
    return false;
  }
  return (0, _isLuhnNumber["default"])(card);
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./isLuhnNumber":484,"./util/assertString":524}],443:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isCurrency;
var _merge = _interopRequireDefault(require("./util/merge"));
var _assertString = _interopRequireDefault(require("./util/assertString"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
function currencyRegex(options) {
  var decimal_digits = "\\d{".concat(options.digits_after_decimal[0], "}");
  options.digits_after_decimal.forEach(function (digit, index) {
    if (index !== 0) decimal_digits = "".concat(decimal_digits, "|\\d{").concat(digit, "}");
  });
  var symbol = "(".concat(options.symbol.replace(/\W/, function (m) {
      return "\\".concat(m);
    }), ")").concat(options.require_symbol ? '' : '?'),
    negative = '-?',
    whole_dollar_amount_without_sep = '[1-9]\\d*',
    whole_dollar_amount_with_sep = "[1-9]\\d{0,2}(\\".concat(options.thousands_separator, "\\d{3})*"),
    valid_whole_dollar_amounts = ['0', whole_dollar_amount_without_sep, whole_dollar_amount_with_sep],
    whole_dollar_amount = "(".concat(valid_whole_dollar_amounts.join('|'), ")?"),
    decimal_amount = "(\\".concat(options.decimal_separator, "(").concat(decimal_digits, "))").concat(options.require_decimal ? '' : '?');
  var pattern = whole_dollar_amount + (options.allow_decimal || options.require_decimal ? decimal_amount : '');

  // default is negative sign before symbol, but there are two other options (besides parens)
  if (options.allow_negatives && !options.parens_for_negatives) {
    if (options.negative_sign_after_digits) {
      pattern += negative;
    } else if (options.negative_sign_before_digits) {
      pattern = negative + pattern;
    }
  }

  // South African Rand, for example, uses R 123 (space) and R-123 (no space)
  if (options.allow_negative_sign_placeholder) {
    pattern = "( (?!\\-))?".concat(pattern);
  } else if (options.allow_space_after_symbol) {
    pattern = " ?".concat(pattern);
  } else if (options.allow_space_after_digits) {
    pattern += '( (?!$))?';
  }
  if (options.symbol_after_digits) {
    pattern += symbol;
  } else {
    pattern = symbol + pattern;
  }
  if (options.allow_negatives) {
    if (options.parens_for_negatives) {
      pattern = "(\\(".concat(pattern, "\\)|").concat(pattern, ")");
    } else if (!(options.negative_sign_before_digits || options.negative_sign_after_digits)) {
      pattern = negative + pattern;
    }
  }

  // ensure there's a dollar and/or decimal amount, and that
  // it doesn't start with a space or a negative sign followed by a space
  return new RegExp("^(?!-? )(?=.*\\d)".concat(pattern, "$"));
}
var default_currency_options = {
  symbol: '$',
  require_symbol: false,
  allow_space_after_symbol: false,
  symbol_after_digits: false,
  allow_negatives: true,
  parens_for_negatives: false,
  negative_sign_before_digits: false,
  negative_sign_after_digits: false,
  allow_negative_sign_placeholder: false,
  thousands_separator: ',',
  decimal_separator: '.',
  allow_decimal: true,
  require_decimal: false,
  digits_after_decimal: [2],
  allow_space_after_digits: false
};
function isCurrency(str, options) {
  (0, _assertString["default"])(str);
  options = (0, _merge["default"])(options, default_currency_options);
  return currencyRegex(options).test(str);
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./util/assertString":524,"./util/merge":526}],444:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isDataURI;
var _assertString = _interopRequireDefault(require("./util/assertString"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
var validMediaType = /^[a-z]+\/[a-z0-9\-\+\._]+$/i;
var validAttribute = /^[a-z\-]+=[a-z0-9\-]+$/i;
var validData = /^[a-z0-9!\$&'\(\)\*\+,;=\-\._~:@\/\?%\s]*$/i;
function isDataURI(str) {
  (0, _assertString["default"])(str);
  var data = str.split(',');
  if (data.length < 2) {
    return false;
  }
  var attributes = data.shift().trim().split(';');
  var schemeAndMediaType = attributes.shift();
  if (schemeAndMediaType.slice(0, 5) !== 'data:') {
    return false;
  }
  var mediaType = schemeAndMediaType.slice(5);
  if (mediaType !== '' && !validMediaType.test(mediaType)) {
    return false;
  }
  for (var i = 0; i < attributes.length; i++) {
    if (!(i === attributes.length - 1 && attributes[i].toLowerCase() === 'base64') && !validAttribute.test(attributes[i])) {
      return false;
    }
  }
  for (var _i = 0; _i < data.length; _i++) {
    if (!validData.test(data[_i])) {
      return false;
    }
  }
  return true;
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./util/assertString":524}],445:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isDate;
var _merge = _interopRequireDefault(require("./util/merge"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArrayLimit(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e,
      n,
      i,
      u,
      a = [],
      f = !0,
      o = !1;
    try {
      if (i = (t = t.call(r)).next, 0 === l) {
        if (Object(t) !== t) return;
        f = !1;
      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);
    } catch (r) {
      o = !0, n = r;
    } finally {
      try {
        if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}
function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      var F = function F() {};
      return {
        s: F,
        n: function n() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function e(_e) {
          throw _e;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true,
    didErr = false,
    err;
  return {
    s: function s() {
      it = it.call(o);
    },
    n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function e(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function f() {
      try {
        if (!normalCompletion && it["return"] != null) it["return"]();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
var default_date_options = {
  format: 'YYYY/MM/DD',
  delimiters: ['/', '-'],
  strictMode: false
};
function isValidFormat(format) {
  return /(^(y{4}|y{2})[.\/-](m{1,2})[.\/-](d{1,2})$)|(^(m{1,2})[.\/-](d{1,2})[.\/-]((y{4}|y{2})$))|(^(d{1,2})[.\/-](m{1,2})[.\/-]((y{4}|y{2})$))/gi.test(format);
}
function zip(date, format) {
  var zippedArr = [],
    len = Math.min(date.length, format.length);
  for (var i = 0; i < len; i++) {
    zippedArr.push([date[i], format[i]]);
  }
  return zippedArr;
}
function isDate(input, options) {
  if (typeof options === 'string') {
    // Allow backward compatibility for old format isDate(input [, format])
    options = (0, _merge["default"])({
      format: options
    }, default_date_options);
  } else {
    options = (0, _merge["default"])(options, default_date_options);
  }
  if (typeof input === 'string' && isValidFormat(options.format)) {
    var formatDelimiter = options.delimiters.find(function (delimiter) {
      return options.format.indexOf(delimiter) !== -1;
    });
    var dateDelimiter = options.strictMode ? formatDelimiter : options.delimiters.find(function (delimiter) {
      return input.indexOf(delimiter) !== -1;
    });
    var dateAndFormat = zip(input.split(dateDelimiter), options.format.toLowerCase().split(formatDelimiter));
    var dateObj = {};
    var _iterator = _createForOfIteratorHelper(dateAndFormat),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _step$value = _slicedToArray(_step.value, 2),
          dateWord = _step$value[0],
          formatWord = _step$value[1];
        if (dateWord.length !== formatWord.length) {
          return false;
        }
        dateObj[formatWord.charAt(0)] = dateWord;
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    var fullYear = dateObj.y;

    // Check if the year starts with a hyphen
    if (fullYear.startsWith('-')) {
      return false; // Hyphen before year is not allowed
    }
    if (dateObj.y.length === 2) {
      var parsedYear = parseInt(dateObj.y, 10);
      if (isNaN(parsedYear)) {
        return false;
      }
      var currentYearLastTwoDigits = new Date().getFullYear() % 100;
      if (parsedYear < currentYearLastTwoDigits) {
        fullYear = "20".concat(dateObj.y);
      } else {
        fullYear = "19".concat(dateObj.y);
      }
    }
    var month = dateObj.m;
    if (dateObj.m.length === 1) {
      month = "0".concat(dateObj.m);
    }
    var day = dateObj.d;
    if (dateObj.d.length === 1) {
      day = "0".concat(dateObj.d);
    }
    return new Date("".concat(fullYear, "-").concat(month, "-").concat(day, "T00:00:00.000Z")).getUTCDate() === +dateObj.d;
  }
  if (!options.strictMode) {
    return Object.prototype.toString.call(input) === '[object Date]' && isFinite(input);
  }
  return false;
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./util/merge":526}],446:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isDecimal;
var _merge = _interopRequireDefault(require("./util/merge"));
var _assertString = _interopRequireDefault(require("./util/assertString"));
var _includes = _interopRequireDefault(require("./util/includes"));
var _alpha = require("./alpha");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
function decimalRegExp(options) {
  var regExp = new RegExp("^[-+]?([0-9]+)?(\\".concat(_alpha.decimal[options.locale], "[0-9]{").concat(options.decimal_digits, "})").concat(options.force_decimal ? '' : '?', "$"));
  return regExp;
}
var default_decimal_options = {
  force_decimal: false,
  decimal_digits: '1,',
  locale: 'en-US'
};
var blacklist = ['', '-', '+'];
function isDecimal(str, options) {
  (0, _assertString["default"])(str);
  options = (0, _merge["default"])(options, default_decimal_options);
  if (options.locale in _alpha.decimal) {
    return !(0, _includes["default"])(blacklist, str.replace(/ /g, '')) && decimalRegExp(options).test(str);
  }
  throw new Error("Invalid locale '".concat(options.locale, "'"));
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./alpha":424,"./util/assertString":524,"./util/includes":525,"./util/merge":526}],447:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isDivisibleBy;
var _assertString = _interopRequireDefault(require("./util/assertString"));
var _toFloat = _interopRequireDefault(require("./toFloat"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
function isDivisibleBy(str, num) {
  (0, _assertString["default"])(str);
  return (0, _toFloat["default"])(str) % parseInt(num, 10) === 0;
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./toFloat":519,"./util/assertString":524}],448:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isEAN;
var _assertString = _interopRequireDefault(require("./util/assertString"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
/**
 * The most commonly used EAN standard is
 * the thirteen-digit EAN-13, while the
 * less commonly used 8-digit EAN-8 barcode was
 * introduced for use on small packages.
 * Also EAN/UCC-14 is used for Grouping of individual
 * trade items above unit level(Intermediate, Carton or Pallet).
 * For more info about EAN-14 checkout: https://www.gtin.info/itf-14-barcodes/
 * EAN consists of:
 * GS1 prefix, manufacturer code, product code and check digit
 * Reference: https://en.wikipedia.org/wiki/International_Article_Number
 * Reference: https://www.gtin.info/
 */

/**
 * Define EAN Lenghts; 8 for EAN-8; 13 for EAN-13; 14 for EAN-14
 * and Regular Expression for valid EANs (EAN-8, EAN-13, EAN-14),
 * with exact numberic matching of 8 or 13 or 14 digits [0-9]
 */
var LENGTH_EAN_8 = 8;
var LENGTH_EAN_14 = 14;
var validEanRegex = /^(\d{8}|\d{13}|\d{14})$/;

/**
 * Get position weight given:
 * EAN length and digit index/position
 *
 * @param {number} length
 * @param {number} index
 * @return {number}
 */
function getPositionWeightThroughLengthAndIndex(length, index) {
  if (length === LENGTH_EAN_8 || length === LENGTH_EAN_14) {
    return index % 2 === 0 ? 3 : 1;
  }
  return index % 2 === 0 ? 1 : 3;
}

/**
 * Calculate EAN Check Digit
 * Reference: https://en.wikipedia.org/wiki/International_Article_Number#Calculation_of_checksum_digit
 *
 * @param {string} ean
 * @return {number}
 */
function calculateCheckDigit(ean) {
  var checksum = ean.slice(0, -1).split('').map(function (_char, index) {
    return Number(_char) * getPositionWeightThroughLengthAndIndex(ean.length, index);
  }).reduce(function (acc, partialSum) {
    return acc + partialSum;
  }, 0);
  var remainder = 10 - checksum % 10;
  return remainder < 10 ? remainder : 0;
}

/**
 * Check if string is valid EAN:
 * Matches EAN-8/EAN-13/EAN-14 regex
 * Has valid check digit.
 *
 * @param {string} str
 * @return {boolean}
 */
function isEAN(str) {
  (0, _assertString["default"])(str);
  var actualCheckDigit = Number(str.slice(-1));
  return validEanRegex.test(str) && actualCheckDigit === calculateCheckDigit(str);
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./util/assertString":524}],449:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isEmail;
var _assertString = _interopRequireDefault(require("./util/assertString"));
var _isByteLength = _interopRequireDefault(require("./isByteLength"));
var _isFQDN = _interopRequireDefault(require("./isFQDN"));
var _isIP = _interopRequireDefault(require("./isIP"));
var _merge = _interopRequireDefault(require("./util/merge"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
var default_email_options = {
  allow_display_name: false,
  allow_underscores: false,
  require_display_name: false,
  allow_utf8_local_part: true,
  require_tld: true,
  blacklisted_chars: '',
  ignore_max_length: false,
  host_blacklist: [],
  host_whitelist: []
};

/* eslint-disable max-len */
/* eslint-disable no-control-regex */
var splitNameAddress = /^([^\x00-\x1F\x7F-\x9F\cX]+)</i;
var emailUserPart = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~]+$/i;
var gmailUserPart = /^[a-z\d]+$/;
var quotedEmailUser = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f]))*$/i;
var emailUserUtf8Part = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\u00A1-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+$/i;
var quotedEmailUserUtf8 = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))*$/i;
var defaultMaxEmailLength = 254;
/* eslint-enable max-len */
/* eslint-enable no-control-regex */

/**
 * Validate display name according to the RFC2822: https://tools.ietf.org/html/rfc2822#appendix-A.1.2
 * @param {String} display_name
 */
function validateDisplayName(display_name) {
  var display_name_without_quotes = display_name.replace(/^"(.+)"$/, '$1');
  // display name with only spaces is not valid
  if (!display_name_without_quotes.trim()) {
    return false;
  }

  // check whether display name contains illegal character
  var contains_illegal = /[\.";<>]/.test(display_name_without_quotes);
  if (contains_illegal) {
    // if contains illegal characters,
    // must to be enclosed in double-quotes, otherwise it's not a valid display name
    if (display_name_without_quotes === display_name) {
      return false;
    }

    // the quotes in display name must start with character symbol \
    var all_start_with_back_slash = display_name_without_quotes.split('"').length === display_name_without_quotes.split('\\"').length;
    if (!all_start_with_back_slash) {
      return false;
    }
  }
  return true;
}
function isEmail(str, options) {
  (0, _assertString["default"])(str);
  options = (0, _merge["default"])(options, default_email_options);
  if (options.require_display_name || options.allow_display_name) {
    var display_email = str.match(splitNameAddress);
    if (display_email) {
      var display_name = display_email[1];

      // Remove display name and angle brackets to get email address
      // Can be done in the regex but will introduce a ReDOS (See  #1597 for more info)
      str = str.replace(display_name, '').replace(/(^<|>$)/g, '');

      // sometimes need to trim the last space to get the display name
      // because there may be a space between display name and email address
      // eg. myname <address@gmail.com>
      // the display name is `myname` instead of `myname `, so need to trim the last space
      if (display_name.endsWith(' ')) {
        display_name = display_name.slice(0, -1);
      }
      if (!validateDisplayName(display_name)) {
        return false;
      }
    } else if (options.require_display_name) {
      return false;
    }
  }
  if (!options.ignore_max_length && str.length > defaultMaxEmailLength) {
    return false;
  }
  var parts = str.split('@');
  var domain = parts.pop();
  var lower_domain = domain.toLowerCase();
  if (options.host_blacklist.includes(lower_domain)) {
    return false;
  }
  if (options.host_whitelist.length > 0 && !options.host_whitelist.includes(lower_domain)) {
    return false;
  }
  var user = parts.join('@');
  if (options.domain_specific_validation && (lower_domain === 'gmail.com' || lower_domain === 'googlemail.com')) {
    /*
      Previously we removed dots for gmail addresses before validating.
      This was removed because it allows `multiple..dots@gmail.com`
      to be reported as valid, but it is not.
      Gmail only normalizes single dots, removing them from here is pointless,
      should be done in normalizeEmail
    */
    user = user.toLowerCase();

    // Removing sub-address from username before gmail validation
    var username = user.split('+')[0];

    // Dots are not included in gmail length restriction
    if (!(0, _isByteLength["default"])(username.replace(/\./g, ''), {
      min: 6,
      max: 30
    })) {
      return false;
    }
    var _user_parts = username.split('.');
    for (var i = 0; i < _user_parts.length; i++) {
      if (!gmailUserPart.test(_user_parts[i])) {
        return false;
      }
    }
  }
  if (options.ignore_max_length === false && (!(0, _isByteLength["default"])(user, {
    max: 64
  }) || !(0, _isByteLength["default"])(domain, {
    max: 254
  }))) {
    return false;
  }
  if (!(0, _isFQDN["default"])(domain, {
    require_tld: options.require_tld,
    ignore_max_length: options.ignore_max_length,
    allow_underscores: options.allow_underscores
  })) {
    if (!options.allow_ip_domain) {
      return false;
    }
    if (!(0, _isIP["default"])(domain)) {
      if (!domain.startsWith('[') || !domain.endsWith(']')) {
        return false;
      }
      var noBracketdomain = domain.slice(1, -1);
      if (noBracketdomain.length === 0 || !(0, _isIP["default"])(noBracketdomain)) {
        return false;
      }
    }
  }
  if (user[0] === '"') {
    user = user.slice(1, user.length - 1);
    return options.allow_utf8_local_part ? quotedEmailUserUtf8.test(user) : quotedEmailUser.test(user);
  }
  var pattern = options.allow_utf8_local_part ? emailUserUtf8Part : emailUserPart;
  var user_parts = user.split('.');
  for (var _i = 0; _i < user_parts.length; _i++) {
    if (!pattern.test(user_parts[_i])) {
      return false;
    }
  }
  if (options.blacklisted_chars) {
    if (user.search(new RegExp("[".concat(options.blacklisted_chars, "]+"), 'g')) !== -1) return false;
  }
  return true;
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./isByteLength":441,"./isFQDN":452,"./isIP":462,"./util/assertString":524,"./util/merge":526}],450:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isEmpty;
var _assertString = _interopRequireDefault(require("./util/assertString"));
var _merge = _interopRequireDefault(require("./util/merge"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
var default_is_empty_options = {
  ignore_whitespace: false
};
function isEmpty(str, options) {
  (0, _assertString["default"])(str);
  options = (0, _merge["default"])(options, default_is_empty_options);
  return (options.ignore_whitespace ? str.trim().length : str.length) === 0;
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./util/assertString":524,"./util/merge":526}],451:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isEthereumAddress;
var _assertString = _interopRequireDefault(require("./util/assertString"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
var eth = /^(0x)[0-9a-f]{40}$/i;
function isEthereumAddress(str) {
  (0, _assertString["default"])(str);
  return eth.test(str);
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./util/assertString":524}],452:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isFQDN;
var _assertString = _interopRequireDefault(require("./util/assertString"));
var _merge = _interopRequireDefault(require("./util/merge"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
var default_fqdn_options = {
  require_tld: true,
  allow_underscores: false,
  allow_trailing_dot: false,
  allow_numeric_tld: false,
  allow_wildcard: false,
  ignore_max_length: false
};
function isFQDN(str, options) {
  (0, _assertString["default"])(str);
  options = (0, _merge["default"])(options, default_fqdn_options);

  /* Remove the optional trailing dot before checking validity */
  if (options.allow_trailing_dot && str[str.length - 1] === '.') {
    str = str.substring(0, str.length - 1);
  }

  /* Remove the optional wildcard before checking validity */
  if (options.allow_wildcard === true && str.indexOf('*.') === 0) {
    str = str.substring(2);
  }
  var parts = str.split('.');
  var tld = parts[parts.length - 1];
  if (options.require_tld) {
    // disallow fqdns without tld
    if (parts.length < 2) {
      return false;
    }
    if (!options.allow_numeric_tld && !/^([a-z\u00A1-\u00A8\u00AA-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}|xn[a-z0-9-]{2,})$/i.test(tld)) {
      return false;
    }

    // disallow spaces
    if (/\s/.test(tld)) {
      return false;
    }
  }

  // reject numeric TLDs
  if (!options.allow_numeric_tld && /^\d+$/.test(tld)) {
    return false;
  }
  return parts.every(function (part) {
    if (part.length > 63 && !options.ignore_max_length) {
      return false;
    }
    if (!/^[a-z_\u00a1-\uffff0-9-]+$/i.test(part)) {
      return false;
    }

    // disallow full-width chars
    if (/[\uff01-\uff5e]/.test(part)) {
      return false;
    }

    // disallow parts starting or ending with hyphen
    if (/^-|-$/.test(part)) {
      return false;
    }
    if (!options.allow_underscores && /_/.test(part)) {
      return false;
    }
    return true;
  });
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./util/assertString":524,"./util/merge":526}],453:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isFloat;
exports.locales = void 0;
var _assertString = _interopRequireDefault(require("./util/assertString"));
var _alpha = require("./alpha");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
function isFloat(str, options) {
  (0, _assertString["default"])(str);
  options = options || {};
  var _float = new RegExp("^(?:[-+])?(?:[0-9]+)?(?:\\".concat(options.locale ? _alpha.decimal[options.locale] : '.', "[0-9]*)?(?:[eE][\\+\\-]?(?:[0-9]+))?$"));
  if (str === '' || str === '.' || str === ',' || str === '-' || str === '+') {
    return false;
  }
  var value = parseFloat(str.replace(',', '.'));
  return _float.test(str) && (!options.hasOwnProperty('min') || value >= options.min) && (!options.hasOwnProperty('max') || value <= options.max) && (!options.hasOwnProperty('lt') || value < options.lt) && (!options.hasOwnProperty('gt') || value > options.gt);
}
var locales = exports.locales = Object.keys(_alpha.decimal);

},{"./alpha":424,"./util/assertString":524}],454:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isFullWidth;
exports.fullWidth = void 0;
var _assertString = _interopRequireDefault(require("./util/assertString"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
var fullWidth = exports.fullWidth = /[^\u0020-\u007E\uFF61-\uFF9F\uFFA0-\uFFDC\uFFE8-\uFFEE0-9a-zA-Z]/;
function isFullWidth(str) {
  (0, _assertString["default"])(str);
  return fullWidth.test(str);
}

},{"./util/assertString":524}],455:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isHSL;
var _assertString = _interopRequireDefault(require("./util/assertString"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
var hslComma = /^hsla?\(((\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?))(deg|grad|rad|turn)?(,(\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?)%){2}(,((\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?)%?))?\)$/i;
var hslSpace = /^hsla?\(((\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?))(deg|grad|rad|turn)?(\s(\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?)%){2}\s?(\/\s((\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?)%?)\s?)?\)$/i;
function isHSL(str) {
  (0, _assertString["default"])(str);

  // Strip duplicate spaces before calling the validation regex (See  #1598 for more info)
  var strippedStr = str.replace(/\s+/g, ' ').replace(/\s?(hsla?\(|\)|,)\s?/ig, '$1');
  if (strippedStr.indexOf(',') !== -1) {
    return hslComma.test(strippedStr);
  }
  return hslSpace.test(strippedStr);
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./util/assertString":524}],456:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isHalfWidth;
exports.halfWidth = void 0;
var _assertString = _interopRequireDefault(require("./util/assertString"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
var halfWidth = exports.halfWidth = /[\u0020-\u007E\uFF61-\uFF9F\uFFA0-\uFFDC\uFFE8-\uFFEE0-9a-zA-Z]/;
function isHalfWidth(str) {
  (0, _assertString["default"])(str);
  return halfWidth.test(str);
}

},{"./util/assertString":524}],457:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isHash;
var _assertString = _interopRequireDefault(require("./util/assertString"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
var lengths = {
  md5: 32,
  md4: 32,
  sha1: 40,
  sha256: 64,
  sha384: 96,
  sha512: 128,
  ripemd128: 32,
  ripemd160: 40,
  tiger128: 32,
  tiger160: 40,
  tiger192: 48,
  crc32: 8,
  crc32b: 8
};
function isHash(str, algorithm) {
  (0, _assertString["default"])(str);
  var hash = new RegExp("^[a-fA-F0-9]{".concat(lengths[algorithm], "}$"));
  return hash.test(str);
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./util/assertString":524}],458:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isHexColor;
var _assertString = _interopRequireDefault(require("./util/assertString"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
var hexcolor = /^#?([0-9A-F]{3}|[0-9A-F]{4}|[0-9A-F]{6}|[0-9A-F]{8})$/i;
function isHexColor(str) {
  (0, _assertString["default"])(str);
  return hexcolor.test(str);
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./util/assertString":524}],459:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isHexadecimal;
var _assertString = _interopRequireDefault(require("./util/assertString"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
var hexadecimal = /^(0x|0h)?[0-9A-F]+$/i;
function isHexadecimal(str) {
  (0, _assertString["default"])(str);
  return hexadecimal.test(str);
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./util/assertString":524}],460:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isIBAN;
exports.locales = void 0;
var _assertString = _interopRequireDefault(require("./util/assertString"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
/**
 * List of country codes with
 * corresponding IBAN regular expression
 * Reference: https://en.wikipedia.org/wiki/International_Bank_Account_Number
 */
var ibanRegexThroughCountryCode = {
  AD: /^(AD[0-9]{2})\d{8}[A-Z0-9]{12}$/,
  AE: /^(AE[0-9]{2})\d{3}\d{16}$/,
  AL: /^(AL[0-9]{2})\d{8}[A-Z0-9]{16}$/,
  AT: /^(AT[0-9]{2})\d{16}$/,
  AZ: /^(AZ[0-9]{2})[A-Z0-9]{4}\d{20}$/,
  BA: /^(BA[0-9]{2})\d{16}$/,
  BE: /^(BE[0-9]{2})\d{12}$/,
  BG: /^(BG[0-9]{2})[A-Z]{4}\d{6}[A-Z0-9]{8}$/,
  BH: /^(BH[0-9]{2})[A-Z]{4}[A-Z0-9]{14}$/,
  BR: /^(BR[0-9]{2})\d{23}[A-Z]{1}[A-Z0-9]{1}$/,
  BY: /^(BY[0-9]{2})[A-Z0-9]{4}\d{20}$/,
  CH: /^(CH[0-9]{2})\d{5}[A-Z0-9]{12}$/,
  CR: /^(CR[0-9]{2})\d{18}$/,
  CY: /^(CY[0-9]{2})\d{8}[A-Z0-9]{16}$/,
  CZ: /^(CZ[0-9]{2})\d{20}$/,
  DE: /^(DE[0-9]{2})\d{18}$/,
  DK: /^(DK[0-9]{2})\d{14}$/,
  DO: /^(DO[0-9]{2})[A-Z]{4}\d{20}$/,
  DZ: /^(DZ\d{24})$/,
  EE: /^(EE[0-9]{2})\d{16}$/,
  EG: /^(EG[0-9]{2})\d{25}$/,
  ES: /^(ES[0-9]{2})\d{20}$/,
  FI: /^(FI[0-9]{2})\d{14}$/,
  FO: /^(FO[0-9]{2})\d{14}$/,
  FR: /^(FR[0-9]{2})\d{10}[A-Z0-9]{11}\d{2}$/,
  GB: /^(GB[0-9]{2})[A-Z]{4}\d{14}$/,
  GE: /^(GE[0-9]{2})[A-Z0-9]{2}\d{16}$/,
  GI: /^(GI[0-9]{2})[A-Z]{4}[A-Z0-9]{15}$/,
  GL: /^(GL[0-9]{2})\d{14}$/,
  GR: /^(GR[0-9]{2})\d{7}[A-Z0-9]{16}$/,
  GT: /^(GT[0-9]{2})[A-Z0-9]{4}[A-Z0-9]{20}$/,
  HR: /^(HR[0-9]{2})\d{17}$/,
  HU: /^(HU[0-9]{2})\d{24}$/,
  IE: /^(IE[0-9]{2})[A-Z0-9]{4}\d{14}$/,
  IL: /^(IL[0-9]{2})\d{19}$/,
  IQ: /^(IQ[0-9]{2})[A-Z]{4}\d{15}$/,
  IR: /^(IR[0-9]{2})0\d{2}0\d{18}$/,
  IS: /^(IS[0-9]{2})\d{22}$/,
  IT: /^(IT[0-9]{2})[A-Z]{1}\d{10}[A-Z0-9]{12}$/,
  JO: /^(JO[0-9]{2})[A-Z]{4}\d{22}$/,
  KW: /^(KW[0-9]{2})[A-Z]{4}[A-Z0-9]{22}$/,
  KZ: /^(KZ[0-9]{2})\d{3}[A-Z0-9]{13}$/,
  LB: /^(LB[0-9]{2})\d{4}[A-Z0-9]{20}$/,
  LC: /^(LC[0-9]{2})[A-Z]{4}[A-Z0-9]{24}$/,
  LI: /^(LI[0-9]{2})\d{5}[A-Z0-9]{12}$/,
  LT: /^(LT[0-9]{2})\d{16}$/,
  LU: /^(LU[0-9]{2})\d{3}[A-Z0-9]{13}$/,
  LV: /^(LV[0-9]{2})[A-Z]{4}[A-Z0-9]{13}$/,
  MA: /^(MA[0-9]{26})$/,
  MC: /^(MC[0-9]{2})\d{10}[A-Z0-9]{11}\d{2}$/,
  MD: /^(MD[0-9]{2})[A-Z0-9]{20}$/,
  ME: /^(ME[0-9]{2})\d{18}$/,
  MK: /^(MK[0-9]{2})\d{3}[A-Z0-9]{10}\d{2}$/,
  MR: /^(MR[0-9]{2})\d{23}$/,
  MT: /^(MT[0-9]{2})[A-Z]{4}\d{5}[A-Z0-9]{18}$/,
  MU: /^(MU[0-9]{2})[A-Z]{4}\d{19}[A-Z]{3}$/,
  MZ: /^(MZ[0-9]{2})\d{21}$/,
  NL: /^(NL[0-9]{2})[A-Z]{4}\d{10}$/,
  NO: /^(NO[0-9]{2})\d{11}$/,
  PK: /^(PK[0-9]{2})[A-Z0-9]{4}\d{16}$/,
  PL: /^(PL[0-9]{2})\d{24}$/,
  PS: /^(PS[0-9]{2})[A-Z0-9]{4}\d{21}$/,
  PT: /^(PT[0-9]{2})\d{21}$/,
  QA: /^(QA[0-9]{2})[A-Z]{4}[A-Z0-9]{21}$/,
  RO: /^(RO[0-9]{2})[A-Z]{4}[A-Z0-9]{16}$/,
  RS: /^(RS[0-9]{2})\d{18}$/,
  SA: /^(SA[0-9]{2})\d{2}[A-Z0-9]{18}$/,
  SC: /^(SC[0-9]{2})[A-Z]{4}\d{20}[A-Z]{3}$/,
  SE: /^(SE[0-9]{2})\d{20}$/,
  SI: /^(SI[0-9]{2})\d{15}$/,
  SK: /^(SK[0-9]{2})\d{20}$/,
  SM: /^(SM[0-9]{2})[A-Z]{1}\d{10}[A-Z0-9]{12}$/,
  SV: /^(SV[0-9]{2})[A-Z0-9]{4}\d{20}$/,
  TL: /^(TL[0-9]{2})\d{19}$/,
  TN: /^(TN[0-9]{2})\d{20}$/,
  TR: /^(TR[0-9]{2})\d{5}[A-Z0-9]{17}$/,
  UA: /^(UA[0-9]{2})\d{6}[A-Z0-9]{19}$/,
  VA: /^(VA[0-9]{2})\d{18}$/,
  VG: /^(VG[0-9]{2})[A-Z0-9]{4}\d{16}$/,
  XK: /^(XK[0-9]{2})\d{16}$/
};

/**
 * Check if the country codes passed are valid using the
 * ibanRegexThroughCountryCode as a reference
 *
 * @param {array} countryCodeArray
 * @return {boolean}
 */

function hasOnlyValidCountryCodes(countryCodeArray) {
  var countryCodeArrayFilteredWithObjectIbanCode = countryCodeArray.filter(function (countryCode) {
    return !(countryCode in ibanRegexThroughCountryCode);
  });
  if (countryCodeArrayFilteredWithObjectIbanCode.length > 0) {
    return false;
  }
  return true;
}

/**
 * Check whether string has correct universal IBAN format
 * The IBAN consists of up to 34 alphanumeric characters, as follows:
 * Country Code using ISO 3166-1 alpha-2, two letters
 * check digits, two digits and
 * Basic Bank Account Number (BBAN), up to 30 alphanumeric characters.
 * NOTE: Permitted IBAN characters are: digits [0-9] and the 26 latin alphabetic [A-Z]
 *
 * @param {string} str - string under validation
 * @param {object} options - object to pass the countries to be either whitelisted or blacklisted
 * @return {boolean}
 */
function hasValidIbanFormat(str, options) {
  // Strip white spaces and hyphens
  var strippedStr = str.replace(/[\s\-]+/gi, '').toUpperCase();
  var isoCountryCode = strippedStr.slice(0, 2).toUpperCase();
  var isoCountryCodeInIbanRegexCodeObject = isoCountryCode in ibanRegexThroughCountryCode;
  if (options.whitelist) {
    if (!hasOnlyValidCountryCodes(options.whitelist)) {
      return false;
    }
    var isoCountryCodeInWhiteList = options.whitelist.includes(isoCountryCode);
    if (!isoCountryCodeInWhiteList) {
      return false;
    }
  }
  if (options.blacklist) {
    var isoCountryCodeInBlackList = options.blacklist.includes(isoCountryCode);
    if (isoCountryCodeInBlackList) {
      return false;
    }
  }
  return isoCountryCodeInIbanRegexCodeObject && ibanRegexThroughCountryCode[isoCountryCode].test(strippedStr);
}

/**
   * Check whether string has valid IBAN Checksum
   * by performing basic mod-97 operation and
   * the remainder should equal 1
   * -- Start by rearranging the IBAN by moving the four initial characters to the end of the string
   * -- Replace each letter in the string with two digits, A -> 10, B = 11, Z = 35
   * -- Interpret the string as a decimal integer and
   * -- compute the remainder on division by 97 (mod 97)
   * Reference: https://en.wikipedia.org/wiki/International_Bank_Account_Number
   *
   * @param {string} str
   * @return {boolean}
   */
function hasValidIbanChecksum(str) {
  var strippedStr = str.replace(/[^A-Z0-9]+/gi, '').toUpperCase(); // Keep only digits and A-Z latin alphabetic
  var rearranged = strippedStr.slice(4) + strippedStr.slice(0, 4);
  var alphaCapsReplacedWithDigits = rearranged.replace(/[A-Z]/g, function (_char) {
    return _char.charCodeAt(0) - 55;
  });
  var remainder = alphaCapsReplacedWithDigits.match(/\d{1,7}/g).reduce(function (acc, value) {
    return Number(acc + value) % 97;
  }, '');
  return remainder === 1;
}
function isIBAN(str) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  (0, _assertString["default"])(str);
  return hasValidIbanFormat(str, options) && hasValidIbanChecksum(str);
}
var locales = exports.locales = Object.keys(ibanRegexThroughCountryCode);

},{"./util/assertString":524}],461:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isIMEI;
var _assertString = _interopRequireDefault(require("./util/assertString"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
var imeiRegexWithoutHypens = /^[0-9]{15}$/;
var imeiRegexWithHypens = /^\d{2}-\d{6}-\d{6}-\d{1}$/;
function isIMEI(str, options) {
  (0, _assertString["default"])(str);
  options = options || {};

  // default regex for checking imei is the one without hyphens

  var imeiRegex = imeiRegexWithoutHypens;
  if (options.allow_hyphens) {
    imeiRegex = imeiRegexWithHypens;
  }
  if (!imeiRegex.test(str)) {
    return false;
  }
  str = str.replace(/-/g, '');
  var sum = 0,
    mul = 2,
    l = 14;
  for (var i = 0; i < l; i++) {
    var digit = str.substring(l - i - 1, l - i);
    var tp = parseInt(digit, 10) * mul;
    if (tp >= 10) {
      sum += tp % 10 + 1;
    } else {
      sum += tp;
    }
    if (mul === 1) {
      mul += 1;
    } else {
      mul -= 1;
    }
  }
  var chk = (10 - sum % 10) % 10;
  if (chk !== parseInt(str.substring(14, 15), 10)) {
    return false;
  }
  return true;
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./util/assertString":524}],462:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isIP;
var _assertString = _interopRequireDefault(require("./util/assertString"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
/**
11.3.  Examples

   The following addresses

             fe80::1234 (on the 1st link of the node)
             ff02::5678 (on the 5th link of the node)
             ff08::9abc (on the 10th organization of the node)

   would be represented as follows:

             fe80::1234%1
             ff02::5678%5
             ff08::9abc%10

   (Here we assume a natural translation from a zone index to the
   <zone_id> part, where the Nth zone of any scope is translated into
   "N".)

   If we use interface names as <zone_id>, those addresses could also be
   represented as follows:

            fe80::1234%ne0
            ff02::5678%pvc1.3
            ff08::9abc%interface10

   where the interface "ne0" belongs to the 1st link, "pvc1.3" belongs
   to the 5th link, and "interface10" belongs to the 10th organization.
 * * */
var IPv4SegmentFormat = '(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])';
var IPv4AddressFormat = "(".concat(IPv4SegmentFormat, "[.]){3}").concat(IPv4SegmentFormat);
var IPv4AddressRegExp = new RegExp("^".concat(IPv4AddressFormat, "$"));
var IPv6SegmentFormat = '(?:[0-9a-fA-F]{1,4})';
var IPv6AddressRegExp = new RegExp('^(' + "(?:".concat(IPv6SegmentFormat, ":){7}(?:").concat(IPv6SegmentFormat, "|:)|") + "(?:".concat(IPv6SegmentFormat, ":){6}(?:").concat(IPv4AddressFormat, "|:").concat(IPv6SegmentFormat, "|:)|") + "(?:".concat(IPv6SegmentFormat, ":){5}(?::").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,2}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){4}(?:(:").concat(IPv6SegmentFormat, "){0,1}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,3}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){3}(?:(:").concat(IPv6SegmentFormat, "){0,2}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,4}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){2}(?:(:").concat(IPv6SegmentFormat, "){0,3}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,5}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){1}(?:(:").concat(IPv6SegmentFormat, "){0,4}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,6}|:)|") + "(?::((?::".concat(IPv6SegmentFormat, "){0,5}:").concat(IPv4AddressFormat, "|(?::").concat(IPv6SegmentFormat, "){1,7}|:))") + ')(%[0-9a-zA-Z-.:]{1,})?$');
function isIP(str) {
  var version = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  (0, _assertString["default"])(str);
  version = String(version);
  if (!version) {
    return isIP(str, 4) || isIP(str, 6);
  }
  if (version === '4') {
    return IPv4AddressRegExp.test(str);
  }
  if (version === '6') {
    return IPv6AddressRegExp.test(str);
  }
  return false;
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./util/assertString":524}],463:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isIPRange;
var _assertString = _interopRequireDefault(require("./util/assertString"));
var _isIP = _interopRequireDefault(require("./isIP"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
var subnetMaybe = /^\d{1,3}$/;
var v4Subnet = 32;
var v6Subnet = 128;
function isIPRange(str) {
  var version = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  (0, _assertString["default"])(str);
  var parts = str.split('/');

  // parts[0] -> ip, parts[1] -> subnet
  if (parts.length !== 2) {
    return false;
  }
  if (!subnetMaybe.test(parts[1])) {
    return false;
  }

  // Disallow preceding 0 i.e. 01, 02, ...
  if (parts[1].length > 1 && parts[1].startsWith('0')) {
    return false;
  }
  var isValidIP = (0, _isIP["default"])(parts[0], version);
  if (!isValidIP) {
    return false;
  }

  // Define valid subnet according to IP's version
  var expectedSubnet = null;
  switch (String(version)) {
    case '4':
      expectedSubnet = v4Subnet;
      break;
    case '6':
      expectedSubnet = v6Subnet;
      break;
    default:
      expectedSubnet = (0, _isIP["default"])(parts[0], '6') ? v6Subnet : v4Subnet;
  }
  return parts[1] <= expectedSubnet && parts[1] >= 0;
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./isIP":462,"./util/assertString":524}],464:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isISBN;
var _assertString = _interopRequireDefault(require("./util/assertString"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
var possibleIsbn10 = /^(?:[0-9]{9}X|[0-9]{10})$/;
var possibleIsbn13 = /^(?:[0-9]{13})$/;
var factor = [1, 3];
function isISBN(isbn, options) {
  (0, _assertString["default"])(isbn);

  // For backwards compatibility:
  // isISBN(str [, version]), i.e. `options` could be used as argument for the legacy `version`
  var version = String((options === null || options === void 0 ? void 0 : options.version) || options);
  if (!(options !== null && options !== void 0 && options.version || options)) {
    return isISBN(isbn, {
      version: 10
    }) || isISBN(isbn, {
      version: 13
    });
  }
  var sanitizedIsbn = isbn.replace(/[\s-]+/g, '');
  var checksum = 0;
  if (version === '10') {
    if (!possibleIsbn10.test(sanitizedIsbn)) {
      return false;
    }
    for (var i = 0; i < version - 1; i++) {
      checksum += (i + 1) * sanitizedIsbn.charAt(i);
    }
    if (sanitizedIsbn.charAt(9) === 'X') {
      checksum += 10 * 10;
    } else {
      checksum += 10 * sanitizedIsbn.charAt(9);
    }
    if (checksum % 11 === 0) {
      return true;
    }
  } else if (version === '13') {
    if (!possibleIsbn13.test(sanitizedIsbn)) {
      return false;
    }
    for (var _i = 0; _i < 12; _i++) {
      checksum += factor[_i % 2] * sanitizedIsbn.charAt(_i);
    }
    if (sanitizedIsbn.charAt(12) - (10 - checksum % 10) % 10 === 0) {
      return true;
    }
  }
  return false;
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./util/assertString":524}],465:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isISIN;
var _assertString = _interopRequireDefault(require("./util/assertString"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
var isin = /^[A-Z]{2}[0-9A-Z]{9}[0-9]$/;

// this link details how the check digit is calculated:
// https://www.isin.org/isin-format/. it is a little bit
// odd in that it works with digits, not numbers. in order
// to make only one pass through the ISIN characters, the
// each alpha character is handled as 2 characters within
// the loop.

function isISIN(str) {
  (0, _assertString["default"])(str);
  if (!isin.test(str)) {
    return false;
  }
  var _double = true;
  var sum = 0;
  // convert values
  for (var i = str.length - 2; i >= 0; i--) {
    if (str[i] >= 'A' && str[i] <= 'Z') {
      var value = str[i].charCodeAt(0) - 55;
      var lo = value % 10;
      var hi = Math.trunc(value / 10);
      // letters have two digits, so handle the low order
      // and high order digits separately.
      for (var _i = 0, _arr = [lo, hi]; _i < _arr.length; _i++) {
        var digit = _arr[_i];
        if (_double) {
          if (digit >= 5) {
            sum += 1 + (digit - 5) * 2;
          } else {
            sum += digit * 2;
          }
        } else {
          sum += digit;
        }
        _double = !_double;
      }
    } else {
      var _digit = str[i].charCodeAt(0) - '0'.charCodeAt(0);
      if (_double) {
        if (_digit >= 5) {
          sum += 1 + (_digit - 5) * 2;
        } else {
          sum += _digit * 2;
        }
      } else {
        sum += _digit;
      }
      _double = !_double;
    }
  }
  var check = Math.trunc((sum + 9) / 10) * 10 - sum;
  return +str[str.length - 1] === check;
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./util/assertString":524}],466:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CountryCodes = void 0;
exports["default"] = isISO31661Alpha2;
var _assertString = _interopRequireDefault(require("./util/assertString"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
// from https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2
var validISO31661Alpha2CountriesCodes = new Set(['AD', 'AE', 'AF', 'AG', 'AI', 'AL', 'AM', 'AO', 'AQ', 'AR', 'AS', 'AT', 'AU', 'AW', 'AX', 'AZ', 'BA', 'BB', 'BD', 'BE', 'BF', 'BG', 'BH', 'BI', 'BJ', 'BL', 'BM', 'BN', 'BO', 'BQ', 'BR', 'BS', 'BT', 'BV', 'BW', 'BY', 'BZ', 'CA', 'CC', 'CD', 'CF', 'CG', 'CH', 'CI', 'CK', 'CL', 'CM', 'CN', 'CO', 'CR', 'CU', 'CV', 'CW', 'CX', 'CY', 'CZ', 'DE', 'DJ', 'DK', 'DM', 'DO', 'DZ', 'EC', 'EE', 'EG', 'EH', 'ER', 'ES', 'ET', 'FI', 'FJ', 'FK', 'FM', 'FO', 'FR', 'GA', 'GB', 'GD', 'GE', 'GF', 'GG', 'GH', 'GI', 'GL', 'GM', 'GN', 'GP', 'GQ', 'GR', 'GS', 'GT', 'GU', 'GW', 'GY', 'HK', 'HM', 'HN', 'HR', 'HT', 'HU', 'ID', 'IE', 'IL', 'IM', 'IN', 'IO', 'IQ', 'IR', 'IS', 'IT', 'JE', 'JM', 'JO', 'JP', 'KE', 'KG', 'KH', 'KI', 'KM', 'KN', 'KP', 'KR', 'KW', 'KY', 'KZ', 'LA', 'LB', 'LC', 'LI', 'LK', 'LR', 'LS', 'LT', 'LU', 'LV', 'LY', 'MA', 'MC', 'MD', 'ME', 'MF', 'MG', 'MH', 'MK', 'ML', 'MM', 'MN', 'MO', 'MP', 'MQ', 'MR', 'MS', 'MT', 'MU', 'MV', 'MW', 'MX', 'MY', 'MZ', 'NA', 'NC', 'NE', 'NF', 'NG', 'NI', 'NL', 'NO', 'NP', 'NR', 'NU', 'NZ', 'OM', 'PA', 'PE', 'PF', 'PG', 'PH', 'PK', 'PL', 'PM', 'PN', 'PR', 'PS', 'PT', 'PW', 'PY', 'QA', 'RE', 'RO', 'RS', 'RU', 'RW', 'SA', 'SB', 'SC', 'SD', 'SE', 'SG', 'SH', 'SI', 'SJ', 'SK', 'SL', 'SM', 'SN', 'SO', 'SR', 'SS', 'ST', 'SV', 'SX', 'SY', 'SZ', 'TC', 'TD', 'TF', 'TG', 'TH', 'TJ', 'TK', 'TL', 'TM', 'TN', 'TO', 'TR', 'TT', 'TV', 'TW', 'TZ', 'UA', 'UG', 'UM', 'US', 'UY', 'UZ', 'VA', 'VC', 'VE', 'VG', 'VI', 'VN', 'VU', 'WF', 'WS', 'YE', 'YT', 'ZA', 'ZM', 'ZW']);
function isISO31661Alpha2(str) {
  (0, _assertString["default"])(str);
  return validISO31661Alpha2CountriesCodes.has(str.toUpperCase());
}
var CountryCodes = exports.CountryCodes = validISO31661Alpha2CountriesCodes;

},{"./util/assertString":524}],467:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isISO31661Alpha3;
var _assertString = _interopRequireDefault(require("./util/assertString"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
// from https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3
var validISO31661Alpha3CountriesCodes = new Set(['AFG', 'ALA', 'ALB', 'DZA', 'ASM', 'AND', 'AGO', 'AIA', 'ATA', 'ATG', 'ARG', 'ARM', 'ABW', 'AUS', 'AUT', 'AZE', 'BHS', 'BHR', 'BGD', 'BRB', 'BLR', 'BEL', 'BLZ', 'BEN', 'BMU', 'BTN', 'BOL', 'BES', 'BIH', 'BWA', 'BVT', 'BRA', 'IOT', 'BRN', 'BGR', 'BFA', 'BDI', 'KHM', 'CMR', 'CAN', 'CPV', 'CYM', 'CAF', 'TCD', 'CHL', 'CHN', 'CXR', 'CCK', 'COL', 'COM', 'COG', 'COD', 'COK', 'CRI', 'CIV', 'HRV', 'CUB', 'CUW', 'CYP', 'CZE', 'DNK', 'DJI', 'DMA', 'DOM', 'ECU', 'EGY', 'SLV', 'GNQ', 'ERI', 'EST', 'ETH', 'FLK', 'FRO', 'FJI', 'FIN', 'FRA', 'GUF', 'PYF', 'ATF', 'GAB', 'GMB', 'GEO', 'DEU', 'GHA', 'GIB', 'GRC', 'GRL', 'GRD', 'GLP', 'GUM', 'GTM', 'GGY', 'GIN', 'GNB', 'GUY', 'HTI', 'HMD', 'VAT', 'HND', 'HKG', 'HUN', 'ISL', 'IND', 'IDN', 'IRN', 'IRQ', 'IRL', 'IMN', 'ISR', 'ITA', 'JAM', 'JPN', 'JEY', 'JOR', 'KAZ', 'KEN', 'KIR', 'PRK', 'KOR', 'KWT', 'KGZ', 'LAO', 'LVA', 'LBN', 'LSO', 'LBR', 'LBY', 'LIE', 'LTU', 'LUX', 'MAC', 'MKD', 'MDG', 'MWI', 'MYS', 'MDV', 'MLI', 'MLT', 'MHL', 'MTQ', 'MRT', 'MUS', 'MYT', 'MEX', 'FSM', 'MDA', 'MCO', 'MNG', 'MNE', 'MSR', 'MAR', 'MOZ', 'MMR', 'NAM', 'NRU', 'NPL', 'NLD', 'NCL', 'NZL', 'NIC', 'NER', 'NGA', 'NIU', 'NFK', 'MNP', 'NOR', 'OMN', 'PAK', 'PLW', 'PSE', 'PAN', 'PNG', 'PRY', 'PER', 'PHL', 'PCN', 'POL', 'PRT', 'PRI', 'QAT', 'REU', 'ROU', 'RUS', 'RWA', 'BLM', 'SHN', 'KNA', 'LCA', 'MAF', 'SPM', 'VCT', 'WSM', 'SMR', 'STP', 'SAU', 'SEN', 'SRB', 'SYC', 'SLE', 'SGP', 'SXM', 'SVK', 'SVN', 'SLB', 'SOM', 'ZAF', 'SGS', 'SSD', 'ESP', 'LKA', 'SDN', 'SUR', 'SJM', 'SWZ', 'SWE', 'CHE', 'SYR', 'TWN', 'TJK', 'TZA', 'THA', 'TLS', 'TGO', 'TKL', 'TON', 'TTO', 'TUN', 'TUR', 'TKM', 'TCA', 'TUV', 'UGA', 'UKR', 'ARE', 'GBR', 'USA', 'UMI', 'URY', 'UZB', 'VUT', 'VEN', 'VNM', 'VGB', 'VIR', 'WLF', 'ESH', 'YEM', 'ZMB', 'ZWE']);
function isISO31661Alpha3(str) {
  (0, _assertString["default"])(str);
  return validISO31661Alpha3CountriesCodes.has(str.toUpperCase());
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./util/assertString":524}],468:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CurrencyCodes = void 0;
exports["default"] = isISO4217;
var _assertString = _interopRequireDefault(require("./util/assertString"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
// from https://en.wikipedia.org/wiki/ISO_4217
var validISO4217CurrencyCodes = new Set(['AED', 'AFN', 'ALL', 'AMD', 'ANG', 'AOA', 'ARS', 'AUD', 'AWG', 'AZN', 'BAM', 'BBD', 'BDT', 'BGN', 'BHD', 'BIF', 'BMD', 'BND', 'BOB', 'BOV', 'BRL', 'BSD', 'BTN', 'BWP', 'BYN', 'BZD', 'CAD', 'CDF', 'CHE', 'CHF', 'CHW', 'CLF', 'CLP', 'CNY', 'COP', 'COU', 'CRC', 'CUC', 'CUP', 'CVE', 'CZK', 'DJF', 'DKK', 'DOP', 'DZD', 'EGP', 'ERN', 'ETB', 'EUR', 'FJD', 'FKP', 'GBP', 'GEL', 'GHS', 'GIP', 'GMD', 'GNF', 'GTQ', 'GYD', 'HKD', 'HNL', 'HRK', 'HTG', 'HUF', 'IDR', 'ILS', 'INR', 'IQD', 'IRR', 'ISK', 'JMD', 'JOD', 'JPY', 'KES', 'KGS', 'KHR', 'KMF', 'KPW', 'KRW', 'KWD', 'KYD', 'KZT', 'LAK', 'LBP', 'LKR', 'LRD', 'LSL', 'LYD', 'MAD', 'MDL', 'MGA', 'MKD', 'MMK', 'MNT', 'MOP', 'MRU', 'MUR', 'MVR', 'MWK', 'MXN', 'MXV', 'MYR', 'MZN', 'NAD', 'NGN', 'NIO', 'NOK', 'NPR', 'NZD', 'OMR', 'PAB', 'PEN', 'PGK', 'PHP', 'PKR', 'PLN', 'PYG', 'QAR', 'RON', 'RSD', 'RUB', 'RWF', 'SAR', 'SBD', 'SCR', 'SDG', 'SEK', 'SGD', 'SHP', 'SLE', 'SLL', 'SOS', 'SRD', 'SSP', 'STN', 'SVC', 'SYP', 'SZL', 'THB', 'TJS', 'TMT', 'TND', 'TOP', 'TRY', 'TTD', 'TWD', 'TZS', 'UAH', 'UGX', 'USD', 'USN', 'UYI', 'UYU', 'UYW', 'UZS', 'VES', 'VND', 'VUV', 'WST', 'XAF', 'XAG', 'XAU', 'XBA', 'XBB', 'XBC', 'XBD', 'XCD', 'XDR', 'XOF', 'XPD', 'XPF', 'XPT', 'XSU', 'XTS', 'XUA', 'XXX', 'YER', 'ZAR', 'ZMW', 'ZWL']);
function isISO4217(str) {
  (0, _assertString["default"])(str);
  return validISO4217CurrencyCodes.has(str.toUpperCase());
}
var CurrencyCodes = exports.CurrencyCodes = validISO4217CurrencyCodes;

},{"./util/assertString":524}],469:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isFreightContainerID = void 0;
exports.isISO6346 = isISO6346;
var _assertString = _interopRequireDefault(require("./util/assertString"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
// https://en.wikipedia.org/wiki/ISO_6346
// according to ISO6346 standard, checksum digit is mandatory for freight container but recommended
// for other container types (J and Z)
var isISO6346Str = /^[A-Z]{3}(U[0-9]{7})|([J,Z][0-9]{6,7})$/;
var isDigit = /^[0-9]$/;
function isISO6346(str) {
  (0, _assertString["default"])(str);
  str = str.toUpperCase();
  if (!isISO6346Str.test(str)) return false;
  if (str.length === 11) {
    var sum = 0;
    for (var i = 0; i < str.length - 1; i++) {
      if (!isDigit.test(str[i])) {
        var convertedCode = void 0;
        var letterCode = str.charCodeAt(i) - 55;
        if (letterCode < 11) convertedCode = letterCode;else if (letterCode >= 11 && letterCode <= 20) convertedCode = 12 + letterCode % 11;else if (letterCode >= 21 && letterCode <= 30) convertedCode = 23 + letterCode % 21;else convertedCode = 34 + letterCode % 31;
        sum += convertedCode * Math.pow(2, i);
      } else sum += str[i] * Math.pow(2, i);
    }
    var checkSumDigit = sum % 11;
    return Number(str[str.length - 1]) === checkSumDigit;
  }
  return true;
}
var isFreightContainerID = exports.isFreightContainerID = isISO6346;

},{"./util/assertString":524}],470:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isISO6391;
var _assertString = _interopRequireDefault(require("./util/assertString"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
var isISO6391Set = new Set(['aa', 'ab', 'ae', 'af', 'ak', 'am', 'an', 'ar', 'as', 'av', 'ay', 'az', 'az', 'ba', 'be', 'bg', 'bh', 'bi', 'bm', 'bn', 'bo', 'br', 'bs', 'ca', 'ce', 'ch', 'co', 'cr', 'cs', 'cu', 'cv', 'cy', 'da', 'de', 'dv', 'dz', 'ee', 'el', 'en', 'eo', 'es', 'et', 'eu', 'fa', 'ff', 'fi', 'fj', 'fo', 'fr', 'fy', 'ga', 'gd', 'gl', 'gn', 'gu', 'gv', 'ha', 'he', 'hi', 'ho', 'hr', 'ht', 'hu', 'hy', 'hz', 'ia', 'id', 'ie', 'ig', 'ii', 'ik', 'io', 'is', 'it', 'iu', 'ja', 'jv', 'ka', 'kg', 'ki', 'kj', 'kk', 'kl', 'km', 'kn', 'ko', 'kr', 'ks', 'ku', 'kv', 'kw', 'ky', 'la', 'lb', 'lg', 'li', 'ln', 'lo', 'lt', 'lu', 'lv', 'mg', 'mh', 'mi', 'mk', 'ml', 'mn', 'mr', 'ms', 'mt', 'my', 'na', 'nb', 'nd', 'ne', 'ng', 'nl', 'nn', 'no', 'nr', 'nv', 'ny', 'oc', 'oj', 'om', 'or', 'os', 'pa', 'pi', 'pl', 'ps', 'pt', 'qu', 'rm', 'rn', 'ro', 'ru', 'rw', 'sa', 'sc', 'sd', 'se', 'sg', 'si', 'sk', 'sl', 'sm', 'sn', 'so', 'sq', 'sr', 'ss', 'st', 'su', 'sv', 'sw', 'ta', 'te', 'tg', 'th', 'ti', 'tk', 'tl', 'tn', 'to', 'tr', 'ts', 'tt', 'tw', 'ty', 'ug', 'uk', 'ur', 'uz', 've', 'vi', 'vo', 'wa', 'wo', 'xh', 'yi', 'yo', 'za', 'zh', 'zu']);
function isISO6391(str) {
  (0, _assertString["default"])(str);
  return isISO6391Set.has(str);
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./util/assertString":524}],471:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isISO8601;
var _assertString = _interopRequireDefault(require("./util/assertString"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
/* eslint-disable max-len */
// from http://goo.gl/0ejHHW
var iso8601 = /^([\+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-3])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T\s]((([01]\d|2[0-3])((:?)[0-5]\d)?|24:?00)([\.,]\d+(?!:))?)?(\17[0-5]\d([\.,]\d+)?)?([zZ]|([\+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/;
// same as above, except with a strict 'T' separator between date and time
var iso8601StrictSeparator = /^([\+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-3])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T]((([01]\d|2[0-3])((:?)[0-5]\d)?|24:?00)([\.,]\d+(?!:))?)?(\17[0-5]\d([\.,]\d+)?)?([zZ]|([\+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/;
/* eslint-enable max-len */
var isValidDate = function isValidDate(str) {
  // str must have passed the ISO8601 check
  // this check is meant to catch invalid dates
  // like 2009-02-31
  // first check for ordinal dates
  var ordinalMatch = str.match(/^(\d{4})-?(\d{3})([ T]{1}\.*|$)/);
  if (ordinalMatch) {
    var oYear = Number(ordinalMatch[1]);
    var oDay = Number(ordinalMatch[2]);
    // if is leap year
    if (oYear % 4 === 0 && oYear % 100 !== 0 || oYear % 400 === 0) return oDay <= 366;
    return oDay <= 365;
  }
  var match = str.match(/(\d{4})-?(\d{0,2})-?(\d*)/).map(Number);
  var year = match[1];
  var month = match[2];
  var day = match[3];
  var monthString = month ? "0".concat(month).slice(-2) : month;
  var dayString = day ? "0".concat(day).slice(-2) : day;

  // create a date object and compare
  var d = new Date("".concat(year, "-").concat(monthString || '01', "-").concat(dayString || '01'));
  if (month && day) {
    return d.getUTCFullYear() === year && d.getUTCMonth() + 1 === month && d.getUTCDate() === day;
  }
  return true;
};
function isISO8601(str) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  (0, _assertString["default"])(str);
  var check = options.strictSeparator ? iso8601StrictSeparator.test(str) : iso8601.test(str);
  if (check && options.strict) return isValidDate(str);
  return check;
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./util/assertString":524}],472:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isISRC;
var _assertString = _interopRequireDefault(require("./util/assertString"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
// see http://isrc.ifpi.org/en/isrc-standard/code-syntax
var isrc = /^[A-Z]{2}[0-9A-Z]{3}\d{2}\d{5}$/;
function isISRC(str) {
  (0, _assertString["default"])(str);
  return isrc.test(str);
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./util/assertString":524}],473:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isISSN;
var _assertString = _interopRequireDefault(require("./util/assertString"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
var issn = '^\\d{4}-?\\d{3}[\\dX]$';
function isISSN(str) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  (0, _assertString["default"])(str);
  var testIssn = issn;
  testIssn = options.require_hyphen ? testIssn.replace('?', '') : testIssn;
  testIssn = options.case_sensitive ? new RegExp(testIssn) : new RegExp(testIssn, 'i');
  if (!testIssn.test(str)) {
    return false;
  }
  var digits = str.replace('-', '').toUpperCase();
  var checksum = 0;
  for (var i = 0; i < digits.length; i++) {
    var digit = digits[i];
    checksum += (digit === 'X' ? 10 : +digit) * (8 - i);
  }
  return checksum % 11 === 0;
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./util/assertString":524}],474:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isIdentityCard;
var _assertString = _interopRequireDefault(require("./util/assertString"));
var _isInt = _interopRequireDefault(require("./isInt"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
var validators = {
  PL: function PL(str) {
    (0, _assertString["default"])(str);
    var weightOfDigits = {
      1: 1,
      2: 3,
      3: 7,
      4: 9,
      5: 1,
      6: 3,
      7: 7,
      8: 9,
      9: 1,
      10: 3,
      11: 0
    };
    if (str != null && str.length === 11 && (0, _isInt["default"])(str, {
      allow_leading_zeroes: true
    })) {
      var digits = str.split('').slice(0, -1);
      var sum = digits.reduce(function (acc, digit, index) {
        return acc + Number(digit) * weightOfDigits[index + 1];
      }, 0);
      var modulo = sum % 10;
      var lastDigit = Number(str.charAt(str.length - 1));
      if (modulo === 0 && lastDigit === 0 || lastDigit === 10 - modulo) {
        return true;
      }
    }
    return false;
  },
  ES: function ES(str) {
    (0, _assertString["default"])(str);
    var DNI = /^[0-9X-Z][0-9]{7}[TRWAGMYFPDXBNJZSQVHLCKE]$/;
    var charsValue = {
      X: 0,
      Y: 1,
      Z: 2
    };
    var controlDigits = ['T', 'R', 'W', 'A', 'G', 'M', 'Y', 'F', 'P', 'D', 'X', 'B', 'N', 'J', 'Z', 'S', 'Q', 'V', 'H', 'L', 'C', 'K', 'E'];

    // sanitize user input
    var sanitized = str.trim().toUpperCase();

    // validate the data structure
    if (!DNI.test(sanitized)) {
      return false;
    }

    // validate the control digit
    var number = sanitized.slice(0, -1).replace(/[X,Y,Z]/g, function (_char) {
      return charsValue[_char];
    });
    return sanitized.endsWith(controlDigits[number % 23]);
  },
  FI: function FI(str) {
    // https://dvv.fi/en/personal-identity-code#:~:text=control%20character%20for%20a-,personal,-identity%20code%20calculated
    (0, _assertString["default"])(str);
    if (str.length !== 11) {
      return false;
    }
    if (!str.match(/^\d{6}[\-A\+]\d{3}[0-9ABCDEFHJKLMNPRSTUVWXY]{1}$/)) {
      return false;
    }
    var checkDigits = '0123456789ABCDEFHJKLMNPRSTUVWXY';
    var idAsNumber = parseInt(str.slice(0, 6), 10) * 1000 + parseInt(str.slice(7, 10), 10);
    var remainder = idAsNumber % 31;
    var checkDigit = checkDigits[remainder];
    return checkDigit === str.slice(10, 11);
  },
  IN: function IN(str) {
    var DNI = /^[1-9]\d{3}\s?\d{4}\s?\d{4}$/;

    // multiplication table
    var d = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 2, 3, 4, 0, 6, 7, 8, 9, 5], [2, 3, 4, 0, 1, 7, 8, 9, 5, 6], [3, 4, 0, 1, 2, 8, 9, 5, 6, 7], [4, 0, 1, 2, 3, 9, 5, 6, 7, 8], [5, 9, 8, 7, 6, 0, 4, 3, 2, 1], [6, 5, 9, 8, 7, 1, 0, 4, 3, 2], [7, 6, 5, 9, 8, 2, 1, 0, 4, 3], [8, 7, 6, 5, 9, 3, 2, 1, 0, 4], [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]];

    // permutation table
    var p = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 5, 7, 6, 2, 8, 3, 0, 9, 4], [5, 8, 0, 3, 7, 9, 6, 1, 4, 2], [8, 9, 1, 6, 0, 4, 3, 5, 2, 7], [9, 4, 5, 3, 1, 2, 6, 8, 7, 0], [4, 2, 8, 6, 5, 7, 3, 9, 0, 1], [2, 7, 9, 3, 8, 0, 6, 4, 1, 5], [7, 0, 4, 6, 9, 1, 3, 2, 5, 8]];

    // sanitize user input
    var sanitized = str.trim();

    // validate the data structure
    if (!DNI.test(sanitized)) {
      return false;
    }
    var c = 0;
    var invertedArray = sanitized.replace(/\s/g, '').split('').map(Number).reverse();
    invertedArray.forEach(function (val, i) {
      c = d[c][p[i % 8][val]];
    });
    return c === 0;
  },
  IR: function IR(str) {
    if (!str.match(/^\d{10}$/)) return false;
    str = "0000".concat(str).slice(str.length - 6);
    if (parseInt(str.slice(3, 9), 10) === 0) return false;
    var lastNumber = parseInt(str.slice(9, 10), 10);
    var sum = 0;
    for (var i = 0; i < 9; i++) {
      sum += parseInt(str.slice(i, i + 1), 10) * (10 - i);
    }
    sum %= 11;
    return sum < 2 && lastNumber === sum || sum >= 2 && lastNumber === 11 - sum;
  },
  IT: function IT(str) {
    if (str.length !== 9) return false;
    if (str === 'CA00000AA') return false; // https://it.wikipedia.org/wiki/Carta_d%27identit%C3%A0_elettronica_italiana
    return str.search(/C[A-Z]\d{5}[A-Z]{2}/i) > -1;
  },
  NO: function NO(str) {
    var sanitized = str.trim();
    if (isNaN(Number(sanitized))) return false;
    if (sanitized.length !== 11) return false;
    if (sanitized === '00000000000') return false;

    // https://no.wikipedia.org/wiki/F%C3%B8dselsnummer
    var f = sanitized.split('').map(Number);
    var k1 = (11 - (3 * f[0] + 7 * f[1] + 6 * f[2] + 1 * f[3] + 8 * f[4] + 9 * f[5] + 4 * f[6] + 5 * f[7] + 2 * f[8]) % 11) % 11;
    var k2 = (11 - (5 * f[0] + 4 * f[1] + 3 * f[2] + 2 * f[3] + 7 * f[4] + 6 * f[5] + 5 * f[6] + 4 * f[7] + 3 * f[8] + 2 * k1) % 11) % 11;
    if (k1 !== f[9] || k2 !== f[10]) return false;
    return true;
  },
  TH: function TH(str) {
    if (!str.match(/^[1-8]\d{12}$/)) return false;

    // validate check digit
    var sum = 0;
    for (var i = 0; i < 12; i++) {
      sum += parseInt(str[i], 10) * (13 - i);
    }
    return str[12] === ((11 - sum % 11) % 10).toString();
  },
  LK: function LK(str) {
    var old_nic = /^[1-9]\d{8}[vx]$/i;
    var new_nic = /^[1-9]\d{11}$/i;
    if (str.length === 10 && old_nic.test(str)) return true;else if (str.length === 12 && new_nic.test(str)) return true;
    return false;
  },
  'he-IL': function heIL(str) {
    var DNI = /^\d{9}$/;

    // sanitize user input
    var sanitized = str.trim();

    // validate the data structure
    if (!DNI.test(sanitized)) {
      return false;
    }
    var id = sanitized;
    var sum = 0,
      incNum;
    for (var i = 0; i < id.length; i++) {
      incNum = Number(id[i]) * (i % 2 + 1); // Multiply number by 1 or 2
      sum += incNum > 9 ? incNum - 9 : incNum; // Sum the digits up and add to total
    }
    return sum % 10 === 0;
  },
  'ar-LY': function arLY(str) {
    // Libya National Identity Number NIN is 12 digits, the first digit is either 1 or 2
    var NIN = /^(1|2)\d{11}$/;

    // sanitize user input
    var sanitized = str.trim();

    // validate the data structure
    if (!NIN.test(sanitized)) {
      return false;
    }
    return true;
  },
  'ar-TN': function arTN(str) {
    var DNI = /^\d{8}$/;

    // sanitize user input
    var sanitized = str.trim();

    // validate the data structure
    if (!DNI.test(sanitized)) {
      return false;
    }
    return true;
  },
  'zh-CN': function zhCN(str) {
    var provincesAndCities = ['11',
    // 
    '12',
    // 
    '13',
    // 
    '14',
    // 
    '15',
    // 
    '21',
    // 
    '22',
    // 
    '23',
    // 
    '31',
    // 
    '32',
    // 
    '33',
    // 
    '34',
    // 
    '35',
    // 
    '36',
    // 
    '37',
    // 
    '41',
    // 
    '42',
    // 
    '43',
    // 
    '44',
    // 
    '45',
    // 
    '46',
    // 
    '50',
    // 
    '51',
    // 
    '52',
    // 
    '53',
    // 
    '54',
    // 
    '61',
    // 
    '62',
    // 
    '63',
    // 
    '64',
    // 
    '65',
    // 
    '71',
    // 
    '81',
    // 
    '82',
    // 
    '91' // 
    ];
    var powers = ['7', '9', '10', '5', '8', '4', '2', '1', '6', '3', '7', '9', '10', '5', '8', '4', '2'];
    var parityBit = ['1', '0', 'X', '9', '8', '7', '6', '5', '4', '3', '2'];
    var checkAddressCode = function checkAddressCode(addressCode) {
      return provincesAndCities.includes(addressCode);
    };
    var checkBirthDayCode = function checkBirthDayCode(birDayCode) {
      var yyyy = parseInt(birDayCode.substring(0, 4), 10);
      var mm = parseInt(birDayCode.substring(4, 6), 10);
      var dd = parseInt(birDayCode.substring(6), 10);
      var xdata = new Date(yyyy, mm - 1, dd);
      if (xdata > new Date()) {
        return false;
        // eslint-disable-next-line max-len
      } else if (xdata.getFullYear() === yyyy && xdata.getMonth() === mm - 1 && xdata.getDate() === dd) {
        return true;
      }
      return false;
    };
    var getParityBit = function getParityBit(idCardNo) {
      var id17 = idCardNo.substring(0, 17);
      var power = 0;
      for (var i = 0; i < 17; i++) {
        power += parseInt(id17.charAt(i), 10) * parseInt(powers[i], 10);
      }
      var mod = power % 11;
      return parityBit[mod];
    };
    var checkParityBit = function checkParityBit(idCardNo) {
      return getParityBit(idCardNo) === idCardNo.charAt(17).toUpperCase();
    };
    var check15IdCardNo = function check15IdCardNo(idCardNo) {
      var check = /^[1-9]\d{7}((0[1-9])|(1[0-2]))((0[1-9])|([1-2][0-9])|(3[0-1]))\d{3}$/.test(idCardNo);
      if (!check) return false;
      var addressCode = idCardNo.substring(0, 2);
      check = checkAddressCode(addressCode);
      if (!check) return false;
      var birDayCode = "19".concat(idCardNo.substring(6, 12));
      check = checkBirthDayCode(birDayCode);
      if (!check) return false;
      return true;
    };
    var check18IdCardNo = function check18IdCardNo(idCardNo) {
      var check = /^[1-9]\d{5}[1-9]\d{3}((0[1-9])|(1[0-2]))((0[1-9])|([1-2][0-9])|(3[0-1]))\d{3}(\d|x|X)$/.test(idCardNo);
      if (!check) return false;
      var addressCode = idCardNo.substring(0, 2);
      check = checkAddressCode(addressCode);
      if (!check) return false;
      var birDayCode = idCardNo.substring(6, 14);
      check = checkBirthDayCode(birDayCode);
      if (!check) return false;
      return checkParityBit(idCardNo);
    };
    var checkIdCardNo = function checkIdCardNo(idCardNo) {
      var check = /^\d{15}|(\d{17}(\d|x|X))$/.test(idCardNo);
      if (!check) return false;
      if (idCardNo.length === 15) {
        return check15IdCardNo(idCardNo);
      }
      return check18IdCardNo(idCardNo);
    };
    return checkIdCardNo(str);
  },
  'zh-HK': function zhHK(str) {
    // sanitize user input
    str = str.trim();

    // HKID number starts with 1 or 2 letters, followed by 6 digits,
    // then a checksum contained in square / round brackets or nothing
    var regexHKID = /^[A-Z]{1,2}[0-9]{6}((\([0-9A]\))|(\[[0-9A]\])|([0-9A]))$/;
    var regexIsDigit = /^[0-9]$/;

    // convert the user input to all uppercase and apply regex
    str = str.toUpperCase();
    if (!regexHKID.test(str)) return false;
    str = str.replace(/\[|\]|\(|\)/g, '');
    if (str.length === 8) str = "3".concat(str);
    var checkSumVal = 0;
    for (var i = 0; i <= 7; i++) {
      var convertedChar = void 0;
      if (!regexIsDigit.test(str[i])) convertedChar = (str[i].charCodeAt(0) - 55) % 11;else convertedChar = str[i];
      checkSumVal += convertedChar * (9 - i);
    }
    checkSumVal %= 11;
    var checkSumConverted;
    if (checkSumVal === 0) checkSumConverted = '0';else if (checkSumVal === 1) checkSumConverted = 'A';else checkSumConverted = String(11 - checkSumVal);
    if (checkSumConverted === str[str.length - 1]) return true;
    return false;
  },
  'zh-TW': function zhTW(str) {
    var ALPHABET_CODES = {
      A: 10,
      B: 11,
      C: 12,
      D: 13,
      E: 14,
      F: 15,
      G: 16,
      H: 17,
      I: 34,
      J: 18,
      K: 19,
      L: 20,
      M: 21,
      N: 22,
      O: 35,
      P: 23,
      Q: 24,
      R: 25,
      S: 26,
      T: 27,
      U: 28,
      V: 29,
      W: 32,
      X: 30,
      Y: 31,
      Z: 33
    };
    var sanitized = str.trim().toUpperCase();
    if (!/^[A-Z][0-9]{9}$/.test(sanitized)) return false;
    return Array.from(sanitized).reduce(function (sum, number, index) {
      if (index === 0) {
        var code = ALPHABET_CODES[number];
        return code % 10 * 9 + Math.floor(code / 10);
      }
      if (index === 9) {
        return (10 - sum % 10 - Number(number)) % 10 === 0;
      }
      return sum + Number(number) * (9 - index);
    }, 0);
  }
};
function isIdentityCard(str, locale) {
  (0, _assertString["default"])(str);
  if (locale in validators) {
    return validators[locale](str);
  } else if (locale === 'any') {
    for (var key in validators) {
      // https://github.com/gotwarlost/istanbul/blob/master/ignoring-code-for-coverage.md#ignoring-code-for-coverage-purposes
      // istanbul ignore else
      if (validators.hasOwnProperty(key)) {
        var validator = validators[key];
        if (validator(str)) {
          return true;
        }
      }
    }
    return false;
  }
  throw new Error("Invalid locale '".concat(locale, "'"));
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./isInt":476,"./util/assertString":524}],475:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isIn;
var _assertString = _interopRequireDefault(require("./util/assertString"));
var _toString = _interopRequireDefault(require("./util/toString"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}
function isIn(str, options) {
  (0, _assertString["default"])(str);
  var i;
  if (Object.prototype.toString.call(options) === '[object Array]') {
    var array = [];
    for (i in options) {
      // https://github.com/gotwarlost/istanbul/blob/master/ignoring-code-for-coverage.md#ignoring-code-for-coverage-purposes
      // istanbul ignore else
      if ({}.hasOwnProperty.call(options, i)) {
        array[i] = (0, _toString["default"])(options[i]);
      }
    }
    return array.indexOf(str) >= 0;
  } else if (_typeof(options) === 'object') {
    return options.hasOwnProperty(str);
  } else if (options && typeof options.indexOf === 'function') {
    return options.indexOf(str) >= 0;
  }
  return false;
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./util/assertString":524,"./util/toString":528}],476:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isInt;
var _assertString = _interopRequireDefault(require("./util/assertString"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
var _int = /^(?:[-+]?(?:0|[1-9][0-9]*))$/;
var intLeadingZeroes = /^[-+]?[0-9]+$/;
function isInt(str, options) {
  (0, _assertString["default"])(str);
  options = options || {};

  // Get the regex to use for testing, based on whether
  // leading zeroes are allowed or not.
  var regex = options.allow_leading_zeroes === false ? _int : intLeadingZeroes;

  // Check min/max/lt/gt
  var minCheckPassed = !options.hasOwnProperty('min') || str >= options.min;
  var maxCheckPassed = !options.hasOwnProperty('max') || str <= options.max;
  var ltCheckPassed = !options.hasOwnProperty('lt') || str < options.lt;
  var gtCheckPassed = !options.hasOwnProperty('gt') || str > options.gt;
  return regex.test(str) && minCheckPassed && maxCheckPassed && ltCheckPassed && gtCheckPassed;
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./util/assertString":524}],477:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isJSON;
var _assertString = _interopRequireDefault(require("./util/assertString"));
var _merge = _interopRequireDefault(require("./util/merge"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}
var default_json_options = {
  allow_primitives: false
};
function isJSON(str, options) {
  (0, _assertString["default"])(str);
  try {
    options = (0, _merge["default"])(options, default_json_options);
    var primitives = [];
    if (options.allow_primitives) {
      primitives = [null, false, true];
    }
    var obj = JSON.parse(str);
    return primitives.includes(obj) || !!obj && _typeof(obj) === 'object';
  } catch (e) {/* ignore */}
  return false;
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./util/assertString":524,"./util/merge":526}],478:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isJWT;
var _assertString = _interopRequireDefault(require("./util/assertString"));
var _isBase = _interopRequireDefault(require("./isBase64"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
function isJWT(str) {
  (0, _assertString["default"])(str);
  var dotSplit = str.split('.');
  var len = dotSplit.length;
  if (len !== 3) {
    return false;
  }
  return dotSplit.reduce(function (acc, currElem) {
    return acc && (0, _isBase["default"])(currElem, {
      urlSafe: true
    });
  }, true);
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./isBase64":437,"./util/assertString":524}],479:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isLatLong;
var _assertString = _interopRequireDefault(require("./util/assertString"));
var _merge = _interopRequireDefault(require("./util/merge"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
var lat = /^\(?[+-]?(90(\.0+)?|[1-8]?\d(\.\d+)?)$/;
var _long = /^\s?[+-]?(180(\.0+)?|1[0-7]\d(\.\d+)?|\d{1,2}(\.\d+)?)\)?$/;
var latDMS = /^(([1-8]?\d)\D+([1-5]?\d|60)\D+([1-5]?\d|60)(\.\d+)?|90\D+0\D+0)\D+[NSns]?$/i;
var longDMS = /^\s*([1-7]?\d{1,2}\D+([1-5]?\d|60)\D+([1-5]?\d|60)(\.\d+)?|180\D+0\D+0)\D+[EWew]?$/i;
var defaultLatLongOptions = {
  checkDMS: false
};
function isLatLong(str, options) {
  (0, _assertString["default"])(str);
  options = (0, _merge["default"])(options, defaultLatLongOptions);
  if (!str.includes(',')) return false;
  var pair = str.split(',');
  if (pair[0].startsWith('(') && !pair[1].endsWith(')') || pair[1].endsWith(')') && !pair[0].startsWith('(')) return false;
  if (options.checkDMS) {
    return latDMS.test(pair[0]) && longDMS.test(pair[1]);
  }
  return lat.test(pair[0]) && _long.test(pair[1]);
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./util/assertString":524,"./util/merge":526}],480:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isLength;
var _assertString = _interopRequireDefault(require("./util/assertString"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}
/* eslint-disable prefer-rest-params */
function isLength(str, options) {
  (0, _assertString["default"])(str);
  var min;
  var max;
  if (_typeof(options) === 'object') {
    min = options.min || 0;
    max = options.max;
  } else {
    // backwards compatibility: isLength(str, min [, max])
    min = arguments[1] || 0;
    max = arguments[2];
  }
  var presentationSequences = str.match(/(\uFE0F|\uFE0E)/g) || [];
  var surrogatePairs = str.match(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g) || [];
  var len = str.length - presentationSequences.length - surrogatePairs.length;
  return len >= min && (typeof max === 'undefined' || len <= max);
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./util/assertString":524}],481:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isLicensePlate;
var _assertString = _interopRequireDefault(require("./util/assertString"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
var validators = {
  'cs-CZ': function csCZ(str) {
    return /^(([ABCDEFHIJKLMNPRSTUVXYZ]|[0-9])-?){5,8}$/.test(str);
  },
  'de-DE': function deDE(str) {
    return /^((A|AA|AB|AC|AE|AH|AK|AM|AN|A|AP|AS|AT|AU|AW|AZ|B|BA|BB|BC|BE|BF|BH|BI|BK|BL|BM|BN|BO|B|BS|BT|BZ|C|CA|CB|CE|CO|CR|CW|D|DA|DD|DE|DH|DI|DL|DM|DN|DO|DU|DW|DZ|E|EA|EB|ED|EE|EF|EG|EH|EI|EL|EM|EN|ER|ES|EU|EW|F|FB|FD|FF|FG|FI|FL|FN|FO|FR|FS|FT|F|FW|FZ|G|GA|GC|GD|GE|GF|GG|GI|GK|GL|GM|GN|G|GP|GR|GS|GT|G|GV|GW|GZ|H|HA|HB|HC|HD|HE|HF|HG|HH|HI|HK|HL|HM|HN|HO|HP|HR|HS|HU|HV|HX|HY|HZ|IK|IL|IN|IZ|J|JE|JL|K|KA|KB|KC|KE|KF|KG|KH|KI|KK|KL|KM|KN|KO|KR|KS|KT|KU|KW|KY|L|LA|LB|LC|LD|LF|LG|LH|LI|LL|LM|LN|L|LP|LR|LU|M|MA|MB|MC|MD|ME|MG|MH|MI|MK|ML|MM|MN|MO|MQ|MR|MS|M|MW|MY|MZ|N|NB|ND|NE|NF|NH|NI|NK|NM|N|NP|NR|NT|NU|NW|NY|NZ|OA|OB|OC|OD|OE|OF|OG|OH|OK|OL|OP|OS|OZ|P|PA|PB|PE|PF|PI|PL|PM|PN|PR|PS|PW|PZ|R|RA|RC|RD|RE|RG|RH|RI|RL|RM|RN|RO|RP|RS|RT|RU|RV|RW|RZ|S|SB|SC|SE|SG|SI|SK|SL|SM|SN|SO|SP|SR|ST|SU|SW|SY|SZ|TE|TF|TG|TO|TP|TR|TS|TT|T|B|UE|UH|UL|UM|UN|V|VB|VG|VK|VR|VS|W|WA|WB|WE|WF|WI|WK|WL|WM|WN|WO|WR|WS|WT|W|WW|WZ|Z|ZE|ZI|ZP|ZR|ZW|ZZ)[- ]?[A-Z]{1,2}[- ]?\d{1,4}|(ABG|ABI|AIB|AIC|ALF|ALZ|ANA|ANG|ANK|APD|ARN|ART|ASL|ASZ|AUR|AZE|BAD|BAR|BBG|BCH|BED|BER|BGD|BGL|BID|BIN|BIR|BIT|BIW|BKS|BLB|BLK|BNA|BOG|BOH|BOR|BOT|BRA|BRB|BRG|BRK|BRL|BRV|BSB|BSK|BTF|BD|BUL|BR|BS|BZ|CAS|CHA|CLP|CLZ|COC|COE|CUX|DAH|DAN|DAU|DBR|DEG|DEL|DGF|DIL|DIN|DIZ|DKB|DLG|DON|DUD|DW|EBE|EBN|EBS|ECK|EIC|EIL|EIN|EIS|EMD|EMS|ERB|ERH|ERK|ERZ|ESB|ESW|FDB|FDS|FEU|FFB|FKB|FL|FOR|FRG|FRI|FRW|FTL|FS|GAN|GAP|GDB|GEL|GEO|GER|GHA|GHC|GLA|GMN|GNT|GOA|GOH|GRA|GRH|GRI|GRM|GRZ|GTH|GUB|GUN|GVM|HAB|HAL|HAM|HAS|HBN|HBS|HCH|HDH|HDL|HEB|HEF|HEI|HER|HET|HGN|HGW|HHM|HIG|HIP|HM|HOG|HOH|HOL|HOM|HOR|HS|HOT|HRO|HSK|HST|HVL|HWI|IGB|ILL|JL|KEH|KEL|KEM|KIB|KLE|KLZ|KN|KT|KZ|KRU|KN|KUS|KYF|LAN|LAU|LBS|LBZ|LDK|LDS|LEO|LER|LEV|LIB|LIF|LIP|LB|LOS|LRO|LSZ|LN|LUP|LWL|MAB|MAI|MAK|MAL|MED|MEG|MEI|MEK|MEL|MER|MET|MGH|MGN|MHL|MIL|MKK|MOD|MOL|MON|MOS|MSE|MSH|MSP|MST|MTK|MTL|MB|MR|MYK|MZG|NAB|NAI|NAU|NDH|NEA|NEB|NEC|NEN|NES|NEW|NMB|NMS|NOH|NOL|NOM|NOR|NVP|NWM|OAL|OBB|OBG|OCH|OHA|HR|OHV|OHZ|OPR|OSL|OVI|OVL|OVP|PAF|PAN|PAR|PCH|PEG|PIR|PL|PR|QFT|QLB|RDG|REG|REH|REI|RID|RIE|ROD|ROF|ROK|ROL|ROS|ROT|ROW|RSL|RD|RG|SAB|SAD|SAN|SAW|SBG|SBK|SCZ|SDH|SDL|SDT|SEB|SEE|SEF|SEL|SFB|SFT|SGH|SHA|SHG|SHK|SHL|SIG|SIM|SLE|SLF|SLK|SLN|SLS|SL|SLZ|SM|SOB|SOG|SOK|SM|SON|SPB|SPN|SRB|SRO|STA|STB|STD|STE|STL|SUL|SW|SWA|SZB|TBB|TDO|TET|TIR|TL|TUT|UEM|UER|UFF|USI|VAI|VEC|VER|VIB|VIE|VIT|VOH|WAF|WAK|WAN|WAR|WAT|WBS|WDA|WEL|WEN|WER|WES|WHV|WIL|WIS|WIT|WIZ|WLG|WMS|WND|WOB|WOH|WOL|WOR|WOS|WRN|WSF|WST|WSW|WTL|WTM|WUG|WM|WUN|WUR|WZL|ZEL|ZIG)[- ]?(([A-Z][- ]?\d{1,4})|([A-Z]{2}[- ]?\d{1,3})))[- ]?(E|H)?$/.test(str);
  },
  'de-LI': function deLI(str) {
    return /^FL[- ]?\d{1,5}[UZ]?$/.test(str);
  },
  'en-IN': function enIN(str) {
    return /^[A-Z]{2}[ -]?[0-9]{1,2}(?:[ -]?[A-Z])(?:[ -]?[A-Z]*)?[ -]?[0-9]{4}$/.test(str);
  },
  'es-AR': function esAR(str) {
    return /^(([A-Z]{2} ?[0-9]{3} ?[A-Z]{2})|([A-Z]{3} ?[0-9]{3}))$/.test(str);
  },
  'fi-FI': function fiFI(str) {
    return /^(?=.{4,7})(([A-Z]{1,3}|[0-9]{1,3})[\s-]?([A-Z]{1,3}|[0-9]{1,5}))$/.test(str);
  },
  'hu-HU': function huHU(str) {
    return /^((((?!AAA)(([A-NPRSTVZWXY]{1})([A-PR-Z]{1})([A-HJ-NPR-Z]))|(A[ABC]I)|A[ABC]O|A[A-W]Q|BPI|BPO|UCO|UDO|XAO)-(?!000)\d{3})|(M\d{6})|((CK|DT|CD|HC|H[ABEFIKLMNPRSTVX]|MA|OT|R[A-Z]) \d{2}-\d{2})|(CD \d{3}-\d{3})|(C-(C|X) \d{4})|(X-(A|B|C) \d{4})|(([EPVZ]-\d{5}))|(S A[A-Z]{2} \d{2})|(SP \d{2}-\d{2}))$/.test(str);
  },
  'pt-BR': function ptBR(str) {
    return /^[A-Z]{3}[ -]?[0-9][A-Z][0-9]{2}|[A-Z]{3}[ -]?[0-9]{4}$/.test(str);
  },
  'pt-PT': function ptPT(str) {
    return /^([A-Z]{2}|[0-9]{2})[ -]?([A-Z]{2}|[0-9]{2})[ -]?([A-Z]{2}|[0-9]{2})$/.test(str);
  },
  'sq-AL': function sqAL(str) {
    return /^[A-Z]{2}[- ]?((\d{3}[- ]?(([A-Z]{2})|T))|(R[- ]?\d{3}))$/.test(str);
  },
  'sv-SE': function svSE(str) {
    return /^[A-HJ-PR-UW-Z]{3} ?[\d]{2}[A-HJ-PR-UW-Z1-9]$|(^[A-Z ]{2,7}$)/.test(str.trim());
  },
  'en-PK': function enPK(str) {
    return /(^[A-Z]{2}((\s|-){0,1})[0-9]{3,4}((\s|-)[0-9]{2}){0,1}$)|(^[A-Z]{3}((\s|-){0,1})[0-9]{3,4}((\s|-)[0-9]{2}){0,1}$)|(^[A-Z]{4}((\s|-){0,1})[0-9]{3,4}((\s|-)[0-9]{2}){0,1}$)|(^[A-Z]((\s|-){0,1})[0-9]{4}((\s|-)[0-9]{2}){0,1}$)/.test(str.trim());
  }
};
function isLicensePlate(str, locale) {
  (0, _assertString["default"])(str);
  if (locale in validators) {
    return validators[locale](str);
  } else if (locale === 'any') {
    for (var key in validators) {
      /* eslint guard-for-in: 0 */
      var validator = validators[key];
      if (validator(str)) {
        return true;
      }
    }
    return false;
  }
  throw new Error("Invalid locale '".concat(locale, "'"));
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./util/assertString":524}],482:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isLocale;
var _assertString = _interopRequireDefault(require("./util/assertString"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
/*
  = 3ALPHA              ; selected ISO 639 codes
    *2("-" 3ALPHA)      ; permanently reserved
 */
var extlang = '([A-Za-z]{3}(-[A-Za-z]{3}){0,2})';

/*
  = 2*3ALPHA            ; shortest ISO 639 code
    ["-" extlang]       ; sometimes followed by
                        ; extended language subtags
  / 4ALPHA              ; or reserved for future use
  / 5*8ALPHA            ; or registered language subtag
 */
var language = "(([a-zA-Z]{2,3}(-".concat(extlang, ")?)|([a-zA-Z]{5,8}))");

/*
  = 4ALPHA              ; ISO 15924 code
 */
var script = '([A-Za-z]{4})';

/*
  = 2ALPHA              ; ISO 3166-1 code
  / 3DIGIT              ; UN M.49 code
 */
var region = '([A-Za-z]{2}|\\d{3})';

/*
  = 5*8alphanum         ; registered variants
  / (DIGIT 3alphanum)
 */
var variant = '([A-Za-z0-9]{5,8}|(\\d[A-Z-a-z0-9]{3}))';

/*
  = DIGIT               ; 0 - 9
  / %x41-57             ; A - W
  / %x59-5A             ; Y - Z
  / %x61-77             ; a - w
  / %x79-7A             ; y - z
 */
var singleton = '(\\d|[A-W]|[Y-Z]|[a-w]|[y-z])';

/*
  = singleton 1*("-" (2*8alphanum))
                        ; Single alphanumerics
                        ; "x" reserved for private use
 */
var extension = "(".concat(singleton, "(-[A-Za-z0-9]{2,8})+)");

/*
  = "x" 1*("-" (1*8alphanum))
 */
var privateuse = '(x(-[A-Za-z0-9]{1,8})+)';

// irregular tags do not match the 'langtag' production and would not
// otherwise be considered 'well-formed'. These tags are all valid, but
// most are deprecated in favor of more modern subtags or subtag combination

var irregular = '((en-GB-oed)|(i-ami)|(i-bnn)|(i-default)|(i-enochian)|' + '(i-hak)|(i-klingon)|(i-lux)|(i-mingo)|(i-navajo)|(i-pwn)|(i-tao)|' + '(i-tay)|(i-tsu)|(sgn-BE-FR)|(sgn-BE-NL)|(sgn-CH-DE))';

// regular tags match the 'langtag' production, but their subtags are not
// extended language or variant subtags: their meaning is defined by
// their registration and all of these are deprecated in favor of a more
// modern subtag or sequence of subtags

var regular = '((art-lojban)|(cel-gaulish)|(no-bok)|(no-nyn)|(zh-guoyu)|' + '(zh-hakka)|(zh-min)|(zh-min-nan)|(zh-xiang))';

/*
  = irregular           ; non-redundant tags registered
  / regular             ; during the RFC 3066 era

 */
var grandfathered = "(".concat(irregular, "|").concat(regular, ")");

/*
  RFC 5646 defines delimitation of subtags via a hyphen:

      "Subtag" refers to a specific section of a tag, delimited by a
      hyphen, such as the subtags 'zh', 'Hant', and 'CN' in the tag "zh-
      Hant-CN".  Examples of subtags in this document are enclosed in
      single quotes ('Hant')

  However, we need to add "_" to maintain the existing behaviour.
 */
var delimiter = '(-|_)';

/*
  = language
    ["-" script]
    ["-" region]
    *("-" variant)
    *("-" extension)
    ["-" privateuse]
 */
var langtag = "".concat(language, "(").concat(delimiter).concat(script, ")?(").concat(delimiter).concat(region, ")?(").concat(delimiter).concat(variant, ")*(").concat(delimiter).concat(extension, ")*(").concat(delimiter).concat(privateuse, ")?");

/*
  Regex implementation based on BCP RFC 5646
  Tags for Identifying Languages
  https://www.rfc-editor.org/rfc/rfc5646.html
 */
var languageTagRegex = new RegExp("(^".concat(privateuse, "$)|(^").concat(grandfathered, "$)|(^").concat(langtag, "$)"));
function isLocale(str) {
  (0, _assertString["default"])(str);
  return languageTagRegex.test(str);
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./util/assertString":524}],483:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isLowercase;
var _assertString = _interopRequireDefault(require("./util/assertString"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
function isLowercase(str) {
  (0, _assertString["default"])(str);
  return str === str.toLowerCase();
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./util/assertString":524}],484:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isLuhnNumber;
var _assertString = _interopRequireDefault(require("./util/assertString"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
function isLuhnNumber(str) {
  (0, _assertString["default"])(str);
  var sanitized = str.replace(/[- ]+/g, '');
  var sum = 0;
  var digit;
  var tmpNum;
  var shouldDouble;
  for (var i = sanitized.length - 1; i >= 0; i--) {
    digit = sanitized.substring(i, i + 1);
    tmpNum = parseInt(digit, 10);
    if (shouldDouble) {
      tmpNum *= 2;
      if (tmpNum >= 10) {
        sum += tmpNum % 10 + 1;
      } else {
        sum += tmpNum;
      }
    } else {
      sum += tmpNum;
    }
    shouldDouble = !shouldDouble;
  }
  return !!(sum % 10 === 0 ? sanitized : false);
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./util/assertString":524}],485:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isMACAddress;
var _assertString = _interopRequireDefault(require("./util/assertString"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
var macAddress48 = /^(?:[0-9a-fA-F]{2}([-:\s]))([0-9a-fA-F]{2}\1){4}([0-9a-fA-F]{2})$/;
var macAddress48NoSeparators = /^([0-9a-fA-F]){12}$/;
var macAddress48WithDots = /^([0-9a-fA-F]{4}\.){2}([0-9a-fA-F]{4})$/;
var macAddress64 = /^(?:[0-9a-fA-F]{2}([-:\s]))([0-9a-fA-F]{2}\1){6}([0-9a-fA-F]{2})$/;
var macAddress64NoSeparators = /^([0-9a-fA-F]){16}$/;
var macAddress64WithDots = /^([0-9a-fA-F]{4}\.){3}([0-9a-fA-F]{4})$/;
function isMACAddress(str, options) {
  (0, _assertString["default"])(str);
  if (options !== null && options !== void 0 && options.eui) {
    options.eui = String(options.eui);
  }
  /**
   * @deprecated `no_colons` TODO: remove it in the next major
  */
  if (options !== null && options !== void 0 && options.no_colons || options !== null && options !== void 0 && options.no_separators) {
    if (options.eui === '48') {
      return macAddress48NoSeparators.test(str);
    }
    if (options.eui === '64') {
      return macAddress64NoSeparators.test(str);
    }
    return macAddress48NoSeparators.test(str) || macAddress64NoSeparators.test(str);
  }
  if ((options === null || options === void 0 ? void 0 : options.eui) === '48') {
    return macAddress48.test(str) || macAddress48WithDots.test(str);
  }
  if ((options === null || options === void 0 ? void 0 : options.eui) === '64') {
    return macAddress64.test(str) || macAddress64WithDots.test(str);
  }
  return isMACAddress(str, {
    eui: '48'
  }) || isMACAddress(str, {
    eui: '64'
  });
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./util/assertString":524}],486:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isMD5;
var _assertString = _interopRequireDefault(require("./util/assertString"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
var md5 = /^[a-f0-9]{32}$/;
function isMD5(str) {
  (0, _assertString["default"])(str);
  return md5.test(str);
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./util/assertString":524}],487:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isMagnetURI;
var _assertString = _interopRequireDefault(require("./util/assertString"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
var magnetURIComponent = /(?:^magnet:\?|[^?&]&)xt(?:\.1)?=urn:(?:(?:aich|bitprint|btih|ed2k|ed2khash|kzhash|md5|sha1|tree:tiger):[a-z0-9]{32}(?:[a-z0-9]{8})?|btmh:1220[a-z0-9]{64})(?:$|&)/i;
function isMagnetURI(url) {
  (0, _assertString["default"])(url);
  if (url.indexOf('magnet:?') !== 0) {
    return false;
  }
  return magnetURIComponent.test(url);
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./util/assertString":524}],488:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isMailtoURI;
var _trim = _interopRequireDefault(require("./trim"));
var _isEmail = _interopRequireDefault(require("./isEmail"));
var _assertString = _interopRequireDefault(require("./util/assertString"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArrayLimit(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e,
      n,
      i,
      u,
      a = [],
      f = !0,
      o = !1;
    try {
      if (i = (t = t.call(r)).next, 0 === l) {
        if (Object(t) !== t) return;
        f = !1;
      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);
    } catch (r) {
      o = !0, n = r;
    } finally {
      try {
        if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}
function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;
      var F = function F() {};
      return {
        s: F,
        n: function n() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function e(_e) {
          throw _e;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true,
    didErr = false,
    err;
  return {
    s: function s() {
      it = it.call(o);
    },
    n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function e(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function f() {
      try {
        if (!normalCompletion && it["return"] != null) it["return"]();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function parseMailtoQueryString(queryString) {
  var allowedParams = new Set(['subject', 'body', 'cc', 'bcc']),
    query = {
      cc: '',
      bcc: ''
    };
  var isParseFailed = false;
  var queryParams = queryString.split('&');
  if (queryParams.length > 4) {
    return false;
  }
  var _iterator = _createForOfIteratorHelper(queryParams),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var q = _step.value;
      var _q$split = q.split('='),
        _q$split2 = _slicedToArray(_q$split, 2),
        key = _q$split2[0],
        value = _q$split2[1];

      // checked for invalid and duplicated query params
      if (key && !allowedParams.has(key)) {
        isParseFailed = true;
        break;
      }
      if (value && (key === 'cc' || key === 'bcc')) {
        query[key] = value;
      }
      if (key) {
        allowedParams["delete"](key);
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  return isParseFailed ? false : query;
}
function isMailtoURI(url, options) {
  (0, _assertString["default"])(url);
  if (url.indexOf('mailto:') !== 0) {
    return false;
  }
  var _url$replace$split = url.replace('mailto:', '').split('?'),
    _url$replace$split2 = _slicedToArray(_url$replace$split, 2),
    to = _url$replace$split2[0],
    _url$replace$split2$ = _url$replace$split2[1],
    queryString = _url$replace$split2$ === void 0 ? '' : _url$replace$split2$;
  if (!to && !queryString) {
    return true;
  }
  var query = parseMailtoQueryString(queryString);
  if (!query) {
    return false;
  }
  return "".concat(to, ",").concat(query.cc, ",").concat(query.bcc).split(',').every(function (email) {
    email = (0, _trim["default"])(email, ' ');
    if (email) {
      return (0, _isEmail["default"])(email, options);
    }
    return true;
  });
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./isEmail":449,"./trim":521,"./util/assertString":524}],489:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isMimeType;
var _assertString = _interopRequireDefault(require("./util/assertString"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
/*
  Checks if the provided string matches to a correct Media type format (MIME type)

  This function only checks is the string format follows the
  etablished rules by the according RFC specifications.
  This function supports 'charset' in textual media types
  (https://tools.ietf.org/html/rfc6657).

  This function does not check against all the media types listed
  by the IANA (https://www.iana.org/assignments/media-types/media-types.xhtml)
  because of lightness purposes : it would require to include
  all these MIME types in this librairy, which would weigh it
  significantly. This kind of effort maybe is not worth for the use that
  this function has in this entire librairy.

  More informations in the RFC specifications :
  - https://tools.ietf.org/html/rfc2045
  - https://tools.ietf.org/html/rfc2046
  - https://tools.ietf.org/html/rfc7231#section-3.1.1.1
  - https://tools.ietf.org/html/rfc7231#section-3.1.1.5
*/

// Match simple MIME types
// NB :
//   Subtype length must not exceed 100 characters.
//   This rule does not comply to the RFC specs (what is the max length ?).
var mimeTypeSimple = /^(application|audio|font|image|message|model|multipart|text|video)\/[a-zA-Z0-9\.\-\+_]{1,100}$/i; // eslint-disable-line max-len

// Handle "charset" in "text/*"
var mimeTypeText = /^text\/[a-zA-Z0-9\.\-\+]{1,100};\s?charset=("[a-zA-Z0-9\.\-\+\s]{0,70}"|[a-zA-Z0-9\.\-\+]{0,70})(\s?\([a-zA-Z0-9\.\-\+\s]{1,20}\))?$/i; // eslint-disable-line max-len

// Handle "boundary" in "multipart/*"
var mimeTypeMultipart = /^multipart\/[a-zA-Z0-9\.\-\+]{1,100}(;\s?(boundary|charset)=("[a-zA-Z0-9\.\-\+\s]{0,70}"|[a-zA-Z0-9\.\-\+]{0,70})(\s?\([a-zA-Z0-9\.\-\+\s]{1,20}\))?){0,2}$/i; // eslint-disable-line max-len

function isMimeType(str) {
  (0, _assertString["default"])(str);
  return mimeTypeSimple.test(str) || mimeTypeText.test(str) || mimeTypeMultipart.test(str);
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./util/assertString":524}],490:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isMobilePhone;
exports.locales = void 0;
var _assertString = _interopRequireDefault(require("./util/assertString"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
/* eslint-disable max-len */
var phones = {
  'am-AM': /^(\+?374|0)(33|4[134]|55|77|88|9[13-689])\d{6}$/,
  'ar-AE': /^((\+?971)|0)?5[024568]\d{7}$/,
  'ar-BH': /^(\+?973)?(3|6)\d{7}$/,
  'ar-DZ': /^(\+?213|0)(5|6|7)\d{8}$/,
  'ar-LB': /^(\+?961)?((3|81)\d{6}|7\d{7})$/,
  'ar-EG': /^((\+?20)|0)?1[0125]\d{8}$/,
  'ar-IQ': /^(\+?964|0)?7[0-9]\d{8}$/,
  'ar-JO': /^(\+?962|0)?7[789]\d{7}$/,
  'ar-KW': /^(\+?965)([569]\d{7}|41\d{6})$/,
  'ar-LY': /^((\+?218)|0)?(9[1-6]\d{7}|[1-8]\d{7,9})$/,
  'ar-MA': /^(?:(?:\+|00)212|0)[5-7]\d{8}$/,
  'ar-OM': /^((\+|00)968)?(9[1-9])\d{6}$/,
  'ar-PS': /^(\+?970|0)5[6|9](\d{7})$/,
  'ar-SA': /^(!?(\+?966)|0)?5\d{8}$/,
  'ar-SD': /^((\+?249)|0)?(9[012369]|1[012])\d{7}$/,
  'ar-SY': /^(!?(\+?963)|0)?9\d{8}$/,
  'ar-TN': /^(\+?216)?[2459]\d{7}$/,
  'az-AZ': /^(\+994|0)(10|5[015]|7[07]|99)\d{7}$/,
  'bs-BA': /^((((\+|00)3876)|06))((([0-3]|[5-6])\d{6})|(4\d{7}))$/,
  'be-BY': /^(\+?375)?(24|25|29|33|44)\d{7}$/,
  'bg-BG': /^(\+?359|0)?8[789]\d{7}$/,
  'bn-BD': /^(\+?880|0)1[13456789][0-9]{8}$/,
  'ca-AD': /^(\+376)?[346]\d{5}$/,
  'cs-CZ': /^(\+?420)? ?[1-9][0-9]{2} ?[0-9]{3} ?[0-9]{3}$/,
  'da-DK': /^(\+?45)?\s?\d{2}\s?\d{2}\s?\d{2}\s?\d{2}$/,
  'de-DE': /^((\+49|0)1)(5[0-25-9]\d|6([23]|0\d?)|7([0-57-9]|6\d))\d{7,9}$/,
  'de-AT': /^(\+43|0)\d{1,4}\d{3,12}$/,
  'de-CH': /^(\+41|0)([1-9])\d{1,9}$/,
  'de-LU': /^(\+352)?((6\d1)\d{6})$/,
  'dv-MV': /^(\+?960)?(7[2-9]|9[1-9])\d{5}$/,
  'el-GR': /^(\+?30|0)?6(8[5-9]|9(?![26])[0-9])\d{7}$/,
  'el-CY': /^(\+?357?)?(9(9|6)\d{6})$/,
  'en-AI': /^(\+?1|0)264(?:2(35|92)|4(?:6[1-2]|76|97)|5(?:3[6-9]|8[1-4])|7(?:2(4|9)|72))\d{4}$/,
  'en-AU': /^(\+?61|0)4\d{8}$/,
  'en-AG': /^(?:\+1|1)268(?:464|7(?:1[3-9]|[28]\d|3[0246]|64|7[0-689]))\d{4}$/,
  'en-BM': /^(\+?1)?441(((3|7)\d{6}$)|(5[0-3][0-9]\d{4}$)|(59\d{5}$))/,
  'en-BS': /^(\+?1[-\s]?|0)?\(?242\)?[-\s]?\d{3}[-\s]?\d{4}$/,
  'en-GB': /^(\+?44|0)7\d{9}$/,
  'en-GG': /^(\+?44|0)1481\d{6}$/,
  'en-GH': /^(\+233|0)(20|50|24|54|27|57|26|56|23|28|55|59)\d{7}$/,
  'en-GY': /^(\+592|0)6\d{6}$/,
  'en-HK': /^(\+?852[-\s]?)?[456789]\d{3}[-\s]?\d{4}$/,
  'en-MO': /^(\+?853[-\s]?)?[6]\d{3}[-\s]?\d{4}$/,
  'en-IE': /^(\+?353|0)8[356789]\d{7}$/,
  'en-IN': /^(\+?91|0)?[6789]\d{9}$/,
  'en-JM': /^(\+?876)?\d{7}$/,
  'en-KE': /^(\+?254|0)(7|1)\d{8}$/,
  'fr-CF': /^(\+?236| ?)(70|75|77|72|21|22)\d{6}$/,
  'en-SS': /^(\+?211|0)(9[1257])\d{7}$/,
  'en-KI': /^((\+686|686)?)?( )?((6|7)(2|3|8)[0-9]{6})$/,
  'en-KN': /^(?:\+1|1)869(?:46\d|48[89]|55[6-8]|66\d|76[02-7])\d{4}$/,
  'en-LS': /^(\+?266)(22|28|57|58|59|27|52)\d{6}$/,
  'en-MT': /^(\+?356|0)?(99|79|77|21|27|22|25)[0-9]{6}$/,
  'en-MU': /^(\+?230|0)?\d{8}$/,
  'en-MW': /^(\+?265|0)(((77|88|31|99|98|21)\d{7})|(((111)|1)\d{6})|(32000\d{4}))$/,
  'en-NA': /^(\+?264|0)(6|8)\d{7}$/,
  'en-NG': /^(\+?234|0)?[789]\d{9}$/,
  'en-NZ': /^(\+?64|0)[28]\d{7,9}$/,
  'en-PG': /^(\+?675|0)?(7\d|8[18])\d{6}$/,
  'en-PK': /^((00|\+)?92|0)3[0-6]\d{8}$/,
  'en-PH': /^(09|\+639)\d{9}$/,
  'en-RW': /^(\+?250|0)?[7]\d{8}$/,
  'en-SG': /^(\+65)?[3689]\d{7}$/,
  'en-SL': /^(\+?232|0)\d{8}$/,
  'en-TZ': /^(\+?255|0)?[67]\d{8}$/,
  'en-UG': /^(\+?256|0)?[7]\d{8}$/,
  'en-US': /^((\+1|1)?( |-)?)?(\([2-9][0-9]{2}\)|[2-9][0-9]{2})( |-)?([2-9][0-9]{2}( |-)?[0-9]{4})$/,
  'en-ZA': /^(\+?27|0)\d{9}$/,
  'en-ZM': /^(\+?26)?09[567]\d{7}$/,
  'en-ZW': /^(\+263)[0-9]{9}$/,
  'en-BW': /^(\+?267)?(7[1-8]{1})\d{6}$/,
  'es-AR': /^\+?549(11|[2368]\d)\d{8}$/,
  'es-BO': /^(\+?591)?(6|7)\d{7}$/,
  'es-CO': /^(\+?57)?3(0(0|1|2|4|5)|1\d|2[0-4]|5(0|1))\d{7}$/,
  'es-CL': /^(\+?56|0)[2-9]\d{1}\d{7}$/,
  'es-CR': /^(\+506)?[2-8]\d{7}$/,
  'es-CU': /^(\+53|0053)?5\d{7}$/,
  'es-DO': /^(\+?1)?8[024]9\d{7}$/,
  'es-HN': /^(\+?504)?[9|8|3|2]\d{7}$/,
  'es-EC': /^(\+?593|0)([2-7]|9[2-9])\d{7}$/,
  'es-ES': /^(\+?34)?[6|7]\d{8}$/,
  'es-PE': /^(\+?51)?9\d{8}$/,
  'es-MX': /^(\+?52)?(1|01)?\d{10,11}$/,
  'es-NI': /^(\+?505)\d{7,8}$/,
  'es-PA': /^(\+?507)\d{7,8}$/,
  'es-PY': /^(\+?595|0)9[9876]\d{7}$/,
  'es-SV': /^(\+?503)?[67]\d{7}$/,
  'es-UY': /^(\+598|0)9[1-9][\d]{6}$/,
  'es-VE': /^(\+?58)?(2|4)\d{9}$/,
  'et-EE': /^(\+?372)?\s?(5|8[1-4])\s?([0-9]\s?){6,7}$/,
  'fa-IR': /^(\+?98[\-\s]?|0)9[0-39]\d[\-\s]?\d{3}[\-\s]?\d{4}$/,
  'fi-FI': /^(\+?358|0)\s?(4[0-6]|50)\s?(\d\s?){4,8}$/,
  'fj-FJ': /^(\+?679)?\s?\d{3}\s?\d{4}$/,
  'fo-FO': /^(\+?298)?\s?\d{2}\s?\d{2}\s?\d{2}$/,
  'fr-BF': /^(\+226|0)[67]\d{7}$/,
  'fr-BJ': /^(\+229)\d{8}$/,
  'fr-CD': /^(\+?243|0)?(8|9)\d{8}$/,
  'fr-CM': /^(\+?237)6[0-9]{8}$/,
  'fr-FR': /^(\+?33|0)[67]\d{8}$/,
  'fr-GF': /^(\+?594|0|00594)[67]\d{8}$/,
  'fr-GP': /^(\+?590|0|00590)[67]\d{8}$/,
  'fr-MQ': /^(\+?596|0|00596)[67]\d{8}$/,
  'fr-PF': /^(\+?689)?8[789]\d{6}$/,
  'fr-RE': /^(\+?262|0|00262)[67]\d{8}$/,
  'fr-WF': /^(\+681)?\d{6}$/,
  'he-IL': /^(\+972|0)([23489]|5[012345689]|77)[1-9]\d{6}$/,
  'hu-HU': /^(\+?36|06)(20|30|31|50|70)\d{7}$/,
  'id-ID': /^(\+?62|0)8(1[123456789]|2[1238]|3[1238]|5[12356789]|7[78]|9[56789]|8[123456789])([\s?|\d]{5,11})$/,
  'ir-IR': /^(\+98|0)?9\d{9}$/,
  'it-IT': /^(\+?39)?\s?3\d{2} ?\d{6,7}$/,
  'it-SM': /^((\+378)|(0549)|(\+390549)|(\+3780549))?6\d{5,9}$/,
  'ja-JP': /^(\+81[ \-]?(\(0\))?|0)[6789]0[ \-]?\d{4}[ \-]?\d{4}$/,
  'ka-GE': /^(\+?995)?(79\d{7}|5\d{8})$/,
  'kk-KZ': /^(\+?7|8)?7\d{9}$/,
  'kl-GL': /^(\+?299)?\s?\d{2}\s?\d{2}\s?\d{2}$/,
  'ko-KR': /^((\+?82)[ \-]?)?0?1([0|1|6|7|8|9]{1})[ \-]?\d{3,4}[ \-]?\d{4}$/,
  'ky-KG': /^(\+?7\s?\+?7|0)\s?\d{2}\s?\d{3}\s?\d{4}$/,
  'lt-LT': /^(\+370|8)\d{8}$/,
  'lv-LV': /^(\+?371)2\d{7}$/,
  'mg-MG': /^((\+?261|0)(2|3)\d)?\d{7}$/,
  'mn-MN': /^(\+|00|011)?976(77|81|88|91|94|95|96|99)\d{6}$/,
  'my-MM': /^(\+?959|09|9)(2[5-7]|3[1-2]|4[0-5]|6[6-9]|7[5-9]|9[6-9])[0-9]{7}$/,
  'ms-MY': /^(\+?60|0)1(([0145](-|\s)?\d{7,8})|([236-9](-|\s)?\d{7}))$/,
  'mz-MZ': /^(\+?258)?8[234567]\d{7}$/,
  'nb-NO': /^(\+?47)?[49]\d{7}$/,
  'ne-NP': /^(\+?977)?9[78]\d{8}$/,
  'nl-BE': /^(\+?32|0)4\d{8}$/,
  'nl-NL': /^(((\+|00)?31\(0\))|((\+|00)?31)|0)6{1}\d{8}$/,
  'nl-AW': /^(\+)?297(56|59|64|73|74|99)\d{5}$/,
  'nn-NO': /^(\+?47)?[49]\d{7}$/,
  'pl-PL': /^(\+?48)? ?([5-8]\d|45) ?\d{3} ?\d{2} ?\d{2}$/,
  'pt-BR': /^((\+?55\ ?[1-9]{2}\ ?)|(\+?55\ ?\([1-9]{2}\)\ ?)|(0[1-9]{2}\ ?)|(\([1-9]{2}\)\ ?)|([1-9]{2}\ ?))((\d{4}\-?\d{4})|(9[1-9]{1}\d{3}\-?\d{4}))$/,
  'pt-PT': /^(\+?351)?9[1236]\d{7}$/,
  'pt-AO': /^(\+244)\d{9}$/,
  'ro-MD': /^(\+?373|0)((6(0|1|2|6|7|8|9))|(7(6|7|8|9)))\d{6}$/,
  'ro-RO': /^(\+?40|0)\s?7\d{2}(\/|\s|\.|-)?\d{3}(\s|\.|-)?\d{3}$/,
  'ru-RU': /^(\+?7|8)?9\d{9}$/,
  'si-LK': /^(?:0|94|\+94)?(7(0|1|2|4|5|6|7|8)( |-)?)\d{7}$/,
  'sl-SI': /^(\+386\s?|0)(\d{1}\s?\d{3}\s?\d{2}\s?\d{2}|\d{2}\s?\d{3}\s?\d{3})$/,
  'sk-SK': /^(\+?421)? ?[1-9][0-9]{2} ?[0-9]{3} ?[0-9]{3}$/,
  'so-SO': /^(\+?252|0)((6[0-9])\d{7}|(7[1-9])\d{7})$/,
  'sq-AL': /^(\+355|0)6[789]\d{6}$/,
  'sr-RS': /^(\+3816|06)[- \d]{5,9}$/,
  'sv-SE': /^(\+?46|0)[\s\-]?7[\s\-]?[02369]([\s\-]?\d){7}$/,
  'tg-TJ': /^(\+?992)?[5][5]\d{7}$/,
  'th-TH': /^(\+66|66|0)\d{9}$/,
  'tr-TR': /^(\+?90|0)?5\d{9}$/,
  'tk-TM': /^(\+993|993|8)\d{8}$/,
  'uk-UA': /^(\+?38|8)?0\d{9}$/,
  'uz-UZ': /^(\+?998)?(6[125-79]|7[1-69]|88|9\d)\d{7}$/,
  'vi-VN': /^((\+?84)|0)((3([2-9]))|(5([25689]))|(7([0|6-9]))|(8([1-9]))|(9([0-9])))([0-9]{7})$/,
  'zh-CN': /^((\+|00)86)?(1[3-9]|9[28])\d{9}$/,
  'zh-TW': /^(\+?886\-?|0)?9\d{8}$/,
  'dz-BT': /^(\+?975|0)?(17|16|77|02)\d{6}$/,
  'ar-YE': /^(((\+|00)9677|0?7)[0137]\d{7}|((\+|00)967|0)[1-7]\d{6})$/,
  'ar-EH': /^(\+?212|0)[\s\-]?(5288|5289)[\s\-]?\d{5}$/,
  'fa-AF': /^(\+93|0)?(2{1}[0-8]{1}|[3-5]{1}[0-4]{1})(\d{7})$/
};
/* eslint-enable max-len */

// aliases
phones['en-CA'] = phones['en-US'];
phones['fr-CA'] = phones['en-CA'];
phones['fr-BE'] = phones['nl-BE'];
phones['zh-HK'] = phones['en-HK'];
phones['zh-MO'] = phones['en-MO'];
phones['ga-IE'] = phones['en-IE'];
phones['fr-CH'] = phones['de-CH'];
phones['it-CH'] = phones['fr-CH'];
function isMobilePhone(str, locale, options) {
  (0, _assertString["default"])(str);
  if (options && options.strictMode && !str.startsWith('+')) {
    return false;
  }
  if (Array.isArray(locale)) {
    return locale.some(function (key) {
      // https://github.com/gotwarlost/istanbul/blob/master/ignoring-code-for-coverage.md#ignoring-code-for-coverage-purposes
      // istanbul ignore else
      if (phones.hasOwnProperty(key)) {
        var phone = phones[key];
        if (phone.test(str)) {
          return true;
        }
      }
      return false;
    });
  } else if (locale in phones) {
    return phones[locale].test(str);
    // alias falsey locale as 'any'
  } else if (!locale || locale === 'any') {
    for (var key in phones) {
      // istanbul ignore else
      if (phones.hasOwnProperty(key)) {
        var phone = phones[key];
        if (phone.test(str)) {
          return true;
        }
      }
    }
    return false;
  }
  throw new Error("Invalid locale '".concat(locale, "'"));
}
var locales = exports.locales = Object.keys(phones);

},{"./util/assertString":524}],491:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isMongoId;
var _assertString = _interopRequireDefault(require("./util/assertString"));
var _isHexadecimal = _interopRequireDefault(require("./isHexadecimal"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
function isMongoId(str) {
  (0, _assertString["default"])(str);
  return (0, _isHexadecimal["default"])(str) && str.length === 24;
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./isHexadecimal":459,"./util/assertString":524}],492:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isMultibyte;
var _assertString = _interopRequireDefault(require("./util/assertString"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
/* eslint-disable no-control-regex */
var multibyte = /[^\x00-\x7F]/;
/* eslint-enable no-control-regex */

function isMultibyte(str) {
  (0, _assertString["default"])(str);
  return multibyte.test(str);
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./util/assertString":524}],493:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isNumeric;
var _assertString = _interopRequireDefault(require("./util/assertString"));
var _alpha = require("./alpha");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
var numericNoSymbols = /^[0-9]+$/;
function isNumeric(str, options) {
  (0, _assertString["default"])(str);
  if (options && options.no_symbols) {
    return numericNoSymbols.test(str);
  }
  return new RegExp("^[+-]?([0-9]*[".concat((options || {}).locale ? _alpha.decimal[options.locale] : '.', "])?[0-9]+$")).test(str);
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./alpha":424,"./util/assertString":524}],494:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isOctal;
var _assertString = _interopRequireDefault(require("./util/assertString"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
var octal = /^(0o)?[0-7]+$/i;
function isOctal(str) {
  (0, _assertString["default"])(str);
  return octal.test(str);
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./util/assertString":524}],495:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isPassportNumber;
var _assertString = _interopRequireDefault(require("./util/assertString"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
/**
 * Reference:
 * https://en.wikipedia.org/ -- Wikipedia
 * https://docs.microsoft.com/en-us/microsoft-365/compliance/eu-passport-number -- EU Passport Number
 * https://countrycode.org/ -- Country Codes
 */
var passportRegexByCountryCode = {
  AM: /^[A-Z]{2}\d{7}$/,
  // ARMENIA
  AR: /^[A-Z]{3}\d{6}$/,
  // ARGENTINA
  AT: /^[A-Z]\d{7}$/,
  // AUSTRIA
  AU: /^[A-Z]\d{7}$/,
  // AUSTRALIA
  AZ: /^[A-Z]{1}\d{8}$/,
  // AZERBAIJAN
  BE: /^[A-Z]{2}\d{6}$/,
  // BELGIUM
  BG: /^\d{9}$/,
  // BULGARIA
  BR: /^[A-Z]{2}\d{6}$/,
  // BRAZIL
  BY: /^[A-Z]{2}\d{7}$/,
  // BELARUS
  CA: /^[A-Z]{2}\d{6}$/,
  // CANADA
  CH: /^[A-Z]\d{7}$/,
  // SWITZERLAND
  CN: /^G\d{8}$|^E(?![IO])[A-Z0-9]\d{7}$/,
  // CHINA [G=Ordinary, E=Electronic] followed by 8-digits, or E followed by any UPPERCASE letter (except I and O) followed by 7 digits
  CY: /^[A-Z](\d{6}|\d{8})$/,
  // CYPRUS
  CZ: /^\d{8}$/,
  // CZECH REPUBLIC
  DE: /^[CFGHJKLMNPRTVWXYZ0-9]{9}$/,
  // GERMANY
  DK: /^\d{9}$/,
  // DENMARK
  DZ: /^\d{9}$/,
  // ALGERIA
  EE: /^([A-Z]\d{7}|[A-Z]{2}\d{7})$/,
  // ESTONIA (K followed by 7-digits), e-passports have 2 UPPERCASE followed by 7 digits
  ES: /^[A-Z0-9]{2}([A-Z0-9]?)\d{6}$/,
  // SPAIN
  FI: /^[A-Z]{2}\d{7}$/,
  // FINLAND
  FR: /^\d{2}[A-Z]{2}\d{5}$/,
  // FRANCE
  GB: /^\d{9}$/,
  // UNITED KINGDOM
  GR: /^[A-Z]{2}\d{7}$/,
  // GREECE
  HR: /^\d{9}$/,
  // CROATIA
  HU: /^[A-Z]{2}(\d{6}|\d{7})$/,
  // HUNGARY
  IE: /^[A-Z0-9]{2}\d{7}$/,
  // IRELAND
  IN: /^[A-Z]{1}-?\d{7}$/,
  // INDIA
  ID: /^[A-C]\d{7}$/,
  // INDONESIA
  IR: /^[A-Z]\d{8}$/,
  // IRAN
  IS: /^(A)\d{7}$/,
  // ICELAND
  IT: /^[A-Z0-9]{2}\d{7}$/,
  // ITALY
  JM: /^[Aa]\d{7}$/,
  // JAMAICA
  JP: /^[A-Z]{2}\d{7}$/,
  // JAPAN
  KR: /^[MS]\d{8}$/,
  // SOUTH KOREA, REPUBLIC OF KOREA, [S=PS Passports, M=PM Passports]
  KZ: /^[a-zA-Z]\d{7}$/,
  // KAZAKHSTAN
  LI: /^[a-zA-Z]\d{5}$/,
  // LIECHTENSTEIN
  LT: /^[A-Z0-9]{8}$/,
  // LITHUANIA
  LU: /^[A-Z0-9]{8}$/,
  // LUXEMBURG
  LV: /^[A-Z0-9]{2}\d{7}$/,
  // LATVIA
  LY: /^[A-Z0-9]{8}$/,
  // LIBYA
  MT: /^\d{7}$/,
  // MALTA
  MZ: /^([A-Z]{2}\d{7})|(\d{2}[A-Z]{2}\d{5})$/,
  // MOZAMBIQUE
  MY: /^[AHK]\d{8}$/,
  // MALAYSIA
  MX: /^\d{10,11}$/,
  // MEXICO
  NL: /^[A-Z]{2}[A-Z0-9]{6}\d$/,
  // NETHERLANDS
  NZ: /^([Ll]([Aa]|[Dd]|[Ff]|[Hh])|[Ee]([Aa]|[Pp])|[Nn])\d{6}$/,
  // NEW ZEALAND
  PH: /^([A-Z](\d{6}|\d{7}[A-Z]))|([A-Z]{2}(\d{6}|\d{7}))$/,
  // PHILIPPINES
  PK: /^[A-Z]{2}\d{7}$/,
  // PAKISTAN
  PL: /^[A-Z]{2}\d{7}$/,
  // POLAND
  PT: /^[A-Z]\d{6}$/,
  // PORTUGAL
  RO: /^\d{8,9}$/,
  // ROMANIA
  RU: /^\d{9}$/,
  // RUSSIAN FEDERATION
  SE: /^\d{8}$/,
  // SWEDEN
  SL: /^(P)[A-Z]\d{7}$/,
  // SLOVENIA
  SK: /^[0-9A-Z]\d{7}$/,
  // SLOVAKIA
  TH: /^[A-Z]{1,2}\d{6,7}$/,
  // THAILAND
  TR: /^[A-Z]\d{8}$/,
  // TURKEY
  UA: /^[A-Z]{2}\d{6}$/,
  // UKRAINE
  US: /^\d{9}$/,
  // UNITED STATES
  ZA: /^[TAMD]\d{8}$/ // SOUTH AFRICA
};

/**
 * Check if str is a valid passport number
 * relative to provided ISO Country Code.
 *
 * @param {string} str
 * @param {string} countryCode
 * @return {boolean}
 */
function isPassportNumber(str, countryCode) {
  (0, _assertString["default"])(str);
  /** Remove All Whitespaces, Convert to UPPERCASE */
  var normalizedStr = str.replace(/\s/g, '').toUpperCase();
  return countryCode.toUpperCase() in passportRegexByCountryCode && passportRegexByCountryCode[countryCode].test(normalizedStr);
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./util/assertString":524}],496:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isPort;
var _isInt = _interopRequireDefault(require("./isInt"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
function isPort(str) {
  return (0, _isInt["default"])(str, {
    allow_leading_zeroes: false,
    min: 0,
    max: 65535
  });
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./isInt":476}],497:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isPostalCode;
exports.locales = void 0;
var _assertString = _interopRequireDefault(require("./util/assertString"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
// common patterns
var threeDigit = /^\d{3}$/;
var fourDigit = /^\d{4}$/;
var fiveDigit = /^\d{5}$/;
var sixDigit = /^\d{6}$/;
var patterns = {
  AD: /^AD\d{3}$/,
  AT: fourDigit,
  AU: fourDigit,
  AZ: /^AZ\d{4}$/,
  BA: /^([7-8]\d{4}$)/,
  BE: fourDigit,
  BG: fourDigit,
  BR: /^\d{5}-\d{3}$/,
  BY: /^2[1-4]\d{4}$/,
  CA: /^[ABCEGHJKLMNPRSTVXY]\d[ABCEGHJ-NPRSTV-Z][\s\-]?\d[ABCEGHJ-NPRSTV-Z]\d$/i,
  CH: fourDigit,
  CN: /^(0[1-7]|1[012356]|2[0-7]|3[0-6]|4[0-7]|5[1-7]|6[1-7]|7[1-5]|8[1345]|9[09])\d{4}$/,
  CZ: /^\d{3}\s?\d{2}$/,
  DE: fiveDigit,
  DK: fourDigit,
  DO: fiveDigit,
  DZ: fiveDigit,
  EE: fiveDigit,
  ES: /^(5[0-2]{1}|[0-4]{1}\d{1})\d{3}$/,
  FI: fiveDigit,
  FR: /^\d{2}\s?\d{3}$/,
  GB: /^(gir\s?0aa|[a-z]{1,2}\d[\da-z]?\s?(\d[a-z]{2})?)$/i,
  GR: /^\d{3}\s?\d{2}$/,
  HR: /^([1-5]\d{4}$)/,
  HT: /^HT\d{4}$/,
  HU: fourDigit,
  ID: fiveDigit,
  IE: /^(?!.*(?:o))[A-Za-z]\d[\dw]\s\w{4}$/i,
  IL: /^(\d{5}|\d{7})$/,
  IN: /^((?!10|29|35|54|55|65|66|86|87|88|89)[1-9][0-9]{5})$/,
  IR: /^(?!(\d)\1{3})[13-9]{4}[1346-9][013-9]{5}$/,
  IS: threeDigit,
  IT: fiveDigit,
  JP: /^\d{3}\-\d{4}$/,
  KE: fiveDigit,
  KR: /^(\d{5}|\d{6})$/,
  LI: /^(948[5-9]|949[0-7])$/,
  LT: /^LT\-\d{5}$/,
  LU: fourDigit,
  LV: /^LV\-\d{4}$/,
  LK: fiveDigit,
  MG: threeDigit,
  MX: fiveDigit,
  MT: /^[A-Za-z]{3}\s{0,1}\d{4}$/,
  MY: fiveDigit,
  NL: /^[1-9]\d{3}\s?(?!sa|sd|ss)[a-z]{2}$/i,
  NO: fourDigit,
  NP: /^(10|21|22|32|33|34|44|45|56|57)\d{3}$|^(977)$/i,
  NZ: fourDigit,
  PL: /^\d{2}\-\d{3}$/,
  PR: /^00[679]\d{2}([ -]\d{4})?$/,
  PT: /^\d{4}\-\d{3}?$/,
  RO: sixDigit,
  RU: sixDigit,
  SA: fiveDigit,
  SE: /^[1-9]\d{2}\s?\d{2}$/,
  SG: sixDigit,
  SI: fourDigit,
  SK: /^\d{3}\s?\d{2}$/,
  TH: fiveDigit,
  TN: fourDigit,
  TW: /^\d{3}(\d{2})?$/,
  UA: fiveDigit,
  US: /^\d{5}(-\d{4})?$/,
  ZA: fourDigit,
  ZM: fiveDigit
};
var locales = exports.locales = Object.keys(patterns);
function isPostalCode(str, locale) {
  (0, _assertString["default"])(str);
  if (locale in patterns) {
    return patterns[locale].test(str);
  } else if (locale === 'any') {
    for (var key in patterns) {
      // https://github.com/gotwarlost/istanbul/blob/master/ignoring-code-for-coverage.md#ignoring-code-for-coverage-purposes
      // istanbul ignore else
      if (patterns.hasOwnProperty(key)) {
        var pattern = patterns[key];
        if (pattern.test(str)) {
          return true;
        }
      }
    }
    return false;
  }
  throw new Error("Invalid locale '".concat(locale, "'"));
}

},{"./util/assertString":524}],498:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isRFC3339;
var _assertString = _interopRequireDefault(require("./util/assertString"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
/* Based on https://tools.ietf.org/html/rfc3339#section-5.6 */

var dateFullYear = /[0-9]{4}/;
var dateMonth = /(0[1-9]|1[0-2])/;
var dateMDay = /([12]\d|0[1-9]|3[01])/;
var timeHour = /([01][0-9]|2[0-3])/;
var timeMinute = /[0-5][0-9]/;
var timeSecond = /([0-5][0-9]|60)/;
var timeSecFrac = /(\.[0-9]+)?/;
var timeNumOffset = new RegExp("[-+]".concat(timeHour.source, ":").concat(timeMinute.source));
var timeOffset = new RegExp("([zZ]|".concat(timeNumOffset.source, ")"));
var partialTime = new RegExp("".concat(timeHour.source, ":").concat(timeMinute.source, ":").concat(timeSecond.source).concat(timeSecFrac.source));
var fullDate = new RegExp("".concat(dateFullYear.source, "-").concat(dateMonth.source, "-").concat(dateMDay.source));
var fullTime = new RegExp("".concat(partialTime.source).concat(timeOffset.source));
var rfc3339 = new RegExp("^".concat(fullDate.source, "[ tT]").concat(fullTime.source, "$"));
function isRFC3339(str) {
  (0, _assertString["default"])(str);
  return rfc3339.test(str);
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./util/assertString":524}],499:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isRgbColor;
var _assertString = _interopRequireDefault(require("./util/assertString"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
var rgbColor = /^rgb\((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]),){2}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\)$/;
var rgbaColor = /^rgba\((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]),){3}(0?\.\d|1(\.0)?|0(\.0)?)\)$/;
var rgbColorPercent = /^rgb\((([0-9]%|[1-9][0-9]%|100%),){2}([0-9]%|[1-9][0-9]%|100%)\)$/;
var rgbaColorPercent = /^rgba\((([0-9]%|[1-9][0-9]%|100%),){3}(0?\.\d|1(\.0)?|0(\.0)?)\)$/;
function isRgbColor(str) {
  var includePercentValues = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  (0, _assertString["default"])(str);
  if (!includePercentValues) {
    return rgbColor.test(str) || rgbaColor.test(str);
  }
  return rgbColor.test(str) || rgbaColor.test(str) || rgbColorPercent.test(str) || rgbaColorPercent.test(str);
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./util/assertString":524}],500:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isSemVer;
var _assertString = _interopRequireDefault(require("./util/assertString"));
var _multilineRegex = _interopRequireDefault(require("./util/multilineRegex"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
/**
 * Regular Expression to match
 * semantic versioning (SemVer)
 * built from multi-line, multi-parts regexp
 * Reference: https://semver.org/
 */
var semanticVersioningRegex = (0, _multilineRegex["default"])(['^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)', '(?:-((?:0|[1-9]\\d*|\\d*[a-z-][0-9a-z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-z-][0-9a-z-]*))*))', '?(?:\\+([0-9a-z-]+(?:\\.[0-9a-z-]+)*))?$'], 'i');
function isSemVer(str) {
  (0, _assertString["default"])(str);
  return semanticVersioningRegex.test(str);
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./util/assertString":524,"./util/multilineRegex":527}],501:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isSlug;
var _assertString = _interopRequireDefault(require("./util/assertString"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
var charsetRegex = /^[^\s-_](?!.*?[-_]{2,})[a-z0-9-\\][^\s]*[^-_\s]$/;
function isSlug(str) {
  (0, _assertString["default"])(str);
  return charsetRegex.test(str);
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./util/assertString":524}],502:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isStrongPassword;
var _merge = _interopRequireDefault(require("./util/merge"));
var _assertString = _interopRequireDefault(require("./util/assertString"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
var upperCaseRegex = /^[A-Z]$/;
var lowerCaseRegex = /^[a-z]$/;
var numberRegex = /^[0-9]$/;
var symbolRegex = /^[-#!$@%^&*()_+|~=`{}\[\]:";'<>?,.\/\\ ]$/;
var defaultOptions = {
  minLength: 8,
  minLowercase: 1,
  minUppercase: 1,
  minNumbers: 1,
  minSymbols: 1,
  returnScore: false,
  pointsPerUnique: 1,
  pointsPerRepeat: 0.5,
  pointsForContainingLower: 10,
  pointsForContainingUpper: 10,
  pointsForContainingNumber: 10,
  pointsForContainingSymbol: 10
};

/* Counts number of occurrences of each char in a string
 * could be moved to util/ ?
*/
function countChars(str) {
  var result = {};
  Array.from(str).forEach(function (_char) {
    var curVal = result[_char];
    if (curVal) {
      result[_char] += 1;
    } else {
      result[_char] = 1;
    }
  });
  return result;
}

/* Return information about a password */
function analyzePassword(password) {
  var charMap = countChars(password);
  var analysis = {
    length: password.length,
    uniqueChars: Object.keys(charMap).length,
    uppercaseCount: 0,
    lowercaseCount: 0,
    numberCount: 0,
    symbolCount: 0
  };
  Object.keys(charMap).forEach(function (_char2) {
    /* istanbul ignore else */
    if (upperCaseRegex.test(_char2)) {
      analysis.uppercaseCount += charMap[_char2];
    } else if (lowerCaseRegex.test(_char2)) {
      analysis.lowercaseCount += charMap[_char2];
    } else if (numberRegex.test(_char2)) {
      analysis.numberCount += charMap[_char2];
    } else if (symbolRegex.test(_char2)) {
      analysis.symbolCount += charMap[_char2];
    }
  });
  return analysis;
}
function scorePassword(analysis, scoringOptions) {
  var points = 0;
  points += analysis.uniqueChars * scoringOptions.pointsPerUnique;
  points += (analysis.length - analysis.uniqueChars) * scoringOptions.pointsPerRepeat;
  if (analysis.lowercaseCount > 0) {
    points += scoringOptions.pointsForContainingLower;
  }
  if (analysis.uppercaseCount > 0) {
    points += scoringOptions.pointsForContainingUpper;
  }
  if (analysis.numberCount > 0) {
    points += scoringOptions.pointsForContainingNumber;
  }
  if (analysis.symbolCount > 0) {
    points += scoringOptions.pointsForContainingSymbol;
  }
  return points;
}
function isStrongPassword(str) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  (0, _assertString["default"])(str);
  var analysis = analyzePassword(str);
  options = (0, _merge["default"])(options || {}, defaultOptions);
  if (options.returnScore) {
    return scorePassword(analysis, options);
  }
  return analysis.length >= options.minLength && analysis.lowercaseCount >= options.minLowercase && analysis.uppercaseCount >= options.minUppercase && analysis.numberCount >= options.minNumbers && analysis.symbolCount >= options.minSymbols;
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./util/assertString":524,"./util/merge":526}],503:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isSurrogatePair;
var _assertString = _interopRequireDefault(require("./util/assertString"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
var surrogatePair = /[\uD800-\uDBFF][\uDC00-\uDFFF]/;
function isSurrogatePair(str) {
  (0, _assertString["default"])(str);
  return surrogatePair.test(str);
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./util/assertString":524}],504:[function(require,module,exports){
"use strict";

function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isTaxID;
var _assertString = _interopRequireDefault(require("./util/assertString"));
var algorithms = _interopRequireWildcard(require("./util/algorithms"));
var _isDate = _interopRequireDefault(require("./isDate"));
function _getRequireWildcardCache(e) {
  if ("function" != typeof WeakMap) return null;
  var r = new WeakMap(),
    t = new WeakMap();
  return (_getRequireWildcardCache = function _getRequireWildcardCache(e) {
    return e ? t : r;
  })(e);
}
function _interopRequireWildcard(e, r) {
  if (!r && e && e.__esModule) return e;
  if (null === e || "object" != _typeof(e) && "function" != typeof e) return {
    "default": e
  };
  var t = _getRequireWildcardCache(r);
  if (t && t.has(e)) return t.get(e);
  var n = {
      __proto__: null
    },
    a = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) {
    var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
    i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
  }
  return n["default"] = e, t && t.set(e, n), n;
}
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
/**
 * TIN Validation
 * Validates Tax Identification Numbers (TINs) from the US, EU member states and the United Kingdom.
 *
 * EU-UK:
 * National TIN validity is calculated using public algorithms as made available by DG TAXUD.
 *
 * See `https://ec.europa.eu/taxation_customs/tin/specs/FS-TIN%20Algorithms-Public.docx` for more information.
 *
 * US:
 * An Employer Identification Number (EIN), also known as a Federal Tax Identification Number,
 *  is used to identify a business entity.
 *
 * NOTES:
 *  - Prefix 47 is being reserved for future use
 *  - Prefixes 26, 27, 45, 46 and 47 were previously assigned by the Philadelphia campus.
 *
 * See `http://www.irs.gov/Businesses/Small-Businesses-&-Self-Employed/How-EINs-are-Assigned-and-Valid-EIN-Prefixes`
 * for more information.
 */

// Locale functions

/*
 * bg-BG validation function
 * (Edinen gradanski nomer (EGN/), persons only)
 * Checks if birth date (first six digits) is valid and calculates check (last) digit
 */
function bgBgCheck(tin) {
  // Extract full year, normalize month and check birth date validity
  var century_year = tin.slice(0, 2);
  var month = parseInt(tin.slice(2, 4), 10);
  if (month > 40) {
    month -= 40;
    century_year = "20".concat(century_year);
  } else if (month > 20) {
    month -= 20;
    century_year = "18".concat(century_year);
  } else {
    century_year = "19".concat(century_year);
  }
  if (month < 10) {
    month = "0".concat(month);
  }
  var date = "".concat(century_year, "/").concat(month, "/").concat(tin.slice(4, 6));
  if (!(0, _isDate["default"])(date, 'YYYY/MM/DD')) {
    return false;
  }

  // split digits into an array for further processing
  var digits = tin.split('').map(function (a) {
    return parseInt(a, 10);
  });

  // Calculate checksum by multiplying digits with fixed values
  var multip_lookup = [2, 4, 8, 5, 10, 9, 7, 3, 6];
  var checksum = 0;
  for (var i = 0; i < multip_lookup.length; i++) {
    checksum += digits[i] * multip_lookup[i];
  }
  checksum = checksum % 11 === 10 ? 0 : checksum % 11;
  return checksum === digits[9];
}

/**
 * Check if an input is a valid Canadian SIN (Social Insurance Number)
 *
 * The Social Insurance Number (SIN) is a 9 digit number that
 * you need to work in Canada or to have access to government programs and benefits.
 *
 * https://en.wikipedia.org/wiki/Social_Insurance_Number
 * https://www.canada.ca/en/employment-social-development/services/sin.html
 * https://www.codercrunch.com/challenge/819302488/sin-validator
 *
 * @param {string} input
 * @return {boolean}
 */
function isCanadianSIN(input) {
  var digitsArray = input.split('');
  var even = digitsArray.filter(function (_, idx) {
    return idx % 2;
  }).map(function (i) {
    return Number(i) * 2;
  }).join('').split('');
  var total = digitsArray.filter(function (_, idx) {
    return !(idx % 2);
  }).concat(even).map(function (i) {
    return Number(i);
  }).reduce(function (acc, cur) {
    return acc + cur;
  });
  return total % 10 === 0;
}

/*
 * cs-CZ validation function
 * (Rodn slo (R), persons only)
 * Checks if birth date (first six digits) is valid and divisibility by 11
 * Material not in DG TAXUD document sourced from:
 * -`https://lorenc.info/3MA381/overeni-spravnosti-rodneho-cisla.htm`
 * -`https://www.mvcr.cz/clanek/rady-a-sluzby-dokumenty-rodne-cislo.aspx`
 */
function csCzCheck(tin) {
  tin = tin.replace(/\W/, '');

  // Extract full year from TIN length
  var full_year = parseInt(tin.slice(0, 2), 10);
  if (tin.length === 10) {
    if (full_year < 54) {
      full_year = "20".concat(full_year);
    } else {
      full_year = "19".concat(full_year);
    }
  } else {
    if (tin.slice(6) === '000') {
      return false;
    } // Three-zero serial not assigned before 1954
    if (full_year < 54) {
      full_year = "19".concat(full_year);
    } else {
      return false; // No 18XX years seen in any of the resources
    }
  }
  // Add missing zero if needed
  if (full_year.length === 3) {
    full_year = [full_year.slice(0, 2), '0', full_year.slice(2)].join('');
  }

  // Extract month from TIN and normalize
  var month = parseInt(tin.slice(2, 4), 10);
  if (month > 50) {
    month -= 50;
  }
  if (month > 20) {
    // Month-plus-twenty was only introduced in 2004
    if (parseInt(full_year, 10) < 2004) {
      return false;
    }
    month -= 20;
  }
  if (month < 10) {
    month = "0".concat(month);
  }

  // Check date validity
  var date = "".concat(full_year, "/").concat(month, "/").concat(tin.slice(4, 6));
  if (!(0, _isDate["default"])(date, 'YYYY/MM/DD')) {
    return false;
  }

  // Verify divisibility by 11
  if (tin.length === 10) {
    if (parseInt(tin, 10) % 11 !== 0) {
      // Some numbers up to and including 1985 are still valid if
      // check (last) digit equals 0 and modulo of first 9 digits equals 10
      var checkdigit = parseInt(tin.slice(0, 9), 10) % 11;
      if (parseInt(full_year, 10) < 1986 && checkdigit === 10) {
        if (parseInt(tin.slice(9), 10) !== 0) {
          return false;
        }
      } else {
        return false;
      }
    }
  }
  return true;
}

/*
 * de-AT validation function
 * (Abgabenkontonummer, persons/entities)
 * Verify TIN validity by calling luhnCheck()
 */
function deAtCheck(tin) {
  return algorithms.luhnCheck(tin);
}

/*
 * de-DE validation function
 * (Steueridentifikationsnummer (Steuer-IdNr.), persons only)
 * Tests for single duplicate/triplicate value, then calculates ISO 7064 check (last) digit
 * Partial implementation of spec (same result with both algorithms always)
 */
function deDeCheck(tin) {
  // Split digits into an array for further processing
  var digits = tin.split('').map(function (a) {
    return parseInt(a, 10);
  });

  // Fill array with strings of number positions
  var occurences = [];
  for (var i = 0; i < digits.length - 1; i++) {
    occurences.push('');
    for (var j = 0; j < digits.length - 1; j++) {
      if (digits[i] === digits[j]) {
        occurences[i] += j;
      }
    }
  }

  // Remove digits with one occurence and test for only one duplicate/triplicate
  occurences = occurences.filter(function (a) {
    return a.length > 1;
  });
  if (occurences.length !== 2 && occurences.length !== 3) {
    return false;
  }

  // In case of triplicate value only two digits are allowed next to each other
  if (occurences[0].length === 3) {
    var trip_locations = occurences[0].split('').map(function (a) {
      return parseInt(a, 10);
    });
    var recurrent = 0; // Amount of neighbour occurences
    for (var _i = 0; _i < trip_locations.length - 1; _i++) {
      if (trip_locations[_i] + 1 === trip_locations[_i + 1]) {
        recurrent += 1;
      }
    }
    if (recurrent === 2) {
      return false;
    }
  }
  return algorithms.iso7064Check(tin);
}

/*
 * dk-DK validation function
 * (CPR-nummer (personnummer), persons only)
 * Checks if birth date (first six digits) is valid and assigned to century (seventh) digit,
 * and calculates check (last) digit
 */
function dkDkCheck(tin) {
  tin = tin.replace(/\W/, '');

  // Extract year, check if valid for given century digit and add century
  var year = parseInt(tin.slice(4, 6), 10);
  var century_digit = tin.slice(6, 7);
  switch (century_digit) {
    case '0':
    case '1':
    case '2':
    case '3':
      year = "19".concat(year);
      break;
    case '4':
    case '9':
      if (year < 37) {
        year = "20".concat(year);
      } else {
        year = "19".concat(year);
      }
      break;
    default:
      if (year < 37) {
        year = "20".concat(year);
      } else if (year > 58) {
        year = "18".concat(year);
      } else {
        return false;
      }
      break;
  }
  // Add missing zero if needed
  if (year.length === 3) {
    year = [year.slice(0, 2), '0', year.slice(2)].join('');
  }
  // Check date validity
  var date = "".concat(year, "/").concat(tin.slice(2, 4), "/").concat(tin.slice(0, 2));
  if (!(0, _isDate["default"])(date, 'YYYY/MM/DD')) {
    return false;
  }

  // Split digits into an array for further processing
  var digits = tin.split('').map(function (a) {
    return parseInt(a, 10);
  });
  var checksum = 0;
  var weight = 4;
  // Multiply by weight and add to checksum
  for (var i = 0; i < 9; i++) {
    checksum += digits[i] * weight;
    weight -= 1;
    if (weight === 1) {
      weight = 7;
    }
  }
  checksum %= 11;
  if (checksum === 1) {
    return false;
  }
  return checksum === 0 ? digits[9] === 0 : digits[9] === 11 - checksum;
}

/*
 * el-CY validation function
 * (Arithmos Forologikou Mitroou (AFM/), persons only)
 * Verify TIN validity by calculating ASCII value of check (last) character
 */
function elCyCheck(tin) {
  // split digits into an array for further processing
  var digits = tin.slice(0, 8).split('').map(function (a) {
    return parseInt(a, 10);
  });
  var checksum = 0;
  // add digits in even places
  for (var i = 1; i < digits.length; i += 2) {
    checksum += digits[i];
  }

  // add digits in odd places
  for (var _i2 = 0; _i2 < digits.length; _i2 += 2) {
    if (digits[_i2] < 2) {
      checksum += 1 - digits[_i2];
    } else {
      checksum += 2 * (digits[_i2] - 2) + 5;
      if (digits[_i2] > 4) {
        checksum += 2;
      }
    }
  }
  return String.fromCharCode(checksum % 26 + 65) === tin.charAt(8);
}

/*
 * el-GR validation function
 * (Arithmos Forologikou Mitroou (AFM/), persons/entities)
 * Verify TIN validity by calculating check (last) digit
 * Algorithm not in DG TAXUD document- sourced from:
 * - `http://epixeirisi.gr/%CE%9A%CE%A1%CE%99%CE%A3%CE%99%CE%9C%CE%91-%CE%98%CE%95%CE%9C%CE%91%CE%A4%CE%91-%CE%A6%CE%9F%CE%A1%CE%9F%CE%9B%CE%9F%CE%93%CE%99%CE%91%CE%A3-%CE%9A%CE%91%CE%99-%CE%9B%CE%9F%CE%93%CE%99%CE%A3%CE%A4%CE%99%CE%9A%CE%97%CE%A3/23791/%CE%91%CF%81%CE%B9%CE%B8%CE%BC%CF%8C%CF%82-%CE%A6%CE%BF%CF%81%CE%BF%CE%BB%CE%BF%CE%B3%CE%B9%CE%BA%CE%BF%CF%8D-%CE%9C%CE%B7%CF%84%CF%81%CF%8E%CE%BF%CF%85`
 */
function elGrCheck(tin) {
  // split digits into an array for further processing
  var digits = tin.split('').map(function (a) {
    return parseInt(a, 10);
  });
  var checksum = 0;
  for (var i = 0; i < 8; i++) {
    checksum += digits[i] * Math.pow(2, 8 - i);
  }
  return checksum % 11 % 10 === digits[8];
}

/*
 * en-GB validation function (should go here if needed)
 * (National Insurance Number (NINO) or Unique Taxpayer Reference (UTR),
 * persons/entities respectively)
 */

/*
 * en-IE validation function
 * (Personal Public Service Number (PPS No), persons only)
 * Verify TIN validity by calculating check (second to last) character
 */
function enIeCheck(tin) {
  var checksum = algorithms.reverseMultiplyAndSum(tin.split('').slice(0, 7).map(function (a) {
    return parseInt(a, 10);
  }), 8);
  if (tin.length === 9 && tin[8] !== 'W') {
    checksum += (tin[8].charCodeAt(0) - 64) * 9;
  }
  checksum %= 23;
  if (checksum === 0) {
    return tin[7].toUpperCase() === 'W';
  }
  return tin[7].toUpperCase() === String.fromCharCode(64 + checksum);
}

// Valid US IRS campus prefixes
var enUsCampusPrefix = {
  andover: ['10', '12'],
  atlanta: ['60', '67'],
  austin: ['50', '53'],
  brookhaven: ['01', '02', '03', '04', '05', '06', '11', '13', '14', '16', '21', '22', '23', '25', '34', '51', '52', '54', '55', '56', '57', '58', '59', '65'],
  cincinnati: ['30', '32', '35', '36', '37', '38', '61'],
  fresno: ['15', '24'],
  internet: ['20', '26', '27', '45', '46', '47'],
  kansas: ['40', '44'],
  memphis: ['94', '95'],
  ogden: ['80', '90'],
  philadelphia: ['33', '39', '41', '42', '43', '46', '48', '62', '63', '64', '66', '68', '71', '72', '73', '74', '75', '76', '77', '81', '82', '83', '84', '85', '86', '87', '88', '91', '92', '93', '98', '99'],
  sba: ['31']
};

// Return an array of all US IRS campus prefixes
function enUsGetPrefixes() {
  var prefixes = [];
  for (var location in enUsCampusPrefix) {
    // https://github.com/gotwarlost/istanbul/blob/master/ignoring-code-for-coverage.md#ignoring-code-for-coverage-purposes
    // istanbul ignore else
    if (enUsCampusPrefix.hasOwnProperty(location)) {
      prefixes.push.apply(prefixes, _toConsumableArray(enUsCampusPrefix[location]));
    }
  }
  return prefixes;
}

/*
 * en-US validation function
 * Verify that the TIN starts with a valid IRS campus prefix
 */
function enUsCheck(tin) {
  return enUsGetPrefixes().indexOf(tin.slice(0, 2)) !== -1;
}

/*
 * es-AR validation function
 * Clave nica de Identificacin Tributaria (CUIT/CUIL)
 * Sourced from:
 * - https://servicioscf.afip.gob.ar/publico/abc/ABCpaso2.aspx?id_nivel1=3036&id_nivel2=3040&p=Conceptos%20b%C3%A1sicos
 * - https://es.wikipedia.org/wiki/Clave_%C3%9Anica_de_Identificaci%C3%B3n_Tributaria
 */

function esArCheck(tin) {
  var accum = 0;
  var digits = tin.split('');
  var digit = parseInt(digits.pop(), 10);
  for (var i = 0; i < digits.length; i++) {
    accum += digits[9 - i] * (2 + i % 6);
  }
  var verif = 11 - accum % 11;
  if (verif === 11) {
    verif = 0;
  } else if (verif === 10) {
    verif = 9;
  }
  return digit === verif;
}

/*
 * es-ES validation function
 * (Documento Nacional de Identidad (DNI)
 * or Nmero de Identificacin de Extranjero (NIE), persons only)
 * Verify TIN validity by calculating check (last) character
 */
function esEsCheck(tin) {
  // Split characters into an array for further processing
  var chars = tin.toUpperCase().split('');

  // Replace initial letter if needed
  if (isNaN(parseInt(chars[0], 10)) && chars.length > 1) {
    var lead_replace = 0;
    switch (chars[0]) {
      case 'Y':
        lead_replace = 1;
        break;
      case 'Z':
        lead_replace = 2;
        break;
      default:
    }
    chars.splice(0, 1, lead_replace);
    // Fill with zeros if smaller than proper
  } else {
    while (chars.length < 9) {
      chars.unshift(0);
    }
  }

  // Calculate checksum and check according to lookup
  var lookup = ['T', 'R', 'W', 'A', 'G', 'M', 'Y', 'F', 'P', 'D', 'X', 'B', 'N', 'J', 'Z', 'S', 'Q', 'V', 'H', 'L', 'C', 'K', 'E'];
  chars = chars.join('');
  var checksum = parseInt(chars.slice(0, 8), 10) % 23;
  return chars[8] === lookup[checksum];
}

/*
 * et-EE validation function
 * (Isikukood (IK), persons only)
 * Checks if birth date (century digit and six following) is valid and calculates check (last) digit
 * Material not in DG TAXUD document sourced from:
 * - `https://www.oecd.org/tax/automatic-exchange/crs-implementation-and-assistance/tax-identification-numbers/Estonia-TIN.pdf`
 */
function etEeCheck(tin) {
  // Extract year and add century
  var full_year = tin.slice(1, 3);
  var century_digit = tin.slice(0, 1);
  switch (century_digit) {
    case '1':
    case '2':
      full_year = "18".concat(full_year);
      break;
    case '3':
    case '4':
      full_year = "19".concat(full_year);
      break;
    default:
      full_year = "20".concat(full_year);
      break;
  }
  // Check date validity
  var date = "".concat(full_year, "/").concat(tin.slice(3, 5), "/").concat(tin.slice(5, 7));
  if (!(0, _isDate["default"])(date, 'YYYY/MM/DD')) {
    return false;
  }

  // Split digits into an array for further processing
  var digits = tin.split('').map(function (a) {
    return parseInt(a, 10);
  });
  var checksum = 0;
  var weight = 1;
  // Multiply by weight and add to checksum
  for (var i = 0; i < 10; i++) {
    checksum += digits[i] * weight;
    weight += 1;
    if (weight === 10) {
      weight = 1;
    }
  }
  // Do again if modulo 11 of checksum is 10
  if (checksum % 11 === 10) {
    checksum = 0;
    weight = 3;
    for (var _i3 = 0; _i3 < 10; _i3++) {
      checksum += digits[_i3] * weight;
      weight += 1;
      if (weight === 10) {
        weight = 1;
      }
    }
    if (checksum % 11 === 10) {
      return digits[10] === 0;
    }
  }
  return checksum % 11 === digits[10];
}

/*
 * fi-FI validation function
 * (Henkiltunnus (HETU), persons only)
 * Checks if birth date (first six digits plus century symbol) is valid
 * and calculates check (last) digit
 */
function fiFiCheck(tin) {
  // Extract year and add century
  var full_year = tin.slice(4, 6);
  var century_symbol = tin.slice(6, 7);
  switch (century_symbol) {
    case '+':
      full_year = "18".concat(full_year);
      break;
    case '-':
      full_year = "19".concat(full_year);
      break;
    default:
      full_year = "20".concat(full_year);
      break;
  }
  // Check date validity
  var date = "".concat(full_year, "/").concat(tin.slice(2, 4), "/").concat(tin.slice(0, 2));
  if (!(0, _isDate["default"])(date, 'YYYY/MM/DD')) {
    return false;
  }

  // Calculate check character
  var checksum = parseInt(tin.slice(0, 6) + tin.slice(7, 10), 10) % 31;
  if (checksum < 10) {
    return checksum === parseInt(tin.slice(10), 10);
  }
  checksum -= 10;
  var letters_lookup = ['A', 'B', 'C', 'D', 'E', 'F', 'H', 'J', 'K', 'L', 'M', 'N', 'P', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y'];
  return letters_lookup[checksum] === tin.slice(10);
}

/*
 * fr/nl-BE validation function
 * (Numro national (N.N.), persons only)
 * Checks if birth date (first six digits) is valid and calculates check (last two) digits
 */
function frBeCheck(tin) {
  // Zero month/day value is acceptable
  if (tin.slice(2, 4) !== '00' || tin.slice(4, 6) !== '00') {
    // Extract date from first six digits of TIN
    var date = "".concat(tin.slice(0, 2), "/").concat(tin.slice(2, 4), "/").concat(tin.slice(4, 6));
    if (!(0, _isDate["default"])(date, 'YY/MM/DD')) {
      return false;
    }
  }
  var checksum = 97 - parseInt(tin.slice(0, 9), 10) % 97;
  var checkdigits = parseInt(tin.slice(9, 11), 10);
  if (checksum !== checkdigits) {
    checksum = 97 - parseInt("2".concat(tin.slice(0, 9)), 10) % 97;
    if (checksum !== checkdigits) {
      return false;
    }
  }
  return true;
}

/*
 * fr-FR validation function
 * (Numro fiscal de rfrence (numro SPI), persons only)
 * Verify TIN validity by calculating check (last three) digits
 */
function frFrCheck(tin) {
  tin = tin.replace(/\s/g, '');
  var checksum = parseInt(tin.slice(0, 10), 10) % 511;
  var checkdigits = parseInt(tin.slice(10, 13), 10);
  return checksum === checkdigits;
}

/*
 * fr/lb-LU validation function
 * (numro didentification personnelle, persons only)
 * Verify birth date validity and run Luhn and Verhoeff checks
 */
function frLuCheck(tin) {
  // Extract date and check validity
  var date = "".concat(tin.slice(0, 4), "/").concat(tin.slice(4, 6), "/").concat(tin.slice(6, 8));
  if (!(0, _isDate["default"])(date, 'YYYY/MM/DD')) {
    return false;
  }

  // Run Luhn check
  if (!algorithms.luhnCheck(tin.slice(0, 12))) {
    return false;
  }
  // Remove Luhn check digit and run Verhoeff check
  return algorithms.verhoeffCheck("".concat(tin.slice(0, 11)).concat(tin[12]));
}

/*
 * hr-HR validation function
 * (Osobni identifikacijski broj (OIB), persons/entities)
 * Verify TIN validity by calling iso7064Check(digits)
 */
function hrHrCheck(tin) {
  return algorithms.iso7064Check(tin);
}

/*
 * hu-HU validation function
 * (Adazonost jel, persons only)
 * Verify TIN validity by calculating check (last) digit
 */
function huHuCheck(tin) {
  // split digits into an array for further processing
  var digits = tin.split('').map(function (a) {
    return parseInt(a, 10);
  });
  var checksum = 8;
  for (var i = 1; i < 9; i++) {
    checksum += digits[i] * (i + 1);
  }
  return checksum % 11 === digits[9];
}

/*
 * lt-LT validation function (should go here if needed)
 * (Asmens kodas, persons/entities respectively)
 * Current validation check is alias of etEeCheck- same format applies
 */

/*
 * it-IT first/last name validity check
 * Accepts it-IT TIN-encoded names as a three-element character array and checks their validity
 * Due to lack of clarity between resources ("Are only Italian consonants used?
 * What happens if a person has X in their name?" etc.) only two test conditions
 * have been implemented:
 * Vowels may only be followed by other vowels or an X character
 * and X characters after vowels may only be followed by other X characters.
 */
function itItNameCheck(name) {
  // true at the first occurence of a vowel
  var vowelflag = false;

  // true at the first occurence of an X AFTER vowel
  // (to properly handle last names with X as consonant)
  var xflag = false;
  for (var i = 0; i < 3; i++) {
    if (!vowelflag && /[AEIOU]/.test(name[i])) {
      vowelflag = true;
    } else if (!xflag && vowelflag && name[i] === 'X') {
      xflag = true;
    } else if (i > 0) {
      if (vowelflag && !xflag) {
        if (!/[AEIOU]/.test(name[i])) {
          return false;
        }
      }
      if (xflag) {
        if (!/X/.test(name[i])) {
          return false;
        }
      }
    }
  }
  return true;
}

/*
 * it-IT validation function
 * (Codice fiscale (TIN-IT), persons only)
 * Verify name, birth date and codice catastale validity
 * and calculate check character.
 * Material not in DG-TAXUD document sourced from:
 * `https://en.wikipedia.org/wiki/Italian_fiscal_code`
 */
function itItCheck(tin) {
  // Capitalize and split characters into an array for further processing
  var chars = tin.toUpperCase().split('');

  // Check first and last name validity calling itItNameCheck()
  if (!itItNameCheck(chars.slice(0, 3))) {
    return false;
  }
  if (!itItNameCheck(chars.slice(3, 6))) {
    return false;
  }

  // Convert letters in number spaces back to numbers if any
  var number_locations = [6, 7, 9, 10, 12, 13, 14];
  var number_replace = {
    L: '0',
    M: '1',
    N: '2',
    P: '3',
    Q: '4',
    R: '5',
    S: '6',
    T: '7',
    U: '8',
    V: '9'
  };
  for (var _i4 = 0, _number_locations = number_locations; _i4 < _number_locations.length; _i4++) {
    var i = _number_locations[_i4];
    if (chars[i] in number_replace) {
      chars.splice(i, 1, number_replace[chars[i]]);
    }
  }

  // Extract month and day, and check date validity
  var month_replace = {
    A: '01',
    B: '02',
    C: '03',
    D: '04',
    E: '05',
    H: '06',
    L: '07',
    M: '08',
    P: '09',
    R: '10',
    S: '11',
    T: '12'
  };
  var month = month_replace[chars[8]];
  var day = parseInt(chars[9] + chars[10], 10);
  if (day > 40) {
    day -= 40;
  }
  if (day < 10) {
    day = "0".concat(day);
  }
  var date = "".concat(chars[6]).concat(chars[7], "/").concat(month, "/").concat(day);
  if (!(0, _isDate["default"])(date, 'YY/MM/DD')) {
    return false;
  }

  // Calculate check character by adding up even and odd characters as numbers
  var checksum = 0;
  for (var _i5 = 1; _i5 < chars.length - 1; _i5 += 2) {
    var char_to_int = parseInt(chars[_i5], 10);
    if (isNaN(char_to_int)) {
      char_to_int = chars[_i5].charCodeAt(0) - 65;
    }
    checksum += char_to_int;
  }
  var odd_convert = {
    // Maps of characters at odd places
    A: 1,
    B: 0,
    C: 5,
    D: 7,
    E: 9,
    F: 13,
    G: 15,
    H: 17,
    I: 19,
    J: 21,
    K: 2,
    L: 4,
    M: 18,
    N: 20,
    O: 11,
    P: 3,
    Q: 6,
    R: 8,
    S: 12,
    T: 14,
    U: 16,
    V: 10,
    W: 22,
    X: 25,
    Y: 24,
    Z: 23,
    0: 1,
    1: 0
  };
  for (var _i6 = 0; _i6 < chars.length - 1; _i6 += 2) {
    var _char_to_int = 0;
    if (chars[_i6] in odd_convert) {
      _char_to_int = odd_convert[chars[_i6]];
    } else {
      var multiplier = parseInt(chars[_i6], 10);
      _char_to_int = 2 * multiplier + 1;
      if (multiplier > 4) {
        _char_to_int += 2;
      }
    }
    checksum += _char_to_int;
  }
  if (String.fromCharCode(65 + checksum % 26) !== chars[15]) {
    return false;
  }
  return true;
}

/*
 * lv-LV validation function
 * (Personas kods (PK), persons only)
 * Check validity of birth date and calculate check (last) digit
 * Support only for old format numbers (not starting with '32', issued before 2017/07/01)
 * Material not in DG TAXUD document sourced from:
 * `https://boot.ritakafija.lv/forums/index.php?/topic/88314-personas-koda-algoritms-%C4%8Deksumma/`
 */
function lvLvCheck(tin) {
  tin = tin.replace(/\W/, '');
  // Extract date from TIN
  var day = tin.slice(0, 2);
  if (day !== '32') {
    // No date/checksum check if new format
    var month = tin.slice(2, 4);
    if (month !== '00') {
      // No date check if unknown month
      var full_year = tin.slice(4, 6);
      switch (tin[6]) {
        case '0':
          full_year = "18".concat(full_year);
          break;
        case '1':
          full_year = "19".concat(full_year);
          break;
        default:
          full_year = "20".concat(full_year);
          break;
      }
      // Check date validity
      var date = "".concat(full_year, "/").concat(tin.slice(2, 4), "/").concat(day);
      if (!(0, _isDate["default"])(date, 'YYYY/MM/DD')) {
        return false;
      }
    }

    // Calculate check digit
    var checksum = 1101;
    var multip_lookup = [1, 6, 3, 7, 9, 10, 5, 8, 4, 2];
    for (var i = 0; i < tin.length - 1; i++) {
      checksum -= parseInt(tin[i], 10) * multip_lookup[i];
    }
    return parseInt(tin[10], 10) === checksum % 11;
  }
  return true;
}

/*
 * mt-MT validation function
 * (Identity Card Number or Unique Taxpayer Reference, persons/entities)
 * Verify Identity Card Number structure (no other tests found)
 */
function mtMtCheck(tin) {
  if (tin.length !== 9) {
    // No tests for UTR
    var chars = tin.toUpperCase().split('');
    // Fill with zeros if smaller than proper
    while (chars.length < 8) {
      chars.unshift(0);
    }
    // Validate format according to last character
    switch (tin[7]) {
      case 'A':
      case 'P':
        if (parseInt(chars[6], 10) === 0) {
          return false;
        }
        break;
      default:
        {
          var first_part = parseInt(chars.join('').slice(0, 5), 10);
          if (first_part > 32000) {
            return false;
          }
          var second_part = parseInt(chars.join('').slice(5, 7), 10);
          if (first_part === second_part) {
            return false;
          }
        }
    }
  }
  return true;
}

/*
 * nl-NL validation function
 * (Burgerservicenummer (BSN) or Rechtspersonen Samenwerkingsverbanden Informatie Nummer (RSIN),
 * persons/entities respectively)
 * Verify TIN validity by calculating check (last) digit (variant of MOD 11)
 */
function nlNlCheck(tin) {
  return algorithms.reverseMultiplyAndSum(tin.split('').slice(0, 8).map(function (a) {
    return parseInt(a, 10);
  }), 9) % 11 === parseInt(tin[8], 10);
}

/*
 * pl-PL validation function
 * (Powszechny Elektroniczny System Ewidencji Ludnoci (PESEL)
 * or Numer identyfikacji podatkowej (NIP), persons/entities)
 * Verify TIN validity by validating birth date (PESEL) and calculating check (last) digit
 */
function plPlCheck(tin) {
  // NIP
  if (tin.length === 10) {
    // Calculate last digit by multiplying with lookup
    var lookup = [6, 5, 7, 2, 3, 4, 5, 6, 7];
    var _checksum = 0;
    for (var i = 0; i < lookup.length; i++) {
      _checksum += parseInt(tin[i], 10) * lookup[i];
    }
    _checksum %= 11;
    if (_checksum === 10) {
      return false;
    }
    return _checksum === parseInt(tin[9], 10);
  }

  // PESEL
  // Extract full year using month
  var full_year = tin.slice(0, 2);
  var month = parseInt(tin.slice(2, 4), 10);
  if (month > 80) {
    full_year = "18".concat(full_year);
    month -= 80;
  } else if (month > 60) {
    full_year = "22".concat(full_year);
    month -= 60;
  } else if (month > 40) {
    full_year = "21".concat(full_year);
    month -= 40;
  } else if (month > 20) {
    full_year = "20".concat(full_year);
    month -= 20;
  } else {
    full_year = "19".concat(full_year);
  }
  // Add leading zero to month if needed
  if (month < 10) {
    month = "0".concat(month);
  }
  // Check date validity
  var date = "".concat(full_year, "/").concat(month, "/").concat(tin.slice(4, 6));
  if (!(0, _isDate["default"])(date, 'YYYY/MM/DD')) {
    return false;
  }

  // Calculate last digit by mulitplying with odd one-digit numbers except 5
  var checksum = 0;
  var multiplier = 1;
  for (var _i7 = 0; _i7 < tin.length - 1; _i7++) {
    checksum += parseInt(tin[_i7], 10) * multiplier % 10;
    multiplier += 2;
    if (multiplier > 10) {
      multiplier = 1;
    } else if (multiplier === 5) {
      multiplier += 2;
    }
  }
  checksum = 10 - checksum % 10;
  return checksum === parseInt(tin[10], 10);
}

/*
* pt-BR validation function
* (Cadastro de Pessoas Fsicas (CPF, persons)
* Cadastro Nacional de Pessoas Jurdicas (CNPJ, entities)
* Both inputs will be validated
*/

function ptBrCheck(tin) {
  if (tin.length === 11) {
    var _sum;
    var remainder;
    _sum = 0;
    if (
    // Reject known invalid CPFs
    tin === '11111111111' || tin === '22222222222' || tin === '33333333333' || tin === '44444444444' || tin === '55555555555' || tin === '66666666666' || tin === '77777777777' || tin === '88888888888' || tin === '99999999999' || tin === '00000000000') return false;
    for (var i = 1; i <= 9; i++) _sum += parseInt(tin.substring(i - 1, i), 10) * (11 - i);
    remainder = _sum * 10 % 11;
    if (remainder === 10) remainder = 0;
    if (remainder !== parseInt(tin.substring(9, 10), 10)) return false;
    _sum = 0;
    for (var _i8 = 1; _i8 <= 10; _i8++) _sum += parseInt(tin.substring(_i8 - 1, _i8), 10) * (12 - _i8);
    remainder = _sum * 10 % 11;
    if (remainder === 10) remainder = 0;
    if (remainder !== parseInt(tin.substring(10, 11), 10)) return false;
    return true;
  }
  if (
  // Reject know invalid CNPJs
  tin === '00000000000000' || tin === '11111111111111' || tin === '22222222222222' || tin === '33333333333333' || tin === '44444444444444' || tin === '55555555555555' || tin === '66666666666666' || tin === '77777777777777' || tin === '88888888888888' || tin === '99999999999999') {
    return false;
  }
  var length = tin.length - 2;
  var identifiers = tin.substring(0, length);
  var verificators = tin.substring(length);
  var sum = 0;
  var pos = length - 7;
  for (var _i9 = length; _i9 >= 1; _i9--) {
    sum += identifiers.charAt(length - _i9) * pos;
    pos -= 1;
    if (pos < 2) {
      pos = 9;
    }
  }
  var result = sum % 11 < 2 ? 0 : 11 - sum % 11;
  if (result !== parseInt(verificators.charAt(0), 10)) {
    return false;
  }
  length += 1;
  identifiers = tin.substring(0, length);
  sum = 0;
  pos = length - 7;
  for (var _i10 = length; _i10 >= 1; _i10--) {
    sum += identifiers.charAt(length - _i10) * pos;
    pos -= 1;
    if (pos < 2) {
      pos = 9;
    }
  }
  result = sum % 11 < 2 ? 0 : 11 - sum % 11;
  if (result !== parseInt(verificators.charAt(1), 10)) {
    return false;
  }
  return true;
}

/*
 * pt-PT validation function
 * (Nmero de identificao fiscal (NIF), persons/entities)
 * Verify TIN validity by calculating check (last) digit (variant of MOD 11)
 */
function ptPtCheck(tin) {
  var checksum = 11 - algorithms.reverseMultiplyAndSum(tin.split('').slice(0, 8).map(function (a) {
    return parseInt(a, 10);
  }), 9) % 11;
  if (checksum > 9) {
    return parseInt(tin[8], 10) === 0;
  }
  return checksum === parseInt(tin[8], 10);
}

/*
 * ro-RO validation function
 * (Cod Numeric Personal (CNP) or Cod de nregistrare fiscal (CIF),
 * persons only)
 * Verify CNP validity by calculating check (last) digit (test not found for CIF)
 * Material not in DG TAXUD document sourced from:
 * `https://en.wikipedia.org/wiki/National_identification_number#Romania`
 */
function roRoCheck(tin) {
  if (tin.slice(0, 4) !== '9000') {
    // No test found for this format
    // Extract full year using century digit if possible
    var full_year = tin.slice(1, 3);
    switch (tin[0]) {
      case '1':
      case '2':
        full_year = "19".concat(full_year);
        break;
      case '3':
      case '4':
        full_year = "18".concat(full_year);
        break;
      case '5':
      case '6':
        full_year = "20".concat(full_year);
        break;
      default:
    }

    // Check date validity
    var date = "".concat(full_year, "/").concat(tin.slice(3, 5), "/").concat(tin.slice(5, 7));
    if (date.length === 8) {
      if (!(0, _isDate["default"])(date, 'YY/MM/DD')) {
        return false;
      }
    } else if (!(0, _isDate["default"])(date, 'YYYY/MM/DD')) {
      return false;
    }

    // Calculate check digit
    var digits = tin.split('').map(function (a) {
      return parseInt(a, 10);
    });
    var multipliers = [2, 7, 9, 1, 4, 6, 3, 5, 8, 2, 7, 9];
    var checksum = 0;
    for (var i = 0; i < multipliers.length; i++) {
      checksum += digits[i] * multipliers[i];
    }
    if (checksum % 11 === 10) {
      return digits[12] === 1;
    }
    return digits[12] === checksum % 11;
  }
  return true;
}

/*
 * sk-SK validation function
 * (Rodn slo (R) or bezvznamov identifikan slo (BI), persons only)
 * Checks validity of pre-1954 birth numbers (rodn slo) only
 * Due to the introduction of the pseudo-random BI it is not possible to test
 * post-1954 birth numbers without knowing whether they are BI or R beforehand
 */
function skSkCheck(tin) {
  if (tin.length === 9) {
    tin = tin.replace(/\W/, '');
    if (tin.slice(6) === '000') {
      return false;
    } // Three-zero serial not assigned before 1954

    // Extract full year from TIN length
    var full_year = parseInt(tin.slice(0, 2), 10);
    if (full_year > 53) {
      return false;
    }
    if (full_year < 10) {
      full_year = "190".concat(full_year);
    } else {
      full_year = "19".concat(full_year);
    }

    // Extract month from TIN and normalize
    var month = parseInt(tin.slice(2, 4), 10);
    if (month > 50) {
      month -= 50;
    }
    if (month < 10) {
      month = "0".concat(month);
    }

    // Check date validity
    var date = "".concat(full_year, "/").concat(month, "/").concat(tin.slice(4, 6));
    if (!(0, _isDate["default"])(date, 'YYYY/MM/DD')) {
      return false;
    }
  }
  return true;
}

/*
 * sl-SI validation function
 * (Davna tevilka, persons/entities)
 * Verify TIN validity by calculating check (last) digit (variant of MOD 11)
 */
function slSiCheck(tin) {
  var checksum = 11 - algorithms.reverseMultiplyAndSum(tin.split('').slice(0, 7).map(function (a) {
    return parseInt(a, 10);
  }), 8) % 11;
  if (checksum === 10) {
    return parseInt(tin[7], 10) === 0;
  }
  return checksum === parseInt(tin[7], 10);
}

/*
 * sv-SE validation function
 * (Personnummer or samordningsnummer, persons only)
 * Checks validity of birth date and calls luhnCheck() to validate check (last) digit
 */
function svSeCheck(tin) {
  // Make copy of TIN and normalize to two-digit year form
  var tin_copy = tin.slice(0);
  if (tin.length > 11) {
    tin_copy = tin_copy.slice(2);
  }

  // Extract date of birth
  var full_year = '';
  var month = tin_copy.slice(2, 4);
  var day = parseInt(tin_copy.slice(4, 6), 10);
  if (tin.length > 11) {
    full_year = tin.slice(0, 4);
  } else {
    full_year = tin.slice(0, 2);
    if (tin.length === 11 && day < 60) {
      // Extract full year from centenarian symbol
      // Should work just fine until year 10000 or so
      var current_year = new Date().getFullYear().toString();
      var current_century = parseInt(current_year.slice(0, 2), 10);
      current_year = parseInt(current_year, 10);
      if (tin[6] === '-') {
        if (parseInt("".concat(current_century).concat(full_year), 10) > current_year) {
          full_year = "".concat(current_century - 1).concat(full_year);
        } else {
          full_year = "".concat(current_century).concat(full_year);
        }
      } else {
        full_year = "".concat(current_century - 1).concat(full_year);
        if (current_year - parseInt(full_year, 10) < 100) {
          return false;
        }
      }
    }
  }

  // Normalize day and check date validity
  if (day > 60) {
    day -= 60;
  }
  if (day < 10) {
    day = "0".concat(day);
  }
  var date = "".concat(full_year, "/").concat(month, "/").concat(day);
  if (date.length === 8) {
    if (!(0, _isDate["default"])(date, 'YY/MM/DD')) {
      return false;
    }
  } else if (!(0, _isDate["default"])(date, 'YYYY/MM/DD')) {
    return false;
  }
  return algorithms.luhnCheck(tin.replace(/\W/, ''));
}

/**
 * uk-UA validation function
 * Verify TIN validity by calculating check (last) digit (variant of MOD 11)
 */
function ukUaCheck(tin) {
  // Calculate check digit
  var digits = tin.split('').map(function (a) {
    return parseInt(a, 10);
  });
  var multipliers = [-1, 5, 7, 9, 4, 6, 10, 5, 7];
  var checksum = 0;
  for (var i = 0; i < multipliers.length; i++) {
    checksum += digits[i] * multipliers[i];
  }
  return checksum % 11 === 10 ? digits[9] === 0 : digits[9] === checksum % 11;
}

// Locale lookup objects

/*
 * Tax id regex formats for various locales
 *
 * Where not explicitly specified in DG-TAXUD document both
 * uppercase and lowercase letters are acceptable.
 */
var taxIdFormat = {
  'bg-BG': /^\d{10}$/,
  'cs-CZ': /^\d{6}\/{0,1}\d{3,4}$/,
  'de-AT': /^\d{9}$/,
  'de-DE': /^[1-9]\d{10}$/,
  'dk-DK': /^\d{6}-{0,1}\d{4}$/,
  'el-CY': /^[09]\d{7}[A-Z]$/,
  'el-GR': /^([0-4]|[7-9])\d{8}$/,
  'en-CA': /^\d{9}$/,
  'en-GB': /^\d{10}$|^(?!GB|NK|TN|ZZ)(?![DFIQUV])[A-Z](?![DFIQUVO])[A-Z]\d{6}[ABCD ]$/i,
  'en-IE': /^\d{7}[A-W][A-IW]{0,1}$/i,
  'en-US': /^\d{2}[- ]{0,1}\d{7}$/,
  'es-AR': /(20|23|24|27|30|33|34)[0-9]{8}[0-9]/,
  'es-ES': /^(\d{0,8}|[XYZKLM]\d{7})[A-HJ-NP-TV-Z]$/i,
  'et-EE': /^[1-6]\d{6}(00[1-9]|0[1-9][0-9]|[1-6][0-9]{2}|70[0-9]|710)\d$/,
  'fi-FI': /^\d{6}[-+A]\d{3}[0-9A-FHJ-NPR-Y]$/i,
  'fr-BE': /^\d{11}$/,
  'fr-FR': /^[0-3]\d{12}$|^[0-3]\d\s\d{2}(\s\d{3}){3}$/,
  // Conforms both to official spec and provided example
  'fr-LU': /^\d{13}$/,
  'hr-HR': /^\d{11}$/,
  'hu-HU': /^8\d{9}$/,
  'it-IT': /^[A-Z]{6}[L-NP-V0-9]{2}[A-EHLMPRST][L-NP-V0-9]{2}[A-ILMZ][L-NP-V0-9]{3}[A-Z]$/i,
  'lv-LV': /^\d{6}-{0,1}\d{5}$/,
  // Conforms both to DG TAXUD spec and original research
  'mt-MT': /^\d{3,7}[APMGLHBZ]$|^([1-8])\1\d{7}$/i,
  'nl-NL': /^\d{9}$/,
  'pl-PL': /^\d{10,11}$/,
  'pt-BR': /(?:^\d{11}$)|(?:^\d{14}$)/,
  'pt-PT': /^\d{9}$/,
  'ro-RO': /^\d{13}$/,
  'sk-SK': /^\d{6}\/{0,1}\d{3,4}$/,
  'sl-SI': /^[1-9]\d{7}$/,
  'sv-SE': /^(\d{6}[-+]{0,1}\d{4}|(18|19|20)\d{6}[-+]{0,1}\d{4})$/,
  'uk-UA': /^\d{10}$/
};
// taxIdFormat locale aliases
taxIdFormat['lb-LU'] = taxIdFormat['fr-LU'];
taxIdFormat['lt-LT'] = taxIdFormat['et-EE'];
taxIdFormat['nl-BE'] = taxIdFormat['fr-BE'];
taxIdFormat['fr-CA'] = taxIdFormat['en-CA'];

// Algorithmic tax id check functions for various locales
var taxIdCheck = {
  'bg-BG': bgBgCheck,
  'cs-CZ': csCzCheck,
  'de-AT': deAtCheck,
  'de-DE': deDeCheck,
  'dk-DK': dkDkCheck,
  'el-CY': elCyCheck,
  'el-GR': elGrCheck,
  'en-CA': isCanadianSIN,
  'en-IE': enIeCheck,
  'en-US': enUsCheck,
  'es-AR': esArCheck,
  'es-ES': esEsCheck,
  'et-EE': etEeCheck,
  'fi-FI': fiFiCheck,
  'fr-BE': frBeCheck,
  'fr-FR': frFrCheck,
  'fr-LU': frLuCheck,
  'hr-HR': hrHrCheck,
  'hu-HU': huHuCheck,
  'it-IT': itItCheck,
  'lv-LV': lvLvCheck,
  'mt-MT': mtMtCheck,
  'nl-NL': nlNlCheck,
  'pl-PL': plPlCheck,
  'pt-BR': ptBrCheck,
  'pt-PT': ptPtCheck,
  'ro-RO': roRoCheck,
  'sk-SK': skSkCheck,
  'sl-SI': slSiCheck,
  'sv-SE': svSeCheck,
  'uk-UA': ukUaCheck
};
// taxIdCheck locale aliases
taxIdCheck['lb-LU'] = taxIdCheck['fr-LU'];
taxIdCheck['lt-LT'] = taxIdCheck['et-EE'];
taxIdCheck['nl-BE'] = taxIdCheck['fr-BE'];
taxIdCheck['fr-CA'] = taxIdCheck['en-CA'];

// Regexes for locales where characters should be omitted before checking format
var allsymbols = /[-\\\/!@#$%\^&\*\(\)\+\=\[\]]+/g;
var sanitizeRegexes = {
  'de-AT': allsymbols,
  'de-DE': /[\/\\]/g,
  'fr-BE': allsymbols
};
// sanitizeRegexes locale aliases
sanitizeRegexes['nl-BE'] = sanitizeRegexes['fr-BE'];

/*
 * Validator function
 * Return true if the passed string is a valid tax identification number
 * for the specified locale.
 * Throw an error exception if the locale is not supported.
 */
function isTaxID(str) {
  var locale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'en-US';
  (0, _assertString["default"])(str);
  // Copy TIN to avoid replacement if sanitized
  var strcopy = str.slice(0);
  if (locale in taxIdFormat) {
    if (locale in sanitizeRegexes) {
      strcopy = strcopy.replace(sanitizeRegexes[locale], '');
    }
    if (!taxIdFormat[locale].test(strcopy)) {
      return false;
    }
    if (locale in taxIdCheck) {
      return taxIdCheck[locale](strcopy);
    }
    // Fallthrough; not all locales have algorithmic checks
    return true;
  }
  throw new Error("Invalid locale '".concat(locale, "'"));
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./isDate":445,"./util/algorithms":523,"./util/assertString":524}],505:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isTime;
var _merge = _interopRequireDefault(require("./util/merge"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
var default_time_options = {
  hourFormat: 'hour24',
  mode: 'default'
};
var formats = {
  hour24: {
    "default": /^([01]?[0-9]|2[0-3]):([0-5][0-9])$/,
    withSeconds: /^([01]?[0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9])$/
  },
  hour12: {
    "default": /^(0?[1-9]|1[0-2]):([0-5][0-9]) (A|P)M$/,
    withSeconds: /^(0?[1-9]|1[0-2]):([0-5][0-9]):([0-5][0-9]) (A|P)M$/
  }
};
function isTime(input, options) {
  options = (0, _merge["default"])(options, default_time_options);
  if (typeof input !== 'string') return false;
  return formats[options.hourFormat][options.mode].test(input);
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./util/merge":526}],506:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isURL;
var _assertString = _interopRequireDefault(require("./util/assertString"));
var _isFQDN = _interopRequireDefault(require("./isFQDN"));
var _isIP = _interopRequireDefault(require("./isIP"));
var _merge = _interopRequireDefault(require("./util/merge"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e,
      n,
      i,
      u,
      a = [],
      f = !0,
      o = !1;
    try {
      if (i = (t = t.call(r)).next, 0 === l) {
        if (Object(t) !== t) return;
        f = !1;
      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);
    } catch (r) {
      o = !0, n = r;
    } finally {
      try {
        if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}
/*
options for isURL method

require_protocol - if set as true isURL will return false if protocol is not present in the URL
require_valid_protocol - isURL will check if the URL's protocol is present in the protocols option
protocols - valid protocols can be modified with this option
require_host - if set as false isURL will not check if host is present in the URL
require_port - if set as true isURL will check if port is present in the URL
allow_protocol_relative_urls - if set as true protocol relative URLs will be allowed
validate_length - if set as false isURL will skip string length validation (IE maximum is 2083)

*/

var default_url_options = {
  protocols: ['http', 'https', 'ftp'],
  require_tld: true,
  require_protocol: false,
  require_host: true,
  require_port: false,
  require_valid_protocol: true,
  allow_underscores: false,
  allow_trailing_dot: false,
  allow_protocol_relative_urls: false,
  allow_fragments: true,
  allow_query_components: true,
  validate_length: true
};
var wrapped_ipv6 = /^\[([^\]]+)\](?::([0-9]+))?$/;
function isRegExp(obj) {
  return Object.prototype.toString.call(obj) === '[object RegExp]';
}
function checkHost(host, matches) {
  for (var i = 0; i < matches.length; i++) {
    var match = matches[i];
    if (host === match || isRegExp(match) && match.test(host)) {
      return true;
    }
  }
  return false;
}
function isURL(url, options) {
  (0, _assertString["default"])(url);
  if (!url || /[\s<>]/.test(url)) {
    return false;
  }
  if (url.indexOf('mailto:') === 0) {
    return false;
  }
  options = (0, _merge["default"])(options, default_url_options);
  if (options.validate_length && url.length >= 2083) {
    return false;
  }
  if (!options.allow_fragments && url.includes('#')) {
    return false;
  }
  if (!options.allow_query_components && (url.includes('?') || url.includes('&'))) {
    return false;
  }
  var protocol, auth, host, hostname, port, port_str, split, ipv6;
  split = url.split('#');
  url = split.shift();
  split = url.split('?');
  url = split.shift();
  split = url.split('://');
  if (split.length > 1) {
    protocol = split.shift().toLowerCase();
    if (options.require_valid_protocol && options.protocols.indexOf(protocol) === -1) {
      return false;
    }
  } else if (options.require_protocol) {
    return false;
  } else if (url.slice(0, 2) === '//') {
    if (!options.allow_protocol_relative_urls) {
      return false;
    }
    split[0] = url.slice(2);
  }
  url = split.join('://');
  if (url === '') {
    return false;
  }
  split = url.split('/');
  url = split.shift();
  if (url === '' && !options.require_host) {
    return true;
  }
  split = url.split('@');
  if (split.length > 1) {
    if (options.disallow_auth) {
      return false;
    }
    if (split[0] === '') {
      return false;
    }
    auth = split.shift();
    if (auth.indexOf(':') >= 0 && auth.split(':').length > 2) {
      return false;
    }
    var _auth$split = auth.split(':'),
      _auth$split2 = _slicedToArray(_auth$split, 2),
      user = _auth$split2[0],
      password = _auth$split2[1];
    if (user === '' && password === '') {
      return false;
    }
  }
  hostname = split.join('@');
  port_str = null;
  ipv6 = null;
  var ipv6_match = hostname.match(wrapped_ipv6);
  if (ipv6_match) {
    host = '';
    ipv6 = ipv6_match[1];
    port_str = ipv6_match[2] || null;
  } else {
    split = hostname.split(':');
    host = split.shift();
    if (split.length) {
      port_str = split.join(':');
    }
  }
  if (port_str !== null && port_str.length > 0) {
    port = parseInt(port_str, 10);
    if (!/^[0-9]+$/.test(port_str) || port <= 0 || port > 65535) {
      return false;
    }
  } else if (options.require_port) {
    return false;
  }
  if (options.host_whitelist) {
    return checkHost(host, options.host_whitelist);
  }
  if (host === '' && !options.require_host) {
    return true;
  }
  if (!(0, _isIP["default"])(host) && !(0, _isFQDN["default"])(host, options) && (!ipv6 || !(0, _isIP["default"])(ipv6, 6))) {
    return false;
  }
  host = host || ipv6;
  if (options.host_blacklist && checkHost(host, options.host_blacklist)) {
    return false;
  }
  return true;
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./isFQDN":452,"./isIP":462,"./util/assertString":524,"./util/merge":526}],507:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isUUID;
var _assertString = _interopRequireDefault(require("./util/assertString"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
var uuid = {
  1: /^[0-9A-F]{8}-[0-9A-F]{4}-1[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i,
  2: /^[0-9A-F]{8}-[0-9A-F]{4}-2[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i,
  3: /^[0-9A-F]{8}-[0-9A-F]{4}-3[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i,
  4: /^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
  5: /^[0-9A-F]{8}-[0-9A-F]{4}-5[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
  7: /^[0-9A-F]{8}-[0-9A-F]{4}-7[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
  all: /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i
};
function isUUID(str, version) {
  (0, _assertString["default"])(str);
  var pattern = uuid[![undefined, null].includes(version) ? version : 'all'];
  return !!pattern && pattern.test(str);
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./util/assertString":524}],508:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isUppercase;
var _assertString = _interopRequireDefault(require("./util/assertString"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
function isUppercase(str) {
  (0, _assertString["default"])(str);
  return str === str.toUpperCase();
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./util/assertString":524}],509:[function(require,module,exports){
"use strict";

function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isVAT;
exports.vatMatchers = void 0;
var _assertString = _interopRequireDefault(require("./util/assertString"));
var algorithms = _interopRequireWildcard(require("./util/algorithms"));
function _getRequireWildcardCache(e) {
  if ("function" != typeof WeakMap) return null;
  var r = new WeakMap(),
    t = new WeakMap();
  return (_getRequireWildcardCache = function _getRequireWildcardCache(e) {
    return e ? t : r;
  })(e);
}
function _interopRequireWildcard(e, r) {
  if (!r && e && e.__esModule) return e;
  if (null === e || "object" != _typeof(e) && "function" != typeof e) return {
    "default": e
  };
  var t = _getRequireWildcardCache(r);
  if (t && t.has(e)) return t.get(e);
  var n = {
      __proto__: null
    },
    a = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) {
    var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
    i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
  }
  return n["default"] = e, t && t.set(e, n), n;
}
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
var AU = function AU(str) {
  var match = str.match(/^(AU)?(\d{11})$/);
  if (!match) {
    return false;
  }
  // @see {@link https://abr.business.gov.au/Help/AbnFormat}
  var weights = [10, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19];
  str = str.replace(/^AU/, '');
  var ABN = (parseInt(str.slice(0, 1), 10) - 1).toString() + str.slice(1);
  var total = 0;
  for (var i = 0; i < 11; i++) {
    total += weights[i] * ABN.charAt(i);
  }
  return total !== 0 && total % 89 === 0;
};
var CH = function CH(str) {
  // @see {@link https://www.ech.ch/de/ech/ech-0097/5.2.0}
  var hasValidCheckNumber = function hasValidCheckNumber(digits) {
    var lastDigit = digits.pop(); // used as check number
    var weights = [5, 4, 3, 2, 7, 6, 5, 4];
    var calculatedCheckNumber = (11 - digits.reduce(function (acc, el, idx) {
      return acc + el * weights[idx];
    }, 0) % 11) % 11;
    return lastDigit === calculatedCheckNumber;
  };

  // @see {@link https://www.estv.admin.ch/estv/de/home/mehrwertsteuer/uid/mwst-uid-nummer.html}
  return /^(CHE[- ]?)?(\d{9}|(\d{3}\.\d{3}\.\d{3})|(\d{3} \d{3} \d{3})) ?(TVA|MWST|IVA)?$/.test(str) && hasValidCheckNumber(str.match(/\d/g).map(function (el) {
    return +el;
  }));
};
var PT = function PT(str) {
  var match = str.match(/^(PT)?(\d{9})$/);
  if (!match) {
    return false;
  }
  var tin = match[2];
  var checksum = 11 - algorithms.reverseMultiplyAndSum(tin.split('').slice(0, 8).map(function (a) {
    return parseInt(a, 10);
  }), 9) % 11;
  if (checksum > 9) {
    return parseInt(tin[8], 10) === 0;
  }
  return checksum === parseInt(tin[8], 10);
};
var vatMatchers = exports.vatMatchers = {
  /**
   * European Union VAT identification numbers
   */
  AT: function AT(str) {
    return /^(AT)?U\d{8}$/.test(str);
  },
  BE: function BE(str) {
    return /^(BE)?\d{10}$/.test(str);
  },
  BG: function BG(str) {
    return /^(BG)?\d{9,10}$/.test(str);
  },
  HR: function HR(str) {
    return /^(HR)?\d{11}$/.test(str);
  },
  CY: function CY(str) {
    return /^(CY)?\w{9}$/.test(str);
  },
  CZ: function CZ(str) {
    return /^(CZ)?\d{8,10}$/.test(str);
  },
  DK: function DK(str) {
    return /^(DK)?\d{8}$/.test(str);
  },
  EE: function EE(str) {
    return /^(EE)?\d{9}$/.test(str);
  },
  FI: function FI(str) {
    return /^(FI)?\d{8}$/.test(str);
  },
  FR: function FR(str) {
    return /^(FR)?\w{2}\d{9}$/.test(str);
  },
  DE: function DE(str) {
    return /^(DE)?\d{9}$/.test(str);
  },
  EL: function EL(str) {
    return /^(EL)?\d{9}$/.test(str);
  },
  HU: function HU(str) {
    return /^(HU)?\d{8}$/.test(str);
  },
  IE: function IE(str) {
    return /^(IE)?\d{7}\w{1}(W)?$/.test(str);
  },
  IT: function IT(str) {
    return /^(IT)?\d{11}$/.test(str);
  },
  LV: function LV(str) {
    return /^(LV)?\d{11}$/.test(str);
  },
  LT: function LT(str) {
    return /^(LT)?\d{9,12}$/.test(str);
  },
  LU: function LU(str) {
    return /^(LU)?\d{8}$/.test(str);
  },
  MT: function MT(str) {
    return /^(MT)?\d{8}$/.test(str);
  },
  NL: function NL(str) {
    return /^(NL)?\d{9}B\d{2}$/.test(str);
  },
  PL: function PL(str) {
    return /^(PL)?(\d{10}|(\d{3}-\d{3}-\d{2}-\d{2})|(\d{3}-\d{2}-\d{2}-\d{3}))$/.test(str);
  },
  PT: PT,
  RO: function RO(str) {
    return /^(RO)?\d{2,10}$/.test(str);
  },
  SK: function SK(str) {
    return /^(SK)?\d{10}$/.test(str);
  },
  SI: function SI(str) {
    return /^(SI)?\d{8}$/.test(str);
  },
  ES: function ES(str) {
    return /^(ES)?\w\d{7}[A-Z]$/.test(str);
  },
  SE: function SE(str) {
    return /^(SE)?\d{12}$/.test(str);
  },
  /**
   * VAT numbers of non-EU countries
   */
  AL: function AL(str) {
    return /^(AL)?\w{9}[A-Z]$/.test(str);
  },
  MK: function MK(str) {
    return /^(MK)?\d{13}$/.test(str);
  },
  AU: AU,
  BY: function BY(str) {
    return /^( )?\d{9}$/.test(str);
  },
  CA: function CA(str) {
    return /^(CA)?\d{9}$/.test(str);
  },
  IS: function IS(str) {
    return /^(IS)?\d{5,6}$/.test(str);
  },
  IN: function IN(str) {
    return /^(IN)?\d{15}$/.test(str);
  },
  ID: function ID(str) {
    return /^(ID)?(\d{15}|(\d{2}.\d{3}.\d{3}.\d{1}-\d{3}.\d{3}))$/.test(str);
  },
  IL: function IL(str) {
    return /^(IL)?\d{9}$/.test(str);
  },
  KZ: function KZ(str) {
    return /^(KZ)?\d{12}$/.test(str);
  },
  NZ: function NZ(str) {
    return /^(NZ)?\d{9}$/.test(str);
  },
  NG: function NG(str) {
    return /^(NG)?(\d{12}|(\d{8}-\d{4}))$/.test(str);
  },
  NO: function NO(str) {
    return /^(NO)?\d{9}MVA$/.test(str);
  },
  PH: function PH(str) {
    return /^(PH)?(\d{12}|\d{3} \d{3} \d{3} \d{3})$/.test(str);
  },
  RU: function RU(str) {
    return /^(RU)?(\d{10}|\d{12})$/.test(str);
  },
  SM: function SM(str) {
    return /^(SM)?\d{5}$/.test(str);
  },
  SA: function SA(str) {
    return /^(SA)?\d{15}$/.test(str);
  },
  RS: function RS(str) {
    return /^(RS)?\d{9}$/.test(str);
  },
  CH: CH,
  TR: function TR(str) {
    return /^(TR)?\d{10}$/.test(str);
  },
  UA: function UA(str) {
    return /^(UA)?\d{12}$/.test(str);
  },
  GB: function GB(str) {
    return /^GB((\d{3} \d{4} ([0-8][0-9]|9[0-6]))|(\d{9} \d{3})|(((GD[0-4])|(HA[5-9]))[0-9]{2}))$/.test(str);
  },
  UZ: function UZ(str) {
    return /^(UZ)?\d{9}$/.test(str);
  },
  /**
   * VAT numbers of Latin American countries
   */
  AR: function AR(str) {
    return /^(AR)?\d{11}$/.test(str);
  },
  BO: function BO(str) {
    return /^(BO)?\d{7}$/.test(str);
  },
  BR: function BR(str) {
    return /^(BR)?((\d{2}.\d{3}.\d{3}\/\d{4}-\d{2})|(\d{3}.\d{3}.\d{3}-\d{2}))$/.test(str);
  },
  CL: function CL(str) {
    return /^(CL)?\d{8}-\d{1}$/.test(str);
  },
  CO: function CO(str) {
    return /^(CO)?\d{10}$/.test(str);
  },
  CR: function CR(str) {
    return /^(CR)?\d{9,12}$/.test(str);
  },
  EC: function EC(str) {
    return /^(EC)?\d{13}$/.test(str);
  },
  SV: function SV(str) {
    return /^(SV)?\d{4}-\d{6}-\d{3}-\d{1}$/.test(str);
  },
  GT: function GT(str) {
    return /^(GT)?\d{7}-\d{1}$/.test(str);
  },
  HN: function HN(str) {
    return /^(HN)?$/.test(str);
  },
  MX: function MX(str) {
    return /^(MX)?\w{3,4}\d{6}\w{3}$/.test(str);
  },
  NI: function NI(str) {
    return /^(NI)?\d{3}-\d{6}-\d{4}\w{1}$/.test(str);
  },
  PA: function PA(str) {
    return /^(PA)?$/.test(str);
  },
  PY: function PY(str) {
    return /^(PY)?\d{6,8}-\d{1}$/.test(str);
  },
  PE: function PE(str) {
    return /^(PE)?\d{11}$/.test(str);
  },
  DO: function DO(str) {
    return /^(DO)?(\d{11}|(\d{3}-\d{7}-\d{1})|[1,4,5]{1}\d{8}|([1,4,5]{1})-\d{2}-\d{5}-\d{1})$/.test(str);
  },
  UY: function UY(str) {
    return /^(UY)?\d{12}$/.test(str);
  },
  VE: function VE(str) {
    return /^(VE)?[J,G,V,E]{1}-(\d{9}|(\d{8}-\d{1}))$/.test(str);
  }
};
function isVAT(str, countryCode) {
  (0, _assertString["default"])(str);
  (0, _assertString["default"])(countryCode);
  if (countryCode in vatMatchers) {
    return vatMatchers[countryCode](str);
  }
  throw new Error("Invalid country code: '".concat(countryCode, "'"));
}

},{"./util/algorithms":523,"./util/assertString":524}],510:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isVariableWidth;
var _assertString = _interopRequireDefault(require("./util/assertString"));
var _isFullWidth = require("./isFullWidth");
var _isHalfWidth = require("./isHalfWidth");
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
function isVariableWidth(str) {
  (0, _assertString["default"])(str);
  return _isFullWidth.fullWidth.test(str) && _isHalfWidth.halfWidth.test(str);
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./isFullWidth":454,"./isHalfWidth":456,"./util/assertString":524}],511:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = isWhitelisted;
var _assertString = _interopRequireDefault(require("./util/assertString"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
function isWhitelisted(str, chars) {
  (0, _assertString["default"])(str);
  for (var i = str.length - 1; i >= 0; i--) {
    if (chars.indexOf(str[i]) === -1) {
      return false;
    }
  }
  return true;
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./util/assertString":524}],512:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = ltrim;
var _assertString = _interopRequireDefault(require("./util/assertString"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
function ltrim(str, chars) {
  (0, _assertString["default"])(str);
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Escaping
  var pattern = chars ? new RegExp("^[".concat(chars.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), "]+"), 'g') : /^\s+/g;
  return str.replace(pattern, '');
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./util/assertString":524}],513:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = matches;
var _assertString = _interopRequireDefault(require("./util/assertString"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
function matches(str, pattern, modifiers) {
  (0, _assertString["default"])(str);
  if (Object.prototype.toString.call(pattern) !== '[object RegExp]') {
    pattern = new RegExp(pattern, modifiers);
  }
  return !!str.match(pattern);
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./util/assertString":524}],514:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = normalizeEmail;
var _merge = _interopRequireDefault(require("./util/merge"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
var default_normalize_email_options = {
  // The following options apply to all email addresses
  // Lowercases the local part of the email address.
  // Please note this may violate RFC 5321 as per http://stackoverflow.com/a/9808332/192024).
  // The domain is always lowercased, as per RFC 1035
  all_lowercase: true,
  // The following conversions are specific to GMail
  // Lowercases the local part of the GMail address (known to be case-insensitive)
  gmail_lowercase: true,
  // Removes dots from the local part of the email address, as that's ignored by GMail
  gmail_remove_dots: true,
  // Removes the subaddress (e.g. "+foo") from the email address
  gmail_remove_subaddress: true,
  // Conversts the googlemail.com domain to gmail.com
  gmail_convert_googlemaildotcom: true,
  // The following conversions are specific to Outlook.com / Windows Live / Hotmail
  // Lowercases the local part of the Outlook.com address (known to be case-insensitive)
  outlookdotcom_lowercase: true,
  // Removes the subaddress (e.g. "+foo") from the email address
  outlookdotcom_remove_subaddress: true,
  // The following conversions are specific to Yahoo
  // Lowercases the local part of the Yahoo address (known to be case-insensitive)
  yahoo_lowercase: true,
  // Removes the subaddress (e.g. "-foo") from the email address
  yahoo_remove_subaddress: true,
  // The following conversions are specific to Yandex
  // Lowercases the local part of the Yandex address (known to be case-insensitive)
  yandex_lowercase: true,
  // The following conversions are specific to iCloud
  // Lowercases the local part of the iCloud address (known to be case-insensitive)
  icloud_lowercase: true,
  // Removes the subaddress (e.g. "+foo") from the email address
  icloud_remove_subaddress: true
};

// List of domains used by iCloud
var icloud_domains = ['icloud.com', 'me.com'];

// List of domains used by Outlook.com and its predecessors
// This list is likely incomplete.
// Partial reference:
// https://blogs.office.com/2013/04/17/outlook-com-gets-two-step-verification-sign-in-by-alias-and-new-international-domains/
var outlookdotcom_domains = ['hotmail.at', 'hotmail.be', 'hotmail.ca', 'hotmail.cl', 'hotmail.co.il', 'hotmail.co.nz', 'hotmail.co.th', 'hotmail.co.uk', 'hotmail.com', 'hotmail.com.ar', 'hotmail.com.au', 'hotmail.com.br', 'hotmail.com.gr', 'hotmail.com.mx', 'hotmail.com.pe', 'hotmail.com.tr', 'hotmail.com.vn', 'hotmail.cz', 'hotmail.de', 'hotmail.dk', 'hotmail.es', 'hotmail.fr', 'hotmail.hu', 'hotmail.id', 'hotmail.ie', 'hotmail.in', 'hotmail.it', 'hotmail.jp', 'hotmail.kr', 'hotmail.lv', 'hotmail.my', 'hotmail.ph', 'hotmail.pt', 'hotmail.sa', 'hotmail.sg', 'hotmail.sk', 'live.be', 'live.co.uk', 'live.com', 'live.com.ar', 'live.com.mx', 'live.de', 'live.es', 'live.eu', 'live.fr', 'live.it', 'live.nl', 'msn.com', 'outlook.at', 'outlook.be', 'outlook.cl', 'outlook.co.il', 'outlook.co.nz', 'outlook.co.th', 'outlook.com', 'outlook.com.ar', 'outlook.com.au', 'outlook.com.br', 'outlook.com.gr', 'outlook.com.pe', 'outlook.com.tr', 'outlook.com.vn', 'outlook.cz', 'outlook.de', 'outlook.dk', 'outlook.es', 'outlook.fr', 'outlook.hu', 'outlook.id', 'outlook.ie', 'outlook.in', 'outlook.it', 'outlook.jp', 'outlook.kr', 'outlook.lv', 'outlook.my', 'outlook.ph', 'outlook.pt', 'outlook.sa', 'outlook.sg', 'outlook.sk', 'passport.com'];

// List of domains used by Yahoo Mail
// This list is likely incomplete
var yahoo_domains = ['rocketmail.com', 'yahoo.ca', 'yahoo.co.uk', 'yahoo.com', 'yahoo.de', 'yahoo.fr', 'yahoo.in', 'yahoo.it', 'ymail.com'];

// List of domains used by yandex.ru
var yandex_domains = ['yandex.ru', 'yandex.ua', 'yandex.kz', 'yandex.com', 'yandex.by', 'ya.ru'];

// replace single dots, but not multiple consecutive dots
function dotsReplacer(match) {
  if (match.length > 1) {
    return match;
  }
  return '';
}
function normalizeEmail(email, options) {
  options = (0, _merge["default"])(options, default_normalize_email_options);
  var raw_parts = email.split('@');
  var domain = raw_parts.pop();
  var user = raw_parts.join('@');
  var parts = [user, domain];

  // The domain is always lowercased, as it's case-insensitive per RFC 1035
  parts[1] = parts[1].toLowerCase();
  if (parts[1] === 'gmail.com' || parts[1] === 'googlemail.com') {
    // Address is GMail
    if (options.gmail_remove_subaddress) {
      parts[0] = parts[0].split('+')[0];
    }
    if (options.gmail_remove_dots) {
      // this does not replace consecutive dots like example..email@gmail.com
      parts[0] = parts[0].replace(/\.+/g, dotsReplacer);
    }
    if (!parts[0].length) {
      return false;
    }
    if (options.all_lowercase || options.gmail_lowercase) {
      parts[0] = parts[0].toLowerCase();
    }
    parts[1] = options.gmail_convert_googlemaildotcom ? 'gmail.com' : parts[1];
  } else if (icloud_domains.indexOf(parts[1]) >= 0) {
    // Address is iCloud
    if (options.icloud_remove_subaddress) {
      parts[0] = parts[0].split('+')[0];
    }
    if (!parts[0].length) {
      return false;
    }
    if (options.all_lowercase || options.icloud_lowercase) {
      parts[0] = parts[0].toLowerCase();
    }
  } else if (outlookdotcom_domains.indexOf(parts[1]) >= 0) {
    // Address is Outlook.com
    if (options.outlookdotcom_remove_subaddress) {
      parts[0] = parts[0].split('+')[0];
    }
    if (!parts[0].length) {
      return false;
    }
    if (options.all_lowercase || options.outlookdotcom_lowercase) {
      parts[0] = parts[0].toLowerCase();
    }
  } else if (yahoo_domains.indexOf(parts[1]) >= 0) {
    // Address is Yahoo
    if (options.yahoo_remove_subaddress) {
      var components = parts[0].split('-');
      parts[0] = components.length > 1 ? components.slice(0, -1).join('-') : components[0];
    }
    if (!parts[0].length) {
      return false;
    }
    if (options.all_lowercase || options.yahoo_lowercase) {
      parts[0] = parts[0].toLowerCase();
    }
  } else if (yandex_domains.indexOf(parts[1]) >= 0) {
    if (options.all_lowercase || options.yandex_lowercase) {
      parts[0] = parts[0].toLowerCase();
    }
    parts[1] = 'yandex.ru'; // all yandex domains are equal, 1st preferred
  } else if (options.all_lowercase) {
    // Any other address
    parts[0] = parts[0].toLowerCase();
  }
  return parts.join('@');
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./util/merge":526}],515:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = rtrim;
var _assertString = _interopRequireDefault(require("./util/assertString"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
function rtrim(str, chars) {
  (0, _assertString["default"])(str);
  if (chars) {
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Escaping
    var pattern = new RegExp("[".concat(chars.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), "]+$"), 'g');
    return str.replace(pattern, '');
  }
  // Use a faster and more safe than regex trim method https://blog.stevenlevithan.com/archives/faster-trim-javascript
  var strIndex = str.length - 1;
  while (/\s/.test(str.charAt(strIndex))) {
    strIndex -= 1;
  }
  return str.slice(0, strIndex + 1);
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./util/assertString":524}],516:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = stripLow;
var _assertString = _interopRequireDefault(require("./util/assertString"));
var _blacklist = _interopRequireDefault(require("./blacklist"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
function stripLow(str, keep_new_lines) {
  (0, _assertString["default"])(str);
  var chars = keep_new_lines ? '\\x00-\\x09\\x0B\\x0C\\x0E-\\x1F\\x7F' : '\\x00-\\x1F\\x7F';
  return (0, _blacklist["default"])(str, chars);
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./blacklist":425,"./util/assertString":524}],517:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = toBoolean;
var _assertString = _interopRequireDefault(require("./util/assertString"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
function toBoolean(str, strict) {
  (0, _assertString["default"])(str);
  if (strict) {
    return str === '1' || /^true$/i.test(str);
  }
  return str !== '0' && !/^false$/i.test(str) && str !== '';
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./util/assertString":524}],518:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = toDate;
var _assertString = _interopRequireDefault(require("./util/assertString"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
function toDate(date) {
  (0, _assertString["default"])(date);
  date = Date.parse(date);
  return !isNaN(date) ? new Date(date) : null;
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./util/assertString":524}],519:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = toFloat;
var _isFloat = _interopRequireDefault(require("./isFloat"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
function toFloat(str) {
  if (!(0, _isFloat["default"])(str)) return NaN;
  return parseFloat(str);
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./isFloat":453}],520:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = toInt;
var _assertString = _interopRequireDefault(require("./util/assertString"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
function toInt(str, radix) {
  (0, _assertString["default"])(str);
  return parseInt(str, radix || 10);
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./util/assertString":524}],521:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = trim;
var _rtrim = _interopRequireDefault(require("./rtrim"));
var _ltrim = _interopRequireDefault(require("./ltrim"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
function trim(str, chars) {
  return (0, _rtrim["default"])((0, _ltrim["default"])(str, chars), chars);
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./ltrim":512,"./rtrim":515}],522:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = unescape;
var _assertString = _interopRequireDefault(require("./util/assertString"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
function unescape(str) {
  (0, _assertString["default"])(str);
  return str.replace(/&quot;/g, '"').replace(/&#x27;/g, "'").replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&#x2F;/g, '/').replace(/&#x5C;/g, '\\').replace(/&#96;/g, '`').replace(/&amp;/g, '&');
  // &amp; replacement has to be the last one to prevent
  // bugs with intermediate strings containing escape sequences
  // See: https://github.com/validatorjs/validator.js/issues/1827
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./util/assertString":524}],523:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.iso7064Check = iso7064Check;
exports.luhnCheck = luhnCheck;
exports.reverseMultiplyAndSum = reverseMultiplyAndSum;
exports.verhoeffCheck = verhoeffCheck;
/**
 * Algorithmic validation functions
 * May be used as is or implemented in the workflow of other validators.
 */

/*
 * ISO 7064 validation function
 * Called with a string of numbers (incl. check digit)
 * to validate according to ISO 7064 (MOD 11, 10).
 */
function iso7064Check(str) {
  var checkvalue = 10;
  for (var i = 0; i < str.length - 1; i++) {
    checkvalue = (parseInt(str[i], 10) + checkvalue) % 10 === 0 ? 10 * 2 % 11 : (parseInt(str[i], 10) + checkvalue) % 10 * 2 % 11;
  }
  checkvalue = checkvalue === 1 ? 0 : 11 - checkvalue;
  return checkvalue === parseInt(str[10], 10);
}

/*
 * Luhn (mod 10) validation function
 * Called with a string of numbers (incl. check digit)
 * to validate according to the Luhn algorithm.
 */
function luhnCheck(str) {
  var checksum = 0;
  var second = false;
  for (var i = str.length - 1; i >= 0; i--) {
    if (second) {
      var product = parseInt(str[i], 10) * 2;
      if (product > 9) {
        // sum digits of product and add to checksum
        checksum += product.toString().split('').map(function (a) {
          return parseInt(a, 10);
        }).reduce(function (a, b) {
          return a + b;
        }, 0);
      } else {
        checksum += product;
      }
    } else {
      checksum += parseInt(str[i], 10);
    }
    second = !second;
  }
  return checksum % 10 === 0;
}

/*
 * Reverse TIN multiplication and summation helper function
 * Called with an array of single-digit integers and a base multiplier
 * to calculate the sum of the digits multiplied in reverse.
 * Normally used in variations of MOD 11 algorithmic checks.
 */
function reverseMultiplyAndSum(digits, base) {
  var total = 0;
  for (var i = 0; i < digits.length; i++) {
    total += digits[i] * (base - i);
  }
  return total;
}

/*
 * Verhoeff validation helper function
 * Called with a string of numbers
 * to validate according to the Verhoeff algorithm.
 */
function verhoeffCheck(str) {
  var d_table = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 2, 3, 4, 0, 6, 7, 8, 9, 5], [2, 3, 4, 0, 1, 7, 8, 9, 5, 6], [3, 4, 0, 1, 2, 8, 9, 5, 6, 7], [4, 0, 1, 2, 3, 9, 5, 6, 7, 8], [5, 9, 8, 7, 6, 0, 4, 3, 2, 1], [6, 5, 9, 8, 7, 1, 0, 4, 3, 2], [7, 6, 5, 9, 8, 2, 1, 0, 4, 3], [8, 7, 6, 5, 9, 3, 2, 1, 0, 4], [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]];
  var p_table = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 5, 7, 6, 2, 8, 3, 0, 9, 4], [5, 8, 0, 3, 7, 9, 6, 1, 4, 2], [8, 9, 1, 6, 0, 4, 3, 5, 2, 7], [9, 4, 5, 3, 1, 2, 6, 8, 7, 0], [4, 2, 8, 6, 5, 7, 3, 9, 0, 1], [2, 7, 9, 3, 8, 0, 6, 4, 1, 5], [7, 0, 4, 6, 9, 1, 3, 2, 5, 8]];

  // Copy (to prevent replacement) and reverse
  var str_copy = str.split('').reverse().join('');
  var checksum = 0;
  for (var i = 0; i < str_copy.length; i++) {
    checksum = d_table[checksum][p_table[i % 8][parseInt(str_copy[i], 10)]];
  }
  return checksum === 0;
}

},{}],524:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = assertString;
function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}
function assertString(input) {
  var isString = typeof input === 'string' || input instanceof String;
  if (!isString) {
    var invalidType = _typeof(input);
    if (input === null) invalidType = 'null';else if (invalidType === 'object') invalidType = input.constructor.name;
    throw new TypeError("Expected a string but received a ".concat(invalidType));
  }
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{}],525:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var includes = function includes(arr, val) {
  return arr.some(function (arrVal) {
    return val === arrVal;
  });
};
var _default = exports["default"] = includes;
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{}],526:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = merge;
function merge() {
  var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var defaults = arguments.length > 1 ? arguments[1] : undefined;
  for (var key in defaults) {
    if (typeof obj[key] === 'undefined') {
      obj[key] = defaults[key];
    }
  }
  return obj;
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{}],527:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = multilineRegexp;
/**
 * Build RegExp object from an array
 * of multiple/multi-line regexp parts
 *
 * @param {string[]} parts
 * @param {string} flags
 * @return {object} - RegExp object
 */
function multilineRegexp(parts, flags) {
  var regexpAsStringLiteral = parts.join('');
  return new RegExp(regexpAsStringLiteral, flags);
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{}],528:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = toString;
function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}
function toString(input) {
  if (_typeof(input) === 'object' && input !== null) {
    if (typeof input.toString === 'function') {
      input = input.toString();
    } else {
      input = '[object Object]';
    }
  } else if (input === null || typeof input === 'undefined' || isNaN(input) && !input.length) {
    input = '';
  }
  return String(input);
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{}],529:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = whitelist;
var _assertString = _interopRequireDefault(require("./util/assertString"));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
function whitelist(str, chars) {
  (0, _assertString["default"])(str);
  return str.replace(new RegExp("[^".concat(chars, "]+"), 'g'), '');
}
module.exports = exports["default"];
module.exports["default"] = exports["default"];

},{"./util/assertString":524}],530:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var indexOf = function indexOf(xs, item) {
  if (xs.indexOf) return xs.indexOf(item);else for (var i = 0; i < xs.length; i++) {
    if (xs[i] === item) return i;
  }
  return -1;
};
var Object_keys = function Object_keys(obj) {
  if (Object.keys) return Object.keys(obj);else {
    var res = [];
    for (var key in obj) res.push(key);
    return res;
  }
};
var forEach = function forEach(xs, fn) {
  if (xs.forEach) return xs.forEach(fn);else for (var i = 0; i < xs.length; i++) {
    fn(xs[i], i, xs);
  }
};
var defineProp = function () {
  try {
    Object.defineProperty({}, '_', {});
    return function (obj, name, value) {
      Object.defineProperty(obj, name, {
        writable: true,
        enumerable: false,
        configurable: true,
        value: value
      });
    };
  } catch (e) {
    return function (obj, name, value) {
      obj[name] = value;
    };
  }
}();
var globals = ['Array', 'Boolean', 'Date', 'Error', 'EvalError', 'Function', 'Infinity', 'JSON', 'Math', 'NaN', 'Number', 'Object', 'RangeError', 'ReferenceError', 'RegExp', 'String', 'SyntaxError', 'TypeError', 'URIError', 'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'escape', 'eval', 'isFinite', 'isNaN', 'parseFloat', 'parseInt', 'undefined', 'unescape'];
function Context() {}
Context.prototype = {};
var Script = exports.Script = function NodeScript(code) {
  if (!(this instanceof Script)) return new Script(code);
  this.code = code;
};
Script.prototype.runInContext = function (context) {
  if (!(context instanceof Context)) {
    throw new TypeError("needs a 'context' argument.");
  }
  var iframe = document.createElement('iframe');
  if (!iframe.style) iframe.style = {};
  iframe.style.display = 'none';
  document.body.appendChild(iframe);
  var win = iframe.contentWindow;
  var wEval = win.eval,
    wExecScript = win.execScript;
  if (!wEval && wExecScript) {
    // win.eval() magically appears when this is called in IE:
    wExecScript.call(win, 'null');
    wEval = win.eval;
  }
  forEach(Object_keys(context), function (key) {
    win[key] = context[key];
  });
  forEach(globals, function (key) {
    if (context[key]) {
      win[key] = context[key];
    }
  });
  var winKeys = Object_keys(win);
  var res = wEval.call(win, this.code);
  forEach(Object_keys(win), function (key) {
    // Avoid copying circular objects like `top` and `window` by only
    // updating existing context properties or new properties in the `win`
    // that was only introduced after the eval.
    if (key in context || indexOf(winKeys, key) === -1) {
      context[key] = win[key];
    }
  });
  forEach(globals, function (key) {
    if (!(key in context)) {
      defineProp(context, key, win[key]);
    }
  });
  document.body.removeChild(iframe);
  return res;
};
Script.prototype.runInThisContext = function () {
  return eval(this.code); // maybe...
};
Script.prototype.runInNewContext = function (context) {
  var ctx = Script.createContext(context);
  var res = this.runInContext(ctx);
  if (context) {
    forEach(Object_keys(ctx), function (key) {
      context[key] = ctx[key];
    });
  }
  return res;
};
forEach(Object_keys(Script.prototype), function (name) {
  exports[name] = Script[name] = function (code) {
    var s = Script(code);
    return s[name].apply(s, [].slice.call(arguments, 1));
  };
});
exports.isContext = function (context) {
  return context instanceof Context;
};
exports.createScript = function (code) {
  return exports.Script(code);
};
exports.createContext = Script.createContext = function (context) {
  var copy = new Context();
  if (_typeof(context) === 'object') {
    forEach(Object_keys(context), function (key) {
      copy[key] = context[key];
    });
  }
  return copy;
};

},{}],531:[function(require,module,exports){
"use strict";

var _require = require('@ethersproject/abi'),
  AbiCoder = _require.AbiCoder;
var _require2 = require('./address'),
  address = _require2.address,
  ADDRESS_PREFIX = _require2.ADDRESS_PREFIX,
  ADDRESS_PREFIX_REGEX = _require2.ADDRESS_PREFIX_REGEX;
var _require3 = require('@ethersproject/abi'),
  Interface = _require3.Interface;
var abiCoder = new AbiCoder();
function _isArray(_array) {
  return Array.isArray(_array);
}
function _addressToHex(value) {
  return value.slice(2, value.length);
  // return address.toHex(value).replace(ADDRESS_PREFIX_REGEX, '0x');
}
function deepCopy(target) {
  if (Object.prototype.toString.call(target) !== '[object Object]' && Object.prototype.toString.call(target) !== '[object Array]') {
    return target;
  }
  var newTarget = _isArray(target) ? [] : {};
  Object.keys(target).forEach(function (key) {
    return newTarget[key] = target[key] instanceof Object && !target[key]._isBigNumber ? deepCopy(target[key]) : target[key];
  });
  return newTarget;
}
function decodeParams(names, types, output, ignoreMethodHash) {
  if (!output || typeof output === 'boolean') {
    ignoreMethodHash = output;
    output = types;
    types = names;
    names = [];
  }
  if (ignoreMethodHash && output.replace(/^0x/, '').length % 64 === 8) output = '0x' + output.replace(/^0x/, '').substring(8);
  if (output.replace(/^0x/, '').length % 64) throw new Error('The encoded string is not valid. Its length must be a multiple of 64.');

  // workaround for unsupported srcToken type
  types = types.map(function (type) {
    if (/srcToken/.test(type)) {
      type = type.replace(/srcToken/, 'uint256');
    }
    return type;
  });
  return abiCoder.decode(types, output).reduce(function (obj, arg, index) {
    if (types[index] == 'address') arg = ADDRESS_PREFIX + arg.substr(2).toLowerCase();
    if (names.length) obj[names[index]] = arg;else obj.push(arg);
    return obj;
  }, names.length ? {} : []);
}
function encodeParams(types, values) {
  for (var i = 0; i < types.length; i++) {
    if (types[i] === 'address') {
      values[i] = address.toHex(values[i]).replace(ADDRESS_PREFIX_REGEX, '0x');
    }
  }
  return abiCoder.encode(types, values);
}
function extractSize(type) {
  var size = type.match(/([a-zA-Z0-9])(\[.*\])/);
  return size ? size[2] : '';
}
function extractArrayDim(type) {
  var size = extractSize(type);
  return (size.match(/\]\[/g) || []).length + 1;
}
function encodeParamsV2ByABI(funABI, args) {
  var types = [];
  var buildFullTypeDefinition = function buildFullTypeDefinition(typeDef) {
    if (typeDef && typeDef.type.indexOf('tuple') === 0 && typeDef.components) {
      var innerTypes = typeDef.components.map(function (innerType) {
        return buildFullTypeDefinition(innerType);
      });
      return "tuple(".concat(innerTypes.join(','), ")").concat(extractSize(typeDef.type));
    }
    if (/srcToken/.test(typeDef.type)) return typeDef.type.replace(/srcToken/, 'uint256');
    return typeDef.type;
  };
  var convertTypes = function convertTypes(types) {
    for (var i = 0; i < types.length; i++) {
      var type = types[i];
      if (/srcToken/.test(type)) types[i] = type.replace(/srcToken/, 'uint256');
    }
  };
  var convertAddresses = function convertAddresses(addrArr) {
    if (Array.isArray(addrArr)) {
      addrArr.forEach(function (addrs, i) {
        addrArr[i] = convertAddresses(addrs);
      });
      return addrArr;
    } else {
      return _addressToHex(addrArr);
    }
  };
  var mapTuple = function mapTuple(components, args, dimension) {
    if (dimension > 1) {
      if (args.length) {
        args.forEach(function (arg) {
          mapTuple(components, arg, dimension - 1);
        });
      }
    } else {
      if (args.length && dimension) {
        args.forEach(function (arg) {
          encodeArgs(components, arg);
        });
      }
    }
  };
  var encodeArgs = function encodeArgs() {
    var inputs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var args = arguments.length > 1 ? arguments[1] : undefined;
    if (inputs.length) inputs.forEach(function (input, i) {
      var type = input.type;
      if (args[i]) if (type === 'address') args[i] = _addressToHex(args[i]);else if (type.match(/^([^\x5b]*)(\x5b|$)/)[0] === 'address[') convertAddresses(args[i]);else if (type.indexOf('tuple') === 0) if (extractSize(type)) {
        var dimension = extractArrayDim(type);
        mapTuple(input.components, args[i], dimension);
      } else encodeArgs(input.components, args[i]);
    });
  };
  if (funABI.inputs && funABI.inputs.length) {
    for (var i = 0; i < funABI.inputs.length; i++) {
      var type = funABI.inputs[i].type;
      // "false" will be converting to `false` and "true" will be working
      // fine as abiCoder assume anything in quotes as `true`
      if (type === 'bool' && args[i] === 'false') {
        args[i] = false;
      }
      types.push(type.indexOf('tuple') === 0 ? buildFullTypeDefinition(funABI.inputs[i]) : type);
      if (args.length < types.length) {
        args.push('');
      }
    }
  }
  encodeArgs(funABI.inputs, args);
  convertTypes(types);
  var iface = new Interface([funABI]);
  var abiData = iface.encodeFunctionData(funABI.name, args);
  return abiData;
}
function decodeParamsV2ByABI(funABI, data) {
  var convertTypeNames = function convertTypeNames(types) {
    for (var i = 0; i < types.length; i++) {
      var type = types[i];
      if (/^srcToken/.test(type)) types[i] = type.replace(/^srcToken/, 'uint256');
    }
  };
  var convertAddresses = function convertAddresses(addrArr) {
    if (Array.isArray(addrArr)) {
      addrArr.forEach(function (addrs, i) {
        addrArr[i] = convertAddresses(addrs);
      });
      return addrArr;
    } else {
      return address.toHex(addrArr);
    }
  };
  var mapTuple = function mapTuple(components, args, dimension) {
    if (dimension > 1) {
      if (args.length) {
        args.forEach(function (arg) {
          mapTuple(components, arg, dimension - 1);
        });
      }
    } else {
      if (args.length && dimension) {
        args.forEach(function (arg) {
          decodeResult(components, arg);
        });
      }
    }
  };
  var buildFullTypeNameDefinition = function buildFullTypeNameDefinition(typeDef) {
    var name = typeDef.name ? " ".concat(typeDef.name) : '';
    if (typeDef && typeDef.type.indexOf('tuple') === 0 && typeDef.components) {
      var innerTypes = typeDef.components.map(function (innerType) {
        return buildFullTypeNameDefinition(innerType);
      });
      return "tuple(".concat(innerTypes.join(','), ")").concat(extractSize(typeDef.type)).concat(name);
    }
    if (/srcToken/.test(typeDef.type)) return typeDef.type.replace(/srcToken/, 'uint256') + name;
    return typeDef.type + name;
  };
  var decodeResult = function decodeResult() {
    var outputs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var result = arguments.length > 1 ? arguments[1] : undefined;
    if (outputs.length) outputs.forEach(function (output, i) {
      var type = output.type,
        name = output.name;
      if (result[i]) if (type === 'address') {
        result[i] = address.toHex(result[i]);
        if (name) result[name] = address.toHex(result[name]);
      } else if (type.match(/^([^\x5b]*)(\x5b|$)/)[0] === 'address[') {
        convertAddresses(result[i]);
        if (name) convertAddresses(result[name]);
      } else if (type.indexOf('tuple') === 0) {
        if (extractSize(type)) {
          var dimension = extractArrayDim(type);
          mapTuple(output.components, result[i], dimension);
        } else decodeResult(output.components, result[i]);
        if (name) result[name] = result[i];
      }
    });
  };

  // Only decode if there supposed to be fields
  if (funABI.outputs && funABI.outputs.length > 0) {
    var outputTypes = [];
    for (var i = 0; i < funABI.outputs.length; i++) {
      var type = funABI.outputs[i].type;
      var name = funABI.outputs[i].name ? " ".concat(funABI.outputs[i].name) : '';
      outputTypes.push(type.indexOf('tuple') === 0 ? buildFullTypeNameDefinition(funABI.outputs[i]) : type + name);
    }
    convertTypeNames(outputTypes);
    if (!data || !data.length) data = new Uint8Array(32 * funABI.outputs.length); // ensuring the data is at least filled by 0 cause `AbiCoder` throws if there's not engouh data
    // decode data
    var decodeRes = abiCoder.decode(outputTypes, data);
    var decodeResCopy = deepCopy(decodeRes);
    decodeResult(funABI.outputs, decodeResCopy);
    return decodeResCopy;
  }
  return [];
}
module.exports = {
  decodeParams: decodeParams,
  encodeParams: encodeParams,
  encodeParamsV2ByABI: encodeParamsV2ByABI,
  decodeParamsV2ByABI: decodeParamsV2ByABI
};

},{"./address":532,"@ethersproject/abi":16}],532:[function(require,module,exports){
"use strict";

var ADDRESS_SIZE = 34;
var ADDRESS_PREFIX = "41";
var ADDRESS_PREFIX_BYTE = 0x41;
var ADDRESS_PREFIX_REGEX = /^(41)/;
var SCDO_BIP39_PATH_PREFIX = "m/44'/195'";
var SCDO_BIP39_PATH_INDEX_0 = SCDO_BIP39_PATH_PREFIX + "/0'/0/0";
var utils = require('./utils'); // utils

var address = {
  fromHex: function fromHex(address) {
    if (!utils.isHex(address)) return address;
    return utils.crypto.getBase58CheckAddress(utils.code.hexStr2byteArray(address.replace(/^0x/, ADDRESS_PREFIX)));
  },
  toHex: function toHex(address) {
    if (utils.isHex(address)) return address.toLowerCase().replace(/^0x/, ADDRESS_PREFIX);
    return utils.code.byteArray2hexStr(utils.crypto.decodeBase58Address(address)).toLowerCase();
  },
  fromPrivateKey: function fromPrivateKey(privateKey) {
    var strict = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    try {
      return utils.crypto.pkToAddress(privateKey, strict);
    } catch (_unused) {
      return false;
    }
  }
};
module.exports = {
  ADDRESS_SIZE: ADDRESS_SIZE,
  ADDRESS_PREFIX: ADDRESS_PREFIX,
  ADDRESS_PREFIX_BYTE: ADDRESS_PREFIX_BYTE,
  ADDRESS_PREFIX_REGEX: ADDRESS_PREFIX_REGEX,
  SCDO_BIP39_PATH_PREFIX: SCDO_BIP39_PATH_PREFIX,
  SCDO_BIP39_PATH_INDEX_0: SCDO_BIP39_PATH_INDEX_0,
  address: address
};

},{"./utils":546}],533:[function(require,module,exports){
"use strict";

function Base64() {
  var _this = this;
  this._keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
  this.encode = function (input) {
    var output = "";
    var chr1;
    var chr2;
    var chr3;
    var enc1;
    var enc2;
    var enc3;
    var enc4;
    var i = 0;
    while (i < input.length) {
      chr1 = input.charCodeAt(i++);
      chr2 = input.charCodeAt(i++);
      chr3 = input.charCodeAt(i++);
      enc1 = chr1 >> 2;
      enc2 = (chr1 & 3) << 4 | chr2 >> 4;
      enc3 = (chr2 & 15) << 2 | chr3 >> 6;
      enc4 = chr3 & 63;
      if (isNaN(chr2)) enc3 = enc4 = 64;else if (isNaN(chr3)) enc4 = 64;
      output = output + _this._keyStr.charAt(enc1) + _this._keyStr.charAt(enc2) + _this._keyStr.charAt(enc3) + _this._keyStr.charAt(enc4);
    }
    return output;
  };
  this.encodeIgnoreUtf8 = function (inputBytes) {
    var output = "";
    var chr1;
    var chr2;
    var chr3;
    var enc1;
    var enc2;
    var enc3;
    var enc4;
    var i = 0;
    while (i < inputBytes.length) {
      chr1 = inputBytes[i++];
      chr2 = inputBytes[i++];
      chr3 = inputBytes[i++];
      enc1 = chr1 >> 2;
      enc2 = (chr1 & 3) << 4 | chr2 >> 4;
      enc3 = (chr2 & 15) << 2 | chr3 >> 6;
      enc4 = chr3 & 63;
      if (isNaN(chr2)) enc3 = enc4 = 64;else if (isNaN(chr3)) enc4 = 64;
      output = output + _this._keyStr.charAt(enc1) + _this._keyStr.charAt(enc2) + _this._keyStr.charAt(enc3) + _this._keyStr.charAt(enc4);
    }
    return output;
  };
  this.decode = function (input) {
    var output = "";
    var chr1;
    var chr2;
    var chr3;
    var enc1;
    var enc2;
    var enc3;
    var enc4;
    var i = 0;
    input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
    while (i < input.length) {
      enc1 = _this._keyStr.indexOf(input.charAt(i++));
      enc2 = _this._keyStr.indexOf(input.charAt(i++));
      enc3 = _this._keyStr.indexOf(input.charAt(i++));
      enc4 = _this._keyStr.indexOf(input.charAt(i++));
      chr1 = enc1 << 2 | enc2 >> 4;
      chr2 = (enc2 & 15) << 4 | enc3 >> 2;
      chr3 = (enc3 & 3) << 6 | enc4;
      output = output + String.fromCharCode(chr1);
      if (enc3 != 64) output = output + String.fromCharCode(chr2);
      if (enc4 != 64) output = output + String.fromCharCode(chr3);
    }
    return _this._utf8_decode(output);
  };
  this.decodeToByteArray = function (input) {
    var output = "";
    var chr1;
    var chr2;
    var chr3;
    var enc1;
    var enc2;
    var enc3;
    var enc4;
    var i = 0;
    input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
    while (i < input.length) {
      enc1 = _this._keyStr.indexOf(input.charAt(i++));
      enc2 = _this._keyStr.indexOf(input.charAt(i++));
      enc3 = _this._keyStr.indexOf(input.charAt(i++));
      enc4 = _this._keyStr.indexOf(input.charAt(i++));
      chr1 = enc1 << 2 | enc2 >> 4;
      chr2 = (enc2 & 15) << 4 | enc3 >> 2;
      chr3 = (enc3 & 3) << 6 | enc4;
      output = output + String.fromCharCode(chr1);
      if (enc3 != 64) output = output + String.fromCharCode(chr2);
      if (enc4 != 64) output = output + String.fromCharCode(chr3);
    }
    return _this._out2ByteArray(output);
  };
  this._out2ByteArray = function (utftext) {
    var byteArray = new Array(utftext.length);
    var i = 0;
    var c = 0;
    while (i < utftext.length) {
      c = utftext.charCodeAt(i);
      byteArray[i] = c;
      i++;
    }
    return byteArray;
  };
  this._utf8_encode = function (string) {
    string = string.replace(/\r\n/g, "\n");
    var utftext = "";
    for (var n = 0; n < string.length; n++) {
      var c = string.charCodeAt(n);
      if (c < 128) {
        utftext += String.fromCharCode(c);
      } else if (c > 127 && c < 2048) {
        utftext += String.fromCharCode(c >> 6 | 192);
        utftext += String.fromCharCode(c & 63 | 128);
      } else {
        utftext += String.fromCharCode(c >> 12 | 224);
        utftext += String.fromCharCode(c >> 6 & 63 | 128);
        utftext += String.fromCharCode(c & 63 | 128);
      }
    }
    return utftext;
  };
  this._utf8_decode = function (utftext) {
    var string = "";
    var i = 0;
    var c = 0;
    var c2 = 0;
    var c3 = 0;
    while (i < utftext.length) {
      c = utftext.charCodeAt(i);
      if (c < 128) {
        string += String.fromCharCode(c);
        i++;
      } else if (c > 191 && c < 224) {
        c2 = utftext.charCodeAt(i + 1);
        string += String.fromCharCode((c & 31) << 6 | c2 & 63);
        i += 2;
      } else {
        c2 = utftext.charCodeAt(i + 1);
        c3 = utftext.charCodeAt(i + 2);
        string += String.fromCharCode((c & 15) << 12 | (c2 & 63) << 6 | c3 & 63);
        i += 3;
      }
    }
    return string;
  };
}
module.exports = Base64;

},{}],534:[function(require,module,exports){
"use strict";

var _require = require('./base64'),
  Base64 = _require.Base64;
function byte2hexStr(_byte) {
  if (typeof _byte !== 'number') throw new Error('Input must be a number');
  if (_byte < 0 || _byte > 255) throw new Error('Input must be a byte');
  var hexByteMap = '0123456789ABCDEF';
  var str = '';
  str += hexByteMap.charAt(_byte >> 4);
  str += hexByteMap.charAt(_byte & 0x0f);
  return str;
}
function bytesToString(arr) {
  if (typeof arr === 'string') return arr;
  var str = '';
  for (var i = 0; i < arr.length; i++) {
    var one = arr[i].toString(2);
    var v = one.match(/^1+?(?=0)/);
    if (v && one.length === 8) {
      var bytesLength = v[0].length;
      var store = arr[i].toString(2).slice(7 - bytesLength);
      for (var st = 1; st < bytesLength; st++) store += arr[st + i].toString(2).slice(2);
      str += String.fromCharCode(parseInt(store, 2));
      i += bytesLength - 1;
    } else {
      str += String.fromCharCode(arr[i]);
    }
  }
  return str;
}
function hextoString(hex) {
  var arr = hex.replace(/^0x/, '').split('');
  var out = '';
  for (var i = 0; i < arr.length / 2; i++) {
    var tmp = "0x".concat(arr[i * 2]).concat(arr[i * 2 + 1]);
    out += String.fromCharCode(tmp);
  }
  return out;
}
function byteArray2hexStr(byteArray) {
  var str = '';
  for (var i = 0; i < byteArray.length; i++) str += byte2hexStr(byteArray[i]);
  return str;
}
function base64DecodeFromString(string64) {
  return new Base64().decodeToByteArray(string64);
}
function base64EncodeToString(bytes) {
  var b = new Base64();
  var string64 = b.encodeIgnoreUtf8(bytes);
  return string64;
}
module.exports = {
  byte2hexStr: byte2hexStr,
  bytesToString: bytesToString,
  hextoString: hextoString,
  byteArray2hexStr: byteArray2hexStr,
  base64DecodeFromString: base64DecodeFromString,
  base64EncodeToString: base64EncodeToString
};

},{"./base64":533}],535:[function(require,module,exports){
"use strict";

var _require = require('./bytes'),
  byte2hexStr = _require.byte2hexStr,
  bytesToString = _require.bytesToString,
  hextoString = _require.hextoString,
  byteArray2hexStr = _require.byteArray2hexStr,
  base64DecodeFromString = _require.base64DecodeFromString,
  base64EncodeToString = _require.base64EncodeToString;
function bin2String(array) {
  // TODO Do we need this alias?
  return bytesToString(array);
}
function arrayEquals(array1, array2, strict) {
  if (array1.length != array2.length) return false;
  var i;
  for (i = 0; i < array1.length; i++) {
    if (strict) {
      if (array1[i] != array2[i]) return false;
    } else if (JSON.stringify(array1[i]) != JSON.stringify(array2[i])) return false;
  }
  return true;
}
function stringToBytes(str) {
  if (typeof str !== 'string') throw new Error('The passed string is not a string');
  var bytes = new Array();
  var len;
  var c;
  len = str.length;
  for (var i = 0; i < len; i++) {
    c = str.charCodeAt(i);
    if (c >= 0x010000 && c <= 0x10FFFF) {
      bytes.push(c >> 18 & 0x07 | 0xF0);
      bytes.push(c >> 12 & 0x3F | 0x80);
      bytes.push(c >> 6 & 0x3F | 0x80);
      bytes.push(c & 0x3F | 0x80);
    } else if (c >= 0x000800 && c <= 0x00FFFF) {
      bytes.push(c >> 12 & 0x0F | 0xE0);
      bytes.push(c >> 6 & 0x3F | 0x80);
      bytes.push(c & 0x3F | 0x80);
    } else if (c >= 0x000080 && c <= 0x0007FF) {
      bytes.push(c >> 6 & 0x1F | 0xC0);
      bytes.push(c & 0x3F | 0x80);
    } else bytes.push(c & 0xFF);
  }
  return bytes;
}
function hexChar2byte(c) {
  var d;
  if (c >= 'A' && c <= 'F') d = c.charCodeAt(0) - 'A'.charCodeAt(0) + 10;else if (c >= 'a' && c <= 'f') d = c.charCodeAt(0) - 'a'.charCodeAt(0) + 10;else if (c >= '0' && c <= '9') d = c.charCodeAt(0) - '0'.charCodeAt(0);
  if (typeof d === 'number') return d;else throw new Error('The passed hex char is not a valid hex char');
}
function isHexChar(c) {
  if (c >= 'A' && c <= 'F' || c >= 'a' && c <= 'f' || c >= '0' && c <= '9') {
    return 1;
  }
  return 0;
}

// set strict as true: if the length of str is odd, add 0 before the str to make its length as even
function hexStr2byteArray(str) {
  var strict = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  if (typeof str !== 'string') throw new Error('The passed string is not a string');
  var len = str.length;
  if (strict) {
    if (len % 2) {
      str = "0".concat(str);
      len++;
    }
  }
  var byteArray = Array();
  var d = 0;
  var j = 0;
  var k = 0;
  for (var i = 0; i < len; i++) {
    var c = str.charAt(i);
    if (isHexChar(c)) {
      d <<= 4;
      d += hexChar2byte(c);
      j++;
      if (0 === j % 2) {
        byteArray[k++] = d;
        d = 0;
      }
    } else throw new Error('The passed hex char is not a valid hex string');
  }
  return byteArray;
}

//yyyy-MM-DD HH-mm-ss
function strToDate(str) {
  if (!/^\d{4}-\d{2}-\d{2}( \d{2}-\d{2}-\d{2}|)/.test(str)) throw new Error('The passed date string is not valid');
  var tempStrs = str.split(" ");
  var dateStrs = tempStrs[0].split("-");
  var year = parseInt(dateStrs[0], 10);
  var month = parseInt(dateStrs[1], 10) - 1;
  var day = parseInt(dateStrs[2], 10);
  if (tempStrs.length > 1) {
    var timeStrs = tempStrs[1].split("-");
    var hour = parseInt(timeStrs[0], 10);
    var minute = parseInt(timeStrs[1], 10);
    var second = parseInt(timeStrs[2], 10);
    return new Date(year, month, day, hour, minute, second);
  }
  return new Date(year, month, day);
}
function isNumber(c) {
  if (c >= '0' && c <= '9') return 1;
  return 0;
}

//return 1: address  --- 20Bytes HexString
//return 2: blockNumber ------ Decimal number
//return 3: assetName ------ String
//return other: error
function getStringType(str) {
  if (null == str) return -1;
  if (typeof str != 'string') return -1;
  if (str.length == 0 || str == "") return -1;
  var i = 0;

  // TODO Should we return 1 if someone passes a full, 42-chars long address?
  // if (str.length == 42 && /^41/.test(str)) {
  //     for (; i < 40; i++) {
  //         var c = str.charAt(i+2);
  //
  //         if (!isHexChar(c))
  //             break;
  //     }
  // } else
  if (str.length == 40) {
    for (; i < 40; i++) {
      var c = str.charAt(i);
      if (!isHexChar(c)) break;
    }
  }
  if (i == 40) return 1; //40 Hex, Address

  for (i = 0; i < str.length; i++) {
    var c = str.charAt(i);
    if (!isNumber(c)) break;
  }
  if (i == str.length) return 2; // All Decimal number, BlockNumber

  for (i = 0; i < str.length; i++) {
    var c = str.charAt(i);
    if (c > ' ') return 3; // At least one visible character
  }
  return -1;
}

// 
module.exports = {
  bin2String: bin2String,
  arrayEquals: arrayEquals,
  stringToBytes: stringToBytes,
  byte2hexStr: byte2hexStr,
  bytesToString: bytesToString,
  hextoString: hextoString,
  byteArray2hexStr: byteArray2hexStr,
  base64DecodeFromString: base64DecodeFromString,
  base64EncodeToString: base64EncodeToString,
  hexChar2byte: hexChar2byte,
  isHexChar: isHexChar,
  hexStr2byteArray: hexStr2byteArray,
  strToDate: strToDate,
  isNumber: isNumber,
  getStringType: getStringType
};

},{"./bytes":534}],536:[function(require,module,exports){
"use strict";

var commands = module.exports.commands = {
  "scdo": ['getInfo', 'getBalance', 'addTx', 'getAccountNonce', 'getBlockHeight', 'getBlock', 'getBlockByHash', 'getBlockByHeight', 'call', 'getLogs', 'getCode', 'generatePayload', 'estimateGas', 'getBlockTransactionCount', 'getBlockTransactionCountByHeight', 'getBlockTransactionCountByHash', 'getTransactionByBlockIndex', 'getTransactionByBlockHeightAndIndex', 'getTransactionByBlockHashAndIndex', 'getReceiptByTxHash', 'getTransactionsFrom', 'getTransactionsTo', 'getAccountTransactions', 'getBlockTransactions', 'getBlockTransactionsByHeight', 'getBlockTransactionsByHash', 'requestAccounts', 'sendTransaction', 'signTransaction', 'signMessage', 'ecRecover'],
  "txpool": ['getTransactionByHash', 'getDebtByHash', 'getGasPrice', 'getTxPoolContent', 'getTxPoolTxCount', 'getPendingTransactions', 'getPendingDebts'],
  "download": ['getStatus', 'isSyncing'],
  "network": ['getPeersInfo', 'getPeerCount', 'getNetVersion', 'getProtocolVersion', 'getNetworkID', 'isListening'],
  "monitor": ['nodeInfo', 'nodeStats']
};
module.exports.isCommand = function (command) {
  for (var namespace in commands) {
    for (var key in commands[namespace]) {
      if (commands[namespace][key] === command) {
        return true;
      }
    }
  }
};
module.exports.getNamespace = function (command) {
  for (var namespace in commands) {
    for (var key in commands[namespace]) {
      if (commands[namespace][key] === command) {
        return namespace;
      }
    }
  }
};

},{}],537:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var utils = require('../index');
var Method = require('./method');
var injectpromise = require('injectpromise');
var Contract = /*#__PURE__*/function () {
  function Contract() {
    var scdo = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    var abi = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    var address = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    _classCallCheck(this, Contract);
    this.scdo = scdo;
    this.injectPromise = injectpromise(this);
    this.address = address;
    this.abi = abi;
    this.eventListener = false;
    this.bytecode = false;
    this.deployed = false;
    this.lastBlock = false;
    this.methods = {};
    this.methodInstances = {};
    this.props = [];
    if (this.scdo.util.isAddress(address)) this.deployed = true;else this.address = false;

    // this.loadAbi(abi);
  }
  return _createClass(Contract, [{
    key: "_getEvents",
    value: function () {
      var _getEvents2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var _this = this;
        var options,
          events,
          _events$sort,
          _events$sort2,
          latestEvent,
          newEvents,
          _args = arguments;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              options = _args.length > 0 && _args[0] !== undefined ? _args[0] : {};
              _context.next = 3;
              return this.scdo.util.event.getEventsByContractAddress(this.address, options);
            case 3:
              events = _context.sent;
              _events$sort = events.sort(function (a, b) {
                return b.block - a.block;
              }), _events$sort2 = _slicedToArray(_events$sort, 1), latestEvent = _events$sort2[0];
              newEvents = events.filter(function (event, index) {
                if (options.resourceNode && event.resourceNode && options.resourceNode.toLowerCase() !== event.resourceNode.toLowerCase()) {
                  return false;
                }
                var duplicate = events.slice(0, index).some(function (priorEvent) {
                  return JSON.stringify(priorEvent) == JSON.stringify(event);
                });
                if (duplicate) return false;
                if (!_this.lastBlock) return true;
                return event.block > _this.lastBlock;
              });
              if (latestEvent) this.lastBlock = latestEvent.block;
              return _context.abrupt("return", newEvents);
            case 8:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function _getEvents() {
        return _getEvents2.apply(this, arguments);
      }
      return _getEvents;
    }()
  }, {
    key: "_startEventListener",
    value: function () {
      var _startEventListener2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        var _this2 = this;
        var options,
          callback,
          _args2 = arguments;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              options = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : {};
              callback = _args2.length > 1 ? _args2[1] : undefined;
              if (utils.isFunction(options)) {
                callback = options;
                options = {};
              }
              if (this.eventListener) clearInterval(this.eventListener);
              if (this.scdo.util.eventServer) {
                _context2.next = 6;
                break;
              }
              throw new Error('Event server is not configured');
            case 6:
              if (this.address) {
                _context2.next = 8;
                break;
              }
              throw new Error('Contract is not configured with an address');
            case 8:
              this.eventCallback = callback;
              _context2.next = 11;
              return this._getEvents(options);
            case 11:
              this.eventListener = setInterval(function () {
                _this2._getEvents(options).then(function (newEvents) {
                  return newEvents.forEach(function (event) {
                    _this2.eventCallback && _this2.eventCallback(event);
                  });
                })["catch"](function (err) {
                  console.error('Failed to get event list', err);
                });
              }, 3000);
            case 12:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function _startEventListener() {
        return _startEventListener2.apply(this, arguments);
      }
      return _startEventListener;
    }()
  }, {
    key: "_stopEventListener",
    value: function _stopEventListener() {
      if (!this.eventListener) return;
      clearInterval(this.eventListener);
      this.eventListener = false;
      this.eventCallback = false;
    }
  }, {
    key: "hasProperty",
    value: function hasProperty(property) {
      return this.hasOwnProperty(property) || this.__proto__.hasOwnProperty(property);
    }
  }, {
    key: "loadAbi",
    value: function loadAbi(abi, address) {
      var _this3 = this;
      try {
        this.abi = JSON.parse(abi);
      } catch (e) {
        console.error("Invalid JSON string");
      }
      this.address = address;
      this.methods = {};
      this.props.forEach(function (prop) {
        return delete _this3[prop];
      });
      this.abi.forEach(function (func) {
        // Don't build a method for constructor function. That's handled through contract create.
        // Don't build a method for error function.
        if (!func.type || /constructor|error/i.test(func.type)) return;
        var method = new Method(_this3, func);
        var methodCall = method.onMethod.bind(method);
        var name = method.name,
          functionSelector = method.functionSelector,
          signature = method.signature;
        _this3.methods[name] = methodCall;
        _this3.methods[functionSelector] = methodCall;
        _this3.methods[signature] = methodCall;
        _this3.methodInstances[name] = method;
        _this3.methodInstances[functionSelector] = method;
        _this3.methodInstances[signature] = method;
        if (!_this3.hasProperty(name)) {
          _this3[name] = methodCall;
          _this3.props.push(name);
        }
        if (!_this3.hasProperty(functionSelector)) {
          _this3[functionSelector] = methodCall;
          _this3.props.push(functionSelector);
        }
        if (!_this3.hasProperty(signature)) {
          _this3[signature] = methodCall;
          _this3.props.push(signature);
        }
      });
      return _objectSpread({}, this);
    }
  }, {
    key: "decodeInput",
    value: function decodeInput(data) {
      var methodName = data.substring(0, 8);
      var inputData = data.substring(8);
      if (!this.methodInstances[methodName]) throw new Error('Contract method ' + methodName + " not found");
      var methodInstance = this.methodInstances[methodName];
      return {
        name: methodInstance.name,
        params: this.methodInstances[methodName].decodeInput(inputData)
      };
    }
  }, {
    key: "new",
    value: function () {
      var _new2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(options) {
        var privateKey,
          callback,
          address,
          transaction,
          signedTransaction,
          contract,
          _args3 = arguments;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              privateKey = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : this.scdo.util.defaultPrivateKey;
              callback = _args3.length > 2 && _args3[2] !== undefined ? _args3[2] : false;
              if (utils.isFunction(privateKey)) {
                callback = privateKey;
                privateKey = this.scdo.util.defaultPrivateKey;
              }
              if (callback) {
                _context3.next = 5;
                break;
              }
              return _context3.abrupt("return", this.injectPromise(this["new"], options, privateKey));
            case 5:
              _context3.prev = 5;
              address = this.scdo.util.address.fromPrivateKey(privateKey);
              _context3.next = 9;
              return this.scdo.util.transactionBuilder.createSmartContract(options, address);
            case 9:
              transaction = _context3.sent;
              _context3.next = 12;
              return this.scdo.util.trx.sign(transaction, privateKey);
            case 12:
              signedTransaction = _context3.sent;
              _context3.next = 15;
              return this.scdo.util.trx.sendRawTransaction(signedTransaction);
            case 15:
              contract = _context3.sent;
              if (!contract.code) {
                _context3.next = 18;
                break;
              }
              return _context3.abrupt("return", callback({
                error: contract.code,
                message: this.scdo.util.toUtf8(contract.message)
              }));
            case 18:
              _context3.next = 20;
              return utils.sleep(3000);
            case 20:
              return _context3.abrupt("return", this.at(signedTransaction.contract_address, callback));
            case 23:
              _context3.prev = 23;
              _context3.t0 = _context3["catch"](5);
              return _context3.abrupt("return", callback(_context3.t0));
            case 26:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this, [[5, 23]]);
      }));
      function _new(_x) {
        return _new2.apply(this, arguments);
      }
      return _new;
    }()
  }, {
    key: "at",
    value: function () {
      var _at = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(contractAddress) {
        var callback,
          contract,
          _args4 = arguments;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              callback = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : false;
              if (callback) {
                _context4.next = 3;
                break;
              }
              return _context4.abrupt("return", this.injectPromise(this.at, contractAddress));
            case 3:
              _context4.prev = 3;
              _context4.next = 6;
              return this.scdo.util.trx.getContract(contractAddress);
            case 6:
              contract = _context4.sent;
              if (contract.contract_address) {
                _context4.next = 9;
                break;
              }
              return _context4.abrupt("return", callback('Unknown error: ' + JSON.stringify(contract, null, 2)));
            case 9:
              this.address = contract.contract_address;
              this.bytecode = contract.bytecode;
              this.deployed = true;
              this.loadAbi(contract.abi ? contract.abi.entrys ? contract.abi.entrys : [] : []);
              return _context4.abrupt("return", callback(null, this));
            case 16:
              _context4.prev = 16;
              _context4.t0 = _context4["catch"](3);
              if (!_context4.t0.toString().includes('does not exist')) {
                _context4.next = 20;
                break;
              }
              return _context4.abrupt("return", callback('Contract has not been deployed on the network'));
            case 20:
              return _context4.abrupt("return", callback(_context4.t0));
            case 21:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this, [[3, 16]]);
      }));
      function at(_x2) {
        return _at.apply(this, arguments);
      }
      return at;
    }()
  }, {
    key: "events",
    value: function events() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      if (utils.isFunction(options)) {
        callback = options;
        options = {};
      }
      if (!utils.isFunction(callback)) throw new Error('Callback function expected');
      var self = this;
      return {
        start: function start() {
          var startCallback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
          if (!startCallback) {
            self._startEventListener(options, callback);
            return this;
          }
          self._startEventListener(options, callback).then(function () {
            startCallback();
          })["catch"](function (err) {
            startCallback(err);
          });
          return this;
        },
        stop: function stop() {
          self._stopEventListener();
        }
      };
    }
  }]);
}();
module.exports = Contract;

},{"../index":541,"./method":538,"injectpromise":328}],538:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var utils = require('../index');
var _require = require('../abi'),
  encodeParamsV2ByABI = _require.encodeParamsV2ByABI,
  decodeParamsV2ByABI = _require.decodeParamsV2ByABI;
var injectpromise = require('injectpromise');
var _require2 = require('@ethersproject/abi'),
  Interface = _require2.Interface;
var getFunctionSelector = function getFunctionSelector(abi) {
  abi.stateMutability = abi.stateMutability ? abi.stateMutability.toLowerCase() : 'nonpayable';
  abi.type = abi.type ? abi.type.toLowerCase() : '';
  if (abi.type === 'fallback' || abi.type === 'receive') return '0x';
  var iface = new utils.ethersUtils.Interface([abi]);
  if (abi.type === 'event') {
    return iface.getEvent(abi.name).format(utils.ethersUtils.FormatTypes.sighash);
  }
  return iface.getFunction(abi.name).format(utils.ethersUtils.FormatTypes.sighash);
};
var decodeOutput = function decodeOutput(abi, output) {
  return decodeParamsV2ByABI(abi, output);
};
var Method = /*#__PURE__*/function () {
  function Method(contract, abi) {
    _classCallCheck(this, Method);
    this.scdo = contract.scdo;
    this.contract = contract;
    this.abi = abi;
    this.name = abi.name || (abi.name = abi.type);
    this.inputs = abi.inputs || [];
    this.outputs = abi.outputs || [];
    this.functionSelector = getFunctionSelector(abi);
    this.signature = this.scdo.util.sha3(this.functionSelector, false).slice(0, 8);
    this.injectPromise = injectpromise(this);
    this.defaultOptions = {
      feeLimit: this.scdo.util.feeLimit,
      callValue: 0,
      userFeePercentage: 100,
      shouldPollResponse: false // Only used for sign()
    };
  }
  return _createClass(Method, [{
    key: "decodeInput",
    value: function decodeInput(data) {
      return decodeOutput(this.inputs, '0x' + data);
    }
  }, {
    key: "onMethod",
    value: function onMethod() {
      var _this = this;
      var rawParameter = '';
      if (this.abi && !/event/i.test(this.abi.type)) {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        rawParameter = encodeParamsV2ByABI(this.abi, args);
      }
      return {
        call: function call() {
          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          options = _objectSpread(_objectSpread({}, options), {}, {
            rawParameter: rawParameter
          });
          return _this._call(options);
        },
        send: function send() {
          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          options = _objectSpread(_objectSpread({}, options), {}, {
            rawParameter: rawParameter
          });
          return _this._send(options);
        },
        watch: function watch() {
          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          return _this._watch(options);
        },
        encodeAbi: function encodeAbi() {
          return rawParameter;
        }
      };
    }
  }, {
    key: "_call",
    value: function () {
      var _call2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var options,
          stateMutability,
          result,
          _args = arguments;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              options = _args.length > 0 && _args[0] !== undefined ? _args[0] : {};
              this.check();
              stateMutability = this.abi.stateMutability;
              if (['pure', 'view'].includes(stateMutability.toLowerCase())) {
                _context.next = 5;
                break;
              }
              throw new Error("Methods with state mutability \"".concat(stateMutability, "\" must use send()"));
            case 5:
              _context.next = 7;
              return this.scdo.client.call(this.contract.address, options.rawParameter, -1);
            case 7:
              result = _context.sent;
              return _context.abrupt("return", decodeOutput(this.abi, result.result));
            case 9:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function _call() {
        return _call2.apply(this, arguments);
      }
      return _call;
    }()
  }, {
    key: "_send",
    value: function () {
      var _send2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        var options,
          stateMutability,
          transaction,
          _i,
          _Object$entries,
          _Object$entries$_i,
          key,
          value,
          result,
          _args2 = arguments;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              options = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : {};
              this.check();
              stateMutability = this.abi.stateMutability;
              if (!['pure', 'view'].includes(stateMutability.toLowerCase())) {
                _context2.next = 5;
                break;
              }
              throw new Error("Methods with state mutability \"".concat(stateMutability, "\" must use call()"));
            case 5:
              transaction = {
                "to": this.contract.address,
                "payload": options.rawParameter
              };
              _i = 0, _Object$entries = Object.entries(options);
            case 7:
              if (!(_i < _Object$entries.length)) {
                _context2.next = 15;
                break;
              }
              _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2), key = _Object$entries$_i[0], value = _Object$entries$_i[1];
              if (!(key === 'rawParameter')) {
                _context2.next = 11;
                break;
              }
              return _context2.abrupt("continue", 12);
            case 11:
              transaction[key] = value;
            case 12:
              _i++;
              _context2.next = 7;
              break;
            case 15:
              _context2.next = 17;
              return this.scdo.client.sendTransaction(transaction);
            case 17:
              result = _context2.sent;
              return _context2.abrupt("return", result);
            case 19:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function _send() {
        return _send2.apply(this, arguments);
      }
      return _send;
    }()
  }, {
    key: "_watch",
    value: function () {
      var _watch2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
        var options,
          height,
          result,
          _args3 = arguments;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              options = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : {};
              this.check();
              height = options.height || -1;
              if (!(!this.abi.type || !/event/i.test(this.abi.type))) {
                _context3.next = 5;
                break;
              }
              throw new Error('Invalid method type for event watching');
            case 5:
              _context3.next = 7;
              return this.scdo.client.getLogs(height, this.contract.address, this.abi, this.name);
            case 7:
              result = _context3.sent;
              return _context3.abrupt("return", result);
            case 9:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function _watch() {
        return _watch2.apply(this, arguments);
      }
      return _watch;
    }()
  }, {
    key: "check",
    value: function check() {
      if (!this.contract.address) throw new Error('Smart contract is missing address');
    }
  }]);
}();
module.exports = Method;

},{"../abi":531,"../index":541,"@ethersproject/abi":16,"injectpromise":328}],539:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";

var _require = require('ethers'),
  keccak256 = _require.keccak256,
  sha256 = _require.sha256,
  toUtf8Bytes = _require.toUtf8Bytes,
  toUtf8String = _require.toUtf8String,
  recoverAddress = _require.recoverAddress,
  SigningKey = _require.SigningKey,
  AbiCoder = _require.AbiCoder,
  Signature = _require.Signature,
  concat = _require.concat,
  id = _require.id,
  Mnemonic = _require.Mnemonic,
  Wordlist = _require.Wordlist,
  wordlists = _require.wordlists,
  ethersWallet = _require.Wallet,
  ethersHDNodeWallet = _require.HDNodeWallet,
  getBytes = _require.getBytes,
  computeHmac = _require.computeHmac;
var _require2 = require('@ethersproject/abi'),
  Interface = _require2.Interface;
var splitSignature = function splitSignature(sigBytes) {
  return Signature.from(sigBytes);
};
var joinSignature = function joinSignature(splitSig) {
  return Signature.from(splitSig).serialized;
};
var arrayify = function arrayify(value) {
  return getBytes(value);
};
var FormatTypes = {
  sighash: 'sighash',
  minimal: 'minimal',
  full: 'full',
  json: 'json'
};
var isValidMnemonic = Mnemonic.isValidMnemonic;
computeHmac.register(function (algorithm, key, data) {
  return computeHmac._(algorithm, Buffer.from(key), Buffer.from(data));
});
module.exports = {
  keccak256: keccak256,
  sha256: sha256,
  toUtf8Bytes: toUtf8Bytes,
  toUtf8String: toUtf8String,
  recoverAddress: recoverAddress,
  SigningKey: SigningKey,
  Signature: Signature,
  AbiCoder: AbiCoder,
  Interface: Interface,
  FormatTypes: FormatTypes,
  splitSignature: splitSignature,
  joinSignature: joinSignature,
  arrayify: arrayify,
  ethersWallet: ethersWallet,
  ethersHDNodeWallet: ethersHDNodeWallet,
  concat: concat,
  id: id,
  Mnemonic: Mnemonic,
  Wordlist: Wordlist,
  wordlists: wordlists,
  isValidMnemonic: isValidMnemonic
};

}).call(this)}).call(this,require("buffer").Buffer)
},{"@ethersproject/abi":16,"buffer":139,"ethers":235}],540:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var fileter = /*#__PURE__*/function () {
  function fileter(scdo) {
    _classCallCheck(this, fileter);
    this.scdo = scdo;
  }

  /**
   * Filtering transactions for a specific address based on block height, an error occurs if the
   * block height does not exist. If the height is -1, it will filter the current block.
   * When the flag is 1, the transaction `from` equal to the `address` is filtered in the block.
   * When the flag is 2, the transaction `to` equal to the `address` is filtered in the block.
   * @example
   * client.filterBlockTx(-1, "0x4c10f2cd2159bb432094e3be7e17904c2b4aeb21", "1")
   * client.filterBlockTx(1235435, "0x4c10f2cd2159bb432094e3be7e17904c2b4aeb21", "2")
   * @param {Number} height 
   * @param {String} address 
   * @param {Number} flag 1:from 2:to
   * @param {CallBack Function} fn 
   */
  return _createClass(fileter, [{
    key: "blocktx",
    value: function blocktx(height, address, flag, fn) {
      var self = this.scdo;
      var block = self.sendSync("getBlock", "", height, false);
      block.transactions.forEach(function (txHash) {
        self.getTransactionByHash(txHash, function (err, tx) {
          if (err) {
            console.log(err);
            return;
          }
          if (flag === "1" && tx.transaction.from === address) {
            fn(tx);
          }
          if (flag === "2" && tx.transaction.to === address) {
            fn(tx);
          }
        });
      });
      fn("end");
    }

    /**
     * Filtering transactions for a specific address based on block height, an error occurs if the
     * block height does not exist. If the height is -1, it will filter the current block.
     * When the flag is 1, the transaction `from` equal to the `address` is filtered in the block.
     * When the flag is 2, the transaction `to` equal to the `address` is filtered in the block.
     * @example
     * var txs = client.filterBlockTx(-1, "0x4c10f2cd2159bb432094e3be7e17904c2b4aeb21", "1")
     * var txs = client.filterBlockTx(1235435, "0x4c10f2cd2159bb432094e3be7e17904c2b4aeb21", "2")
     * @param {Number} height 
     * @param {String} address 
     * @param {Number} flag 1:from 2:to
     * @returns {Array} txs
     */
  }, {
    key: "blocktxSync",
    value: function blocktxSync(height, address, flag) {
      var self = this.scdo;
      var block = self.sendSync("getBlock", "", height, true);
      var result = new Array();
      block.transactions.forEach(function (tx) {
        // var tx = self.sendSync("getTransactionByHash", txHash);
        if (flag === 1 && tx.from === address) {
          result.push(tx);
        }
        if (flag === 2 && tx.to === address) {
          result.push(tx);
        }
      });
      return result;
    }
  }]);
}();
module.exports = fileter;

},{}],541:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(_typeof(e) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, "catch": function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
var bytes = require('./bytes');
var code = require('./code');
var abi = require('./abi');
var message = require('./message');
var ethersUtils = require('./ethersUtils');
var _require = require('./typedData'),
  _TypedDataEncoder = _require.TypedDataEncoder;
var validator = require('validator');
var BigNumber = require('bignumber.js');
var _require2 = require('./address'),
  ADDRESS_PREFIX = _require2.ADDRESS_PREFIX;
var utils = {
  isValidURL: function isValidURL(url) {
    if (typeof url !== 'string') return false;
    return validator.isURL(url.toString(), {
      protocols: ['http', 'https'],
      require_tld: false
    });
  },
  isObject: function isObject(obj) {
    return obj === Object(obj) && Object.prototype.toString.call(obj) !== '[object Array]';
  },
  isArray: function isArray(array) {
    return Array.isArray(array);
  },
  isJson: function isJson(string) {
    try {
      return !!JSON.parse(string);
    } catch (ex) {
      return false;
    }
  },
  isBoolean: function isBoolean(bool) {
    return typeof bool === 'boolean';
  },
  isBigNumber: function isBigNumber(number) {
    return number && (number instanceof BigNumber || number.constructor && number.constructor.name === 'BigNumber');
  },
  isString: function isString(string) {
    return typeof string === 'string' || string && string.constructor && string.constructor.name === 'String';
  },
  isFunction: function isFunction(obj) {
    return typeof obj === 'function';
  },
  isHex: function isHex(string) {
    return typeof string === 'string' && !isNaN(parseInt(string, 16)) && /^(0x|)[a-fA-F0-9]+$/.test(string);
  },
  isInteger: function isInteger(number) {
    if (number === null) return false;
    return Number.isInteger(Number(number));
  },
  hasProperty: function hasProperty(obj, property) {
    return Object.prototype.hasOwnProperty.call(obj, property);
  },
  hasProperties: function hasProperties(obj) {
    var _this = this;
    for (var _len = arguments.length, properties = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      properties[_key - 1] = arguments[_key];
    }
    return properties.length && !properties.map(function (property) {
      return _this.hasProperty(obj, property);
    }).includes(false);
  },
  mapEvent: function mapEvent(event) {
    var data = {
      block: event.block_number,
      timestamp: event.block_timestamp,
      contract: event.contract_address,
      name: event.event_name,
      transaction: event.transaction_id,
      result: event.result,
      resourceNode: event.resource_Node || (event._unconfirmed ? 'fullNode' : 'solidityNode')
    };
    if (event._unconfirmed) {
      data.unconfirmed = event._unconfirmed;
    }
    if (event._fingerprint) {
      data.fingerprint = event._fingerprint;
    }
    return data;
  },
  parseEvent: function parseEvent(event, _ref) {
    var abi = _ref.inputs;
    if (!event.result) return event;
    if (this.isObject(event.result)) {
      for (var i = 0; i < abi.length; i++) {
        var obj = abi[i];
        if (obj.type == 'address' && obj.name in event.result) event.result[obj.name] = ADDRESS_PREFIX + event.result[obj.name].substr(2).toLowerCase();
      }
    } else if (this.isArray(event.result)) {
      event.result = event.result.reduce(function (obj, result, index) {
        var _abi$index = abi[index],
          name = _abi$index.name,
          type = _abi$index.type;
        if (type == 'address') result = ADDRESS_PREFIX + result.substr(2).toLowerCase();
        obj[name] = result;
        return obj;
      }, {});
    }
    return event;
  },
  padLeft: function padLeft(input, padding, amount) {
    var res = input.toString();
    while (res.length < amount) res = padding + res;
    return res;
  },
  isNotNullOrUndefined: function isNotNullOrUndefined(val) {
    return val !== null && typeof val !== 'undefined';
  },
  sleep: function sleep() {
    var _arguments = arguments;
    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      var millis;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            millis = _arguments.length > 0 && _arguments[0] !== undefined ? _arguments[0] : 1000;
            return _context.abrupt("return", new Promise(function (resolve) {
              return setTimeout(resolve, millis);
            }));
          case 2:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }))();
  }
};
module.exports = _objectSpread(_objectSpread({}, utils), {}, {
  code: code,
  bytes: bytes,
  abi: abi,
  message: message,
  _TypedDataEncoder: _TypedDataEncoder,
  ethersUtils: ethersUtils
});

},{"./abi":531,"./address":532,"./bytes":534,"./code":535,"./ethersUtils":539,"./message":542,"./typedData":545,"bignumber.js":101,"validator":423}],542:[function(require,module,exports){
"use strict";

var _require = require('./ethersUtils'),
  keccak256 = _require.keccak256,
  toUtf8Bytes = _require.toUtf8Bytes,
  concat = _require.concat,
  recoverAddress = _require.recoverAddress,
  SigningKey = _require.SigningKey,
  joinSignature = _require.joinSignature;
var _require2 = require('./address'),
  ADDRESS_PREFIX = _require2.ADDRESS_PREFIX;
// const { getBase58CheckAddress } = require('./crypto');
var _require3 = require('./code'),
  hexStr2byteArray = _require3.hexStr2byteArray;
var SCDO_MESSAGE_PREFIX = "\x19SCDO Signed Message:\n";
function hashMessage(message) {
  if (typeof message === "string") {
    message = toUtf8Bytes(message);
  }
  if (Array.isArray(message)) {
    message = new Uint8Array(message);
  }
  return keccak256(concat([toUtf8Bytes(SCDO_MESSAGE_PREFIX), toUtf8Bytes(String(message.length)), message]));
}
function signMessage(message, privateKey) {
  if (!privateKey.match(/^0x/)) {
    privateKey = '0x' + privateKey;
  }
  var signingKey = new SigningKey(privateKey);
  var messageDigest = hashMessage(message);
  var signature = signingKey.sign(messageDigest);
  return joinSignature(signature);
}

// function verifyMessage(message, signature) {
//     if(!signature.match(/^0x/)) {
//       signature =  '0x' + signature;
//     }
//     const recovered = recoverAddress(hashMessage(message), signature);
//     const base58Address = getBase58CheckAddress(hexStr2byteArray(recovered.replace(/^0x/, ADDRESS_PREFIX)));

//     return base58Address;
// }

module.exports = {
  SCDO_MESSAGE_PREFIX: SCDO_MESSAGE_PREFIX,
  hashMessage: hashMessage,
  signMessage: signMessage
  // verifyMessage
};

},{"./address":532,"./code":535,"./ethersUtils":539}],543:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var createKeccakHash = require('keccak'); // for hashing
var RLP = require('rlp'); // for serialization
var secp256k1 = require('secp256k1'); // for elliptic operations
var stx = /*#__PURE__*/function () {
  function stx() {
    _classCallCheck(this, stx);
  }
  return _createClass(stx, [{
    key: "sign",
    value:
    //***********************************
    // public methods
    //***********************************

    // public method: returns the signature result in json format from tx information and privateKey
    // ps. the only public method
    // input: string[66]
    /*        tx = {
                   "to": "0x27266c2b5706e9282546750764531c71052e0281",
                   "amount": 0.4,
                   "price":10.56,
                   "limit":200000.1,
                   "payload":"0x0101",
                   "nonce": 0
                 }
    output: signedTransaction = {
               "Hash": "0xcaa03e211b3e89b991f8f1c1cff4d8640611eae4f634d435704c7ad2b42d08c4",
               "Data": {
                   "Type": 0,
                   "From": "0x724fdfef2ea6411d6fed3bb95bad56da4170e0e1",
                   "To": "0x27266c2b5706e9282546750764531c71052e0281",
                   "Amount": 0,
                   "AccountNonce": 0,
                   "GasPrice": 10,
                   "GasLimit": 200000,
                   "Timestamp": 0,
                   "Payload": "0x0101"
               },
               "Signature": {
                   "Sig": "kIk8Lx+/h3+0/TuQYvHeU5q9YJkUPE7/7zgD3rlLPatfhEJWMCnCVFHGApFSnzJCXl8jbPBhHXoixLQzVTwcSQA="
               }
           }*/
    function sign(privateKey, tx) {
      // step 1/5 check tx validity
      if (!this.txValidity(tx)) {
        return "failed to sign";
      }
      // step 2/5 initialize tx data values for hashing (also checks privateKey validity in publicKeyOf())
      this.pubKey = this.publicKeyOf(privateKey);
      this.timestamp = 0;
      this.type = 0;
      this.Data = {
        "Type": this.type,
        "From": this.pubKey,
        "To": tx.to,
        "Amount": parseInt(tx.amount.toString()),
        "AccountNonce": parseInt(tx.nonce.toString()),
        "GasPrice": parseInt(tx.price.toString()),
        "GasLimit": parseInt(tx.limit.toString()),
        "Timestamp": this.timestamp,
        "Payload": tx.payload
      };
      // step 3/5 hash tx data values
      this.hash = this.hash();
      // step 4/5 create signature from hash (of tx data values) and private key
      this.sign = this.signHash(this.hash, privateKey);
      // step 5/5 finalize returned signed tx data
      this.signedTransaction = {
        "Hash": "0x" + this.hash,
        "Data": this.Data,
        "Signature": {
          "Sig": this.sign
        }
      };
      return this.signedTransaction;
    }

    //***********************************
    // private methods
    //***********************************

    // private method: returns public key of given private key, but also throws error if invalid input
    // input string[66]
    // output string[42]
  }, {
    key: "publicKeyOf",
    value: function publicKeyOf(privateKey) {
      if (privateKey.length != 66) {
        throw "privatekey string should be of lenth 66";
      }
      if (privateKey.slice(0, 2) != "0x") {
        throw "privateKey string should start with 0x";
      }
      var inbuf = Buffer.from(privateKey.slice(2), 'hex');
      if (!secp256k1.privateKeyVerify(inbuf)) {
        throw "invalid privateKey";
      }
      var oubuf = secp256k1.publicKeyCreate(inbuf, false).slice(1);
      var publicKey = createKeccakHash('keccak256').update(RLP.encode(oubuf)).digest().slice(12).toString('hex');
      return "0x" + publicKey.replace(/.$/i, "1");
    }

    // private method: returns hash string from VALUES OF TXDATA
    // ps. the VALUES only, NOT the FIELDS and the VALUES
    // input none, but uses class properties(contents of this.Data, this.Data.Type ... etc)
    // output string[64]
  }, {
    key: "hash",
    value: function hash() {
      var infolist = [this.Data.Type, this.Data.From, this.Data.To, this.Data.Amount, this.Data.AccountNonce, this.Data.GasPrice, this.Data.GasLimit, this.Data.Timestamp, this.Data.Payload];
      return createKeccakHash('keccak256').update(RLP.encode(infolist)).digest().toString('hex');
    }

    // private method: returns signature from tx data hash and privateKey (0x included)
    // input string[64], string[66]
    // output string[88]
  }, {
    key: "signHash",
    value: function signHash(hash, privateKey) {
      var signature = secp256k1.sign(Buffer.from(hash, 'hex'), Buffer.from(privateKey.slice(2), 'hex'));
      return Buffer.concat([signature.signature, Buffer.from([signature.recovery])]).toString('base64');
    }

    // private method: display result
    // input none,
    // output none,
  }, {
    key: "show",
    value: function show() {
      console.log(JSON.stringify(this.signedTransaction, null, 4));
    }

    // private method: returns true/false as validity of each field of input tx data:
    //                 numerical types (nonce, amount, price, limit) must all be non-negative and are numbers, decimals are allowed but will be ignored
    //                 string  types (to, payload) must be strings and reciever address must be valid address with prefix 0x
    /* input ex tx = {
                   "to": "0x27266c2b5706e9282546750764531c71052e0281",
                   "amount": 0.4,
                   "price":10.56,
                   "limit":200000.1,
                   "payload":"0x0101",
                   "nonce": 0
                 }*/
    // output bool
  }, {
    key: "txValidity",
    value: function txValidity(tx) {
      if (typeof tx.to !== 'string' || tx.to.length != 42 || tx.to.slice(0, 2) != "0x") {
        throw "invalid receiver address, should be of length 42 with prefix 0x";
        return false;
      }
      if (typeof tx.payload !== 'string') {
        throw "invalid payload";
        return false;
      }
      if (typeof tx.nonce !== 'number' || tx.nonce < 0) {
        console.log(_typeof(tx.nonce));
        throw "invalid nonce";
        return false;
      }
      if (typeof tx.amount !== 'number' || tx.amount < 0) {
        console.log(_typeof(tx.amount));
        throw "invalid amount";
        return false;
      }
      if (typeof tx.price !== 'number' || tx.price < 0) {
        console.log(_typeof(tx.price));
        throw "invalid price";
        return false;
      }
      if (typeof tx.limit !== 'number' || tx.limit < 0) {
        console.log(_typeof(tx.limit));
        throw "invalid limit";
        return false;
      }
      return true;

      //nonce, amount, price and limit must be positive integers
    }
  }]);
}();
module.exports = stx;

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":139,"keccak":334,"rlp":383,"secp256k1":386}],544:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var createKeccakHash = require('keccak');
var secp256k1 = require('secp256k1');
var rlp = require('rlp');
var BigNumber = require('bignumber.js');

/**
 * Creates a new transaction object.
 * @example 
 * var rawTx = {
 *   "From":"0xa61e5b0b30e91c4ae10dda3a6ddeb9d9d35ebfe1",
 *    "To":"0x0000000000000000000000000000000000000000",
 *    "Amount":0,
 *    "AccountNonce":123,
 *    "GasPrice":1,
 *    "GasLimit":3000000,
 *    "Timestamp":0,
 *    "Payload":"0x60806040527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff60015534801561003457600080fd5b5033600360006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550610f0b806100856000396000f300608060405260043610610083576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff1680632d142a99146100885780632de2c4da146100bc578063390e61541461015457806348d952e0146101b25780634eef2f46146101dd578063ab91695e1461021b578063f25b3f9914610246575b600080fd5b6100a660048036038101908080359060200190929190505050610295565b6040518082815260200191505060405180910390f35b3480156100c857600080fd5b5061013e6004803603810190808035906020019092919080359060200190929190803590602001909291908035906020019082018035906020019080806020026020016040519081016040528093929190818152602001838360200280828437820191505050505050919291929050505061042c565b6040518082815260200191505060405180910390f35b61019c6004803603810190808035906020019092919080359060200190929190803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050610968565b6040518082815260200191505060405180910390f35b3480156101be57600080fd5b506101c7610b40565b6040518082815260200191505060405180910390f35b6102056004803603810190808035906020019092919080359060200190929190505050610b46565b6040518082815260200191505060405180910390f35b34801561022757600080fd5b50610230610e3d565b6040518082815260200191505060405180910390f35b34801561025257600080fd5b5061027160048036038101908080359060200190929190505050610e43565b60405180848152602001838152602001828152602001935050505060405180910390f35b600080600090506001341015610356577f2889a9dad0676c5d3968f68aee3cf08ec189617986e3bc741824fabbae1dfddd816040518080602001838152602001806020018381038352600e8152602001807f676574426c6f636b486561646572000000000000000000000000000000000000815250602001838103825260168152602001807f4552525f4d4f4e45595f49534e4f545f454e4f55474800000000000000000000815250602001935050505060405180910390a1809150610426565b600360009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166108fc349081150290604051600060405180830381858888f193505050501580156103be573d6000803e3d6000fd5b506000600260008581526020019081526020016000206001015413156103e357600190505b7f9f4ffac40aa756625bacf23a6a8fd81d386dfb2878ef3b572d73d00f454f003e8382604051808381526020018281526020019250505060405180910390a18091505b50919050565b60008060009050600360009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614151561053b577f2889a9dad0676c5d3968f68aee3cf08ec189617986e3bc741824fabbae1dfddd81604051808060200183815260200180602001838103835260108152602001807f73746f7265426c6f636b48656164657200000000000000000000000000000000815250602001838103825260138152602001807f4552525f53544f52455f585f52454c4159455200000000000000000000000000815250602001935050505060405180910390a180915061095f565b600054841415156105f7577f2889a9dad0676c5d3968f68aee3cf08ec189617986e3bc741824fabbae1dfddd81604051808060200183815260200180602001838103835260108152602001807f73746f7265426c6f636b48656164657200000000000000000000000000000000815250602001838103825260118152602001807f4552525f4e4f5f505245565f424c4f434b000000000000000000000000000000815250602001935050505060405180910390a180915061095f565b600154851315156106b3577f2889a9dad0676c5d3968f68aee3cf08ec189617986e3bc741824fabbae1dfddd81604051808060200183815260200180602001838103835260108152602001807f73746f7265426c6f636b48656164657200000000000000000000000000000000815250602001838103825260188152602001807f4552525f424c4f434b5f414c52454144595f4558495354530000000000000000815250602001935050505060405180910390a180915061095f565b600060026000888152602001908152602001600020600101541315610783577f2889a9dad0676c5d3968f68aee3cf08ec189617986e3bc741824fabbae1dfddd81604051808060200183815260200180602001838103835260108152602001807f73746f7265426c6f636b486561646572000000000000000000000000000000008152506020018381038252601d8152602001807f4552525f424c4f434b5f484153485f414c52454144595f455849535453000000815250602001935050505060405180910390a180915061095f565b60008351141561083e577f2889a9dad0676c5d3968f68aee3cf08ec189617986e3bc741824fabbae1dfddd81604051808060200183815260200180602001838103835260108152602001807f73746f7265426c6f636b48656164657200000000000000000000000000000000815250602001838103825260198152602001807f4552525f5452414e53414354494f4e535f49535f454d50545900000000000000815250602001935050505060405180910390a180915061095f565b608060405190810160405280878152602001868152602001858152602001848152506002600088815260200190815260200160002060008201518160000155602082015181600101556040820151816002015560608201518160030190805190602001906108ad929190610e6d565b509050508560008190555084600181905550600190507f3d553c6a50657421fdcfde6c3ab85068b6c074a10dfc0073f149d98980d0395786868686856040518086815260200185815260200184815260200180602001838152602001828103825284818151815260200191508051906020019060200280838360005b83811015610944578082015181840152602081019050610929565b50505050905001965050505050505060405180910390a18091505b50949350505050565b6000806000806000925061097c8787610b46565b9150600082141515610a89578490508073ffffffffffffffffffffffffffffffffffffffff1663e6cb35af88886040518363ffffffff167c01000000000000000000000000000000000000000000000000000000000281526004018083815260200182815260200192505050602060405180830381600087803b158015610a0257600080fd5b505af1158015610a16573d6000803e3d6000fd5b505050506040513d6020811015610a2c57600080fd5b810190808051906020019092919050505050600192507f84ed50b3e2027837051c6eaa0464f66293959fe6892b7a62576d1ebcd53931e18684604051808381526020018281526020019250505060405180910390a1829350610b36565b7f2889a9dad0676c5d3968f68aee3cf08ec189617986e3bc741824fabbae1dfddd83604051808060200183815260200180602001838103835260108152602001807f52656c61795472616e73616374696f6e00000000000000000000000000000000815250602001838103825260108152602001807f4552525f52454c41595f56455249465900000000000000000000000000000000815250602001935050505060405180910390a18293505b5050509392505050565b60015481565b600080606060008092506001341015610c0a577f2889a9dad0676c5d3968f68aee3cf08ec189617986e3bc741824fabbae1dfddd83604051808060200183815260200180602001838103835260088152602001807f7665726966795478000000000000000000000000000000000000000000000000815250602001838103825260168152602001807f4552525f4d4f4e45595f49534e4f545f454e4f55474800000000000000000000815250602001935050505060405180910390a1829350610e34565b60066001540360026000888152602001908152602001600020600101541215610cde577f2889a9dad0676c5d3968f68aee3cf08ec189617986e3bc741824fabbae1dfddd83604051808060200183815260200180602001838103835260088152602001807f76657269667954780000000000000000000000000000000000000000000000008152506020018381038252601d8152602001807f4552525f434f4e4649524d4154494f4e535f4c4553535f5448414e5f36000000815250602001935050505060405180910390a1829350610e34565b600360009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166108fc349081150290604051600060405180830381858888f19350505050158015610d46573d6000803e3d6000fd5b5060026000878152602001908152602001600020600301805480602002602001604051908101604052809291908181526020018280548015610da757602002820191906000526020600020905b815481526020019060010190808311610d93575b50505050509150600090505b8151811015610df157848282815181101515610dcb57fe5b906020019060200201511415610de45760019250610df1565b8080600101915050610db3565b7f7a2933ac2a256db068a8aec8c8977f9866040648de7e973edfb5387e64a3d66a8584604051808381526020018281526020019250505060405180910390a18293505b50505092915050565b60005481565b60026020528060005260406000206000915090508060000154908060010154908060020154905083565b828054828255906000526020600020908101928215610ea9579160200282015b82811115610ea8578251825591602001919060010190610e8d565b5b509050610eb69190610eba565b5090565b610edc91905b80821115610ed8576000816000905550600101610ec0565b5090565b905600a165627a7a72305820fe072090d013b0fe073954d6379f9f21b04b42bce53ca7a5ab469c3b0631bbf10029"
 * }
 * var tx = new Transaction(rawTx);
 * @class Scdo Transaction
 * @property {Buffer} raw The raw rlp encoded transaction
 * @param {Buffer} rawTx.From the from address
 * @param {Buffer} rawTx.To the to address
 * @param {Buffer} rawTx.Amount the amount of ether sent
 * @param {Buffer} rawTx.AccountNonce nonce number
 * @param {Buffer} rawTx.GasPrice transaction gas price
 * @param {Buffer} rawTx.GasLimit maximum gas for contract creation/execution
 * @param {Buffer} rawTx.Timestamp the timestamp of the transaction creation. Always be *0*.
 * @param {Buffer} rawTx.Payload this will contain the data of the message or the init of a contract
 * @todo Check the rawTx properties, if it's null, set the default value.
 **/
var Transaction = /*#__PURE__*/function () {
  function Transaction(rawTx) {
    _classCallCheck(this, Transaction);
    rawTx = rawTx || {};
    var raw = [];
    for (var key in rawTx) {
      if (BigNumber.isBigNumber(rawTx[key])) {
        raw.push("0x" + rawTx[key].toString(16));
      } else {
        raw.push(rawTx[key]);
      }
    }
    this.raw = raw;
    this.Data = rawTx;
  }

  /**
  * Computes a sha3-256 hash of the serialized tx
  * @return {Buffer}
  */
  return _createClass(Transaction, [{
    key: "hash",
    value: function hash() {
      var c = rlp.encode(this.raw);
      return createKeccakHash('keccak256').update(c).digest();
    }

    /**
     * Sign a transaction with a given private key
     * @example 
     * var hashBuffer = tx.hash()
     * var privatekey = Buffer.from("24ce9cadcc9207c94296db166ab7a0fa686f2a6d29f7ea54fe8c22271c40812e", 'hex')
     * tx.sign(privatekey, hashBuffer)
     * @param {Buffer} hashBuffer
     * @param {Buffer} privateKey
     */
  }, {
    key: "sign",
    value: function sign(hashBuffer, privatekey) {
      var sig = secp256k1.sign(hashBuffer, privatekey);
      var recidBuffer = Buffer.alloc(1).fill(sig.recovery);
      return Buffer.concat([sig.signature, recidBuffer], sig.signature.length + recidBuffer.length);
    }
  }]);
}();
module.exports = Transaction;

}).call(this)}).call(this,require("buffer").Buffer)
},{"bignumber.js":101,"buffer":139,"keccak":334,"rlp":383,"secp256k1":386}],545:[function(require,module,exports){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t["return"] || t["return"](); } finally { if (u) throw o; } } }; }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var _require = require("ethers"),
  id = _require.id,
  keccak256 = _require.keccak256,
  concat = _require.concat,
  defineProperties = _require.defineProperties,
  getBigInt = _require.getBigInt,
  getBytes = _require.getBytes,
  hexlify = _require.hexlify,
  mask = _require.mask,
  toTwos = _require.toTwos,
  toBeHex = _require.toBeHex,
  zeroPadValue = _require.zeroPadValue,
  assertArgument = _require.assertArgument;
var _require2 = require('./address'),
  ADDRESS_PREFIX_REGEX = _require2.ADDRESS_PREFIX_REGEX;
function getAddress(address) {
  return address.toHex(address).replace(ADDRESS_PREFIX_REGEX, '0x');
}
function getSCDOAddress(address) {
  return address.toHex(address);
}
var padding = new Uint8Array(32);
padding.fill(0);
var BN__1 = BigInt(-1);
var BN_0 = BigInt(0);
var BN_1 = BigInt(1);
var BN_MAX_UINT256 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function hexPadRight(value) {
  var bytes = getBytes(value);
  var padOffset = bytes.length % 32;
  if (padOffset) {
    return concat([bytes, padding.slice(padOffset)]);
  }
  return hexlify(bytes);
}
var hexTrue = toBeHex(BN_1, 32);
var hexFalse = toBeHex(BN_0, 32);
var domainFieldTypes = {
  name: "string",
  version: "string",
  chainId: "uint256",
  verifyingContract: "address",
  salt: "bytes32"
};
var domainFieldNames = ["name", "version", "chainId", "verifyingContract", "salt"];
function checkString(key) {
  return function (value) {
    assertArgument(typeof value === "string", "invalid domain value for ".concat(JSON.stringify(key)), "domain.".concat(key), value);
    return value;
  };
}
var domainChecks = {
  name: checkString("name"),
  version: checkString("version"),
  chainId: function chainId(value) {
    return getBigInt(value, "domain.chainId");
  },
  verifyingContract: function verifyingContract(value) {
    try {
      return getSCDOAddress(value).toLowerCase();
    } catch (error) {}
    assertArgument(false, "invalid domain value \"verifyingContract\"", "domain.verifyingContract", value);
  },
  salt: function salt(value) {
    var bytes = getBytes(value, "domain.salt");
    assertArgument(bytes.length === 32, "invalid domain value \"salt\"", "domain.salt", value);
    return hexlify(bytes);
  }
};
function getBaseEncoder(type) {
  // intXX and uintXX
  {
    var match = type.match(/^(u?)int(\d*)$/);
    if (match) {
      var signed = match[1] === "";
      var width = parseInt(match[2] || "256");
      assertArgument(width % 8 === 0 && width !== 0 && width <= 256 && (match[2] == null || match[2] === String(width)), "invalid numeric width", "type", type);
      var boundsUpper = mask(BN_MAX_UINT256, signed ? width - 1 : width);
      var boundsLower = signed ? (boundsUpper + BN_1) * BN__1 : BN_0;
      return function (_value) {
        var value = getBigInt(_value, "value");
        assertArgument(value >= boundsLower && value <= boundsUpper, "value out-of-bounds for ".concat(type), "value", value);
        if (!signed) return toBeHex(value, 32);
        return toBeHex(toTwos(value, 256), 32);
      };
    }
  }
  // bytesXX
  {
    var _match = type.match(/^bytes(\d+)$/);
    if (_match) {
      var _width = parseInt(_match[1]);
      assertArgument(_width !== 0 && _width <= 32 && _match[1] === String(_width), "invalid bytes width", "type", type);
      return function (value) {
        var bytes = getBytes(value);
        assertArgument(bytes.length === _width, "invalid length for ".concat(type), "value", value);
        return hexPadRight(value);
      };
    }
  }
  switch (type) {
    case "srcToken":
      return getBaseEncoder('uint256');
    case "address":
      return function (value) {
        return zeroPadValue(getAddress(value), 32);
      };
    case "bool":
      return function (value) {
        return !value ? hexFalse : hexTrue;
      };
    case "bytes":
      return function (value) {
        return keccak256(value);
      };
    case "string":
      return function (value) {
        return id(value);
      };
  }
  return null;
}
function encodeType(name, fields) {
  return "".concat(name, "(").concat(fields.map(function (_ref) {
    var name = _ref.name,
      type = _ref.type;
    return type + " " + name;
  }).join(","), ")");
}
var TypedDataEncoder = /*#__PURE__*/function () {
  function TypedDataEncoder(types) {
    _classCallCheck(this, TypedDataEncoder);
    _defineProperty(this, "primaryType", void 0);
    _defineProperty(this, "privateTypes", void 0);
    _defineProperty(this, "privateFullTypes", void 0);
    _defineProperty(this, "privateEncoderCache", void 0);
    this.privateTypes = JSON.stringify(types);
    this.privateFullTypes = new Map();
    this.privateEncoderCache = new Map();
    // Link struct types to their direct child structs
    var links = new Map();
    // Link structs to structs which contain them as a child
    var parents = new Map();
    // Link all subtypes within a given struct
    var subtypes = new Map();
    Object.keys(types).forEach(function (type) {
      links.set(type, new Set());
      parents.set(type, []);
      subtypes.set(type, new Set());
    });
    for (var name in types) {
      var uniqueNames = new Set();
      var _iterator = _createForOfIteratorHelper(types[name]),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var field = _step.value;
          // Check each field has a unique name
          assertArgument(!uniqueNames.has(field.name), "duplicate variable name ".concat(JSON.stringify(field.name), " in ").concat(JSON.stringify(name)), "types", types);
          uniqueNames.add(field.name);
          // Get the base type (drop any array specifiers)
          var baseType = field.type.match(/^([^\x5b]*)(\x5b|$)/)[1] || null;
          assertArgument(baseType !== name, "circular type reference to ".concat(JSON.stringify(baseType)), "types", types);
          // Is this a base encoding type?
          var encoder = getBaseEncoder(baseType);
          if (encoder) {
            continue;
          }
          assertArgument(parents.has(baseType), "unknown type ".concat(JSON.stringify(baseType)), "types", types);
          // Add linkage
          parents.get(baseType).push(name);
          links.get(name).add(baseType);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
    // Deduce the primary type
    var primaryTypes = Array.from(parents.keys()).filter(function (n) {
      return parents.get(n).length === 0;
    });
    assertArgument(primaryTypes.length !== 0, "missing primary type", "types", types);
    assertArgument(primaryTypes.length === 1, "ambiguous primary types or unused types: ".concat(primaryTypes.map(function (t) {
      return JSON.stringify(t);
    }).join(", ")), "types", types);
    defineProperties(this, {
      primaryType: primaryTypes[0]
    });
    // Check for circular type references
    function checkCircular(type, found) {
      assertArgument(!found.has(type), "circular type reference to ".concat(JSON.stringify(type)), "types", types);
      found.add(type);
      var _iterator2 = _createForOfIteratorHelper(links.get(type)),
        _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var child = _step2.value;
          if (!parents.has(child)) {
            continue;
          }
          // Recursively check children
          checkCircular(child, found);
          // Mark all ancestors as having this decendant
          var _iterator3 = _createForOfIteratorHelper(found),
            _step3;
          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
              var subtype = _step3.value;
              subtypes.get(subtype).add(child);
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      found["delete"](type);
    }
    checkCircular(this.primaryType, new Set());
    // Compute each fully describe type
    var _iterator4 = _createForOfIteratorHelper(subtypes),
      _step4;
    try {
      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
        var _step4$value = _slicedToArray(_step4.value, 2),
          _name = _step4$value[0],
          set = _step4$value[1];
        var st = Array.from(set);
        st.sort();
        this.privateFullTypes.set(_name, encodeType(_name, types[_name]) + st.map(function (t) {
          return encodeType(t, types[t]);
        }).join(""));
      }
    } catch (err) {
      _iterator4.e(err);
    } finally {
      _iterator4.f();
    }
  }
  return _createClass(TypedDataEncoder, [{
    key: "types",
    get: function get() {
      return JSON.parse(this.privateTypes);
    }
  }, {
    key: "getEncoder",
    value: function getEncoder(type) {
      var encoder = this.privateEncoderCache.get(type);
      if (!encoder) {
        encoder = this.privateGetEncoder(type);
        this.privateEncoderCache.set(type, encoder);
      }
      return encoder;
    }
  }, {
    key: "privateGetEncoder",
    value: function privateGetEncoder(type) {
      var _this = this;
      // Basic encoder type (address, bool, uint256, etc)
      {
        var encoder = getBaseEncoder(type);
        if (encoder) {
          return encoder;
        }
      }
      // Array
      var match = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
      if (match) {
        var subtype = match[1];
        var subEncoder = this.getEncoder(subtype);
        return function (value) {
          assertArgument(!match[3] || parseInt(match[3]) === value.length, "array length mismatch; expected length ".concat(parseInt(match[3])), "value", value);
          var result = value.map(subEncoder);
          if (_this.privateFullTypes.has(subtype)) {
            result = result.map(keccak256);
          }
          return keccak256(concat(result));
        };
      }
      // Struct
      var fields = this.types[type];
      if (fields) {
        var encodedType = id(this.privateFullTypes.get(type));
        return function (value) {
          var values = fields.map(function (_ref2) {
            var name = _ref2.name,
              type = _ref2.type;
            var result = _this.getEncoder(type)(value[name]);
            if (_this.privateFullTypes.has(type)) {
              return keccak256(result);
            }
            return result;
          });
          values.unshift(encodedType);
          return concat(values);
        };
      }
      assertArgument(false, "unknown type: ".concat(type), "type", type);
    }
  }, {
    key: "encodeType",
    value: function encodeType(name) {
      var result = this.privateFullTypes.get(name);
      assertArgument(result, "unknown type: ".concat(JSON.stringify(name)), "name", name);
      return result;
    }
  }, {
    key: "encodeData",
    value: function encodeData(type, value) {
      return this.getEncoder(type)(value);
    }
  }, {
    key: "hashStruct",
    value: function hashStruct(name, value) {
      return keccak256(this.encodeData(name, value));
    }
  }, {
    key: "encode",
    value: function encode(value) {
      return this.encodeData(this.primaryType, value);
    }
  }, {
    key: "hash",
    value: function hash(value) {
      return this.hashStruct(this.primaryType, value);
    }
  }, {
    key: "_visit",
    value: function _visit(type, value, callback) {
      var _this2 = this;
      // Basic encoder type (address, bool, uint256, etc)
      {
        var encoder = getBaseEncoder(type);
        if (encoder) {
          return callback(type, value);
        }
      }
      // Array
      var match = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
      if (match) {
        assertArgument(!match[3] || parseInt(match[3]) === value.length, "array length mismatch; expected length ".concat(parseInt(match[3])), "value", value);
        return value.map(function (v) {
          return _this2._visit(match[1], v, callback);
        });
      }
      // Struct
      var fields = this.types[type];
      if (fields) {
        return fields.reduce(function (accum, _ref3) {
          var name = _ref3.name,
            type = _ref3.type;
          accum[name] = _this2._visit(type, value[name], callback);
          return accum;
        }, {});
      }
      assertArgument(false, "unknown type: ".concat(type), "type", type);
    }
  }, {
    key: "visit",
    value: function visit(value, callback) {
      return this._visit(this.primaryType, value, callback);
    }
  }], [{
    key: "from",
    value: function from(types) {
      return new TypedDataEncoder(types);
    }
  }, {
    key: "getPrimaryType",
    value: function getPrimaryType(types) {
      return TypedDataEncoder.from(types).primaryType;
    }
  }, {
    key: "hashStruct",
    value: function hashStruct(name, types, value) {
      return TypedDataEncoder.from(types).hashStruct(name, value);
    }
  }, {
    key: "hashDomain",
    value: function hashDomain(domain) {
      var domainFields = [];
      for (var name in domain) {
        if (domain[name] == null) {
          continue;
        }
        var type = domainFieldTypes[name];
        assertArgument(type, "invalid typed-data domain key: ".concat(JSON.stringify(name)), "domain", domain);
        domainFields.push({
          name: name,
          type: type
        });
      }
      domainFields.sort(function (a, b) {
        return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b.name);
      });
      return TypedDataEncoder.hashStruct("EIP712Domain", {
        EIP712Domain: domainFields
      }, domain);
    }
  }, {
    key: "encode",
    value: function encode(domain, types, value) {
      return concat(["0x1901", TypedDataEncoder.hashDomain(domain), TypedDataEncoder.from(types).hash(value)]);
    }
  }, {
    key: "hash",
    value: function hash(domain, types, value) {
      return keccak256(TypedDataEncoder.encode(domain, types, value));
    }
  }, {
    key: "getPayload",
    value: function getPayload(domain, types, value) {
      // Validate the domain fields
      TypedDataEncoder.hashDomain(domain);
      // Derive the EIP712Domain Struct reference type
      var domainValues = {};
      var domainTypes = [];
      domainFieldNames.forEach(function (name) {
        var value = domain[name];
        if (value == null) {
          return;
        }
        domainValues[name] = domainChecks[name](value);
        domainTypes.push({
          name: name,
          type: domainFieldTypes[name]
        });
      });
      var encoder = TypedDataEncoder.from(types);
      var typesWithDomain = Object.assign({}, types);
      assertArgument(typesWithDomain.EIP712Domain == null, "types must not contain EIP712Domain type", "types.EIP712Domain", types);
      typesWithDomain.EIP712Domain = domainTypes;
      // Validate the data structures and types
      encoder.encode(value);
      return {
        types: typesWithDomain,
        domain: domainValues,
        primaryType: encoder.primaryType,
        message: encoder.visit(value, function (type, value) {
          // bytes
          if (type.match(/^bytes(\d*)/)) {
            return hexlify(getBytes(value));
          }
          // uint or int
          if (type.match(/^u?int/)) {
            return getBigInt(value).toString();
          }
          switch (type) {
            case "srcToken":
              return getBigInt(value).toString();
            case "address":
              return value.toLowerCase();
            case "bool":
              return !!value;
            case "string":
              assertArgument(typeof value === "string", "invalid string", "value", value);
              return value;
          }
          assertArgument(false, "unsupported type", "type", type);
        })
      };
    }
  }]);
}();
module.exports = {
  getAddress: getAddress,
  getSCDOAddress: getSCDOAddress,
  hexPadRight: hexPadRight,
  TypedDataEncoder: TypedDataEncoder
};

},{"./address":532,"ethers":235}],546:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
var _require = require('./ethersUtils'),
  keccak256 = _require.keccak256;
var BigNumber = require('bignumber.js');
var utf8 = require('utf8');

// The result is a maximum of 8 decimal places
// Rounds towards -Infinity
BigNumber.config({
  DECIMAL_PLACES: 8,
  ROUNDING_MODE: 3
});
var unitMap = {
  'noscdo': '0',
  'fen': '1',
  'scdo': '100000000'
};
/**
 * Should be called to pad string to expected length
 *
 * @method padLeft
 * @param {String} string to be padded
 * @param {Number} characters that result string should have
 * @param {String} sign, by default 0
 * @returns {String} right aligned string
 */
var padLeft = function padLeft(string, chars, sign) {
  return new Array(chars - string.length + 1).join(sign ? sign : "0") + string;
};

/**
 * Should be called to pad string to expected length
 *
 * @method padRight
 * @param {String} string to be padded
 * @param {Number} characters that result string should have
 * @param {String} sign, by default 0
 * @returns {String} right aligned string
 */
var padRight = function padRight(string, chars, sign) {
  return string + new Array(chars - string.length + 1).join(sign ? sign : "0");
};

/**
 * Should be called to get utf8 from it's hex representation
 *
 * @method toUtf8
 * @param {String} string in hex
 * @returns {String} ascii string representation of hex value
 */
var toUtf8 = function toUtf8(hex) {
  // Find termination
  var str = "";
  var i = 0,
    l = hex.length;
  if (hex.substring(0, 2) === '0x') {
    i = 2;
  }
  for (; i < l; i += 2) {
    var code = parseInt(hex.substr(i, 2), 16);
    if (code === 0) break;
    str += String.fromCharCode(code);
  }
  return utf8.decode(str);
};

/**
 * Should be called to get ascii from it's hex representation
 *
 * @method toAscii
 * @param {String} string in hex
 * @returns {String} ascii string representation of hex value
 */
var toAscii = function toAscii(hex) {
  // Find termination
  var str = "";
  var i = 0,
    l = hex.length;
  if (hex.substring(0, 2) === '0x') {
    i = 2;
  }
  for (; i < l; i += 2) {
    var code = parseInt(hex.substr(i, 2), 16);
    str += String.fromCharCode(code);
  }
  return str;
};

/**
 * Should be called to get hex representation (prefixed by 0x) of utf8 string
 *
 * @method fromUtf8
 * @param {String} string
 * @param {Boolean} allowZero to convert code point zero to 00 instead of end of string
 * @returns {String} hex representation of input string
 */
var fromUtf8 = function fromUtf8(str, allowZero) {
  str = utf8.encode(str);
  var hex = "";
  for (var i = 0; i < str.length; i++) {
    var code = str.charCodeAt(i);
    if (code === 0) {
      if (allowZero) {
        hex += '00';
      } else {
        break;
      }
    } else {
      var n = code.toString(16);
      hex += n.length < 2 ? '0' + n : n;
    }
  }
  return "0x" + hex;
};

/**
 * Should be called to get hex representation (prefixed by 0x) of ascii string
 *
 * @method fromAscii
 * @param {String} string
 * @param {Number} optional padding
 * @returns {String} hex representation of input string
 */
var fromAscii = function fromAscii(str, num) {
  var hex = "";
  for (var i = 0; i < str.length; i++) {
    var code = str.charCodeAt(i);
    var n = code.toString(16);
    hex += n.length < 2 ? '0' + n : n;
  }
  return "0x" + hex.padEnd(num, '0');
};

/**
 * Should be used to create full function/event name from json abi
 *
 * @method transformToFullName
 * @param {Object} json-abi
 * @return {String} full fnction/event name
 */
var transformToFullName = function transformToFullName(json) {
  if (json.name.indexOf('(') !== -1) {
    return json.name;
  }
  var typeName = json.inputs.map(function (i) {
    return i.type;
  }).join();
  return json.name + '(' + typeName + ')';
};

/**
 * Converts value to it's decimal representation in string
 *
 * @method toDecimal
 * @param {String|Number|BigNumber}
 * @return {String}
 */
var toDecimal = function toDecimal(value) {
  return toBigNumber(value).toNumber();
};

/**
 * Converts value to it's hex representation
 *
 * @method fromDecimal
 * @param {String|Number|BigNumber}
 * @return {String}
 */
var fromDecimal = function fromDecimal(value) {
  var number = toBigNumber(value);
  var result = number.toString(16);
  return number.lessThan(0) ? '-0x' + result.substr(1) : '0x' + result;
};

/**
 * Auto converts any given value into it's hex representation.
 *
 * And even stringifys objects before.
 *
 * @method toHex
 * @param {String|Number|BigNumber|Object}
 * @return {String}
 */
var toHex = function toHex(val) {
  /*jshint maxcomplexity: 8 */

  if (isBoolean(val)) return fromDecimal(+val);
  if (isBigNumber(val)) return fromDecimal(val);
  if (_typeof(val) === 'object') return fromUtf8(JSON.stringify(val));

  // if its a negative number, pass it through fromDecimal
  if (isString(val)) {
    if (val.indexOf('-0x') === 0) return fromDecimal(val);else if (val.indexOf('0x') === 0) return val;else if (!isFinite(val)) return fromUtf8(val, 1);
  }
  return fromDecimal(val);
};

/**
 * Returns value of unit in fen
 *
 * @method getValueOfUnit
 * @param {String} unit the unit to convert to, default scdo
 * @returns {BigNumber} value of the unit (in Wen)
 * @throws error if the unit is not correct:w
 */
var getValueOfUnit = function getValueOfUnit(unit) {
  unit = unit ? unit.toLowerCase() : 'scdo';
  var unitValue = unitMap[unit];
  if (unitValue === undefined) {
    throw new Error('This unit doesn\'t exists, please use the one of the following units' + JSON.stringify(unitMap, null, 2));
  }
  return new BigNumber(unitValue, 10);
};

/**
 * Takes a number of fen and converts it to any other scdo unit.
 *
 * @method fromWen
 * @param {Number|String} number can be a number, number string or a HEX of a decimal
 * @param {String} unit the unit to convert to, default scdo
 * @return {String|Object} When given a BigNumber object it returns one as well, otherwise a number
*/
var fromWen = function fromWen(number, unit) {
  var returnValue = toBigNumber(number).dividedBy(getValueOfUnit(unit));
  return isBigNumber(number) ? returnValue : returnValue.toString(10);
};

/**
 * Takes a number of a unit and converts it to fen.
 *
 * @method toWen
 * @param {Number|String|BigNumber} number can be a number, number string or a HEX of a decimal
 * @param {String} unit the unit to convert from, default scdo
 * @return {String|Object} When given a BigNumber object it returns one as well, otherwise a number
*/
var toWen = function toWen(number, unit) {
  var returnValue = toBigNumber(number).times(getValueOfUnit(unit));
  return isBigNumber(number) ? returnValue : returnValue.toString(10);
};

/**
 * Takes an input and transforms it into an bignumber
 *
 * @method toBigNumber
 * @param {Number|String|BigNumber} a number, string, HEX string or BigNumber
 * @return {BigNumber} BigNumber
*/
var toBigNumber = function toBigNumber(number) {
  /*jshint maxcomplexity:5 */
  number = number || 0;
  if (isBigNumber(number)) return number;
  if (isString(number) && (number.indexOf('0x') === 0 || number.indexOf('-0x') === 0)) {
    return new BigNumber(number.replace('0x', ''), 16);
  }
  return new BigNumber(number.toString(10), 10);
};

/**
 * Takes and input transforms it into bignumber and if it is negative value, into two's complement
 *
 * @method toTwosComplement
 * @param {Number|String|BigNumber}
 * @return {BigNumber}
 */
var toTwosComplement = function toTwosComplement(number) {
  var bigNumber = toBigNumber(number).round();
  if (bigNumber.lessThan(0)) {
    return new BigNumber("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff", 16).plus(bigNumber).plus(1);
  }
  return bigNumber;
};

/**
 * Checks if the given string is strictly an address
 *
 * @method isStrictAddress
 * @param {String} address the given HEX adress
 * @return {Boolean}
*/
var isStrictAddress = function isStrictAddress(address) {
  return /^0x[0-9a-f]{40}$/i.test(address);
};

/**
 * Checks if the given string is an address
 *
 * @method isAddress
 * @param {String} address the given HEX adress
 * @return {Boolean}
*/
var isAddress = function isAddress(address) {
  // if (!/^(0x)?[0-9a-f]{40}$/i.test(address)) {
  //     // check if it has the basic requirements of an address
  //     return false;
  // } else if (/^(0x)?[0-9a-f]{40}$/.test(address) || /^(0x)?[0-9A-F]{40}$/.test(address)) {
  //     // If it's all small caps or all all caps, return true
  //     return true;
  // } else {
  //     return false;
  // }
  if (/^((1s01|2s02|3s03|4s04|1S01|2S02|3S03|4S04)[a-fA-F0-9]{37}[1-2])|0[sSx]0{40}|0x0[1-4][a-fA-F0-9]{37}[1-2]$/.test(address)) {
    return true;
  } else {
    return false;
  }
};

/**
 * Transforms given string to valid 20 bytes-length addres with 0x prefix
 *
 * @method toAddress
 * @param {String} address
 * @return {String} formatted address
 */
var toAddress = function toAddress(address) {
  if (isStrictAddress(address)) {
    return address;
  }
  if (/^[0-9a-f]{40}$/.test(address)) {
    return '0x' + address;
  }
  return '0x' + padLeft(toHex(address).substr(2), 40);
};

/**
 * Returns true if object is BigNumber, otherwise false
 *
 * @method isBigNumber
 * @param {Object}
 * @return {Boolean}
 */
var isBigNumber = function isBigNumber(object) {
  return object && (object instanceof BigNumber || object.constructor && object.constructor.name === 'BigNumber');
};

/**
 * Returns true if object is string, otherwise false
 *
 * @method isString
 * @param {Object}
 * @return {Boolean}
 */
var isString = function isString(object) {
  return typeof object === 'string' || object && object.constructor && object.constructor.name === 'String';
};
var sha3 = function sha3(string) {
  var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  return (prefix ? '0x' : '') + keccak256(Buffer.from(string, 'utf-8')).toString().substring(2);
};
/**
 * Returns true if object is function, otherwise false
 *
 * @method isFunction
 * @param {Object}
 * @return {Boolean}
 */
var isFunction = function isFunction(object) {
  return typeof object === 'function';
};

/**
 * Returns true if object is Objet, otherwise false
 *
 * @method isObject
 * @param {Object}
 * @return {Boolean}
 */
var isObject = function isObject(object) {
  return object !== null && !Array.isArray(object) && _typeof(object) === 'object';
};

/**
 * Returns true if object is boolean, otherwise false
 *
 * @method isBoolean
 * @param {Object}
 * @return {Boolean}
 */
var isBoolean = function isBoolean(object) {
  return typeof object === 'boolean';
};

/**
 * Returns true if object is array, otherwise false
 *
 * @method isArray
 * @param {Object}
 * @return {Boolean}
 */
var isArray = function isArray(object) {
  return Array.isArray(object);
};

/**
 * Returns true if given string is valid json object
 *
 * @method isJson
 * @param {String}
 * @return {Boolean}
 */
var isJson = function isJson(str) {
  try {
    return !!JSON.parse(str);
  } catch (e) {
    return false;
  }
};
module.exports = {
  padLeft: padLeft,
  padRight: padRight,
  toHex: toHex,
  toDecimal: toDecimal,
  fromDecimal: fromDecimal,
  toUtf8: toUtf8,
  toAscii: toAscii,
  fromUtf8: fromUtf8,
  fromAscii: fromAscii,
  transformToFullName: transformToFullName,
  toWen: toWen,
  fromWen: fromWen,
  toBigNumber: toBigNumber,
  toTwosComplement: toTwosComplement,
  toAddress: toAddress,
  isBigNumber: isBigNumber,
  isStrictAddress: isStrictAddress,
  isAddress: isAddress,
  isFunction: isFunction,
  isString: isString,
  isObject: isObject,
  isBoolean: isBoolean,
  isArray: isArray,
  isJson: isJson,
  sha3: sha3
};

}).call(this)}).call(this,require("buffer").Buffer)
},{"./ethersUtils":539,"bignumber.js":101,"buffer":139,"utf8":421}],547:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var fs = require("fs");
var path = require('path');
var scrypt = require('scrypt-js');
var elliptic = require('elliptic');
var ec = new elliptic.ec('secp256k1');
var secp256k1 = require('secp256k1');
var _require = require('crypto'),
  randomBytes = _require.randomBytes;
var createKeccakHash = require('keccak');
var utils = require('./utils');
var rlp = require('rlp');
var shardnum = 4;
var Wallet = /*#__PURE__*/function () {
  function Wallet() {
    _classCallCheck(this, Wallet);
    this.shardnum = 4;
    this.accounts = new Array(this.shardnum);
    for (var index = 0; index < this.accounts.length; index++) {
      this.accounts[index] = new Array();
    }
  }
  return _createClass(Wallet, [{
    key: "create",
    value: function create() {
      var keypair = generateKeypair();
      var shard = this.getshardnum(keypair.publickey);
      this.accounts[shard - 1].push(JSON.stringify(keypair));
      return keypair;
    }
  }, {
    key: "createbyshard",
    value: function createbyshard(shard) {
      if (shard == undefined) {
        shard = 1;
      }
      if (shard < 1 || shard > shardnum) {
        console.log("Error: shard is invalid ");
        return {};
      }
      var keypair;
      do {
        keypair = generateKeypair(shard);
      } while (this.getshardnum(keypair.publickey) != shard);
      this.accounts[shard - 1].push(JSON.stringify(keypair));
      return keypair;
    }
  }, {
    key: "getshardnum",
    value: function getshardnum(publickey) {
      if (!utils.isAddress(publickey)) {
        throw new Error("Invalid publickey: " + publickey);
      }
      var sum = 0;
      return parseInt(publickey.substring(3, 4));
    }
  }]);
}();
function generateKeypair(shard) {
  if (shard == undefined) {
    shard = 1;
  }
  if (shard < 1 || shard > shardnum) {
    console.log("Error: shard is invalid ");
    return {};
  }
  var privKey;
  do {
    privKey = randomBytes(32);
  } while (!secp256k1.privateKeyVerify(privKey));

  // get the public key in a compressed format
  var pubKey = secp256k1.publicKeyCreate(privKey);
  pubKey = secp256k1.publicKeyConvert(pubKey, false).slice(1);

  // Only take the lower 160bits of the hash
  var address = createKeccakHash('keccak256').update(rlp.encode(pubKey)).digest().slice(-20);
  address[0] = shard;
  // address[1] = shard
  address[19] = address[19] & 0xF0 | 1;
  return {
    "publickey": shard + "S" + address.toString('hex'),
    "privatekey": "0x" + privKey.toString('hex')
  };
}

/**
 * According to the key file path and the password to generate the key pair
 * @example
 * var keyfilePath = "C:\\Users\\dell-20\\go\\src\\github.com\\scdoproject\\go-scdo\\cmd\\client\\keyfile\\shard1-0x0a57a2714e193b7ac50475ce625f2dcfb483d741"
 * var pwd = Buffer.from("123")
 * var keypair = New KeyPair(keyfilePath, pwd)
 * @param {String} keyfilePath
 * @param {Buffer} pwd
 * @todo Need to resolve the key to ecdsa, the key is ecdsa D.
 */
function scryptPrivFile(self, keyfilePath, pwd) {
  keyfilePath.split(path.sep).join('/');
  var content = fs.readFileSync(keyfilePath);
  var JSONfile = JSON.parse(content);
  var cry = JSONfile.crypto;
  var salt = Buffer.from(cry.salt, "hex");
  var N = 262144,
    r = 8,
    p = 1;
  var dkLen = 32;
  scrypt(pwd, salt, N, r, p, dkLen, function (error, progress, key) {
    if (error) {
      console.log("Error: " + error);
    } else if (key) {
      console.log("Found: " + key);
      // TODO need to resolve the key to ecdsa, the key is ecdsa D.
      var keyPair = ec.keyFromPrivate("97ddae0f3a25b92268175400149d65d6887b9cefaf28ea2c078e05cdc15a3c0a");
      var privKey = keyPair.getPrivate("hex");
      var pubKey = keyPair.getPublic().encodeCompressed("hex");
      self.privateKey = privKey;
      self.publicKey = pubKey;
      return this;
    } else {
      // update UI with progress complete
      // updateInterface(progress)
    }
  });
}
module.exports = Wallet;

}).call(this)}).call(this,require("buffer").Buffer)
},{"./utils":546,"buffer":139,"crypto":149,"elliptic":161,"fs":137,"keccak":334,"path":355,"rlp":383,"scrypt-js":385,"secp256k1":386}],"scdo":[function(require,module,exports){
(function (global,Buffer){(function (){
"use strict";

function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
var Contract = require('./contract/index.js');
var api = require('./commands.js');
var transaction = require('./tx');
var filter = require('./filter');
var Wallet = require('./wallet');
var util = require('./utils');
var stx = require('./stx');
var JSONbig = require('json-bignumber');
var Scdo = /*#__PURE__*/_createClass(function Scdo(host, headers, user, password, timeout) {
  _classCallCheck(this, Scdo);
  if (typeof host === 'string') {
    this.client = new ScdoNodeProvider(host, headers, user, password, timeout);
  } else {
    this.client = new ScdoWebProvider(host);
  }
  this.keyTool = new ScdoKeyActions();
  this.util = util;
  this.contract = new Contract(this);
});
var ScdoKeyActions = /*#__PURE__*/function () {
  function ScdoKeyActions() {
    _classCallCheck(this, ScdoKeyActions);
  }
  return _createClass(ScdoKeyActions, [{
    key: "signTx",
    value: function signTx(privateKey, tx) {
      var signer = new stx();
      return signer.sign(privateKey, tx);
    }
  }, {
    key: "generateKeys",
    value: function generateKeys(shard) {
      var wallet = new Wallet();
      return wallet.createbyshard(shard);
    }
  }]);
}();
/**
* ScdoNodeProvider should be used to send rpc calls over http
* @param {String} host A domain name or IP address of the server to issue the request to. Default: 'localhost'.
* @param {String} port Port of remote server. Default: '8037'.
* @param {Object} headers An object containing request headers, the format must be [{'name':'', 'vaule':''}, {'name':'', 'vaule':''}...].
* @param {String} user Basic authentication i.e. 'user:password' to compute an Authorization header. Not used.
* @param {String} password Basic authentication i.e. 'user:password' to compute an Authorization header. Not used.
* @param {Number} timeout A number specifying the socket timeout in milliseconds. This will set the timeout before the socket is connected. Default: '30000'.
*/
var ScdoNodeProvider = /*#__PURE__*/function () {
  function ScdoNodeProvider(host, headers, user, password, timeout) {
    _classCallCheck(this, ScdoNodeProvider);
    this.host = host || 'http://localhost:8037';
    this.headers = headers;
    this.user = user;
    this.password = password;
    this.timeout = timeout || 30000;
    this.wallet = new Wallet();
    this.util = util;
  }

  /**
  * Should be called to prepare a new ClientRequest
  * @method prepareRequest
  * @param {Boolean} true if request should be async
  * @return {ClientRequest} object
  */
  return _createClass(ScdoNodeProvider, [{
    key: "prepareRequest",
    value: function prepareRequest(async) {
      var request = new XMLHttpRequest();
      request.withCredentials = false;
      request.open('POST', this.host, async);

      // user and password
      if (this.user && this.password) {
        var auth = 'Basic ' + new Buffer(this.user + ':' + this.password).toString('base64');
        request.setRequestHeader('Authorization', auth);
      }

      // headers
      request.setRequestHeader('Content-Type', 'application/json');
      if (this.headers) {
        this.headers.forEach(function (header) {
          request.setRequestHeader(header.name, header.value);
        });
      }
      return request;
    }

    /**
    * Should be called to make async request
    * @method send
    * @param {String} command
    * @return {Object} request
    * @todo Using namespace
    */
  }, {
    key: "send",
    value: function send(command) {
      var _arguments = arguments,
        _this = this;
      var currHost = this.host;
      return new Promise(function (resolve, reject) {
        var args = Array.prototype.slice.call(_arguments, 1);
        if (typeof args[args.length - 1] === 'function') {
          resolve = args[args.length - 1].bind(_this);
          reject = args.pop().bind(_this);
        }
        var request = _this.prepareRequest(true);
        var rpcData = JSONbig.stringify({
          id: new Date().getTime(),
          method: api.getNamespace(command).concat("_").concat(command),
          params: args
        });
        request.onload = function () {
          if (request.readyState === 4 && request.timeout !== 1) {
            var result = request.responseText;
            try {
              result = JSONbig.parse(result);
              if (result.error) {
                reject(args, new Error(JSONbig.stringify(result)));
                return;
              }
              resolve(result.result);
            } catch (exception) {
              reject(args, new Error(exception + ' : ' + JSONbig.stringify(result)));
            }
          }
        };
        request.ontimeout = function () {
          reject(args, new Error('CONNECTION TIMEOUT: timeout of ' + currHost + ' ms achieved'));
        };
        request.onerror = function () {
          if (request.status == 0) {
            reject(args, new Error('CONNECTION ERROR: Couldn\'t connect to node ' + currHost + '.'));
          } else {
            reject(args, request.statusText);
          }
        };
        try {
          request.send(rpcData);
        } catch (error) {
          reject(args, new Error('CONNECTION ERROR: Couldn\'t connect to node ' + currHost + '.'));
        }
        return request;
      });
    }

    /**
    * Should be called to make sync request
    * @method send
    * @param {String} command
    * @return {Object} result
    * @todo Using namespace
    */
  }, {
    key: "sendSync",
    value: function sendSync(command) {
      var args = Array.prototype.slice.call(arguments, 1);
      var request = this.prepareRequest(false);
      var rpcData = JSONbig.stringify({
        id: new Date().getTime(),
        method: api.getNamespace(command).concat("_").concat(command),
        params: args
      });
      request.onerror = function () {
        throw request.statusText;
      };
      try {
        request.send(rpcData);
      } catch (error) {
        console.log(error);
        throw new Error('CONNECTION ERROR: Couldn\'t connect to node ' + this.host + '.');
      }
      var result = request.responseText;
      try {
        result = JSONbig.parse(result);
        if (result.error) {
          throw new Error(JSONbig.stringify(result));
        }
        return result.result;
      } catch (exception) {
        throw new Error(exception + ' : ' + JSONbig.stringify(result));
      }
    }

    /**
     * If an invalid command is called, it is processed
     * @param {string} command
     */
  }, {
    key: "invalid",
    value: function invalid(command) {
      return console.log(new Error('No such command "' + command + '"'));
    }

    /**
     * Executes the given command with optional arguments. Function `callback` defaults to `console.log`.
     * All of the API commands are supported in lowercase or camelcase. Or uppercase. Anycase!
     * @param {string} command
     */
  }, {
    key: "exec",
    value: function exec(command) {
      var func = api.isCommand(command) ? 'send' : 'invalid';
      return this[func].apply(this, arguments);
    }

    /**
     * Executes the given command with optional arguments. Function `callback` defaults to `console.log`.
     * All of the API commands are supported in lowercase or camelcase. Or uppercase. Anycase!
     * @param {string} command
     */
  }, {
    key: "execSync",
    value: function execSync(command) {
      var func = api.isCommand(command) ? 'sendSync' : 'invalid';
      return this[func].apply(this, arguments);
    }

    /**
    * Generate transaction and sign, the rawTx must be in the example format, otherwise an error will occur.
    * @example
    * var privatekey = "0x24ce9cadcc9207c94296db166ab7a0fa686f2a6d29f7ea54fe8c22271c40812e"
    * var rawTx = {
    *    "Type":0,
    *    "From":"0xa61e5b0b30e91c4ae10dda3a6ddeb9d9d35ebfe1",
    *    "To":"0x0000000000000000000000000000000000000000",
    *    "Amount":0,
    *    "AccountNonce":123,
    *    "GasPrice":1,
    *    "GasLimit":3000000,
    *    "Timestamp":0,
    *    "Payload":"0x60806040527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff60015534801561003457600080fd5b5033600360006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550610f0b806100856000396000f300608060405260043610610083576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff1680632d142a99146100885780632de2c4da146100bc578063390e61541461015457806348d952e0146101b25780634eef2f46146101dd578063ab91695e1461021b578063f25b3f9914610246575b600080fd5b6100a660048036038101908080359060200190929190505050610295565b6040518082815260200191505060405180910390f35b3480156100c857600080fd5b5061013e6004803603810190808035906020019092919080359060200190929190803590602001909291908035906020019082018035906020019080806020026020016040519081016040528093929190818152602001838360200280828437820191505050505050919291929050505061042c565b6040518082815260200191505060405180910390f35b61019c6004803603810190808035906020019092919080359060200190929190803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050610968565b6040518082815260200191505060405180910390f35b3480156101be57600080fd5b506101c7610b40565b6040518082815260200191505060405180910390f35b6102056004803603810190808035906020019092919080359060200190929190505050610b46565b6040518082815260200191505060405180910390f35b34801561022757600080fd5b50610230610e3d565b6040518082815260200191505060405180910390f35b34801561025257600080fd5b5061027160048036038101908080359060200190929190505050610e43565b60405180848152602001838152602001828152602001935050505060405180910390f35b600080600090506001341015610356577f2889a9dad0676c5d3968f68aee3cf08ec189617986e3bc741824fabbae1dfddd816040518080602001838152602001806020018381038352600e8152602001807f676574426c6f636b486561646572000000000000000000000000000000000000815250602001838103825260168152602001807f4552525f4d4f4e45595f49534e4f545f454e4f55474800000000000000000000815250602001935050505060405180910390a1809150610426565b600360009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166108fc349081150290604051600060405180830381858888f193505050501580156103be573d6000803e3d6000fd5b506000600260008581526020019081526020016000206001015413156103e357600190505b7f9f4ffac40aa756625bacf23a6a8fd81d386dfb2878ef3b572d73d00f454f003e8382604051808381526020018281526020019250505060405180910390a18091505b50919050565b60008060009050600360009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614151561053b577f2889a9dad0676c5d3968f68aee3cf08ec189617986e3bc741824fabbae1dfddd81604051808060200183815260200180602001838103835260108152602001807f73746f7265426c6f636b48656164657200000000000000000000000000000000815250602001838103825260138152602001807f4552525f53544f52455f585f52454c4159455200000000000000000000000000815250602001935050505060405180910390a180915061095f565b600054841415156105f7577f2889a9dad0676c5d3968f68aee3cf08ec189617986e3bc741824fabbae1dfddd81604051808060200183815260200180602001838103835260108152602001807f73746f7265426c6f636b48656164657200000000000000000000000000000000815250602001838103825260118152602001807f4552525f4e4f5f505245565f424c4f434b000000000000000000000000000000815250602001935050505060405180910390a180915061095f565b600154851315156106b3577f2889a9dad0676c5d3968f68aee3cf08ec189617986e3bc741824fabbae1dfddd81604051808060200183815260200180602001838103835260108152602001807f73746f7265426c6f636b48656164657200000000000000000000000000000000815250602001838103825260188152602001807f4552525f424c4f434b5f414c52454144595f4558495354530000000000000000815250602001935050505060405180910390a180915061095f565b600060026000888152602001908152602001600020600101541315610783577f2889a9dad0676c5d3968f68aee3cf08ec189617986e3bc741824fabbae1dfddd81604051808060200183815260200180602001838103835260108152602001807f73746f7265426c6f636b486561646572000000000000000000000000000000008152506020018381038252601d8152602001807f4552525f424c4f434b5f484153485f414c52454144595f455849535453000000815250602001935050505060405180910390a180915061095f565b60008351141561083e577f2889a9dad0676c5d3968f68aee3cf08ec189617986e3bc741824fabbae1dfddd81604051808060200183815260200180602001838103835260108152602001807f73746f7265426c6f636b48656164657200000000000000000000000000000000815250602001838103825260198152602001807f4552525f5452414e53414354494f4e535f49535f454d50545900000000000000815250602001935050505060405180910390a180915061095f565b608060405190810160405280878152602001868152602001858152602001848152506002600088815260200190815260200160002060008201518160000155602082015181600101556040820151816002015560608201518160030190805190602001906108ad929190610e6d565b509050508560008190555084600181905550600190507f3d553c6a50657421fdcfde6c3ab85068b6c074a10dfc0073f149d98980d0395786868686856040518086815260200185815260200184815260200180602001838152602001828103825284818151815260200191508051906020019060200280838360005b83811015610944578082015181840152602081019050610929565b50505050905001965050505050505060405180910390a18091505b50949350505050565b6000806000806000925061097c8787610b46565b9150600082141515610a89578490508073ffffffffffffffffffffffffffffffffffffffff1663e6cb35af88886040518363ffffffff167c01000000000000000000000000000000000000000000000000000000000281526004018083815260200182815260200192505050602060405180830381600087803b158015610a0257600080fd5b505af1158015610a16573d6000803e3d6000fd5b505050506040513d6020811015610a2c57600080fd5b810190808051906020019092919050505050600192507f84ed50b3e2027837051c6eaa0464f66293959fe6892b7a62576d1ebcd53931e18684604051808381526020018281526020019250505060405180910390a1829350610b36565b7f2889a9dad0676c5d3968f68aee3cf08ec189617986e3bc741824fabbae1dfddd83604051808060200183815260200180602001838103835260108152602001807f52656c61795472616e73616374696f6e00000000000000000000000000000000815250602001838103825260108152602001807f4552525f52454c41595f56455249465900000000000000000000000000000000815250602001935050505060405180910390a18293505b5050509392505050565b60015481565b600080606060008092506001341015610c0a577f2889a9dad0676c5d3968f68aee3cf08ec189617986e3bc741824fabbae1dfddd83604051808060200183815260200180602001838103835260088152602001807f7665726966795478000000000000000000000000000000000000000000000000815250602001838103825260168152602001807f4552525f4d4f4e45595f49534e4f545f454e4f55474800000000000000000000815250602001935050505060405180910390a1829350610e34565b60066001540360026000888152602001908152602001600020600101541215610cde577f2889a9dad0676c5d3968f68aee3cf08ec189617986e3bc741824fabbae1dfddd83604051808060200183815260200180602001838103835260088152602001807f76657269667954780000000000000000000000000000000000000000000000008152506020018381038252601d8152602001807f4552525f434f4e4649524d4154494f4e535f4c4553535f5448414e5f36000000815250602001935050505060405180910390a1829350610e34565b600360009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166108fc349081150290604051600060405180830381858888f19350505050158015610d46573d6000803e3d6000fd5b5060026000878152602001908152602001600020600301805480602002602001604051908101604052809291908181526020018280548015610da757602002820191906000526020600020905b815481526020019060010190808311610d93575b50505050509150600090505b8151811015610df157848282815181101515610dcb57fe5b906020019060200201511415610de45760019250610df1565b8080600101915050610db3565b7f7a2933ac2a256db068a8aec8c8977f9866040648de7e973edfb5387e64a3d66a8584604051808381526020018281526020019250505060405180910390a18293505b50505092915050565b60005481565b60026020528060005260406000206000915090508060000154908060010154908060020154905083565b828054828255906000526020600020908101928215610ea9579160200282015b82811115610ea8578251825591602001919060010190610e8d565b5b509050610eb69190610eba565b5090565b610edc91905b80821115610ed8576000816000905550600101610ec0565b5090565b905600a165627a7a72305820fe072090d013b0fe073954d6379f9f21b04b42bce53ca7a5ab469c3b0631bbf10029"
    * }
    * tx = generateTx(privatekey, rawTx)
    * @method generateTx
    * @param {Object} privatekey
    * @param {Object} rawTx
    * @return {Object} tx
    */
  }, {
    key: "generateTx",
    value: function generateTx(privatekey, rawTx) {
      if (privatekey.slice(0, 2) === "0x") {
        privatekey = privatekey.slice(2);
      }
      if (rawTx.From != undefined) {
        rawTx.From = "0x" + rawTx.From.slice(2);
      }
      if (rawTx.To != undefined) {
        rawTx.To = "0x" + rawTx.To.slice(2);
      }
      var tx = new transaction(rawTx);
      var hashBuffer = tx.hash();
      tx.Hash = "0x" + hashBuffer.toString('hex');
      console.log("txHash:" + tx.Hash);
      var signBuffer = tx.sign(hashBuffer, Buffer.from(privatekey, 'hex'));
      tx.Signature = {
        "Sig": signBuffer.toString('base64')
      };
      console.log("txSig:" + tx.Signature.Sig);
      return tx;
    }
    /**
     * Filtering transactions for a specific address based on block height, an error occurs if the
     * block height does not exist. If the height is -1, it will filter the current block.
     * When the flag is 1, the transaction `from` equal to the `address` is filtered in the block.
     * When the flag is 2, the transaction `to` equal to the `address` is filtered in the block.
     * @example
     * var txs = client.filterBlockTx(-1, "0x4c10f2cd2159bb432094e3be7e17904c2b4aeb21", "1")
     *
     * client.filterBlockTx(1235435, "0x4c10f2cd2159bb432094e3be7e17904c2b4aeb21", "2", function(txs){
     *     console.log(txs)
     * })
     * @param {Number} height
     * @param {String} address
     * @param {Number} flag 1:from 2:to
     */
  }, {
    key: "filterBlockTx",
    value: function filterBlockTx(height, address, flag) {
      return new filter(this).blocktxSync(height, address, flag);
    }
  }]);
}();
/**
* ScdoWebProvider should be used to send rpc calls over wallet
* @param {Object} provider Contains the provider object, provided by the provider, and requires the implementation of request, on, emit and other methods
*/
var ScdoWebProvider = /*#__PURE__*/function () {
  function ScdoWebProvider(provider) {
    _classCallCheck(this, ScdoWebProvider);
    this.provider = provider;
  }
  /**
   * Should be called to make async request
   * @method send
   * @param {String} command
   * @return {Object} request
   * @todo Using namespace
   */
  return _createClass(ScdoWebProvider, [{
    key: "send",
    value: function send(command) {
      var args = Array.prototype.slice.call(arguments, 1);
      if (typeof args[args.length - 1] === 'function') {
        resolve = args[args.length - 1].bind(this);
        reject = args.pop().bind(this);
      }
      var rpcData = {
        method: api.getNamespace(command).concat("_").concat(command),
        params: args
      };
      return this.provider.request(rpcData);
    }
    /**
     * Should be called to make sync request
     * @method send
     * @param {String} command
     * @return {Object} result
     * @todo Using namespace
     */
  }, {
    key: "sendSync",
    value: function sendSync(_ref) {
      var method = _ref.method,
        params = _ref.params;
      var rpcData = {
        id: new Date().getTime(),
        method: api.getNamespace(method).concat("_").concat(method),
        params: params
      };
      return this.provider.request(rpcData);
    }

    /**
     * If an invalid command is called, it is processed
     * @param {string} command
     */
  }, {
    key: "invalid",
    value: function invalid(command) {
      return console.log(new Error('No such command "' + command + '"'));
    }

    /**
     * Executes the given command with optional arguments. Function `callback` defaults to `console.log`.
     * All of the API commands are supported in lowercase or camelcase. Or uppercase. Anycase!
     * @param {string} command
     */
  }, {
    key: "exec",
    value: function exec(command) {
      var func = api.isCommand(command) ? 'send' : 'invalid';
      return this[func].apply(this, arguments);
    }

    /**
     * Executes the given command with optional arguments. Function `callback` defaults to `console.log`.
     * All of the API commands are supported in lowercase or camelcase. Or uppercase. Anycase!
     * @param {string} command
     */
  }, {
    key: "execSync",
    value: function execSync(command) {
      var func = api.isCommand(command) ? 'sendSync' : 'invalid';
      return this[func].apply(this, arguments);
    }

    /**
     * Generate transaction and sign, the rawTx must be in the example format, otherwise an error will occur.
     * @example
     * var privatekey = "0x24ce9cadcc9207c94296db166ab7a0fa686f2a6d29f7ea54fe8c22271c40812e"
     * var rawTx = {
     *    "Type":0,
     *    "From":"0xa61e5b0b30e91c4ae10dda3a6ddeb9d9d35ebfe1",
     *    "To":"0x0000000000000000000000000000000000000000",
     *    "Amount":0,
     *    "AccountNonce":123,
     *    "GasPrice":1,
     *    "GasLimit":3000000,
     *    "Timestamp":0,
     *    "Payload":"0x60806040527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff60015534801561003457600080fd5b5033600360006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550610f0b806100856000396000f300608060405260043610610083576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff1680632d142a99146100885780632de2c4da146100bc578063390e61541461015457806348d952e0146101b25780634eef2f46146101dd578063ab91695e1461021b578063f25b3f9914610246575b600080fd5b6100a660048036038101908080359060200190929190505050610295565b6040518082815260200191505060405180910390f35b3480156100c857600080fd5b5061013e6004803603810190808035906020019092919080359060200190929190803590602001909291908035906020019082018035906020019080806020026020016040519081016040528093929190818152602001838360200280828437820191505050505050919291929050505061042c565b6040518082815260200191505060405180910390f35b61019c6004803603810190808035906020019092919080359060200190929190803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050610968565b6040518082815260200191505060405180910390f35b3480156101be57600080fd5b506101c7610b40565b6040518082815260200191505060405180910390f35b6102056004803603810190808035906020019092919080359060200190929190505050610b46565b6040518082815260200191505060405180910390f35b34801561022757600080fd5b50610230610e3d565b6040518082815260200191505060405180910390f35b34801561025257600080fd5b5061027160048036038101908080359060200190929190505050610e43565b60405180848152602001838152602001828152602001935050505060405180910390f35b600080600090506001341015610356577f2889a9dad0676c5d3968f68aee3cf08ec189617986e3bc741824fabbae1dfddd816040518080602001838152602001806020018381038352600e8152602001807f676574426c6f636b486561646572000000000000000000000000000000000000815250602001838103825260168152602001807f4552525f4d4f4e45595f49534e4f545f454e4f55474800000000000000000000815250602001935050505060405180910390a1809150610426565b600360009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166108fc349081150290604051600060405180830381858888f193505050501580156103be573d6000803e3d6000fd5b506000600260008581526020019081526020016000206001015413156103e357600190505b7f9f4ffac40aa756625bacf23a6a8fd81d386dfb2878ef3b572d73d00f454f003e8382604051808381526020018281526020019250505060405180910390a18091505b50919050565b60008060009050600360009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614151561053b577f2889a9dad0676c5d3968f68aee3cf08ec189617986e3bc741824fabbae1dfddd81604051808060200183815260200180602001838103835260108152602001807f73746f7265426c6f636b48656164657200000000000000000000000000000000815250602001838103825260138152602001807f4552525f53544f52455f585f52454c4159455200000000000000000000000000815250602001935050505060405180910390a180915061095f565b600054841415156105f7577f2889a9dad0676c5d3968f68aee3cf08ec189617986e3bc741824fabbae1dfddd81604051808060200183815260200180602001838103835260108152602001807f73746f7265426c6f636b48656164657200000000000000000000000000000000815250602001838103825260118152602001807f4552525f4e4f5f505245565f424c4f434b000000000000000000000000000000815250602001935050505060405180910390a180915061095f565b600154851315156106b3577f2889a9dad0676c5d3968f68aee3cf08ec189617986e3bc741824fabbae1dfddd81604051808060200183815260200180602001838103835260108152602001807f73746f7265426c6f636b48656164657200000000000000000000000000000000815250602001838103825260188152602001807f4552525f424c4f434b5f414c52454144595f4558495354530000000000000000815250602001935050505060405180910390a180915061095f565b600060026000888152602001908152602001600020600101541315610783577f2889a9dad0676c5d3968f68aee3cf08ec189617986e3bc741824fabbae1dfddd81604051808060200183815260200180602001838103835260108152602001807f73746f7265426c6f636b486561646572000000000000000000000000000000008152506020018381038252601d8152602001807f4552525f424c4f434b5f484153485f414c52454144595f455849535453000000815250602001935050505060405180910390a180915061095f565b60008351141561083e577f2889a9dad0676c5d3968f68aee3cf08ec189617986e3bc741824fabbae1dfddd81604051808060200183815260200180602001838103835260108152602001807f73746f7265426c6f636b48656164657200000000000000000000000000000000815250602001838103825260198152602001807f4552525f5452414e53414354494f4e535f49535f454d50545900000000000000815250602001935050505060405180910390a180915061095f565b608060405190810160405280878152602001868152602001858152602001848152506002600088815260200190815260200160002060008201518160000155602082015181600101556040820151816002015560608201518160030190805190602001906108ad929190610e6d565b509050508560008190555084600181905550600190507f3d553c6a50657421fdcfde6c3ab85068b6c074a10dfc0073f149d98980d0395786868686856040518086815260200185815260200184815260200180602001838152602001828103825284818151815260200191508051906020019060200280838360005b83811015610944578082015181840152602081019050610929565b50505050905001965050505050505060405180910390a18091505b50949350505050565b6000806000806000925061097c8787610b46565b9150600082141515610a89578490508073ffffffffffffffffffffffffffffffffffffffff1663e6cb35af88886040518363ffffffff167c01000000000000000000000000000000000000000000000000000000000281526004018083815260200182815260200192505050602060405180830381600087803b158015610a0257600080fd5b505af1158015610a16573d6000803e3d6000fd5b505050506040513d6020811015610a2c57600080fd5b810190808051906020019092919050505050600192507f84ed50b3e2027837051c6eaa0464f66293959fe6892b7a62576d1ebcd53931e18684604051808381526020018281526020019250505060405180910390a1829350610b36565b7f2889a9dad0676c5d3968f68aee3cf08ec189617986e3bc741824fabbae1dfddd83604051808060200183815260200180602001838103835260108152602001807f52656c61795472616e73616374696f6e00000000000000000000000000000000815250602001838103825260108152602001807f4552525f52454c41595f56455249465900000000000000000000000000000000815250602001935050505060405180910390a18293505b5050509392505050565b60015481565b600080606060008092506001341015610c0a577f2889a9dad0676c5d3968f68aee3cf08ec189617986e3bc741824fabbae1dfddd83604051808060200183815260200180602001838103835260088152602001807f7665726966795478000000000000000000000000000000000000000000000000815250602001838103825260168152602001807f4552525f4d4f4e45595f49534e4f545f454e4f55474800000000000000000000815250602001935050505060405180910390a1829350610e34565b60066001540360026000888152602001908152602001600020600101541215610cde577f2889a9dad0676c5d3968f68aee3cf08ec189617986e3bc741824fabbae1dfddd83604051808060200183815260200180602001838103835260088152602001807f76657269667954780000000000000000000000000000000000000000000000008152506020018381038252601d8152602001807f4552525f434f4e4649524d4154494f4e535f4c4553535f5448414e5f36000000815250602001935050505060405180910390a1829350610e34565b600360009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166108fc349081150290604051600060405180830381858888f19350505050158015610d46573d6000803e3d6000fd5b5060026000878152602001908152602001600020600301805480602002602001604051908101604052809291908181526020018280548015610da757602002820191906000526020600020905b815481526020019060010190808311610d93575b50505050509150600090505b8151811015610df157848282815181101515610dcb57fe5b906020019060200201511415610de45760019250610df1565b8080600101915050610db3565b7f7a2933ac2a256db068a8aec8c8977f9866040648de7e973edfb5387e64a3d66a8584604051808381526020018281526020019250505060405180910390a18293505b50505092915050565b60005481565b60026020528060005260406000206000915090508060000154908060010154908060020154905083565b828054828255906000526020600020908101928215610ea9579160200282015b82811115610ea8578251825591602001919060010190610e8d565b5b509050610eb69190610eba565b5090565b610edc91905b80821115610ed8576000816000905550600101610ec0565b5090565b905600a165627a7a72305820fe072090d013b0fe073954d6379f9f21b04b42bce53ca7a5ab469c3b0631bbf10029"
     * }
     * tx = generateTx(privatekey, rawTx)
     * @method generateTx
     * @param {Object} privatekey
     * @param {Object} rawTx
     * @return {Object} tx
     */
  }, {
    key: "generateTx",
    value: function generateTx(privatekey, rawTx) {
      if (privatekey.slice(0, 2) === "0x") {
        privatekey = privatekey.slice(2);
      }
      if (rawTx.From != undefined) {
        rawTx.From = "0x" + rawTx.From.slice(2);
      }
      if (rawTx.To != undefined) {
        rawTx.To = "0x" + rawTx.To.slice(2);
      }
      var tx = new transaction(rawTx);
      var hashBuffer = tx.hash();
      tx.Hash = "0x" + hashBuffer.toString('hex');
      console.log("txHash:" + tx.Hash);
      var signBuffer = tx.sign(hashBuffer, Buffer.from(privatekey, 'hex'));
      tx.Signature = {
        "Sig": signBuffer.toString('base64')
      };
      console.log("txSig:" + tx.Signature.Sig);
      return tx;
    }
    /**
     * Filtering transactions for a specific address based on block height, an error occurs if the
     * block height does not exist. If the height is -1, it will filter the current block.
     * When the flag is 1, the transaction `from` equal to the `address` is filtered in the block.
     * When the flag is 2, the transaction `to` equal to the `address` is filtered in the block.
     * @example
     * var txs = client.filterBlockTx(-1, "0x4c10f2cd2159bb432094e3be7e17904c2b4aeb21", "1")
     *
     * client.filterBlockTx(1235435, "0x4c10f2cd2159bb432094e3be7e17904c2b4aeb21", "2", function(txs){
     *     console.log(txs)
     * })
     * @param {Number} height
     * @param {String} address
     * @param {Number} flag 1:from 2:to
     */
  }, {
    key: "filterBlockTx",
    value: function filterBlockTx(height, address, flag) {
      return new filter(this).blocktxSync(height, address, flag);
    }
  }]);
}();
for (var namespace in api.commands) {
  api.commands[namespace].forEach(function (command) {
    ScdoNodeProvider.prototype[command] = function () {
      return this.send.apply(this, [command].concat(Array.prototype.slice.call(arguments)));
    };
    ScdoWebProvider.prototype[command] = function () {
      return this.send.apply(this, [command].concat(Array.prototype.slice.call(arguments)));
    };
  });
}
if (typeof window !== 'undefined' && typeof window.ScdoWebProvider === 'undefined') {
  window.ScdoWebProvider = ScdoWebProvider;
}
if (typeof global !== 'undefined') {
  global.ScdoWebProvider = ScdoWebProvider;
}

// module.exports = {  ScdoKeyActions };
module.exports = Scdo;
// if (typeof window !== 'undefined' && typeof window.Scdo === 'undefined'){
//   window.Scdo = Scdo;
// }
// if(typeof global !== 'undefined') {
//   global.Scdo = Scdo;
// }

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)
},{"./commands.js":536,"./contract/index.js":537,"./filter":540,"./stx":543,"./tx":544,"./utils":546,"./wallet":547,"buffer":139,"json-bignumber":332}]},{},["scdo"]);
